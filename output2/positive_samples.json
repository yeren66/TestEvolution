[
    {
        "product_commit": "47a9b1b647d890d3cce50cd21774f5c78c350782",
        "test_commit": "47a9b1b647d890d3cce50cd21774f5c78c350782",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/WelshPowell.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/WelshPowellTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.stream.IntStream;\n\n/*\n *  The Welsh-Powell algorithm is a graph coloring algorithm\n *  used for coloring a graph with the minimum number of colors.\n *  https://en.wikipedia.org/wiki/Graph_coloring\n */\n\npublic final class WelshPowell {\n    private static final int BLANK_COLOR = -1; // Representing uncolored state\n\n    private WelshPowell() {\n    }\n\n    static class Graph {\n        private HashSet<Integer>[] adjacencyLists;\n\n        private Graph(int vertices) {\n            if (vertices < 0) {\n                throw new IllegalArgumentException(\"Number of vertices cannot be negative\");\n            }\n\n            adjacencyLists = new HashSet[vertices];\n            Arrays.setAll(adjacencyLists, i -> new HashSet<>());\n        }\n\n        private void addEdge(int nodeA, int nodeB) {\n            validateVertex(nodeA);\n            validateVertex(nodeB);\n            if (nodeA == nodeB) {\n                throw new IllegalArgumentException(\"Self-loops are not allowed\");\n            }\n            adjacencyLists[nodeA].add(nodeB);\n            adjacencyLists[nodeB].add(nodeA);\n        }\n\n        private void validateVertex(int vertex) {\n            if (vertex < 0 || vertex >= getNumVertices()) {\n                throw new IllegalArgumentException(\"Vertex \" + vertex + \" is out of bounds\");\n            }\n        }\n\n        HashSet<Integer> getAdjacencyList(int vertex) {\n            return adjacencyLists[vertex];\n        }\n\n        int getNumVertices() {\n            return adjacencyLists.length;\n        }\n    }\n\n    public static Graph makeGraph(int numberOfVertices, int[][] listOfEdges) {\n        Graph graph = new Graph(numberOfVertices);\n        for (int[] edge : listOfEdges) {\n            if (edge.length != 2) {\n                throw new IllegalArgumentException(\"Edge array must have exactly two elements\");\n            }\n            graph.addEdge(edge[0], edge[1]);\n        }\n        return graph;\n    }\n\n    public static int[] findColoring(Graph graph) {\n        int[] colors = initializeColors(graph.getNumVertices());\n        Integer[] sortedVertices = getSortedNodes(graph);\n        for (int vertex : sortedVertices) {\n            if (isBlank(colors[vertex])) {\n                boolean[] usedColors = computeUsedColors(graph, vertex, colors);\n                final var newColor = firstUnusedColor(usedColors);\n                colors[vertex] = newColor;\n                Arrays.stream(sortedVertices).forEach(otherVertex -> {\n                    if (isBlank(colors[otherVertex]) && !isAdjacentToColored(graph, otherVertex, colors)) {\n                        colors[otherVertex] = newColor;\n                    }\n                });\n            }\n        }\n        return colors;\n    }\n\n    private static boolean isBlank(int color) {\n        return color == BLANK_COLOR;\n    }\n\n    private static boolean isAdjacentToColored(Graph graph, int vertex, int[] colors) {\n        return graph.getAdjacencyList(vertex).stream().anyMatch(otherVertex -> !isBlank(colors[otherVertex]));\n    }\n\n    private static int[] initializeColors(int numberOfVertices) {\n        int[] colors = new int[numberOfVertices];\n        Arrays.fill(colors, BLANK_COLOR);\n        return colors;\n    }\n\n    private static Integer[] getSortedNodes(final Graph graph) {\n        return IntStream.range(0, graph.getNumVertices()).boxed().sorted(Comparator.comparingInt(v -> - graph.getAdjacencyList(v).size())).toArray(Integer[] ::new);\n    }\n\n    private static boolean[] computeUsedColors(final Graph graph, final int vertex, final int[] colors) {\n        boolean[] usedColors = new boolean[graph.getNumVertices()];\n        graph.getAdjacencyList(vertex).stream().map(neighbor -> colors[neighbor]).filter(color -> !isBlank(color)).forEach(color -> usedColors[color] = true);\n        return usedColors;\n    }\n\n    private static int firstUnusedColor(boolean[] usedColors) {\n        return IntStream.range(0, usedColors.length).filter(color -> !usedColors[color]).findFirst().getAsInt();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport com.thealgorithms.datastructures.graphs.WelshPowell.Graph;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\nclass WelshPowellTest {\n\n    @Test\n    void testSimpleGraph() {\n        final var graph = WelshPowell.makeGraph(4, new int[][] {{0, 1}, {1, 2}, {2, 3}});\n        int[] colors = WelshPowell.findColoring(graph);\n        assertTrue(isColoringValid(graph, colors));\n        assertEquals(2, countDistinctColors(colors));\n    }\n\n    @Test\n    void testDisconnectedGraph() {\n        final var graph = WelshPowell.makeGraph(3, new int[][] {}); // No edges\n        int[] colors = WelshPowell.findColoring(graph);\n        assertTrue(isColoringValid(graph, colors));\n        assertEquals(1, countDistinctColors(colors));\n    }\n\n    @Test\n    void testCompleteGraph() {\n        final var graph = WelshPowell.makeGraph(3, new int[][] {{0, 1}, {1, 2}, {2, 0}});\n        int[] colors = WelshPowell.findColoring(graph);\n        assertTrue(isColoringValid(graph, colors));\n        assertEquals(3, countDistinctColors(colors));\n    }\n\n    // The following test originates from the following website : https://www.geeksforgeeks.org/welsh-powell-graph-colouring-algorithm/\n    @Test\n    void testComplexGraph() {\n        int[][] edges = {\n            {0, 7}, // A-H\n            {0, 1}, // A-B\n            {1, 3}, // B-D\n            {2, 3}, // C-D\n            {3, 8}, // D-I\n            {3, 10}, // D-K\n            {4, 10}, // E-K\n            {4, 5}, // E-F\n            {5, 6}, // F-G\n            {6, 10}, // G-K\n            {6, 7}, // G-H\n            {7, 8}, // H-I\n            {7, 9}, // H-J\n            {7, 10}, // H-K\n            {8, 9}, // I-J\n            {9, 10}, // J-K\n        };\n\n        final var graph = WelshPowell.makeGraph(11, edges); // 11 vertices from A (0) to K (10)\n        int[] colors = WelshPowell.findColoring(graph);\n\n        assertTrue(isColoringValid(graph, colors), \"The coloring should be valid with no adjacent vertices sharing the same color.\");\n        assertEquals(3, countDistinctColors(colors), \"The chromatic number of the graph should be 3.\");\n    }\n\n    @Test\n    void testNegativeVertices() {\n        assertThrows(IllegalArgumentException.class, () -> { WelshPowell.makeGraph(-1, new int[][] {}); }, \"Number of vertices cannot be negative\");\n    }\n\n    @Test\n    void testSelfLoop() {\n        assertThrows(IllegalArgumentException.class, () -> { WelshPowell.makeGraph(3, new int[][] {{0, 0}}); }, \"Self-loops are not allowed\");\n    }\n\n    @Test\n    void testInvalidVertex() {\n        assertThrows(IllegalArgumentException.class, () -> { WelshPowell.makeGraph(3, new int[][] {{0, 3}}); }, \"Vertex out of bounds\");\n        assertThrows(IllegalArgumentException.class, () -> { WelshPowell.makeGraph(3, new int[][] {{0, -1}}); }, \"Vertex out of bounds\");\n    }\n\n    @Test\n    void testInvalidEdgeArray() {\n        assertThrows(IllegalArgumentException.class, () -> { WelshPowell.makeGraph(3, new int[][] {{0}}); }, \"Edge array must have exactly two elements\");\n    }\n\n    @Test\n    void testWithPreColoredVertex() {\n        // Create a linear graph with 4 vertices and edges connecting them in sequence\n        final var graph = WelshPowell.makeGraph(4, new int[][] {{0, 1}, {1, 2}, {2, 3}});\n\n        // Apply the Welsh-Powell coloring algorithm to the graph\n        int[] colors = WelshPowell.findColoring(graph);\n\n        // Validate that the coloring is correct (no two adjacent vertices have the same color)\n        assertTrue(isColoringValid(graph, colors));\n\n        // Check if the algorithm has used at least 2 colors (expected for a linear graph)\n        assertTrue(countDistinctColors(colors) >= 2);\n\n        // Verify that all vertices have been assigned a color\n        for (int color : colors) {\n            assertTrue(color >= 0);\n        }\n    }\n\n    private boolean isColoringValid(Graph graph, int[] colors) {\n        if (Arrays.stream(colors).anyMatch(n -> n < 0)) {\n            return false;\n        }\n        for (int i = 0; i < graph.getNumVertices(); i++) {\n            for (int neighbor : graph.getAdjacencyList(i)) {\n                if (i != neighbor && colors[i] == colors[neighbor]) {\n                    return false; // Adjacent vertices have the same color\n                }\n            }\n        }\n        return true; // No adjacent vertices share the same color\n    }\n\n    private int countDistinctColors(int[] colors) {\n        return (int) Arrays.stream(colors).distinct().count();\n    }\n}"
    },
    {
        "product_commit": "14b3f45f9f32df108de5d0eace624f23d6bbe1bf",
        "test_commit": "14b3f45f9f32df108de5d0eace624f23d6bbe1bf",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/ExchangeSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/ExchangeSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * ExchangeSort is an implementation of the Exchange Sort algorithm.\n *\n * <p>\n * Exchange sort works by comparing each element with all subsequent elements,\n * swapping where needed, to ensure the correct placement of each element\n * in the final sorted order. It iteratively performs this process for each\n * element in the array. While it lacks the advantage of bubble sort in\n * detecting sorted lists in one pass, it can be more efficient than bubble sort\n * due to a constant factor (one less pass over the data to be sorted; half as\n * many total comparisons) in worst-case scenarios.\n * </p>\n *\n * <p>\n * Reference: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort\n * </p>\n *\n * @author 555vedant (Vedant Kasar)\n */\nclass ExchangeSort implements SortAlgorithm {\n    /**\n     * Implementation of Exchange Sort Algorithm\n     *\n     * @param array the array to be sorted.\n     * @param <T>   the type of elements in the array.\n     * @return the sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 0; i < array.length - 1; i++) {\n            for (int j = i + 1; j < array.length; j++) {\n                if (array[i].compareTo(array[j]) > 0) {\n                    swap(array, i, j);\n                }\n            }\n        }\n        return array;\n    }\n\n    private <T> void swap(T[] array, int i, int j) {\n        T temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\npublic class ExchangeSortTest extends SortingAlgorithmTest {\n    @Override\n    SortAlgorithm getSortAlgorithm() {\n        return new ExchangeSort();\n    }\n}"
    },
    {
        "product_commit": "55f08cc0139579760964e786364e2239cc65a8d9",
        "test_commit": "55f08cc0139579760964e786364e2239cc65a8d9",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/SumOfSubset.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/SumOfSubsetTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\npublic class SumOfSubset {\n\n    public static boolean subsetSum(int[] arr, int num, int Key) {\n        if (Key == 0) {\n            return true;\n        }\n        if (num < 0 || Key < 0) {\n            return false;\n        }\n\n        boolean include = subsetSum(arr, num - 1, Key - arr[num]);\n        boolean exclude = subsetSum(arr, num - 1, Key);\n\n        return include || exclude;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass SumOfSubsetTest {\n\n    @Test\n    void basicCheck() {\n        assertEquals(false, SumOfSubset.subsetSum(new int[] {1, 2, 7, 10, 9}, 4, 14));\n        assertEquals(false, SumOfSubset.subsetSum(new int[] {2, 15, 1, 6, 7}, 4, 4));\n        assertEquals(true, SumOfSubset.subsetSum(new int[] {7, 3, 2, 5, 8}, 4, 14));\n        assertEquals(true, SumOfSubset.subsetSum(new int[] {4, 3, 2, 1}, 3, 5));\n        assertEquals(true, SumOfSubset.subsetSum(new int[] {1, 7, 2, 9, 10}, 4, 13));\n    }\n}"
    },
    {
        "product_commit": "fd84b0b10e2e6d17b161e53586164948b69d3b75",
        "test_commit": "fd84b0b10e2e6d17b161e53586164948b69d3b75",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/SRTFScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/SRTFSchedulingTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Implementation of Shortest Remaining Time First Scheduling Algorithm.\n * In the SRTF scheduling algorithm, the process with the smallest amount of time remaining until completion is selected to execute.\n * Example:\n * Consider the processes p1, p2 and the following table with info about their arrival and burst time:\n * Process | Burst Time | Arrival Time\n * P1      | 6 ms        | 0 ms\n * P2      | 2 ms        | 1 ms\n * In this example, P1 will be executed at time = 0 until time = 1 when P2 arrives. At time = 2, P2 will be executed until time = 4. At time 4, P2 is done, and P1 is executed again to be done.\n * That's a simple example of how the algorithm works.\n * More information you can find here -> https://en.wikipedia.org/wiki/Shortest_remaining_time\n */\npublic class SRTFScheduling {\n    protected List<ProcessDetails> processes;\n    protected List<String> ready;\n\n    /**\n     * Constructor\n     * @param processes ArrayList of ProcessDetails given as input\n     */\n    public SRTFScheduling(ArrayList<ProcessDetails> processes) {\n        this.processes = new ArrayList<>();\n        ready = new ArrayList<>();\n        this.processes = processes;\n    }\n\n    public void evaluateScheduling() {\n        int time = 0, cr = 0; // cr=current running process, time= units of time\n        int n = processes.size();\n        int[] remainingTime = new int[n];\n\n        /* calculating remaining time of every process and total units of time */\n        for (int i = 0; i < n; i++) {\n            remainingTime[i] = processes.get(i).getBurstTime();\n            time += processes.get(i).getBurstTime();\n        }\n\n        /* if the first process doesn't arrive at 0, we have more units of time */\n        if (processes.get(0).getArrivalTime() != 0) {\n            time += processes.get(0).getArrivalTime();\n        }\n\n        /* printing id of the process which is executed at every unit of time */\n        // if the first process doesn't arrive at 0, we print only \\n until it arrives\n        if (processes.get(0).getArrivalTime() != 0) {\n            for (int i = 0; i < processes.get(0).getArrivalTime(); i++) {\n                ready.add(null);\n            }\n        }\n\n        for (int i = processes.get(0).getArrivalTime(); i < time; i++) {\n            /* checking if there's a process with remaining time less than current running process.\n               If we find it, then it executes. */\n            for (int j = 0; j < n; j++) {\n                if (processes.get(j).getArrivalTime() <= i && (remainingTime[j] < remainingTime[cr] && remainingTime[j] > 0 || remainingTime[cr] == 0)) {\n                    cr = j;\n                }\n            }\n            ready.add(processes.get(cr).getProcessId());\n            remainingTime[cr]--;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\n\nclass SRTFSchedulingTest {\n    ArrayList<ProcessDetails> processes;\n\n    public void initialization() {\n        processes = new ArrayList<>();\n        processes.add(new ProcessDetails(\"4\", 0, 3));\n        processes.add(new ProcessDetails(\"3\", 1, 8));\n        processes.add(new ProcessDetails(\"1\", 2, 6));\n        processes.add(new ProcessDetails(\"5\", 4, 4));\n        processes.add(new ProcessDetails(\"2\", 5, 2));\n    }\n\n    @Test\n    public void Constructor() {\n        initialization();\n        SRTFScheduling s = new SRTFScheduling(processes);\n        assertEquals(3, s.processes.get(0).getBurstTime());\n        assertEquals(8, s.processes.get(1).getBurstTime());\n        assertEquals(6, s.processes.get(2).getBurstTime());\n        assertEquals(4, s.processes.get(3).getBurstTime());\n        assertEquals(2, s.processes.get(4).getBurstTime());\n    }\n\n    @Test\n    void evaluateScheduling() {\n        initialization();\n        SRTFScheduling s = new SRTFScheduling(processes);\n        s.evaluateScheduling();\n        assertEquals(\"4\", s.ready.get(0));\n        assertEquals(\"4\", s.ready.get(1));\n        assertEquals(\"4\", s.ready.get(2));\n        assertEquals(\"1\", s.ready.get(3));\n        assertEquals(\"5\", s.ready.get(4));\n        assertEquals(\"2\", s.ready.get(5));\n        assertEquals(\"2\", s.ready.get(6));\n        assertEquals(\"5\", s.ready.get(7));\n        assertEquals(\"5\", s.ready.get(8));\n        assertEquals(\"5\", s.ready.get(9));\n        assertEquals(\"1\", s.ready.get(10));\n        assertEquals(\"1\", s.ready.get(11));\n        assertEquals(\"1\", s.ready.get(12));\n        assertEquals(\"1\", s.ready.get(13));\n        assertEquals(\"1\", s.ready.get(14));\n        assertEquals(\"3\", s.ready.get(15));\n        assertEquals(\"3\", s.ready.get(16));\n        assertEquals(\"3\", s.ready.get(17));\n        assertEquals(\"3\", s.ready.get(18));\n        assertEquals(\"3\", s.ready.get(19));\n        assertEquals(\"3\", s.ready.get(20));\n        assertEquals(\"3\", s.ready.get(21));\n        assertEquals(\"3\", s.ready.get(22));\n    }\n}"
    },
    {
        "product_commit": "0c881e39f24152a47ba03d4580a5cc8a6d6a69bc",
        "test_commit": "0c881e39f24152a47ba03d4580a5cc8a6d6a69bc",
        "product_file_path": "src/main/java/com/thealgorithms/greedyalgorithms/MinimizingLateness.java",
        "test_file_path": "src/test/java/com/thealgorithms/greedyalgorithms/MinimizingLatenessTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport java.util.Arrays;\n\npublic class MinimizingLateness {\n\n    public static class Job {\n        String jobName;\n        int startTime = 0;\n        int lateness = 0;\n        int processingTime;\n        int deadline;\n\n        public Job(String jobName, int processingTime, int deadline) {\n            this.jobName = jobName;\n            this.processingTime = processingTime;\n            this.deadline = deadline;\n        }\n\n        public static Job of(String jobName, int processingTime, int deadline) {\n            return new Job(jobName, processingTime, deadline);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s, startTime: %d, endTime: %d, lateness: %d\", jobName, startTime, processingTime + startTime, lateness);\n        }\n    }\n\n    static void calculateLateness(Job... jobs) {\n\n        // sort the jobs based on their deadline\n        Arrays.sort(jobs, (a, b) -> a.deadline - b.deadline);\n\n        int startTime = 0;\n\n        for (Job job : jobs) {\n            job.startTime = startTime;\n            startTime += job.processingTime;\n            job.lateness = Math.max(0, startTime - job.deadline); // if the job finishes before deadline the lateness is 0\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.thealgorithms.greedyalgorithms.MinimizingLateness.Job;\nimport org.junit.jupiter.api.Test;\n\npublic class MinimizingLatenessTest {\n\n    @Test\n    void testCalculateLateness() {\n        // Test case with three jobs\n        Job job1 = new Job(\"Job1\", 4, 6);\n        Job job2 = new Job(\"Job2\", 2, 8);\n        Job job3 = new Job(\"Job3\", 1, 9);\n        Job job4 = new Job(\"Job4\", 5, 9);\n        Job job5 = new Job(\"Job5\", 4, 10);\n        Job job6 = new Job(\"Job6\", 3, 5);\n\n        MinimizingLateness.calculateLateness(job1, job2, job3, job4, job5, job6);\n\n        // Check lateness for each job\n        assertEquals(6, job4.lateness);\n        assertEquals(0, job6.lateness);\n        assertEquals(1, job2.lateness);\n    }\n\n    @Test\n    void testCheckStartTime() {\n\n        Job job1 = new Job(\"Job1\", 2, 5);\n        Job job2 = new Job(\"Job2\", 1, 7);\n        Job job3 = new Job(\"Job3\", 3, 8);\n        Job job4 = new Job(\"Job4\", 2, 4);\n        Job job5 = new Job(\"Job5\", 4, 10);\n\n        MinimizingLateness.calculateLateness(job1, job2, job3, job4, job5);\n\n        assertEquals(2, job1.startTime);\n        assertEquals(5, job3.startTime);\n        assertEquals(8, job5.startTime);\n    }\n}"
    },
    {
        "product_commit": "8930ab5b16ad3ab062c22004dbfc3da701bb85ef",
        "test_commit": "8930ab5b16ad3ab062c22004dbfc3da701bb85ef",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SumOfDigits.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SumOfDigitsTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class SumOfDigits {\n\n    public static void main(String[] args) {\n        assert sumOfDigits(-123) == 6 && sumOfDigitsRecursion(-123) == 6 && sumOfDigitsFast(-123) == 6;\n\n        assert sumOfDigits(0) == 0 && sumOfDigitsRecursion(0) == 0 && sumOfDigitsFast(0) == 0;\n\n        assert sumOfDigits(12345) == 15 && sumOfDigitsRecursion(12345) == 15 && sumOfDigitsFast(12345) == 15;\n    }\n\n    /**\n     * Calculate the sum of digits of a number\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigits(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        int sum = 0;\n        while (number != 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Calculate the sum of digits of a number using recursion\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsRecursion(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        return number < 10 ? number : number % 10 + sumOfDigitsRecursion(number / 10);\n    }\n\n    /**\n     * Calculate the sum of digits of a number using char array\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsFast(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        char[] digits = (number + \"\").toCharArray();\n        int sum = 0;\n        for (int i = 0; i < digits.length; ++i) {\n            sum += digits[i] - '0';\n        }\n        return sum;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class SumOfDigits {\n    private SumOfDigits() {\n    }\n\n    /**\n     * Calculate the sum of digits of a number\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigits(int number) {\n        final int base = 10;\n        number = Math.abs(number);\n        int sum = 0;\n        while (number != 0) {\n            sum += number % base;\n            number /= base;\n        }\n        return sum;\n    }\n\n    /**\n     * Calculate the sum of digits of a number using recursion\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsRecursion(int number) {\n        final int base = 10;\n        number = Math.abs(number);\n        return number < base ? number : number % base + sumOfDigitsRecursion(number / base);\n    }\n\n    /**\n     * Calculate the sum of digits of a number using char array\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsFast(final int number) {\n        return String.valueOf(Math.abs(number)).chars().map(c -> c - '0').reduce(0, Integer::sum);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SumOfDigitsTest {\n\n    SumOfDigits SoD = new SumOfDigits();\n\n    @Test\n    void testZero() {\n        assertEquals(0, SumOfDigits.sumOfDigits(0));\n        assertEquals(0, SumOfDigits.sumOfDigitsRecursion(0));\n        assertEquals(0, SumOfDigits.sumOfDigitsFast(0));\n    }\n\n    @Test\n    void testPositive() {\n        assertEquals(15, SumOfDigits.sumOfDigits(12345));\n        assertEquals(15, SumOfDigits.sumOfDigitsRecursion(12345));\n        assertEquals(15, SumOfDigits.sumOfDigitsFast(12345));\n    }\n\n    @Test\n    void testNegative() {\n        assertEquals(6, SumOfDigits.sumOfDigits(-123));\n        assertEquals(6, SumOfDigits.sumOfDigitsRecursion(-123));\n        assertEquals(6, SumOfDigits.sumOfDigitsFast(-123));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nclass SumOfDigitsTest {\n    @ParameterizedTest\n    @MethodSource(\"testCases\")\n    void sumOfDigitsTest(final int expected, final int input) {\n        Assertions.assertEquals(expected, SumOfDigits.sumOfDigits(input));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"testCases\")\n    void sumOfDigitsRecursionTest(final int expected, final int input) {\n        Assertions.assertEquals(expected, SumOfDigits.sumOfDigitsRecursion(input));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"testCases\")\n    void sumOfDigitsFastTest(final int expected, final int input) {\n        Assertions.assertEquals(expected, SumOfDigits.sumOfDigitsFast(input));\n    }\n\n    private static Stream<Arguments> testCases() {\n        return Stream.of(Arguments.of(0, 0), Arguments.of(1, 1), Arguments.of(15, 12345), Arguments.of(6, -123), Arguments.of(1, -100000), Arguments.of(8, 512));\n    }\n}"
    },
    {
        "product_commit": "1ea95ffa928e42bda532380233a9667764dafdf5",
        "test_commit": "1ea95ffa928e42bda532380233a9667764dafdf5",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PerfectSquare.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PerfectSquareTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Perfect_square\n */\npublic class PerfectSquare {\n\n    public static void main(String[] args) {\n        assert !isPerfectSquare(-1);\n        assert !isPerfectSquare(3);\n        assert !isPerfectSquare(5);\n        assert isPerfectSquare(9);\n        assert isPerfectSquare(100);\n    }\n\n    /**\n     * Check if a number is perfect square number\n     *\n     * @param number the number to be checked\n     * @return <tt>true</tt> if {@code number} is perfect square, otherwise\n     * <tt>false</tt>\n     */\n    public static boolean isPerfectSquare(int number) {\n        int sqrt = (int) Math.sqrt(number);\n        return sqrt * sqrt == number;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Perfect_square\n */\npublic final class PerfectSquare {\n    private PerfectSquare() {\n    }\n\n    /**\n     * Check if a number is perfect square number\n     *\n     * @param number the number to be checked\n     * @return <tt>true</tt> if {@code number} is perfect square, otherwise\n     * <tt>false</tt>\n     */\n    public static boolean isPerfectSquare(final int number) {\n        final int sqrt = (int) Math.sqrt(number);\n        return sqrt * sqrt == number;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PerfectSquareTest {\n\n    @Test\n    public void TestPerfectSquareifiscorrect() {\n        // Valid Partition\n        int number = 9;\n\n        boolean result = PerfectSquare.isPerfectSquare(number);\n\n        assertTrue(result);\n    }\n\n    @Test\n    public void TestPerfectSquareifisnotcorrect() {\n        // Invalid Partition 1\n        int number = 3;\n\n        boolean result = PerfectSquare.isPerfectSquare(number);\n\n        assertFalse(result);\n    }\n\n    @Test\n    public void TestPerfectSquareifisNegativeNumber() {\n        // Invalid Partition 2\n        int number = -10;\n\n        boolean result = PerfectSquare.isPerfectSquare(number);\n\n        assertFalse(result);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\npublic class PerfectSquareTest {\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2 * 2, 3 * 3, 4 * 4, 5 * 5, 6 * 6, 7 * 7, 8 * 8, 9 * 9, 10 * 10, 11 * 11, 123 * 123})\n    void positiveTest(final int number) {\n        Assertions.assertTrue(PerfectSquare.isPerfectSquare(number));\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {-1, -2, -3, -4, -5, -100, 2, 3, 5, 6, 7, 8, 10, 11, 12, 13, 15, 17, 99, 101, 257, 999, 1001})\n    void negativeTest(final int number) {\n        Assertions.assertFalse(PerfectSquare.isPerfectSquare(number));\n    }\n}"
    },
    {
        "product_commit": "092ac5795bc2004c04032fc2b79ee892e2ffcb05",
        "test_commit": "092ac5795bc2004c04032fc2b79ee892e2ffcb05",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/SetKthBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/SetKthBitTest.java",
        "product_old_content": "package com.thealgorithms.bitmanipulation;\n\n/***\n * Sets the kth bit of a given integer to 1\n * e.g. setting 3rd bit in binary of 17 (binary 10001) gives 25 (binary 11001)\n * @author inishantjain\n */\n\npublic class SetKthBit {\n    /**\n     * Sets the kth bit of a given integer.\n     *\n     * @param num The original integer.\n     * @param k   The position of the bit to set (0-based index).\n     * @return The integer with the kth bit set.\n     */\n    public static int setKthBit(int num, int k) {\n        int mask = 1 << k;\n        num = num | mask;\n        return num;\n    }\n}",
        "product_new_content": null,
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SetKthBitTest {\n\n    @Test\n    void testSetKthBit() {\n        // Test case: Setting the 0th bit in 5 (binary 101)\n        assertEquals(5, SetKthBit.setKthBit(5, 0));\n\n        // Test case: Setting the 2nd bit in 10 (binary 1010)\n        assertEquals(14, SetKthBit.setKthBit(10, 2));\n\n        // Test case: Setting the 3rd bit in 15 (binary 1111)\n        assertEquals(15, SetKthBit.setKthBit(15, 3));\n\n        // Test case: Setting the 1st bit in 0 (binary 0)\n        assertEquals(2, SetKthBit.setKthBit(0, 1));\n    }\n}",
        "test_new_content": null
    },
    {
        "product_commit": "6a0c0585e4530f0c9cfd207ffe825c5acc3f022f",
        "test_commit": "6a0c0585e4530f0c9cfd207ffe825c5acc3f022f",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AutoCorrelation.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AutoCorrelationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Class for linear auto-correlation of a discrete signal\n *\n * @author Athina-Frederiki Swinkels\n * @version 2.0\n */\n\npublic class AutoCorrelation {\n\n    /**\n     * Discrete linear auto-correlation function.\n     * Input and output signals have starting index 0.\n     *\n     * @param x The discrete signal\n     * @return The result of the auto-correlation of signals x. The result is also a signal.\n     */\n    public static double[] autoCorrelation(double[] x) {\n\n        /*\n        To find the auto-correlation of a discrete signal x, we perform cross-correlation between x signal and itself.\n        Here's an example:\n        x=[1,2,1,1]\n        y=[1,2,1,1]\n\n        i=0:      [1,2,1,1]\n            [1,2,1,1]               result[0]=1*1=1\n\n        i=1:       [1,2,1,1]\n               [1,2,1,1]            result[1]=1*1+2*1=3\n\n        i=2:       [1,2,1,1]\n                 [1,2,1,1]          result[2]=1*2+2*1+1*1=5\n\n        i=3:       [1,2,1,1]\n                   [1,2,1,1]        result[3]=1*1+2*2+1*1+1*1=7\n\n        i=4:       [1,2,1,1]\n                     [1,2,1,1]      result[4]=2*1+1*2+1*1=5\n\n        i=5:       [1,2,1,1]\n                       [1,2,1,1]    result[5]=1*1+1*2=3\n\n        i=1:       [1,2,1,1]\n                         [1,2,1,1]  result[6]=1*1=1\n\n        result=[1,3,5,7,5,3,1]\n\n\n         */\n\n        return CrossCorrelation.crossCorrelation(x, x);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\n/**\n * Test class for AutoCorrelation class\n *\n * @author Athina-Frederiki Swinkels\n * @version 2.0\n */\n\npublic class AutoCorrelationTest {\n\n    @ParameterizedTest\n    @CsvSource({\"1;2;1;1, 1;3;5;7;5;3;1\", \"1;2;3, 3;8;14;8;3\", \"1.5;2.3;3.1;4.2, 6.3;14.31;23.6;34.79;23.6;14.31;6.3\"})\n\n    public void testAutoCorrelationParameterized(String input, String expected) {\n        double[] array = convertStringToArray(input);\n        double[] expectedResult = convertStringToArray(expected);\n\n        double[] result = AutoCorrelation.autoCorrelation(array);\n\n        assertArrayEquals(expectedResult, result, 0.0001);\n    }\n\n    private double[] convertStringToArray(String input) {\n        String[] elements = input.split(\";\");\n        double[] result = new double[elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            result[i] = Double.parseDouble(elements[i]);\n        }\n        return result;\n    }\n}"
    },
    {
        "product_commit": "6a0c0585e4530f0c9cfd207ffe825c5acc3f022f",
        "test_commit": "6a0c0585e4530f0c9cfd207ffe825c5acc3f022f",
        "product_file_path": "src/main/java/com/thealgorithms/maths/CrossCorrelation.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/CrossCorrelationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Class for linear cross-correlation of two discrete signals\n *\n * @author Athina-Frederiki Swinkels\n * @version 1.0\n */\n\npublic class CrossCorrelation {\n\n    /**\n     * Discrete linear cross-correlation function.\n     * Input and output signals have starting index 0.\n     *\n     * @param x The first discrete signal\n     * @param y The second discrete signal\n     * @return The result of the cross-correlation of signals x,y. The result is also a signal.\n     */\n    public static double[] crossCorrelation(double[] x, double[] y) {\n        // The result signal's length is the sum of the input signals' lengths minus 1\n        double[] result = new double[x.length + y.length - 1];\n        int N = result.length;\n\n        /*\n        To find the cross-correlation between 2 discrete signals x & y, we start by \"placing\" the second signal\n        y under the first signal x, shifted to the left so that the last value of y meets the first value of x\n        and for every new position (i++) of the result signal, we shift y signal one position to the right, until\n        the first y-value meets the last x-value. The result-value for each position is the sum of all x*y meeting\n        values.\n        Here's an example:\n        x=[1,2,1,1]\n        y=[1,1,2,1]\n\n        i=0:      [1,2,1,1]\n            [1,1,2,1]               result[0]=1*1=1\n\n        i=1:       [1,2,1,1]\n               [1,1,2,1]            result[1]=1*2+2*1=4\n\n        i=2:       [1,2,1,1]\n                 [1,1,2,1]          result[2]=1*1+2*2+1*1=6\n\n        i=3:       [1,2,1,1]\n                   [1,1,2,1]        result[3]=1*1+2*1+1*2+1*1=6\n\n        i=4:       [1,2,1,1]\n                     [1,1,2,1]      result[4]=2*1+1*1+1*2=5\n\n        i=5:       [1,2,1,1]\n                       [1,1,2,1]    result[5]=1*1+1*1=2\n\n        i=1:       [1,2,1,1]\n                         [1,1,2,1]  result[6]=1*1=1\n\n        result=[1,4,6,6,5,2,1]\n\n\n\n\n        To find the result[i] value for each i:0->N-1, the positions of x-signal in which the 2 signals meet\n        are calculated: kMin<=k<=kMax.\n        The variable 'yStart' indicates the starting index of y in each sum calculation.\n        The variable 'count' increases the index of y-signal by 1, to move to the next value.\n         */\n        int yStart = y.length;\n        for (int i = 0; i < N; i++) {\n            result[i] = 0;\n\n            int kMin = Math.max(i - (y.length - 1), 0);\n            int kMax = Math.min(i, x.length - 1);\n\n            if (i < y.length) {\n                yStart--;\n            }\n\n            int count = 0;\n            for (int k = kMin; k <= kMax; k++) {\n                result[i] += x[k] * y[yStart + count];\n                count++;\n            }\n        }\n\n        // The calculated cross-correlation of x & y signals is returned here.\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\n/**\n * Test class for CrossCorrelation class\n *\n * @author Athina-Frederiki Swinkels\n * @version 2.0\n */\npublic class CrossCorrelationTest {\n\n    @ParameterizedTest\n    @CsvSource({\"1;2;1;1, 1;1;2;1, 1;4;6;6;5;2;1\", \"1;2;3, 1;2;3;4;5, 5;14;26;20;14;8;3\", \"1;2;3;4;5, 1;2;3, 3;8;14;20;26;14;5\", \"1.5;2.3;3.1;4.2, 1.1;2.2;3.3, 4.95;10.89;16.94;23.21;12.65;4.62\"})\n\n    public void testCrossCorrelationParameterized(String input1, String input2, String expected) {\n        double[] array1 = convertStringToArray(input1);\n        double[] array2 = convertStringToArray(input2);\n        double[] expectedResult = convertStringToArray(expected);\n\n        double[] result = CrossCorrelation.crossCorrelation(array1, array2);\n\n        assertArrayEquals(expectedResult, result, 0.0001);\n    }\n\n    private double[] convertStringToArray(String input) {\n        String[] elements = input.split(\";\");\n        double[] result = new double[elements.length];\n        for (int i = 0; i < elements.length; i++) {\n            result[i] = Double.parseDouble(elements[i]);\n        }\n        return result;\n    }\n}"
    },
    {
        "product_commit": "a7d140a43e03821728f919f2402b006ae985cfa5",
        "test_commit": "a7d140a43e03821728f919f2402b006ae985cfa5",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/SetKthBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/SetKthBitTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/***\n * Sets the kth bit of a given integer to 1\n * e.g. setting 3rd bit in binary of 17 (binary 10001) gives 25 (binary 11001)\n * @author inishantjain\n */\n\npublic class SetKthBit {\n    /**\n     * Sets the kth bit of a given integer.\n     *\n     * @param num The original integer.\n     * @param k   The position of the bit to set (0-based index).\n     * @return The integer with the kth bit set.\n     */\n    public static int setKthBit(int num, int k) {\n        int mask = 1 << k;\n        num = num | mask;\n        return num;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SetKthBitTest {\n\n    @Test\n    void testSetKthBit() {\n        // Test case: Setting the 0th bit in 5 (binary 101)\n        assertEquals(5, SetKthBit.setKthBit(5, 0));\n\n        // Test case: Setting the 2nd bit in 10 (binary 1010)\n        assertEquals(14, SetKthBit.setKthBit(10, 2));\n\n        // Test case: Setting the 3rd bit in 15 (binary 1111)\n        assertEquals(15, SetKthBit.setKthBit(15, 3));\n\n        // Test case: Setting the 1st bit in 0 (binary 0)\n        assertEquals(2, SetKthBit.setKthBit(0, 1));\n    }\n}"
    },
    {
        "product_commit": "7ece806cf5cae7c3531f2eb54c56cf33fed2e579",
        "test_commit": "7ece806cf5cae7c3531f2eb54c56cf33fed2e579",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/SimpleSubstitutionCipher.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/SimpleSubstitutionCipherTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n *\n * @author Hassan Elseoudy\n */\npublic class SimpleSubstitutionCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @return Encrypted message\n     */\n    public static String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @return message\n     */\n    public static String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n}",
        "product_new_content": null,
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SimpleSubstitutionCipherTest {\n\n    @Test\n    void testEncode() {\n        // Given\n        String message = \"HELLOWORLD\";\n        String key = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // When\n        String actual = SimpleSubstitutionCipher.encode(message, key);\n\n        // Then\n        assertEquals(\"EINNDTDKNG\", actual);\n    }\n\n    @Test\n    void testDecode() {\n        // Given\n        String message = \"EINNDTDKNG\";\n        String key = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // When\n        String actual = SimpleSubstitutionCipher.decode(message, key);\n\n        // Then\n        assertEquals(\"HELLOWORLD\", actual);\n    }\n\n    @Test\n    void testIsTextTheSameAfterEncodeAndDecode() {\n        // Given\n        String text = \"HELLOWORLD\";\n        String key = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // When\n        String encodedText = SimpleSubstitutionCipher.encode(text, key);\n        String decodedText = SimpleSubstitutionCipher.decode(encodedText, key);\n\n        // Then\n        assertEquals(text, decodedText);\n    }\n}",
        "test_new_content": null
    },
    {
        "product_commit": "e26fd9da71130837d327d747f6bc87688322eee5",
        "test_commit": "e26fd9da71130837d327d747f6bc87688322eee5",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/ORSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/ORSetTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.UUID;\n\n/**\n * ORSet (Observed-Removed Set) is a state-based CRDT (Conflict-free Replicated Data Type)\n * that supports both addition and removal of elements. This particular implementation follows\n * the Add-Wins strategy, meaning that in case of conflicting add and remove operations,\n * the add operation takes precedence. The merge operation of two OR-Sets ensures that\n * elements added at any replica are eventually observed at all replicas. Removed elements,\n * once observed, are never reintroduced.\n * This OR-Set implementation provides methods for adding elements, removing elements,\n * checking for element existence, retrieving the set of elements, comparing with other OR-Sets,\n * and merging with another OR-Set to create a new OR-Set containing all unique elements\n * from both sets.\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n * @see <a href=\"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type\">Conflict-free_replicated_data_type</a>\n * @see <a href=\"https://github.com/itakurah\">itakurah (Niklas Hoefflin)</a>\n */\n\npublic class ORSet<T> {\n\n    private final Set<Pair<T>> elements;\n    private final Set<Pair<T>> tombstones;\n\n    /**\n     * Constructs an empty OR-Set.\n     */\n    public ORSet() {\n        this.elements = new HashSet<>();\n        this.tombstones = new HashSet<>();\n    }\n\n    /**\n     * Checks if the set contains the specified element.\n     *\n     * @param element the element to check for\n     * @return true if the set contains the element, false otherwise\n     */\n    public boolean contains(T element) {\n        return elements.stream().anyMatch(pair -> pair.getElement().equals(element));\n    }\n\n    /**\n     * Retrieves the elements in the set.\n     *\n     * @return a set containing the elements\n     */\n    public Set<T> elements() {\n        Set<T> result = new HashSet<>();\n        elements.forEach(pair -> result.add(pair.getElement()));\n        return result;\n    }\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @param element the element to add\n     */\n    public void add(T element) {\n        String n = prepare();\n        effect(element, n);\n    }\n\n    /**\n     * Removes the specified element from the set.\n     *\n     * @param element the element to remove\n     */\n    public void remove(T element) {\n        Set<Pair<T>> pairsToRemove = prepare(element);\n        effect(pairsToRemove);\n    }\n\n    /**\n     * Collect all pairs with the specified element.\n     *\n     * @param element the element to collect pairs for\n     * @return a set of pairs with the specified element to be removed\n     */\n    private Set<Pair<T>> prepare(T element) {\n        Set<Pair<T>> pairsToRemove = new HashSet<>();\n        for (Pair<T> pair : elements) {\n            if (pair.getElement().equals(element)) {\n                pairsToRemove.add(pair);\n            }\n        }\n        return pairsToRemove;\n    }\n\n    /**\n     * Generates a unique tag for the element.\n     *\n     * @return the unique tag\n     */\n    private String prepare() {\n        return generateUniqueTag();\n    }\n\n    /**\n     * Adds the element with the specified unique tag to the set.\n     *\n     * @param element the element to add\n     * @param n       the unique tag associated with the element\n     */\n    private void effect(T element, String n) {\n        Pair<T> pair = new Pair<>(element, n);\n        elements.add(pair);\n        elements.removeAll(tombstones);\n    }\n\n    /**\n     * Removes the specified pairs from the set.\n     *\n     * @param pairsToRemove the pairs to remove\n     */\n    private void effect(Set<Pair<T>> pairsToRemove) {\n        elements.removeAll(pairsToRemove);\n        tombstones.addAll(pairsToRemove);\n    }\n\n    /**\n     * Generates a unique tag.\n     *\n     * @return the unique tag\n     */\n    private String generateUniqueTag() {\n        return UUID.randomUUID().toString();\n    }\n\n    /**\n     * Compares this Add-Wins OR-Set with another OR-Set to check if elements and tombstones are a subset.\n     *\n     * @param other the other OR-Set to compare\n     * @return true if the sets are subset, false otherwise\n     */\n    public boolean compare(ORSet<T> other) {\n        Set<Pair<T>> union = new HashSet<>(elements);\n        union.addAll(tombstones);\n\n        Set<Pair<T>> otherUnion = new HashSet<>(other.elements);\n        otherUnion.addAll(other.tombstones);\n\n        return otherUnion.containsAll(union) && other.tombstones.containsAll(tombstones);\n    }\n\n    /**\n     * Merges this Add-Wins OR-Set with another OR-Set.\n     *\n     * @param other the other OR-Set to merge\n     */\n    public void merge(ORSet<T> other) {\n        elements.removeAll(other.tombstones);\n        other.elements.removeAll(tombstones);\n        elements.addAll(other.elements);\n        tombstones.addAll(other.tombstones);\n    }\n\n    /**\n     * Represents a pair containing an element and a unique tag.\n     *\n     * @param <T> the type of the element in the pair\n     */\n    public static class Pair<T> {\n        private final T element;\n        private final String uniqueTag;\n\n        /**\n         * Constructs a pair with the specified element and unique tag.\n         *\n         * @param element   the element in the pair\n         * @param uniqueTag the unique tag associated with the element\n         */\n        public Pair(T element, String uniqueTag) {\n            this.element = element;\n            this.uniqueTag = uniqueTag;\n        }\n\n        /**\n         * Gets the element from the pair.\n         *\n         * @return the element\n         */\n        public T getElement() {\n            return element;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\n\nclass ORSetTest {\n\n    @Test\n    void testContains() {\n        ORSet<String> orSet = new ORSet<>();\n        orSet.add(\"A\");\n        assertTrue(orSet.contains(\"A\"));\n    }\n\n    @Test\n    void testAdd() {\n        ORSet<String> orSet = new ORSet<>();\n        orSet.add(\"A\");\n        assertTrue(orSet.contains(\"A\"));\n    }\n\n    @Test\n    void testRemove() {\n        ORSet<String> orSet = new ORSet<>();\n        orSet.add(\"A\");\n        orSet.add(\"A\");\n        orSet.remove(\"A\");\n        assertFalse(orSet.contains(\"A\"));\n    }\n\n    @Test\n    void testElements() {\n        ORSet<String> orSet = new ORSet<>();\n        orSet.add(\"A\");\n        orSet.add(\"B\");\n        assertEquals(Set.of(\"A\", \"B\"), orSet.elements());\n    }\n\n    @Test\n    void testCompareEqualSets() {\n        ORSet<String> orSet1 = new ORSet<>();\n        ORSet<String> orSet2 = new ORSet<>();\n\n        orSet1.add(\"A\");\n        orSet2.add(\"A\");\n        orSet2.add(\"B\");\n        orSet2.add(\"C\");\n        orSet2.remove(\"C\");\n        orSet1.merge(orSet2);\n        orSet2.merge(orSet1);\n        orSet2.remove(\"B\");\n\n        assertTrue(orSet1.compare(orSet2));\n    }\n\n    @Test\n    void testCompareDifferentSets() {\n        ORSet<String> orSet1 = new ORSet<>();\n        ORSet<String> orSet2 = new ORSet<>();\n\n        orSet1.add(\"A\");\n        orSet2.add(\"B\");\n\n        assertFalse(orSet1.compare(orSet2));\n    }\n\n    @Test\n    void testMerge() {\n        ORSet<String> orSet1 = new ORSet<>();\n        ORSet<String> orSet2 = new ORSet<>();\n\n        orSet1.add(\"A\");\n        orSet1.add(\"A\");\n        orSet1.add(\"B\");\n        orSet1.remove(\"B\");\n        orSet2.add(\"B\");\n        orSet2.add(\"C\");\n        orSet2.remove(\"C\");\n        orSet1.merge(orSet2);\n\n        assertTrue(orSet1.contains(\"A\"));\n        assertTrue(orSet1.contains(\"B\"));\n    }\n}"
    },
    {
        "product_commit": "4aa8e6a0eb65e8edb9b716851ee4dd8881c434af",
        "test_commit": "4aa8e6a0eb65e8edb9b716851ee4dd8881c434af",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/TwoPSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/TwoPSetTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * TwoPhaseSet (2P-Set) is a state-based CRDT (Conflict-free Replicated Data Type) designed for managing sets\n * with support for both addition and removal operations in a distributed and concurrent environment.\n * It combines two G-Sets (grow-only sets) - one set for additions and another set (tombstone set) for removals.\n * Once an element is removed and placed in the tombstone set, it cannot be re-added, adhering to \"remove-wins\" semantics.\n * This implementation supports querying the presence of elements, adding elements, removing elements,\n * comparing with other 2P-Sets, and merging two 2P-Sets while preserving the remove-wins semantics.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class TwoPSet {\n    private Set<String> setA;\n    private Set<String> setR;\n\n    /**\n     * Constructs an empty Two-Phase Set.\n     */\n    public TwoPSet() {\n        this.setA = new HashSet<>();\n        this.setR = new HashSet<>();\n    }\n\n    /**\n     * Checks if an element is in the set and has not been removed.\n     *\n     * @param element The element to be checked.\n     * @return True if the element is in the set and has not been removed, otherwise false.\n     */\n    public boolean lookup(String element) {\n        return setA.contains(element) && !setR.contains(element);\n    }\n\n    /**\n     * Adds an element to the set.\n     *\n     * @param element The element to be added.\n     */\n    public void add(String element) {\n        setA.add(element);\n    }\n\n    /**\n     * Removes an element from the set. The element will be placed in the tombstone set.\n     *\n     * @param element The element to be removed.\n     */\n    public void remove(String element) {\n        if (lookup(element)) {\n            setR.add(element);\n        }\n    }\n\n    /**\n     * Compares the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to compare with.\n     * @return True if both SetA and SetR are subset, otherwise false.\n     */\n    public boolean compare(TwoPSet otherSet) {\n        return otherSet.setA.containsAll(setA) && otherSet.setR.containsAll(setR);\n    }\n\n    /**\n     * Merges the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to merge with.\n     * @return A new 2P-Set containing the merged elements.\n     */\n    public TwoPSet merge(TwoPSet otherSet) {\n        TwoPSet mergedSet = new TwoPSet();\n        mergedSet.setA.addAll(this.setA);\n        mergedSet.setA.addAll(otherSet.setA);\n        mergedSet.setR.addAll(this.setR);\n        mergedSet.setR.addAll(otherSet.setR);\n        return mergedSet;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * TwoPhaseSet (2P-Set) is a state-based CRDT (Conflict-free Replicated Data Type) designed for managing sets\n * with support for both addition and removal operations in a distributed and concurrent environment.\n * It combines two G-Sets (grow-only sets) - one set for additions and another set (tombstone set) for removals.\n * Once an element is removed and placed in the tombstone set, it cannot be re-added, adhering to \"remove-wins\" semantics.\n * This implementation supports querying the presence of elements, adding elements, removing elements,\n * comparing with other 2P-Sets, and merging two 2P-Sets while preserving the remove-wins semantics.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class TwoPSet<T> {\n    private final Set<T> setA;\n    private final Set<T> setR;\n\n    /**\n     * Constructs an empty Two-Phase Set.\n     */\n    public TwoPSet() {\n        this.setA = new HashSet<>();\n        this.setR = new HashSet<>();\n    }\n\n    /**\n     * Checks if an element is in the set and has not been removed.\n     *\n     * @param element The element to be checked.\n     * @return True if the element is in the set and has not been removed, otherwise false.\n     */\n    public boolean lookup(T element) {\n        return setA.contains(element) && !setR.contains(element);\n    }\n\n    /**\n     * Adds an element to the set.\n     *\n     * @param element The element to be added.\n     */\n    public void add(T element) {\n        setA.add(element);\n    }\n\n    /**\n     * Removes an element from the set. The element will be placed in the tombstone set.\n     *\n     * @param element The element to be removed.\n     */\n    public void remove(T element) {\n        if (lookup(element)) {\n            setR.add(element);\n        }\n    }\n\n    /**\n     * Compares the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to compare with.\n     * @return True if both SetA and SetR are subset, otherwise false.\n     */\n    public boolean compare(TwoPSet<T> otherSet) {\n        return otherSet.setA.containsAll(setA) && otherSet.setR.containsAll(setR);\n    }\n\n    /**\n     * Merges the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to merge with.\n     * @return A new 2P-Set containing the merged elements.\n     */\n    public TwoPSet<T> merge(TwoPSet<T> otherSet) {\n        TwoPSet<T> mergedSet = new TwoPSet<>();\n        mergedSet.setA.addAll(this.setA);\n        mergedSet.setA.addAll(otherSet.setA);\n        mergedSet.setR.addAll(this.setR);\n        mergedSet.setR.addAll(otherSet.setR);\n        return mergedSet;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass TwoPSetTest {\n\n    private TwoPSet set;\n\n    @BeforeEach\n    void setUp() {\n        set = new TwoPSet();\n    }\n\n    @Test\n    void testLookup() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n        assertFalse(set.lookup(\"B\"));\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testAdd() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testRemove() {\n        set.add(\"A\");\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testCompare() {\n        TwoPSet set1 = new TwoPSet();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet set2 = new TwoPSet();\n        set2.add(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.add(\"B\");\n        assertTrue(set1.compare(set2));\n        set1.remove(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.remove(\"A\");\n        assertTrue(set1.compare(set2));\n    }\n\n    @Test\n    void testMerge() {\n        TwoPSet set1 = new TwoPSet();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet set2 = new TwoPSet();\n        set2.add(\"B\");\n        set2.add(\"C\");\n        TwoPSet mergedSet = set1.merge(set2);\n        assertTrue(mergedSet.lookup(\"A\"));\n        assertTrue(mergedSet.lookup(\"B\"));\n        assertTrue(mergedSet.lookup(\"C\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass TwoPSetTest {\n\n    private TwoPSet<String> set;\n\n    @BeforeEach\n    void setUp() {\n        set = new TwoPSet<>();\n    }\n\n    @Test\n    void testLookup() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n        assertFalse(set.lookup(\"B\"));\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testAdd() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testRemove() {\n        set.add(\"A\");\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testCompare() {\n        TwoPSet<String> set1 = new TwoPSet<>();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet<String> set2 = new TwoPSet<>();\n        set2.add(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.add(\"B\");\n        assertTrue(set1.compare(set2));\n        set1.remove(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.remove(\"A\");\n        assertTrue(set1.compare(set2));\n    }\n\n    @Test\n    void testMerge() {\n        TwoPSet<String> set1 = new TwoPSet<>();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet<String> set2 = new TwoPSet<>();\n        set2.add(\"B\");\n        set2.add(\"C\");\n        TwoPSet<String> mergedSet = set1.merge(set2);\n        assertTrue(mergedSet.lookup(\"A\"));\n        assertTrue(mergedSet.lookup(\"B\"));\n        assertTrue(mergedSet.lookup(\"C\"));\n    }\n}"
    },
    {
        "product_commit": "b8b1dea38de84d7647921cd1859b7d58303e9b86",
        "test_commit": "b8b1dea38de84d7647921cd1859b7d58303e9b86",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/LWWElementSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/LWWElementSetTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Last-Write-Wins Element Set (LWWElementSet) is a state-based CRDT (Conflict-free Replicated Data Type)\n * designed for managing sets in a distributed and concurrent environment. It supports the addition and removal\n * of elements, using timestamps to determine the order of operations. The set is split into two subsets:\n * the add set for elements to be added and the remove set for elements to be removed.\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n * @see <a href=\"https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type\">Conflict-free_replicated_data_type</a>\n * @see <a href=\"https://github.com/itakurah\">itakurah (Niklas Hoefflin)</a>\n */\n\nclass Element {\n    String key;\n    int timestamp;\n    Bias bias;\n\n    /**\n     * Constructs a new Element with the specified key, timestamp and bias.\n     *\n     * @param key       The key of the element.\n     * @param timestamp The timestamp associated with the element.\n     * @param bias      The bias of the element (ADDS or REMOVALS).\n     */\n    public Element(String key, int timestamp, Bias bias) {\n        this.key = key;\n        this.timestamp = timestamp;\n        this.bias = bias;\n    }\n}\n\nenum Bias {\n    /**\n     * ADDS bias for the add set.\n     * REMOVALS bias for the remove set.\n     */\n    ADDS,\n    REMOVALS\n}\n\nclass LWWElementSet {\n    private final Map<String, Element> addSet;\n    private final Map<String, Element> removeSet;\n\n    /**\n     * Constructs an empty LWWElementSet.\n     */\n    public LWWElementSet() {\n        this.addSet = new HashMap<>();\n        this.removeSet = new HashMap<>();\n    }\n\n    /**\n     * Adds an element to the addSet.\n     *\n     * @param e The element to be added.\n     */\n    public void add(Element e) {\n        addSet.put(e.key, e);\n    }\n\n    /**\n     * Removes an element from the removeSet.\n     *\n     * @param e The element to be removed.\n     */\n    public void remove(Element e) {\n        if (lookup(e)) {\n            removeSet.put(e.key, e);\n        }\n    }\n\n    /**\n     * Checks if an element is in the LWWElementSet by comparing timestamps in the addSet and removeSet.\n     *\n     * @param e The element to be checked.\n     * @return True if the element is present, false otherwise.\n     */\n    public boolean lookup(Element e) {\n        Element inAddSet = addSet.get(e.key);\n        Element inRemoveSet = removeSet.get(e.key);\n\n        return (inAddSet != null && (inRemoveSet == null || inAddSet.timestamp > inRemoveSet.timestamp));\n    }\n\n    /**\n     * Compares the LWWElementSet with another LWWElementSet to check if addSet and removeSet are a subset.\n     *\n     * @param other The LWWElementSet to compare.\n     * @return True if the set is subset, false otherwise.\n     */\n    public boolean compare(LWWElementSet other) {\n        return other.addSet.keySet().containsAll(addSet.keySet()) && other.removeSet.keySet().containsAll(removeSet.keySet());\n    }\n\n    /**\n     * Merges another LWWElementSet into this set by resolving conflicts based on timestamps.\n     *\n     * @param other The LWWElementSet to merge.\n     */\n    public void merge(LWWElementSet other) {\n        for (Element e : other.addSet.values()) {\n            if (!addSet.containsKey(e.key) || compareTimestamps(addSet.get(e.key), e)) {\n                addSet.put(e.key, e);\n            }\n        }\n\n        for (Element e : other.removeSet.values()) {\n            if (!removeSet.containsKey(e.key) || compareTimestamps(removeSet.get(e.key), e)) {\n                removeSet.put(e.key, e);\n            }\n        }\n    }\n\n    /**\n     * Compares timestamps of two elements based on their bias (ADDS or REMOVALS).\n     *\n     * @param e     The first element.\n     * @param other The second element.\n     * @return True if the first element's timestamp is greater or the bias is ADDS and timestamps are equal.\n     */\n    public boolean compareTimestamps(Element e, Element other) {\n        if (!e.bias.equals(other.bias)) {\n            throw new IllegalArgumentException(\"Invalid bias value\");\n        }\n        Bias bias = e.bias;\n        int timestampComparison = Integer.compare(e.timestamp, other.timestamp);\n\n        if (timestampComparison == 0) {\n            return !bias.equals(Bias.ADDS);\n        }\n        return timestampComparison < 0;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass LWWElementSetTest {\n\n    private LWWElementSet set;\n    private final Bias bias = Bias.ADDS;\n\n    @BeforeEach\n    void setUp() {\n        set = new LWWElementSet();\n    }\n\n    @Test\n    void testAdd() {\n        Element element = new Element(\"key1\", 1, bias);\n        set.add(element);\n\n        assertTrue(set.lookup(element));\n    }\n\n    @Test\n    void testRemove() {\n        Element element = new Element(\"key1\", 1, bias);\n        set.add(element);\n        set.remove(element);\n\n        assertFalse(set.lookup(element));\n    }\n\n    @Test\n    void testRemoveNonexistentElement() {\n        Element element = new Element(\"key1\", 1, bias);\n        set.remove(element);\n\n        assertFalse(set.lookup(element));\n    }\n\n    @Test\n    void testLookupNonexistentElement() {\n        Element element = new Element(\"key1\", 1, bias);\n\n        assertFalse(set.lookup(element));\n    }\n\n    @Test\n    void testCompareEqualSets() {\n        LWWElementSet otherSet = new LWWElementSet();\n\n        Element element = new Element(\"key1\", 1, bias);\n        set.add(element);\n        otherSet.add(element);\n\n        assertTrue(set.compare(otherSet));\n\n        otherSet.add(new Element(\"key2\", 2, bias));\n        assertTrue(set.compare(otherSet));\n    }\n\n    @Test\n    void testCompareDifferentSets() {\n        LWWElementSet otherSet = new LWWElementSet();\n\n        Element element1 = new Element(\"key1\", 1, bias);\n        Element element2 = new Element(\"key2\", 2, bias);\n\n        set.add(element1);\n        otherSet.add(element2);\n\n        assertFalse(set.compare(otherSet));\n    }\n\n    @Test\n    void testMerge() {\n        LWWElementSet otherSet = new LWWElementSet();\n\n        Element element1 = new Element(\"key1\", 1, bias);\n        Element element2 = new Element(\"key2\", 2, bias);\n\n        set.add(element1);\n        otherSet.add(element2);\n\n        set.merge(otherSet);\n\n        assertTrue(set.lookup(element1));\n        assertTrue(set.lookup(element2));\n    }\n\n    @Test\n    void testCompareTimestampsEqualTimestamps() {\n        LWWElementSet lwwElementSet = new LWWElementSet();\n\n        Element e1 = new Element(\"key1\", 10, Bias.REMOVALS);\n        Element e2 = new Element(\"key1\", 10, Bias.REMOVALS);\n\n        assertTrue(lwwElementSet.compareTimestamps(e1, e2));\n\n        e1 = new Element(\"key1\", 10, Bias.ADDS);\n        e2 = new Element(\"key1\", 10, Bias.ADDS);\n\n        assertFalse(lwwElementSet.compareTimestamps(e1, e2));\n    }\n}"
    },
    {
        "product_commit": "92131de3774d6dc7be7662bd0a8a9c02704255d5",
        "test_commit": "92131de3774d6dc7be7662bd0a8a9c02704255d5",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/GSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/GSetTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * GSet (Grow-only Set) is a state-based CRDT (Conflict-free Replicated Data Type)\n * that allows only the addition of elements and ensures that once an element is added,\n * it cannot be removed. The merge operation of two G-Sets is their union.\n * This implementation supports adding elements, looking up elements, comparing with other G-Sets,\n * and merging with another G-Set to create a new G-Set containing all unique elements from both sets.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class GSet<T> {\n    private final Set<T> elements;\n\n    /**\n     * Constructs an empty G-Set.\n     */\n    public GSet() {\n        this.elements = new HashSet<>();\n    }\n\n    /**\n     * Adds an element to the G-Set.\n     *\n     * @param e the element to be added\n     */\n    public void addElement(T e) {\n        elements.add(e);\n    }\n\n    /**\n     * Checks if the given element is present in the G-Set.\n     *\n     * @param e the element to be checked\n     * @return true if the element is present, false otherwise\n     */\n    public boolean lookup(T e) {\n        return elements.contains(e);\n    }\n\n    /**\n     * Compares the G-Set with another G-Set to check if it is a subset.\n     *\n     * @param other the other G-Set to compare with\n     * @return true if the current G-Set is a subset of the other, false otherwise\n     */\n    public boolean compare(GSet<T> other) {\n        return elements.containsAll(other.elements);\n    }\n\n    /**\n     * Merges the current G-Set with another G-Set, creating a new G-Set\n     * containing all unique elements from both sets.\n     *\n     * @param other the G-Set to merge with\n     */\n    public void merge(GSet<T> other) {\n        elements.addAll(other.elements);\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * GSet (Grow-only Set) is a state-based CRDT (Conflict-free Replicated Data Type)\n * that allows only the addition of elements and ensures that once an element is added,\n * it cannot be removed. The merge operation of two G-Sets is their union.\n * This implementation supports adding elements, looking up elements, comparing with other G-Sets,\n * and merging with another G-Set to create a new G-Set containing all unique elements from both sets.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class GSet<T> {\n    private final Set<T> elements;\n\n    /**\n     * Constructs an empty G-Set.\n     */\n    public GSet() {\n        this.elements = new HashSet<>();\n    }\n\n    /**\n     * Adds an element to the G-Set.\n     *\n     * @param e the element to be added\n     */\n    public void addElement(T e) {\n        elements.add(e);\n    }\n\n    /**\n     * Checks if the given element is present in the G-Set.\n     *\n     * @param e the element to be checked\n     * @return true if the element is present, false otherwise\n     */\n    public boolean lookup(T e) {\n        return elements.contains(e);\n    }\n\n    /**\n     * Compares the G-Set with another G-Set to check if it is a subset.\n     *\n     * @param other the other G-Set to compare with\n     * @return true if the current G-Set is a subset of the other, false otherwise\n     */\n    public boolean compare(GSet<T> other) {\n        return other.elements.containsAll(elements);\n    }\n\n    /**\n     * Merges the current G-Set with another G-Set, creating a new G-Set\n     * containing all unique elements from both sets.\n     *\n     * @param other the G-Set to merge with\n     */\n    public void merge(GSet<T> other) {\n        elements.addAll(other.elements);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass GSetTest {\n\n    @Test\n    void testAddElement() {\n        GSet<String> gSet = new GSet<>();\n        gSet.addElement(\"apple\");\n        gSet.addElement(\"orange\");\n\n        assertTrue(gSet.lookup(\"apple\"));\n        assertTrue(gSet.lookup(\"orange\"));\n        assertFalse(gSet.lookup(\"banana\"));\n    }\n\n    @Test\n    void testLookup() {\n        GSet<Integer> gSet = new GSet<>();\n        gSet.addElement(1);\n        gSet.addElement(2);\n\n        assertTrue(gSet.lookup(1));\n        assertTrue(gSet.lookup(2));\n        assertFalse(gSet.lookup(3));\n    }\n\n    @Test\n    void testCompare() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        assertFalse(gSet1.compare(gSet2));\n\n        GSet<String> gSet3 = new GSet<>();\n        gSet3.addElement(\"apple\");\n        gSet3.addElement(\"orange\");\n\n        assertTrue(gSet1.compare(gSet3));\n    }\n\n    @Test\n    void testMerge() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        GSet<String> mergedSet = new GSet<>();\n        mergedSet.merge(gSet1);\n        mergedSet.merge(gSet2);\n\n        assertTrue(mergedSet.lookup(\"apple\"));\n        assertTrue(mergedSet.lookup(\"orange\"));\n        assertTrue(mergedSet.lookup(\"banana\"));\n        assertFalse(mergedSet.lookup(\"grape\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass GSetTest {\n\n    @Test\n    void testAddElement() {\n        GSet<String> gSet = new GSet<>();\n        gSet.addElement(\"apple\");\n        gSet.addElement(\"orange\");\n\n        assertTrue(gSet.lookup(\"apple\"));\n        assertTrue(gSet.lookup(\"orange\"));\n        assertFalse(gSet.lookup(\"banana\"));\n    }\n\n    @Test\n    void testLookup() {\n        GSet<Integer> gSet = new GSet<>();\n        gSet.addElement(1);\n        gSet.addElement(2);\n\n        assertTrue(gSet.lookup(1));\n        assertTrue(gSet.lookup(2));\n        assertFalse(gSet.lookup(3));\n    }\n\n    @Test\n    void testCompare() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n        gSet2.addElement(\"orange\");\n        assertFalse(gSet1.compare(gSet2));\n        gSet2.addElement(\"apple\");\n        assertTrue(gSet1.compare(gSet2));\n        gSet2.addElement(\"banana\");\n        assertTrue(gSet1.compare(gSet2));\n    }\n\n    @Test\n    void testMerge() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        GSet<String> mergedSet = new GSet<>();\n        mergedSet.merge(gSet1);\n        mergedSet.merge(gSet2);\n\n        assertTrue(mergedSet.lookup(\"apple\"));\n        assertTrue(mergedSet.lookup(\"orange\"));\n        assertTrue(mergedSet.lookup(\"banana\"));\n        assertFalse(mergedSet.lookup(\"grape\"));\n    }\n}"
    },
    {
        "product_commit": "249ee1dc994735a6cf02a6048ab8bedd2e91ce4a",
        "test_commit": "249ee1dc994735a6cf02a6048ab8bedd2e91ce4a",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/TwoPSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/TwoPSetTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * TwoPhaseSet (2P-Set) is a state-based CRDT (Conflict-free Replicated Data Type) designed for managing sets\n * with support for both addition and removal operations in a distributed and concurrent environment.\n * It combines two G-Sets (grow-only sets) - one set for additions and another set (tombstone set) for removals.\n * Once an element is removed and placed in the tombstone set, it cannot be re-added, adhering to \"remove-wins\" semantics.\n * This implementation supports querying the presence of elements, adding elements, removing elements,\n * comparing with other 2P-Sets, and merging two 2P-Sets while preserving the remove-wins semantics.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class TwoPSet {\n    private Set<String> setA;\n    private Set<String> setR;\n\n    /**\n     * Constructs an empty Two-Phase Set.\n     */\n    public TwoPSet() {\n        this.setA = new HashSet<>();\n        this.setR = new HashSet<>();\n    }\n\n    /**\n     * Checks if an element is in the set and has not been removed.\n     *\n     * @param element The element to be checked.\n     * @return True if the element is in the set and has not been removed, otherwise false.\n     */\n    public boolean lookup(String element) {\n        return setA.contains(element) && !setR.contains(element);\n    }\n\n    /**\n     * Adds an element to the set.\n     *\n     * @param element The element to be added.\n     */\n    public void add(String element) {\n        setA.add(element);\n    }\n\n    /**\n     * Removes an element from the set. The element will be placed in the tombstone set.\n     *\n     * @param element The element to be removed.\n     */\n    public void remove(String element) {\n        if (lookup(element)) {\n            setR.add(element);\n        }\n    }\n\n    /**\n     * Compares the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to compare with.\n     * @return True if both SetA and SetR are subset, otherwise false.\n     */\n    public boolean compare(TwoPSet otherSet) {\n        return otherSet.setA.containsAll(setA) && otherSet.setR.containsAll(setR);\n    }\n\n    /**\n     * Merges the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to merge with.\n     * @return A new 2P-Set containing the merged elements.\n     */\n    public TwoPSet merge(TwoPSet otherSet) {\n        TwoPSet mergedSet = new TwoPSet();\n        mergedSet.setA.addAll(this.setA);\n        mergedSet.setA.addAll(otherSet.setA);\n        mergedSet.setR.addAll(this.setR);\n        mergedSet.setR.addAll(otherSet.setR);\n        return mergedSet;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass TwoPSetTest {\n\n    private TwoPSet set;\n\n    @BeforeEach\n    void setUp() {\n        set = new TwoPSet();\n    }\n\n    @Test\n    void testLookup() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n        assertFalse(set.lookup(\"B\"));\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testAdd() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testRemove() {\n        set.add(\"A\");\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testCompare() {\n        TwoPSet set1 = new TwoPSet();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet set2 = new TwoPSet();\n        set2.add(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.add(\"B\");\n        assertTrue(set1.compare(set2));\n        set1.remove(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.remove(\"A\");\n        assertTrue(set1.compare(set2));\n    }\n\n    @Test\n    void testMerge() {\n        TwoPSet set1 = new TwoPSet();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet set2 = new TwoPSet();\n        set2.add(\"B\");\n        set2.add(\"C\");\n        TwoPSet mergedSet = set1.merge(set2);\n        assertTrue(mergedSet.lookup(\"A\"));\n        assertTrue(mergedSet.lookup(\"B\"));\n        assertTrue(mergedSet.lookup(\"C\"));\n    }\n}"
    },
    {
        "product_commit": "e59a3b1ebba0b484fad64adb06aedc06eb366825",
        "test_commit": "e59a3b1ebba0b484fad64adb06aedc06eb366825",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/GSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/GSetTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * GSet (Grow-only Set) is a state-based CRDT (Conflict-free Replicated Data Type)\n * that allows only the addition of elements and ensures that once an element is added,\n * it cannot be removed. The merge operation of two G-Sets is their union.\n * This implementation supports adding elements, looking up elements, comparing with other G-Sets,\n * and merging with another G-Set to create a new G-Set containing all unique elements from both sets.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class GSet<T> {\n    private final Set<T> elements;\n\n    /**\n     * Constructs an empty G-Set.\n     */\n    public GSet() {\n        this.elements = new HashSet<>();\n    }\n\n    /**\n     * Adds an element to the G-Set.\n     *\n     * @param e the element to be added\n     */\n    public void addElement(T e) {\n        elements.add(e);\n    }\n\n    /**\n     * Checks if the given element is present in the G-Set.\n     *\n     * @param e the element to be checked\n     * @return true if the element is present, false otherwise\n     */\n    public boolean lookup(T e) {\n        return elements.contains(e);\n    }\n\n    /**\n     * Compares the G-Set with another G-Set to check if it is a subset.\n     *\n     * @param other the other G-Set to compare with\n     * @return true if the current G-Set is a subset of the other, false otherwise\n     */\n    public boolean compare(GSet<T> other) {\n        return elements.containsAll(other.elements);\n    }\n\n    /**\n     * Merges the current G-Set with another G-Set, creating a new G-Set\n     * containing all unique elements from both sets.\n     *\n     * @param other the G-Set to merge with\n     */\n    public void merge(GSet<T> other) {\n        elements.addAll(other.elements);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass GSetTest {\n\n    @Test\n    void testAddElement() {\n        GSet<String> gSet = new GSet<>();\n        gSet.addElement(\"apple\");\n        gSet.addElement(\"orange\");\n\n        assertTrue(gSet.lookup(\"apple\"));\n        assertTrue(gSet.lookup(\"orange\"));\n        assertFalse(gSet.lookup(\"banana\"));\n    }\n\n    @Test\n    void testLookup() {\n        GSet<Integer> gSet = new GSet<>();\n        gSet.addElement(1);\n        gSet.addElement(2);\n\n        assertTrue(gSet.lookup(1));\n        assertTrue(gSet.lookup(2));\n        assertFalse(gSet.lookup(3));\n    }\n\n    @Test\n    void testCompare() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        assertFalse(gSet1.compare(gSet2));\n\n        GSet<String> gSet3 = new GSet<>();\n        gSet3.addElement(\"apple\");\n        gSet3.addElement(\"orange\");\n\n        assertTrue(gSet1.compare(gSet3));\n    }\n\n    @Test\n    void testMerge() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        GSet<String> mergedSet = new GSet<>();\n        mergedSet.merge(gSet1);\n        mergedSet.merge(gSet2);\n\n        assertTrue(mergedSet.lookup(\"apple\"));\n        assertTrue(mergedSet.lookup(\"orange\"));\n        assertTrue(mergedSet.lookup(\"banana\"));\n        assertFalse(mergedSet.lookup(\"grape\"));\n    }\n}"
    },
    {
        "product_commit": "3001620c1eef3246f666c459f096ba390afce06b",
        "test_commit": "3001620c1eef3246f666c459f096ba390afce06b",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/PNCounter.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/PNCounterTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * PN-Counter (Positive-Negative Counter) is a state-based CRDT (Conflict-free Replicated Data Type)\n * designed for tracking counts with both increments and decrements in a distributed and concurrent environment.\n * It combines two G-Counters, one for increments (P) and one for decrements (N).\n * The total count is obtained by subtracting the value of the decrement counter from the increment counter.\n * This implementation supports incrementing, decrementing, querying the total count,\n * comparing with other PN-Counters, and merging with another PN-Counter\n * to compute the element-wise maximum for both increment and decrement counters.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\nclass PNCounter {\n    private final Map<Integer, Integer> P;\n    private final Map<Integer, Integer> N;\n    private final int myId;\n    private final int n;\n\n    /**\n     * Constructs a PN-Counter for a cluster of n nodes.\n     *\n     * @param myId The identifier of the current node.\n     * @param n    The number of nodes in the cluster.\n     */\n    public PNCounter(int myId, int n) {\n        this.myId = myId;\n        this.n = n;\n        this.P = new HashMap<>();\n        this.N = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            P.put(i, 0);\n            N.put(i, 0);\n        }\n    }\n\n    /**\n     * Increments the increment counter for the current node.\n     */\n    public void increment() {\n        P.put(myId, P.get(myId) + 1);\n    }\n\n    /**\n     * Increments the decrement counter for the current node.\n     */\n    public void decrement() {\n        N.put(myId, N.get(myId) + 1);\n    }\n\n    /**\n     * Gets the total value of the counter by subtracting the decrement counter from the increment counter.\n     *\n     * @return The total value of the counter.\n     */\n    public int value() {\n        int sumP = P.values().stream().mapToInt(Integer::intValue).sum();\n        int sumN = N.values().stream().mapToInt(Integer::intValue).sum();\n        return sumP - sumN;\n    }\n\n    /**\n     * Compares the state of this PN-Counter with another PN-Counter.\n     *\n     * @param other The other PN-Counter to compare with.\n     * @return True if the state of this PN-Counter is less than or equal to the state of the other PN-Counter.\n     */\n    public boolean compare(PNCounter other) {\n        if (this.n != other.n) {\n            throw new IllegalArgumentException(\"Cannot compare PN-Counters with different number of nodes\");\n        }\n        for (int i = 0; i < n; i++) {\n            if (this.P.get(i) > other.P.get(i) && this.N.get(i) > other.N.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Merges the state of this PN-Counter with another PN-Counter.\n     *\n     * @param other The other PN-Counter to merge with.\n     */\n    public void merge(PNCounter other) {\n        if (this.n != other.n) {\n            throw new IllegalArgumentException(\"Cannot merge PN-Counters with different number of nodes\");\n        }\n        for (int i = 0; i < n; i++) {\n            this.P.put(i, Math.max(this.P.get(i), other.P.get(i)));\n            this.N.put(i, Math.max(this.N.get(i), other.N.get(i)));\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PNCounterTest {\n\n    @Test\n    public void testIncrement() {\n        PNCounter counter = new PNCounter(0, 3);\n        counter.increment();\n        assertEquals(1, counter.value());\n    }\n\n    @Test\n    public void testDecrement() {\n        PNCounter counter = new PNCounter(0, 3);\n        counter.decrement();\n        assertEquals(-1, counter.value());\n    }\n\n    @Test\n    public void testIncrementAndDecrement() {\n        PNCounter counter = new PNCounter(0, 3);\n        counter.increment();\n        counter.increment();\n        counter.decrement();\n        assertEquals(1, counter.value());\n    }\n\n    @Test\n    public void testCompare() {\n        PNCounter counter1 = new PNCounter(0, 3);\n        counter1.increment();\n        PNCounter counter2 = new PNCounter(1, 3);\n        assertTrue(counter1.compare(counter2));\n        counter2.increment();\n        assertTrue(counter2.compare(counter1));\n        counter1.decrement();\n        assertFalse(counter1.compare(counter2));\n    }\n\n    @Test\n    public void testMerge() {\n        PNCounter counter1 = new PNCounter(0, 3);\n        counter1.increment();\n        counter1.increment();\n        PNCounter counter2 = new PNCounter(1, 3);\n        counter2.increment();\n        counter1.merge(counter2);\n        assertEquals(3, counter1.value());\n    }\n}"
    },
    {
        "product_commit": "e759544c333de9b98ff51458e1d71c69006f976b",
        "test_commit": "e759544c333de9b98ff51458e1d71c69006f976b",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/BoruvkaAlgorithm.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/BoruvkaAlgorithmTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Boruvka's algorithm to find Minimum Spanning Tree\n * (https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm)\n *\n * @author itakurah (https://github.com/itakurah)\n */\n\nfinal class BoruvkaAlgorithm {\n    private BoruvkaAlgorithm() {\n    }\n\n    /**\n     * Represents an edge in the graph\n     */\n    static class Edge {\n        final int src;\n        final int dest;\n        final int weight;\n\n        Edge(final int src, final int dest, final int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n\n    /**\n     * Represents the graph\n     */\n    static class Graph {\n        final int vertex;\n        final List<Edge> edges;\n\n        /**\n         * Constructor for the graph\n         *\n         * @param vertex number of vertices\n         * @param edges  list of edges\n         */\n        Graph(final int vertex, final List<Edge> edges) {\n            if (vertex < 0) {\n                throw new IllegalArgumentException(\"Number of vertices must be positive\");\n            }\n            if (edges == null || edges.isEmpty()) {\n                throw new IllegalArgumentException(\"Edges list must not be null or empty\");\n            }\n            for (final var edge : edges) {\n                checkEdgeVertices(edge.src, vertex);\n                checkEdgeVertices(edge.dest, vertex);\n            }\n\n            this.vertex = vertex;\n            this.edges = edges;\n        }\n    }\n\n    /**\n     * Represents a subset for Union-Find operations\n     */\n    private static class Component {\n        int parent;\n        int rank;\n\n        Component(final int parent, final int rank) {\n            this.parent = parent;\n            this.rank = rank;\n        }\n    }\n\n    /**\n     * Represents the state of Union-Find components and the result list\n     */\n    private static class BoruvkaState {\n        List<Edge> result;\n        Component[] components;\n        final Graph graph;\n\n        BoruvkaState(final Graph graph) {\n            this.result = new ArrayList<>();\n            this.components = initializeComponents(graph);\n            this.graph = graph;\n        }\n\n        /**\n         * Adds the cheapest edges to the result list and performs Union operation on the subsets.\n         *\n         * @param cheapest Array containing the cheapest edge for each subset.\n         */\n        void merge(final Edge[] cheapest) {\n            for (int i = 0; i < graph.vertex; ++i) {\n                if (cheapest[i] != null) {\n                    final var component1 = find(components, cheapest[i].src);\n                    final var component2 = find(components, cheapest[i].dest);\n\n                    if (component1 != component2) {\n                        result.add(cheapest[i]);\n                        union(components, component1, component2);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks if there are more edges to add to the result list\n         *\n         * @return true if there are more edges to add, false otherwise\n         */\n        boolean hasMoreEdgesToAdd() {\n            return result.size() < graph.vertex - 1;\n        }\n\n        /**\n         * Computes the cheapest edges for each subset in the Union-Find structure.\n         *\n         * @return an array containing the cheapest edge for each subset.\n         */\n        private Edge[] computeCheapestEdges() {\n            Edge[] cheapest = new Edge[graph.vertex];\n            for (final var edge : graph.edges) {\n                final var set1 = find(components, edge.src);\n                final var set2 = find(components, edge.dest);\n\n                if (set1 != set2) {\n                    if (cheapest[set1] == null || edge.weight < cheapest[set1].weight) {\n                        cheapest[set1] = edge;\n                    }\n                    if (cheapest[set2] == null || edge.weight < cheapest[set2].weight) {\n                        cheapest[set2] = edge;\n                    }\n                }\n            }\n            return cheapest;\n        }\n\n        /**\n         * Initializes subsets for Union-Find\n         *\n         * @param graph the graph\n         * @return the initialized subsets\n         */\n        private static Component[] initializeComponents(final Graph graph) {\n            Component[] components = new Component[graph.vertex];\n            for (int v = 0; v < graph.vertex; ++v) {\n                components[v] = new Component(v, 0);\n            }\n            return components;\n        }\n    }\n\n    /**\n     * Finds the parent of the subset using path compression\n     *\n     * @param components array of subsets\n     * @param i          index of the subset\n     * @return the parent of the subset\n     */\n    static int find(final Component[] components, final int i) {\n        if (components[i].parent != i) {\n            components[i].parent = find(components, components[i].parent);\n        }\n        return components[i].parent;\n    }\n\n    /**\n     * Performs the Union operation for Union-Find\n     *\n     * @param components array of subsets\n     * @param x          index of the first subset\n     * @param y          index of the second subset\n     */\n    static void union(Component[] components, final int x, final int y) {\n        final int xroot = find(components, x);\n        final int yroot = find(components, y);\n\n        if (components[xroot].rank < components[yroot].rank) {\n            components[xroot].parent = yroot;\n        } else if (components[xroot].rank > components[yroot].rank) {\n            components[yroot].parent = xroot;\n        } else {\n            components[yroot].parent = xroot;\n            components[xroot].rank++;\n        }\n    }\n\n    /**\n     * Boruvka's algorithm to find the Minimum Spanning Tree\n     *\n     * @param graph the graph\n     * @return list of edges in the Minimum Spanning Tree\n     */\n    static List<Edge> boruvkaMST(final Graph graph) {\n        var boruvkaState = new BoruvkaState(graph);\n\n        while (boruvkaState.hasMoreEdgesToAdd()) {\n            final var cheapest = boruvkaState.computeCheapestEdges();\n            boruvkaState.merge(cheapest);\n        }\n        return boruvkaState.result;\n    }\n\n    /**\n     * Checks if the edge vertices are in a valid range\n     *\n     * @param vertex     the vertex to check\n     * @param upperBound the upper bound for the vertex range\n     */\n    private static void checkEdgeVertices(final int vertex, final int upperBound) {\n        if (vertex < 0 || vertex >= upperBound) {\n            throw new IllegalArgumentException(\"Edge vertex out of range\");\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.datastructures.graphs.BoruvkaAlgorithm.Graph;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class BoruvkaAlgorithmTest {\n    @Test\n    public void testBoruvkaMSTV9E14() {\n        List<BoruvkaAlgorithm.Edge> edges = new ArrayList<>();\n\n        edges.add(new BoruvkaAlgorithm.Edge(0, 1, 10));\n        edges.add(new BoruvkaAlgorithm.Edge(0, 2, 12));\n        edges.add(new BoruvkaAlgorithm.Edge(1, 2, 9));\n        edges.add(new BoruvkaAlgorithm.Edge(1, 3, 8));\n        edges.add(new BoruvkaAlgorithm.Edge(2, 4, 3));\n        edges.add(new BoruvkaAlgorithm.Edge(2, 5, 1));\n        edges.add(new BoruvkaAlgorithm.Edge(4, 5, 3));\n        edges.add(new BoruvkaAlgorithm.Edge(4, 3, 7));\n        edges.add(new BoruvkaAlgorithm.Edge(3, 6, 8));\n        edges.add(new BoruvkaAlgorithm.Edge(3, 7, 5));\n        edges.add(new BoruvkaAlgorithm.Edge(5, 7, 6));\n        edges.add(new BoruvkaAlgorithm.Edge(6, 7, 9));\n        edges.add(new BoruvkaAlgorithm.Edge(6, 8, 2));\n        edges.add(new BoruvkaAlgorithm.Edge(7, 8, 11));\n\n        final var graph = new Graph(9, edges);\n        /**\n         * Adjacency matrix\n         *    0   1   2   3   4   5   6   7   8\n         * 0  0  10  12   0   0   0   0   0   0\n         * 1 10   0   9   8   0   0   0   0   0\n         * 2 12   9   0   0   3   1   0   0   0\n         * 3  0   8   0   0   7   0   8   5   0\n         * 4  0   0   3   7   0   3   0   0   0\n         * 5  0   0   1   0   3   0   0   6   0\n         * 6  0   0   0   8   0   0   0   9   2\n         * 7  0   0   0   5   0   6   9   0  11\n         * 8  0   0   0   0   0   0   2  11   0\n         */\n        final var result = BoruvkaAlgorithm.boruvkaMST(graph);\n        assertEquals(8, result.size());\n        assertEquals(43, computeTotalWeight(result));\n    }\n\n    @Test\n    void testBoruvkaMSTV2E1() {\n        List<BoruvkaAlgorithm.Edge> edges = new ArrayList<>();\n\n        edges.add(new BoruvkaAlgorithm.Edge(0, 1, 10));\n\n        final var graph = new Graph(2, edges);\n\n        /**\n         * Adjacency matrix\n         *    0  1\n         * 0  0  10\n         * 1  10  0\n         */\n        final var result = BoruvkaAlgorithm.boruvkaMST(graph);\n        assertEquals(1, result.size());\n        assertEquals(10, computeTotalWeight(result));\n    }\n\n    @Test\n    void testCompleteGraphK4() {\n        List<BoruvkaAlgorithm.Edge> edges = new ArrayList<>();\n        edges.add(new BoruvkaAlgorithm.Edge(0, 1, 7));\n        edges.add(new BoruvkaAlgorithm.Edge(0, 2, 2));\n        edges.add(new BoruvkaAlgorithm.Edge(0, 3, 5));\n        edges.add(new BoruvkaAlgorithm.Edge(1, 2, 3));\n        edges.add(new BoruvkaAlgorithm.Edge(1, 3, 4));\n        edges.add(new BoruvkaAlgorithm.Edge(2, 3, 1));\n\n        final var graph = new Graph(4, edges);\n\n        /**\n         * Adjacency matrix\n         *    0  1  2  3\n         * 0  0  7  2  5\n         * 1  7  0  3  4\n         * 2  2  3  0  1\n         * 3  5  4  1  0\n         */\n        final var result = BoruvkaAlgorithm.boruvkaMST(graph);\n        assertEquals(3, result.size());\n        assertEquals(6, computeTotalWeight(result));\n    }\n\n    @Test\n    void testNegativeVertices() {\n        Exception exception1 = assertThrows(IllegalArgumentException.class, () -> new Graph(-1, null));\n        String expectedMessage = \"Number of vertices must be positive\";\n        String actualMessage = exception1.getMessage();\n\n        assertTrue(actualMessage.contains(expectedMessage));\n    }\n\n    @Test\n    void testEdgesNull() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> new Graph(0, null));\n        String expectedMessage = \"Edges list must not be null or empty\";\n        String actualMessage = exception.getMessage();\n\n        assertTrue(actualMessage.contains(expectedMessage));\n    }\n\n    @Test\n    void testEdgesEmpty() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> new Graph(0, new ArrayList<>()));\n        String expectedMessage = \"Edges list must not be null or empty\";\n        String actualMessage = exception.getMessage();\n\n        assertTrue(actualMessage.contains(expectedMessage));\n    }\n\n    @Test\n    void testEdgesRange() {\n        // Valid input\n        List<BoruvkaAlgorithm.Edge> validEdges = new ArrayList<>();\n        validEdges.add(new BoruvkaAlgorithm.Edge(0, 1, 2));\n        validEdges.add(new BoruvkaAlgorithm.Edge(1, 2, 3));\n        final var validGraph = new BoruvkaAlgorithm.Graph(3, validEdges);\n        assertEquals(validEdges, validGraph.edges);\n\n        // Edge source out of range\n        Exception exception1 = assertThrows(IllegalArgumentException.class, () -> {\n            List<BoruvkaAlgorithm.Edge> invalidEdges = new ArrayList<>();\n            invalidEdges.add(new BoruvkaAlgorithm.Edge(-1, 1, 2));\n            final var invalidGraph = new BoruvkaAlgorithm.Graph(1, invalidEdges);\n            assertEquals(invalidEdges, invalidGraph.edges);\n        });\n        String expectedMessage1 = \"Edge vertex out of range\";\n        String actualMessage1 = exception1.getMessage();\n\n        assertTrue(actualMessage1.contains(expectedMessage1));\n\n        // Edge source out of range\n        Exception exception2 = assertThrows(IllegalArgumentException.class, () -> {\n            List<BoruvkaAlgorithm.Edge> invalidEdges = new ArrayList<>();\n            invalidEdges.add(new BoruvkaAlgorithm.Edge(1, 0, 2));\n            final var invalidGraph = new BoruvkaAlgorithm.Graph(1, invalidEdges);\n            assertEquals(invalidEdges, invalidGraph.edges);\n        });\n        String expectedMessage2 = \"Edge vertex out of range\";\n        String actualMessage2 = exception2.getMessage();\n\n        assertTrue(actualMessage2.contains(expectedMessage2));\n\n        // Edge destination out of range\n        Exception exception3 = assertThrows(IllegalArgumentException.class, () -> {\n            List<BoruvkaAlgorithm.Edge> invalidEdges = new ArrayList<>();\n            invalidEdges.add(new BoruvkaAlgorithm.Edge(0, -1, 2));\n            final var invalidGraph = new BoruvkaAlgorithm.Graph(1, invalidEdges);\n            assertEquals(invalidEdges, invalidGraph.edges);\n        });\n        String expectedMessage3 = \"Edge vertex out of range\";\n        String actualMessage3 = exception3.getMessage();\n\n        assertTrue(actualMessage3.contains(expectedMessage3));\n\n        // Edge destination out of range\n        Exception exception4 = assertThrows(IllegalArgumentException.class, () -> {\n            List<BoruvkaAlgorithm.Edge> invalidEdges = new ArrayList<>();\n            invalidEdges.add(new BoruvkaAlgorithm.Edge(0, 1, 2));\n            final var invalidGraph = new BoruvkaAlgorithm.Graph(1, invalidEdges);\n            assertEquals(invalidEdges, invalidGraph.edges);\n        });\n        String expectedMessage4 = \"Edge vertex out of range\";\n        String actualMessage4 = exception4.getMessage();\n\n        assertTrue(actualMessage4.contains(expectedMessage4));\n    }\n\n    /**\n     * Computes the total weight of the Minimum Spanning Tree\n     *\n     * @param result list of edges in the Minimum Spanning Tree\n     * @return the total weight of the Minimum Spanning Tree\n     */\n    int computeTotalWeight(final List<BoruvkaAlgorithm.Edge> result) {\n        int totalWeight = 0;\n        for (final var edge : result) {\n            totalWeight += edge.weight;\n        }\n        return totalWeight;\n    }\n}"
    },
    {
        "product_commit": "1518e84fb961f988b35ef402ec25a6576879c7ff",
        "test_commit": "1518e84fb961f988b35ef402ec25a6576879c7ff",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/Tribonacci.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/TribonacciTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * The {@code Tribonacci} class provides a method to compute the n-th number in the Tribonacci sequence.\n * N-th Tribonacci Number - https://leetcode.com/problems/n-th-tribonacci-number/description/\n */\npublic class Tribonacci {\n\n    /**\n     * Computes the n-th Tribonacci number.\n     *\n     * @param n the index of the Tribonacci number to compute\n     * @return the n-th Tribonacci number\n     */\n    public static int compute(int n) {\n        if (n == 0) return 0;\n        if (n == 1 || n == 2) return 1;\n\n        int first = 0, second = 1, third = 1;\n\n        for (int i = 3; i <= n; i++) {\n            int next = first + second + third;\n            first = second;\n            second = third;\n            third = next;\n        }\n\n        return third;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test class for {@code Tribonacci}.\n */\npublic class TribonacciTest {\n\n    /**\n     * Tests the Tribonacci computation for a set of known values.\n     */\n    @Test\n    public void testKnownValues() {\n        assertEquals(0, Tribonacci.compute(0), \"The 0th Tribonacci should be 0.\");\n        assertEquals(1, Tribonacci.compute(1), \"The 1st Tribonacci should be 1.\");\n        assertEquals(1, Tribonacci.compute(2), \"The 2nd Tribonacci should be 1.\");\n        assertEquals(2, Tribonacci.compute(3), \"The 3rd Tribonacci should be 2.\");\n        assertEquals(4, Tribonacci.compute(4), \"The 4th Tribonacci should be 4.\");\n        assertEquals(7, Tribonacci.compute(5), \"The 5th Tribonacci should be 7.\");\n    }\n}"
    },
    {
        "product_commit": "b1efd4e34bb18a618ab205c9c2a62802f151c70d",
        "test_commit": "b1efd4e34bb18a618ab205c9c2a62802f151c70d",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/GCounter.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/GCounterTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * G-Counter (Grow-only Counter) is a state-based CRDT (Conflict-free Replicated Data Type)\n * designed for tracking counts in a distributed and concurrent environment.\n * Each process maintains its own counter, allowing only increments. The total count\n * is obtained by summing individual process counts.\n * This implementation supports incrementing, querying the total count,\n * comparing with other G-Counters, and merging with another G-Counter\n * to compute the element-wise maximum.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (https://github.com/itakurah)\n */\n\nclass GCounter {\n    private final Map<Integer, Integer> P;\n    private final int myId;\n    private final int n;\n\n    /**\n     * Constructs a G-Counter for a cluster of n nodes.\n     *\n     * @param n The number of nodes in the cluster.\n     */\n    public GCounter(int myId, int n) {\n        this.myId = myId;\n        this.n = n;\n        this.P = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            P.put(i, 0);\n        }\n    }\n\n    /**\n     * Increments the counter for the current node.\n     */\n    public void increment() {\n        P.put(myId, P.get(myId) + 1);\n    }\n\n    /**\n     * Gets the total value of the counter by summing up values from all nodes.\n     *\n     * @return The total value of the counter.\n     */\n    public int value() {\n        int sum = 0;\n        for (int v : P.values()) {\n            sum += v;\n        }\n        return sum;\n    }\n\n    /**\n     * Compares the state of this G-Counter with another G-Counter.\n     *\n     * @param other The other G-Counter to compare with.\n     * @return True if the state of this G-Counter is less than or equal to the state of the other G-Counter.\n     */\n    public boolean compare(GCounter other) {\n        for (int i = 0; i < n; i++) {\n            if (this.P.get(i) > other.P.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Merges the state of this G-Counter with another G-Counter.\n     *\n     * @param other The other G-Counter to merge with.\n     */\n    public void merge(GCounter other) {\n        for (int i = 0; i < n; i++) {\n            this.P.put(i, Math.max(this.P.get(i), other.P.get(i)));\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class GCounterTest {\n    @Test\n    void increment() {\n        GCounter counter = new GCounter(0, 3);\n        counter.increment();\n        counter.increment();\n        counter.increment();\n        assertEquals(3, counter.value());\n    }\n\n    @Test\n    void merge() {\n        GCounter counter1 = new GCounter(0, 3);\n        counter1.increment();\n        GCounter counter2 = new GCounter(1, 3);\n        counter2.increment();\n        counter2.increment();\n        GCounter counter3 = new GCounter(2, 3);\n        counter3.increment();\n        counter3.increment();\n        counter3.increment();\n        counter1.merge(counter2);\n        counter1.merge(counter3);\n        counter2.merge(counter1);\n        counter3.merge(counter2);\n        assertEquals(6, counter1.value());\n        assertEquals(6, counter2.value());\n        assertEquals(6, counter3.value());\n    }\n\n    @Test\n    void compare() {\n        GCounter counter1 = new GCounter(0, 5);\n        GCounter counter2 = new GCounter(3, 5);\n        counter1.increment();\n        counter1.increment();\n        counter2.merge(counter1);\n        counter2.increment();\n        counter2.increment();\n        assertTrue(counter1.compare(counter2));\n        counter1.increment();\n        counter2.increment();\n        counter2.merge(counter1);\n        assertTrue(counter1.compare(counter2));\n        counter1.increment();\n        assertFalse(counter1.compare(counter2));\n    }\n}"
    },
    {
        "product_commit": "574138c7a35351a0837bb4bd56e2eb295064b690",
        "test_commit": "574138c7a35351a0837bb4bd56e2eb295064b690",
        "product_file_path": "src/main/java/com/thealgorithms/others/BoyerMoore.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/BoyerMooreTest.java",
        "product_old_content": "/* this Code is the illustration of Boyer moore's voting algorithm to\nfind the majority element is an array that appears more than n/2 times in an array\nwhere \"n\" is the length of the array.\nFor more information on the algorithm refer\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n */\npackage com.thealgorithms.others;\n\npublic final class BoyerMoore {\n    private BoyerMoore() {\n    }\n\n    public static int findmajor(final int[] a) {\n        int count = 0;\n        int cand = -1;\n        for (final var k : a) {\n            if (count == 0) {\n                cand = k;\n                count = 1;\n            } else {\n                if (k == cand) {\n                    count++;\n                } else {\n                    count--;\n                }\n            }\n        }\n        count = 0;\n        for (final var j : a) {\n            if (j == cand) {\n                count++;\n            }\n        }\n        if (count > (a.length / 2)) {\n            return cand;\n        }\n        return -1;\n    }\n}",
        "product_new_content": "/* this Code is the illustration of Boyer moore's voting algorithm to\nfind the majority element is an array that appears more than n/2 times in an array\nwhere \"n\" is the length of the array.\nFor more information on the algorithm refer\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n */\npackage com.thealgorithms.others;\nimport java.util.Optional;\n\npublic final class BoyerMoore {\n    private BoyerMoore() {\n    }\n\n    public static Optional<Integer> findMajor(final int[] a) {\n        final var candidate = findCandidate(a);\n        final var count = countOccurrences(candidate, a);\n        if (isMajority(count, a.length)) {\n            return Optional.of(candidate);\n        }\n        return Optional.empty();\n    }\n\n    private static int findCandidate(final int[] a) {\n        int count = 0;\n        int candidate = -1;\n        for (final var k : a) {\n            if (count == 0) {\n                candidate = k;\n                count = 1;\n            } else {\n                if (k == candidate) {\n                    count++;\n                } else {\n                    count--;\n                }\n            }\n        }\n        return candidate;\n    }\n\n    private static int countOccurrences(final int candidate, final int[] a) {\n        int count = 0;\n        for (final var j : a) {\n            if (j == candidate) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static boolean isMajority(final int count, final int totalCount) {\n        return 2 * count > totalCount;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class BoyerMooreTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, BoyerMoore.findmajor(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 2}), Arguments.of(10, new int[] {10, 10, 20}), Arguments.of(10, new int[] {10, 20, 10}), Arguments.of(10, new int[] {20, 10, 10}), Arguments.of(-1, new int[] {10, 10, 20, 20, 30, 30}), Arguments.of(4, new int[] {1, 4, 2, 4, 4, 5, 4}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class BoyerMooreTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStreamWithExistingMajority\")\n    void checkWhenMajorityExists(int expected, int[] input) {\n        Assertions.assertEquals(expected, BoyerMoore.findMajor(input).get());\n    }\n\n    private static Stream<Arguments> inputStreamWithExistingMajority() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 2}), Arguments.of(10, new int[] {10, 10, 20}), Arguments.of(10, new int[] {10, 20, 10}), Arguments.of(10, new int[] {20, 10, 10}), Arguments.of(4, new int[] {1, 4, 2, 4, 4, 5, 4}), Arguments.of(-1, new int[] {-1}));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"inputStreamWithoutMajority\")\n    void checkWhenMajorityExists(int[] input) {\n        Assertions.assertFalse(BoyerMoore.findMajor(input).isPresent());\n    }\n\n    private static Stream<Arguments> inputStreamWithoutMajority() {\n        return Stream.of(Arguments.of(new int[] {10, 10, 20, 20, 30, 30}), Arguments.of(new int[] {10, 20, 30, 40, 50}), Arguments.of(new int[] {1, 2}), Arguments.of(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "945e7b56bb186c3be908e02720e932b5ce834e01",
        "test_commit": "945e7b56bb186c3be908e02720e932b5ce834e01",
        "product_file_path": "src/main/java/com/thealgorithms/others/BoyerMoore.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/BoyerMooreTest.java",
        "product_old_content": "/* this Code is the illustration of Boyer moore's voting algorithm to\nfind the majority element is an array that appears more than n/2 times in an array\nwhere \"n\" is the length of the array.\nFor more information on the algorithm refer\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n */\npackage com.thealgorithms.others;\n\nimport java.util.*;\n\npublic class BoyerMoore {\n\n    public static int findmajor(int[] a) {\n        int count = 0;\n        int cand = -1;\n        for (int i = 0; i < a.length; i++) {\n            if (count == 0) {\n                cand = a[i];\n                count = 1;\n            } else {\n                if (a[i] == cand) {\n                    count++;\n                } else {\n                    count--;\n                }\n            }\n        }\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] == cand) {\n                count++;\n            }\n        }\n        if (count > (a.length / 2)) {\n            return cand;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = input.nextInt();\n        }\n        System.out.println(\"the majority element is \" + findmajor(a));\n        input.close();\n    }\n}",
        "product_new_content": "/* this Code is the illustration of Boyer moore's voting algorithm to\nfind the majority element is an array that appears more than n/2 times in an array\nwhere \"n\" is the length of the array.\nFor more information on the algorithm refer\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n */\npackage com.thealgorithms.others;\n\npublic final class BoyerMoore {\n    private BoyerMoore() {\n    }\n\n    public static int findmajor(final int[] a) {\n        int count = 0;\n        int cand = -1;\n        for (final var k : a) {\n            if (count == 0) {\n                cand = k;\n                count = 1;\n            } else {\n                if (k == cand) {\n                    count++;\n                } else {\n                    count--;\n                }\n            }\n        }\n        count = 0;\n        for (final var j : a) {\n            if (j == cand) {\n                count++;\n            }\n        }\n        if (count > (a.length / 2)) {\n            return cand;\n        }\n        return -1;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class BoyerMooreTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, BoyerMoore.findmajor(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 2}), Arguments.of(10, new int[] {10, 10, 20}), Arguments.of(10, new int[] {10, 20, 10}), Arguments.of(10, new int[] {20, 10, 10}), Arguments.of(-1, new int[] {10, 10, 20, 20, 30, 30}), Arguments.of(4, new int[] {1, 4, 2, 4, 4, 5, 4}));\n    }\n}"
    },
    {
        "product_commit": "9dde8a780832a29c508deb3382410e36f127fdf1",
        "test_commit": "9dde8a780832a29c508deb3382410e36f127fdf1",
        "product_file_path": "src/main/java/com/thealgorithms/maths/MatrixRank.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MatrixRankTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This class provides a method to compute the rank of a matrix.\n * In linear algebra, the rank of a matrix is the maximum number of linearly independent rows or columns in the matrix.\n * For example, consider the following 3x3 matrix:\n * 1 2 3\n * 2 4 6\n * 3 6 9\n * Despite having 3 rows and 3 columns, this matrix only has a rank of 1 because all rows (and columns) are multiples of each other.\n * It's a fundamental concept that gives key insights into the structure of the matrix.\n * It's important to note that the rank is not only defined for square matrices but for any m x n matrix.\n *\n * @author Anup Omkar\n */\npublic final class MatrixRank {\n\n    private MatrixRank() {\n    }\n\n    private static final double EPSILON = 1e-10;\n\n    /**\n     * @brief Computes the rank of the input matrix\n     *\n     * @param matrix The input matrix\n     * @return The rank of the input matrix\n     */\n    public static int computeRank(double[][] matrix) {\n        validateInputMatrix(matrix);\n\n        int numRows = matrix.length;\n        int numColumns = matrix[0].length;\n        int rank = 0;\n\n        boolean[] rowMarked = new boolean[numRows];\n\n        double[][] matrixCopy = deepCopy(matrix);\n\n        for (int colIndex = 0; colIndex < numColumns; ++colIndex) {\n            int pivotRow = findPivotRow(matrixCopy, rowMarked, colIndex);\n            if (pivotRow != numRows) {\n                ++rank;\n                rowMarked[pivotRow] = true;\n                normalizePivotRow(matrixCopy, pivotRow, colIndex);\n                eliminateRows(matrixCopy, pivotRow, colIndex);\n            }\n        }\n        return rank;\n    }\n\n    private static boolean isZero(double value) {\n        return Math.abs(value) < EPSILON;\n    }\n\n    private static double[][] deepCopy(double[][] matrix) {\n        int numRows = matrix.length;\n        int numColumns = matrix[0].length;\n        double[][] matrixCopy = new double[numRows][numColumns];\n        for (int rowIndex = 0; rowIndex < numRows; ++rowIndex) {\n            System.arraycopy(matrix[rowIndex], 0, matrixCopy[rowIndex], 0, numColumns);\n        }\n        return matrixCopy;\n    }\n\n    private static void validateInputMatrix(double[][] matrix) {\n        if (matrix == null) {\n            throw new IllegalArgumentException(\"The input matrix cannot be null\");\n        }\n        if (matrix.length == 0) {\n            throw new IllegalArgumentException(\"The input matrix cannot be empty\");\n        }\n        if (!hasValidRows(matrix)) {\n            throw new IllegalArgumentException(\"The input matrix cannot have null or empty rows\");\n        }\n        if (isJaggedMatrix(matrix)) {\n            throw new IllegalArgumentException(\"The input matrix cannot be jagged\");\n        }\n    }\n\n    private static boolean hasValidRows(double[][] matrix) {\n        for (double[] row : matrix) {\n            if (row == null || row.length == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @brief Checks if the input matrix is a jagged matrix.\n     * Jagged matrix is a matrix where the number of columns in each row is not the same.\n     *\n     * @param matrix The input matrix\n     * @return True if the input matrix is a jagged matrix, false otherwise\n     */\n    private static boolean isJaggedMatrix(double[][] matrix) {\n        int numColumns = matrix[0].length;\n        for (double[] row : matrix) {\n            if (row.length != numColumns) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @brief The pivot row is the row in the matrix that is used to eliminate other rows and reduce the matrix to its row echelon form.\n     * The pivot row is selected as the first row (from top to bottom) where the value in the current column (the pivot column) is not zero.\n     * This row is then used to \"eliminate\" other rows, by subtracting multiples of the pivot row from them, so that all other entries in the pivot column become zero.\n     * This process is repeated for each column, each time selecting a new pivot row, until the matrix is in row echelon form.\n     * The number of pivot rows (rows with a leading entry, or pivot) then gives the rank of the matrix.\n     *\n     * @param matrix The input matrix\n     * @param rowMarked An array indicating which rows have been marked\n     * @param colIndex The column index\n     * @return The pivot row index, or the number of rows if no suitable pivot row was found\n     */\n    private static int findPivotRow(double[][] matrix, boolean[] rowMarked, int colIndex) {\n        int numRows = matrix.length;\n        for (int pivotRow = 0; pivotRow < numRows; ++pivotRow) {\n            if (!rowMarked[pivotRow] && !isZero(matrix[pivotRow][colIndex])) {\n                return pivotRow;\n            }\n        }\n        return numRows;\n    }\n\n    /**\n     * @brief This method divides all values in the pivot row by the value in the given column.\n     * This ensures that the pivot value itself will be 1, which simplifies further calculations.\n     *\n     * @param matrix The input matrix\n     * @param pivotRow The pivot row index\n     * @param colIndex The column index\n     */\n    private static void normalizePivotRow(double[][] matrix, int pivotRow, int colIndex) {\n        int numColumns = matrix[0].length;\n        for (int nextCol = colIndex + 1; nextCol < numColumns; ++nextCol) {\n            matrix[pivotRow][nextCol] /= matrix[pivotRow][colIndex];\n        }\n    }\n\n    /**\n     * @brief This method subtracts multiples of the pivot row from all other rows,\n     * so that all values in the given column of other rows will be zero.\n     * This is a key step in reducing the matrix to row echelon form.\n     *\n     * @param matrix The input matrix\n     * @param pivotRow The pivot row index\n     * @param colIndex The column index\n     */\n    private static void eliminateRows(double[][] matrix, int pivotRow, int colIndex) {\n        int numRows = matrix.length;\n        int numColumns = matrix[0].length;\n        for (int otherRow = 0; otherRow < numRows; ++otherRow) {\n            if (otherRow != pivotRow && !isZero(matrix[otherRow][colIndex])) {\n                for (int col2 = colIndex + 1; col2 < numColumns; ++col2) {\n                    matrix[otherRow][col2] -= matrix[pivotRow][col2] * matrix[otherRow][colIndex];\n                }\n            }\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Arrays;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nclass MatrixRankTest {\n\n    private static Stream<Arguments> validInputStream() {\n        return Stream.of(Arguments.of(3, new double[][] {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}), Arguments.of(0, new double[][] {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}), Arguments.of(1, new double[][] {{1}}), Arguments.of(2, new double[][] {{1, 2}, {3, 4}}),\n            Arguments.of(2, new double[][] {{3, -1, 2}, {-3, 1, 2}, {-6, 2, 4}}), Arguments.of(3, new double[][] {{2, 3, 0, 1}, {1, 0, 1, 2}, {-1, 1, 1, -2}, {1, 5, 3, -1}}), Arguments.of(1, new double[][] {{1, 2, 3}, {3, 6, 9}}),\n            Arguments.of(2, new double[][] {{0.25, 0.5, 0.75, 2}, {1.5, 3, 4.5, 6}, {1, 2, 3, 4}}));\n    }\n\n    private static Stream<Arguments> invalidInputStream() {\n        return Stream.of(Arguments.of((Object) new double[][] {{1, 2}, {10}, {100, 200, 300}}), // jagged array\n            Arguments.of((Object) new double[][] {}), // empty matrix\n            Arguments.of((Object) new double[][] {{}, {}}), // empty row\n            Arguments.of((Object) null), // null matrix\n            Arguments.of((Object) new double[][] {{1, 2}, null}) // null row\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"validInputStream\")\n    void computeRankTests(int expectedRank, double[][] matrix) {\n        int originalHashCode = Arrays.deepHashCode(matrix);\n        int rank = MatrixRank.computeRank(matrix);\n        int newHashCode = Arrays.deepHashCode(matrix);\n\n        assertEquals(expectedRank, rank);\n        assertEquals(originalHashCode, newHashCode);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"invalidInputStream\")\n    void computeRankWithInvalidMatrix(double[][] matrix) {\n        assertThrows(IllegalArgumentException.class, () -> MatrixRank.computeRank(matrix));\n    }\n}"
    },
    {
        "product_commit": "a4711d61d87cf75bf68f1f0b25345b1439220acf",
        "test_commit": "a4711d61d87cf75bf68f1f0b25345b1439220acf",
        "product_file_path": "src/main/java/com/thealgorithms/misc/MapReduce.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/MapReduceTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.misc;\n\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\n/*\n* MapReduce is a programming model for processing and generating large data sets with a parallel,\ndistributed algorithm on a cluster.\n* It has two main steps: the Map step, where the data is divided into smaller chunks and processed in parallel,\nand the Reduce step, where the results from the Map step are combined to produce the final output.\n* Wikipedia link : https://en.wikipedia.org/wiki/MapReduce\n*/\n\npublic class MapReduce {\n    /*\n     *Counting all the words frequency within a sentence.\n     */\n    public static String mapreduce(String sentence) {\n        List<String> wordList = Arrays.stream(sentence.split(\" \")).toList();\n\n        // Map step\n        Map<String, Long> wordCounts = wordList.stream().collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()));\n\n        // Reduce step\n        StringBuilder result = new StringBuilder();\n        wordCounts.forEach((word, count) -> result.append(word).append(\": \").append(count).append(\",\"));\n\n        // Removing the last ',' if it exists\n        if (!result.isEmpty()) {\n            result.setLength(result.length() - 1);\n        }\n\n        return result.toString();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MapReduceTest {\n    @Test\n    public void testMapReduceWithSingleWordSentence() {\n        String oneWordSentence = \"Hactober\";\n        String result = MapReduce.mapreduce(oneWordSentence);\n\n        assertEquals(\"Hactober: 1\", result);\n    }\n\n    @Test\n    public void testMapReduceWithMultipleWordSentence() {\n        String multipleWordSentence = \"I Love Love HactoberFest\";\n        String result = MapReduce.mapreduce(multipleWordSentence);\n\n        assertEquals(\"I: 1,Love: 2,HactoberFest: 1\", result);\n    }\n}"
    },
    {
        "product_commit": "9dae389faa03b8400b6f0796383f47495887151a",
        "test_commit": "9dae389faa03b8400b6f0796383f47495887151a",
        "product_file_path": "src/main/java/com/thealgorithms/maths/HeronsFormula.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/HeronsFormulaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of a triangle using only side lengths\n */\n\npublic class HeronsFormula {\n\n    public static double Herons(int s1, int s2, int s3) {\n        double a = s1;\n        double b = s2;\n        double c = s3;\n        double s = (a + b + c) / 2.0;\n        double area = 0;\n        area = Math.sqrt((s) * (s - a) * (s - b) * (s - c));\n        return area;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Wikipedia for HeronsFormula => https://en.wikipedia.org/wiki/Heron%27s_formula\n * Find the area of a triangle using only side lengths\n */\n\npublic final class HeronsFormula {\n\n    /*\n     * A function to get the Area of a Triangle using Heron's Formula\n     * @param s1,s2,s3 => the three sides of the Triangle\n     * @return area using the formula (\u221a(s(s \u2013 s1)(s \u2013 s2)(s \u2013 s3)))\n     * here s is called semi-perimeter and it is the half of the perimeter (i.e; s = (s1+s2+s3)/2)\n     * @author satyabarghav\n     */\n    private HeronsFormula() {\n    }\n\n    private static boolean areAllSidesPositive(final double a, final double b, final double c) {\n        return a > 0 && b > 0 && c > 0;\n    }\n\n    private static boolean canFormTriangle(final double a, final double b, final double c) {\n        return a + b > c && b + c > a && c + a > b;\n    }\n\n    public static double herons(final double a, final double b, final double c) {\n        if (!areAllSidesPositive(a, b, c) || !canFormTriangle(a, b, c)) {\n            throw new IllegalArgumentException(\"Triangle can't be formed with the given side lengths\");\n        }\n        final double s = (a + b + c) / 2.0;\n        return Math.sqrt((s) * (s - a) * (s - b) * (s - c));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class HeronsFormulaTest {\n\n    @Test\n    void test1() {\n        Assertions.assertEquals(HeronsFormula.Herons(3, 4, 5), 6.0);\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertEquals(HeronsFormula.Herons(24, 30, 18), 216.0);\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertEquals(HeronsFormula.Herons(1, 1, 1), 0.4330127018922193);\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(HeronsFormula.Herons(4, 5, 8), 8.181534085976786);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class HeronsFormulaTest {\n\n    @Test\n    void test1() {\n        Assertions.assertEquals(HeronsFormula.herons(3, 4, 5), 6.0);\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertEquals(HeronsFormula.herons(24, 30, 18), 216.0);\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertEquals(HeronsFormula.herons(1, 1, 1), 0.4330127018922193);\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(HeronsFormula.herons(4, 5, 8), 8.181534085976786);\n    }\n\n    @Test\n    public void testCalculateAreaWithInvalidInput() {\n        Assertions.assertThrows(IllegalArgumentException.class, () -> { HeronsFormula.herons(1, 2, 3); });\n        Assertions.assertThrows(IllegalArgumentException.class, () -> { HeronsFormula.herons(2, 1, 3); });\n        Assertions.assertThrows(IllegalArgumentException.class, () -> { HeronsFormula.herons(3, 2, 1); });\n        Assertions.assertThrows(IllegalArgumentException.class, () -> { HeronsFormula.herons(1, 3, 2); });\n\n        Assertions.assertThrows(IllegalArgumentException.class, () -> { HeronsFormula.herons(1, 1, 0); });\n        Assertions.assertThrows(IllegalArgumentException.class, () -> { HeronsFormula.herons(1, 0, 1); });\n        Assertions.assertThrows(IllegalArgumentException.class, () -> { HeronsFormula.herons(0, 1, 1); });\n    }\n}"
    },
    {
        "product_commit": "48ae88f09d595bf6bdd3440b003e08419c885126",
        "test_commit": "48ae88f09d595bf6bdd3440b003e08419c885126",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/BitSwap.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/BitSwapTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\npublic final class BitSwap {\n    private BitSwap() {\n    }\n    /*\n     * @brief Swaps the bits at the position posA and posB from data\n     */\n    public static int bitSwap(int data, final int posA, final int posB) {\n        if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n            data ^= (1 << posA) ^ (1 << posB);\n        }\n        return data;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class BitSwapTest {\n    @Test\n    void testHighestSetBit() {\n        assertEquals(3, BitSwap.bitSwap(3, 0, 1));\n        assertEquals(5, BitSwap.bitSwap(6, 0, 1));\n        assertEquals(7, BitSwap.bitSwap(7, 1, 1));\n    }\n}"
    },
    {
        "product_commit": "24a82230626e986392bcba7dc86b80118aefcdc3",
        "test_commit": "24a82230626e986392bcba7dc86b80118aefcdc3",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FibonacciLoop.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FibonacciLoopTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.math.BigInteger;\n\n/**\n * This class provides methods for calculating Fibonacci numbers using BigInteger for large values of 'n'.\n */\npublic final class FibonacciLoop {\n\n    private FibonacciLoop() {\n        // Private constructor to prevent instantiation of this utility class.\n    }\n\n    /**\n     * Calculates the nth Fibonacci number.\n     *\n     * @param n The index of the Fibonacci number to calculate.\n     * @return The nth Fibonacci number as a BigInteger.\n     * @throws IllegalArgumentException if the input 'n' is a negative integer.\n     */\n    public static BigInteger compute(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\");\n        }\n\n        if (n <= 1) {\n            return BigInteger.valueOf(n);\n        }\n\n        BigInteger prev = BigInteger.ZERO;\n        BigInteger current = BigInteger.ONE;\n\n        for (int i = 2; i <= n; i++) {\n            BigInteger next = prev.add(current);\n            prev = current;\n            current = next;\n        }\n\n        return current;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.math.BigInteger;\nimport org.junit.jupiter.api.Test;\n\npublic class FibonacciLoopTest {\n    @Test\n    public void checkValueAtZero() {\n        assertEquals(BigInteger.ZERO, FibonacciLoop.compute(0));\n    }\n\n    @Test\n    public void checkValueAtOne() {\n        assertEquals(BigInteger.ONE, FibonacciLoop.compute(1));\n    }\n\n    @Test\n    public void checkValueAtTwo() {\n        assertEquals(BigInteger.ONE, FibonacciLoop.compute(2));\n    }\n\n    @Test\n    public void checkRecurrenceRelation() {\n        for (int i = 0; i < 100; ++i) {\n            assertEquals(FibonacciLoop.compute(i + 2), FibonacciLoop.compute(i + 1).add(FibonacciLoop.compute(i)));\n        }\n    }\n\n    @Test\n    public void checkNegativeInput() {\n        assertThrows(IllegalArgumentException.class, () -> { FibonacciLoop.compute(-1); });\n    }\n}"
    },
    {
        "product_commit": "24a82230626e986392bcba7dc86b80118aefcdc3",
        "test_commit": "24a82230626e986392bcba7dc86b80118aefcdc3",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FibonacciNumberGoldenRation.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FibonacciNumberGoldenRationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This class provides methods for calculating Fibonacci numbers using Binet's formula.\n * Binet's formula is based on the golden ratio and allows computing Fibonacci numbers efficiently.\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Fibonacci_sequence#Binet's_formula\">Binet's formula on Wikipedia</a>\n */\npublic final class FibonacciNumberGoldenRation {\n    private FibonacciNumberGoldenRation() {\n        // Private constructor to prevent instantiation of this utility class.\n    }\n\n    /**\n     * Compute the limit for 'n' that fits in a long data type.\n     * Reducing the limit to 70 due to potential floating-point arithmetic errors\n     * that may result in incorrect results for larger inputs.\n     */\n    public static final int MAX_ARG = 70;\n\n    /**\n     * Calculates the nth Fibonacci number using Binet's formula.\n     *\n     * @param n The index of the Fibonacci number to calculate.\n     * @return The nth Fibonacci number as a long.\n     * @throws IllegalArgumentException if the input 'n' is negative or exceeds the range of a long data type.\n     */\n    public static long compute(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Input 'n' must be a non-negative integer.\");\n        }\n\n        if (n > MAX_ARG) {\n            throw new IllegalArgumentException(\"Input 'n' is too big to give accurate result.\");\n        }\n\n        if (n <= 1) {\n            return n;\n        }\n\n        // Calculate the nth Fibonacci number using the golden ratio formula\n        final double sqrt5 = Math.sqrt(5);\n        final double phi = (1 + sqrt5) / 2;\n        final double psi = (1 - sqrt5) / 2;\n        final double result = (Math.pow(phi, n) - Math.pow(psi, n)) / sqrt5;\n\n        // Round to the nearest integer and return as a long\n        return Math.round(result);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.math.BigInteger;\nimport org.junit.jupiter.api.Test;\n\npublic class FibonacciNumberGoldenRationTest {\n\n    @Test\n    public void returnsCorrectValues() {\n        for (int n = 0; n <= FibonacciNumberGoldenRation.MAX_ARG; ++n) {\n            final var actual = FibonacciNumberGoldenRation.compute(n);\n            final var expected = FibonacciLoop.compute(n);\n            assertEquals(expected, BigInteger.valueOf(actual));\n        }\n    }\n\n    @Test\n    public void throwsIllegalArgumentExceptionForNegativeInput() {\n        assertThrows(IllegalArgumentException.class, () -> { FibonacciNumberGoldenRation.compute(-1); });\n    }\n\n    @Test\n    public void throwsIllegalArgumentExceptionForLargeInput() {\n        assertThrows(IllegalArgumentException.class, () -> { FibonacciNumberGoldenRation.compute(FibonacciNumberGoldenRation.MAX_ARG + 1); });\n    }\n}"
    },
    {
        "product_commit": "1dc64b16859d95446a8bfe1c50692ce57316bc42",
        "test_commit": "1dc64b16859d95446a8bfe1c50692ce57316bc42",
        "product_file_path": "src/main/java/com/thealgorithms/searches/PerfectBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/PerfectBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nclass PerfectBinarySearch {\n\n    static int binarySearch(int[] arr, int target) {\n        int low = 0;\n        int high = arr.length - 1;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n\n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] > target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        assert PerfectBinarySearch.binarySearch(array, -1) == -1;\n        assert PerfectBinarySearch.binarySearch(array, 11) == -1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author D Sunil (https://github.com/sunilnitdgp)\n * @see SearchAlgorithm\n */\n\npublic class PerfectBinarySearch<T> implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search iteratively.\n     *\n     * @param array The array to make the binary search\n     * @param key   The number you are looking for\n     * @return the location of the key, or -1 if not found\n     */\n    private static <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {\n        while (left <= right) {\n            int median = (left + right) >>> 1;\n            int comp = key.compareTo(array[median]);\n\n            if (comp == 0) {\n                return median; // Key found\n            }\n\n            if (comp < 0) {\n                right = median - 1; // Adjust the right bound\n            } else {\n                left = median + 1; // Adjust the left bound\n            }\n        }\n        return -1; // Key not found\n    }\n}",
        "test_old_content": null,
        "test_new_content": "import static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.searches.PerfectBinarySearch;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author D Sunil (https://github.com/sunilnitdgp)\n * @see PerfectBinarySearch\n */\npublic class PerfectBinarySearchTest {\n\n    @Test\n    public void testIntegerBinarySearch() {\n        Integer[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        PerfectBinarySearch<Integer> binarySearch = new PerfectBinarySearch<>();\n\n        // Test cases for elements present in the array\n        assertEquals(0, binarySearch.find(array, 1)); // First element\n        assertEquals(4, binarySearch.find(array, 5)); // Middle element\n        assertEquals(9, binarySearch.find(array, 10)); // Last element\n        assertEquals(6, binarySearch.find(array, 7)); // Element in the middle\n\n        // Test cases for elements not in the array\n        assertEquals(-1, binarySearch.find(array, 0)); // Element before the array\n        assertEquals(-1, binarySearch.find(array, 11)); // Element after the array\n        assertEquals(-1, binarySearch.find(array, 100)); // Element not in the array\n    }\n\n    @Test\n    public void testStringBinarySearch() {\n        String[] array = {\"apple\", \"banana\", \"cherry\", \"date\", \"fig\"};\n        PerfectBinarySearch<String> binarySearch = new PerfectBinarySearch<>();\n\n        // Test cases for elements not in the array\n        assertEquals(-1, binarySearch.find(array, \"apricot\")); // Element not in the array\n        assertEquals(-1, binarySearch.find(array, \"bananaa\")); // Element not in the array\n\n        // Test cases for elements present in the array\n        assertEquals(0, binarySearch.find(array, \"apple\")); // First element\n        assertEquals(2, binarySearch.find(array, \"cherry\")); // Middle element\n        assertEquals(4, binarySearch.find(array, \"fig\")); // Last element\n    }\n}"
    },
    {
        "product_commit": "e9bbf35ff9ab85dd968fcec14f0a4b057ecccb8b",
        "test_commit": "e9bbf35ff9ab85dd968fcec14f0a4b057ecccb8b",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Floor.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FloorTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Random;\n\npublic class Floor {\n\n    public static void main(String[] args) {\n        Random random = new Random();\n        for (int i = 1; i <= 1000; ++i) {\n            double randomNumber = random.nextDouble();\n            assert floor(randomNumber) == Math.floor(randomNumber);\n        }\n    }\n\n    /**\n     * Returns the largest (closest to positive infinity)\n     *\n     * @param number the number\n     * @return the largest (closest to positive infinity) of given\n     * {@code number}\n     */\n    public static double floor(double number) {\n        if (number - (int) number == 0) {\n            return number;\n        } else if (number - (int) number > 0) {\n            return (int) number;\n        } else {\n            return (int) number - 1;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class Floor {\n\n    private Floor() {\n    }\n\n    /**\n     * Returns the largest (closest to positive infinity)\n     *\n     * @param number the number\n     * @return the largest (closest to positive infinity) of given\n     * {@code number}\n     */\n    public static double floor(double number) {\n        if (number - (int) number == 0) {\n            return number;\n        } else if (number - (int) number > 0) {\n            return (int) number;\n        } else {\n            return (int) number - 1;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class FloorTest {\n    @Test\n    public void testFloorWholeNumber() {\n        assertEquals(0, Floor.floor(0));\n        assertEquals(1, Floor.floor(1));\n        assertEquals(-1, Floor.floor(-1));\n        assertEquals(42, Floor.floor(42));\n        assertEquals(-42, Floor.floor(-42));\n    }\n\n    @Test\n    public void testFloorDoubleNumber() {\n        assertEquals(0, Floor.floor(0.1));\n        assertEquals(1, Floor.floor(1.9));\n        assertEquals(-2, Floor.floor(-1.1));\n        assertEquals(-43, Floor.floor(-42.7));\n    }\n\n    @Test\n    public void testFloorNegativeZero() {\n        assertEquals(-0.0, Floor.floor(-0.0));\n    }\n}"
    },
    {
        "product_commit": "17fe4298b699ff4cb6282a5e1e0edcd7541f6735",
        "test_commit": "17fe4298b699ff4cb6282a5e1e0edcd7541f6735",
        "product_file_path": "src/main/java/com/thealgorithms/maths/MaxValue.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MaxValueTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Random;\n\npublic class MaxValue {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* test 100 times using rand numbers */\n        for (int i = 1; i <= 100; ++i) {\n            /* generate number from -50 to 49 */\n            int a = rand.nextInt(100) - 50;\n            int b = rand.nextInt(100) - 50;\n            assert max(a, b) == Math.max(a, b);\n        }\n    }\n\n    /**\n     * Returns the greater of two {@code int} values. That is, the result is the\n     * argument closer to the value of {@link Integer#MAX_VALUE}. If the\n     * arguments have the same value, the result is that same value.\n     *\n     * @param a an argument.\n     * @param b another argument.\n     * @return the larger of {@code a} and {@code b}.\n     */\n    public static int max(int a, int b) {\n        return a >= b ? a : b;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class MaxValue {\n    private MaxValue() {\n    }\n    /**\n     * Returns the greater of two {@code int} values. That is, the result is the\n     * argument closer to the value of {@link Integer#MAX_VALUE}. If the\n     * arguments have the same value, the result is that same value.\n     *\n     * @param a an argument.\n     * @param b another argument.\n     * @return the larger of {@code a} and {@code b}.\n     */\n    public static int max(int a, int b) {\n        return a >= b ? a : b;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MaxValueTest {\n    @Test\n    public void maxTest() {\n        assertEquals(-1, MaxValue.max(-1, -3));\n        assertEquals(3, MaxValue.max(3, 2));\n        assertEquals(5, MaxValue.max(5, 5));\n    }\n}"
    },
    {
        "product_commit": "c6a22de12f820f3f6f92a60515acce979ff16162",
        "test_commit": "c6a22de12f820f3f6f92a60515acce979ff16162",
        "product_file_path": "src/main/java/com/thealgorithms/maths/MinValue.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MinValueTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Random;\n\npublic class MinValue {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* test 100 times using rand numbers */\n        for (int i = 1; i <= 100; ++i) {\n            /* generate number from -50 to 49 */\n            int a = rand.nextInt(100) - 50;\n            int b = rand.nextInt(100) - 50;\n            assert min(a, b) == Math.min(a, b);\n        }\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values. That is, the result the\n     * argument closer to the value of {@link Integer#MIN_VALUE}. If the\n     * arguments have the same value, the result is that same value.\n     *\n     * @param a an argument.\n     * @param b another argument.\n     * @return the smaller of {@code a} and {@code b}.\n     */\n    public static int min(int a, int b) {\n        return a <= b ? a : b;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class MinValue {\n    private MinValue() {\n    }\n    /**\n     * Returns the smaller of two {@code int} values. That is, the result the\n     * argument closer to the value of {@link Integer#MIN_VALUE}. If the\n     * arguments have the same value, the result is that same value.\n     *\n     * @param a an argument.\n     * @param b another argument.\n     * @return the smaller of {@code a} and {@code b}.\n     */\n    public static int min(int a, int b) {\n        return a <= b ? a : b;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MinValueTest {\n    @Test\n    public void minTest() {\n        assertEquals(-1, MinValue.min(-1, 3));\n        assertEquals(2, MinValue.min(3, 2));\n        assertEquals(5, MinValue.min(5, 5));\n    }\n}"
    },
    {
        "product_commit": "8200a791a28002ca23ac70c73d4c83399beab831",
        "test_commit": "8200a791a28002ca23ac70c73d4c83399beab831",
        "product_file_path": "src/main/java/com/thealgorithms/strings/AhoCorasick.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/AhoCorasickTest.java",
        "product_old_content": null,
        "product_new_content": "/*\n * Aho-Corasick String Matching Algorithm Implementation\n *\n * This code implements the Aho-Corasick algorithm, which is used for efficient\n * string matching in a given text. It can find multiple patterns simultaneously\n * and records their positions in the text.\n *\n * Author: Prabhat-Kumar-42\n * GitHub: https://github.com/Prabhat-Kumar-42\n */\n\npackage com.thealgorithms.strings;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\n\npublic final class AhoCorasick {\n    private AhoCorasick() {\n    }\n\n    // Trie Node Class\n    private static class Node {\n        // Represents a character in the trie\n        private HashMap<Character, Node> child = new HashMap<>(); // Child nodes of the current node\n        private Node suffixLink; // Suffix link to another node in the trie\n        private Node outputLink; // Output link to another node in the trie\n        private int patternInd; // Index of the pattern that ends at this node\n\n        Node() {\n            this.suffixLink = null;\n            this.outputLink = null;\n            this.patternInd = -1;\n        }\n\n        public HashMap<Character, Node> getChild() {\n            return child;\n        }\n\n        public Node getSuffixLink() {\n            return suffixLink;\n        }\n\n        public void setSuffixLink(final Node suffixLink) {\n            this.suffixLink = suffixLink;\n        }\n\n        public Node getOutputLink() {\n            return outputLink;\n        }\n\n        public void setOutputLink(final Node outputLink) {\n            this.outputLink = outputLink;\n        }\n\n        public int getPatternInd() {\n            return patternInd;\n        }\n\n        public void setPatternInd(final int patternInd) {\n            this.patternInd = patternInd;\n        }\n    }\n\n    // Trie Class\n    public static class Trie {\n\n        private Node root = null; // Root node of the trie\n        private final String[] patterns; // patterns according to which Trie is constructed\n\n        public Trie(final String[] patterns) {\n            root = new Node(); // Initialize the root of the trie\n            this.patterns = patterns;\n            buildTrie();\n            buildSuffixAndOutputLinks();\n        }\n\n        // builds AhoCorasick Trie\n        private void buildTrie() {\n\n            // Loop through each input pattern and building Trie\n            for (int i = 0; i < patterns.length; i++) {\n                Node curr = root; // Start at the root of the trie for each pattern\n\n                // Loop through each character in the current pattern\n                for (int j = 0; j < patterns[i].length(); j++) {\n                    char c = patterns[i].charAt(j); // Get the current character\n\n                    // Check if the current node has a child for the current character\n                    if (curr.getChild().containsKey(c)) {\n                        curr = curr.getChild().get(c); // Update the current node to the child node\n                    } else {\n                        // If no child node exists, create a new one and add it to the current node's children\n                        Node nn = new Node();\n                        curr.getChild().put(c, nn);\n                        curr = nn; // Update the current node to the new child node\n                    }\n                }\n                curr.setPatternInd(i); // Store the index of the pattern in the current leaf node\n            }\n        }\n\n        private void initializeSuffixLinksForChildNodesOfTheRoot(Queue<Node> q) {\n            for (char rc : root.getChild().keySet()) {\n                Node childNode = root.getChild().get(rc);\n                q.add(childNode); // Add child node to the queue\n                childNode.setSuffixLink(root); // Set suffix link to the root\n            }\n        }\n\n        private void buildSuffixAndOutputLinks() {\n            root.setSuffixLink(root); // Initialize the suffix link of the root to itself\n            Queue<Node> q = new LinkedList<>(); // Initialize a queue for BFS traversal\n\n            initializeSuffixLinksForChildNodesOfTheRoot(q);\n\n            while (!q.isEmpty()) {\n                Node currentState = q.poll(); // Get the current node for processing\n\n                // Iterate through child nodes of the current node\n                for (char cc : currentState.getChild().keySet()) {\n                    Node currentChild = currentState.getChild().get(cc); // Get the child node\n                    Node parentSuffix = currentState.getSuffixLink(); // Get the parent's suffix link\n\n                    // Calculate the suffix link for the child based on the parent's suffix link\n                    while (!parentSuffix.getChild().containsKey(cc) && parentSuffix != root) {\n                        parentSuffix = parentSuffix.getSuffixLink();\n                    }\n\n                    // Set the calculated suffix link or default to root\n                    if (parentSuffix.getChild().containsKey(cc)) {\n                        currentChild.setSuffixLink(parentSuffix.getChild().get(cc));\n                    } else {\n                        currentChild.setSuffixLink(root);\n                    }\n\n                    q.add(currentChild); // Add the child node to the queue for further processing\n                }\n\n                // Establish output links for nodes to efficiently identify patterns within patterns\n                if (currentState.getSuffixLink().getPatternInd() >= 0) {\n                    currentState.setOutputLink(currentState.getSuffixLink());\n                } else {\n                    currentState.setOutputLink(currentState.getSuffixLink().getOutputLink());\n                }\n            }\n        }\n\n        private ArrayList<ArrayList<Integer>> initializePositionByStringIndexValue() {\n            ArrayList<ArrayList<Integer>> positionByStringIndexValue = new ArrayList<>(patterns.length); // Stores positions where patterns are found in the text\n            for (int i = 0; i < patterns.length; i++) {\n                positionByStringIndexValue.add(new ArrayList<Integer>());\n            }\n            return positionByStringIndexValue;\n        }\n\n        // Searches for patterns in the input text and records their positions\n        public ArrayList<ArrayList<Integer>> searchIn(final String text) {\n            var positionByStringIndexValue = initializePositionByStringIndexValue(); // Initialize a list to store positions of the current pattern\n            Node parent = root; // Start searching from the root node\n\n            PatternPositionRecorder positionRecorder = new PatternPositionRecorder(positionByStringIndexValue);\n\n            for (int i = 0; i < text.length(); i++) {\n                char ch = text.charAt(i); // Get the current character in the text\n\n                // Check if the current node has a child for the current character\n                if (parent.getChild().containsKey(ch)) {\n                    parent = parent.getChild().get(ch); // Update the current node to the child node\n                    positionRecorder.recordPatternPositions(parent, i); // Use the method in PatternPositionRecorder to record positions\n                } else {\n                    // If no child node exists for the character, backtrack using suffix links\n                    while (parent != root && !parent.getChild().containsKey(ch)) {\n                        parent = parent.getSuffixLink();\n                    }\n                    if (parent.getChild().containsKey(ch)) {\n                        i--; // Decrement i to reprocess the same character\n                    }\n                }\n            }\n\n            setUpStartPoints(positionByStringIndexValue);\n            return positionByStringIndexValue;\n        }\n\n        // by default positionByStringIndexValue contains end-points. This function converts those\n        // endpoints to start points\n        private void setUpStartPoints(ArrayList<ArrayList<Integer>> positionByStringIndexValue) {\n            for (int i = 0; i < patterns.length; i++) {\n                for (int j = 0; j < positionByStringIndexValue.get(i).size(); j++) {\n                    int endpoint = positionByStringIndexValue.get(i).get(j);\n                    positionByStringIndexValue.get(i).set(j, endpoint - patterns[i].length() + 1);\n                }\n            }\n        }\n    }\n\n    // Class to handle pattern position recording\n    private static class PatternPositionRecorder {\n        private ArrayList<ArrayList<Integer>> positionByStringIndexValue;\n\n        // Constructor to initialize the recorder with the position list\n        PatternPositionRecorder(final ArrayList<ArrayList<Integer>> positionByStringIndexValue) {\n            this.positionByStringIndexValue = positionByStringIndexValue;\n        }\n\n        /**\n         * Records positions for a pattern when it's found in the input text and follows\n         * output links to record positions of other patterns.\n         *\n         * @param parent The current node representing a character in the pattern trie.\n         * @param currentPosition      The current position in the input text.\n         */\n        public void recordPatternPositions(final Node parent, final int currentPosition) {\n            // Check if the current node represents the end of a pattern\n            if (parent.getPatternInd() > -1) {\n                // Add the current position to the list of positions for the found pattern\n                positionByStringIndexValue.get(parent.getPatternInd()).add(currentPosition);\n            }\n\n            Node outputLink = parent.getOutputLink();\n            // Follow output links to find and record positions of other patterns\n            while (outputLink != null) {\n                // Add the current position to the list of positions for the pattern linked by outputLink\n                positionByStringIndexValue.get(outputLink.getPatternInd()).add(currentPosition);\n                outputLink = outputLink.getOutputLink();\n            }\n        }\n    }\n    // method to search for patterns in text\n    public static Map<String, ArrayList<Integer>> search(final String text, final String[] patterns) {\n        final var trie = new Trie(patterns);\n        final var positionByStringIndexValue = trie.searchIn(text);\n        return convert(positionByStringIndexValue, patterns);\n    }\n\n    // method for converting results to a map\n    private static Map<String, ArrayList<Integer>> convert(final ArrayList<ArrayList<Integer>> positionByStringIndexValue, final String[] patterns) {\n        Map<String, ArrayList<Integer>> positionByString = new HashMap<>();\n        for (int i = 0; i < patterns.length; i++) {\n            String pattern = patterns[i];\n            ArrayList<Integer> positions = positionByStringIndexValue.get(i);\n            positionByString.put(pattern, new ArrayList<>(positions));\n        }\n        return positionByString;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "/*\n * Tests For Aho-Corasick String Matching Algorithm\n *\n *            Author: Prabhat-Kumar-42\n *    GitHub: https://github.com/Prabhat-Kumar-42\n */\n\npackage com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Map;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * This class contains test cases for the Aho-Corasick String Matching Algorithm.\n * The Aho-Corasick algorithm is used to efficiently find all occurrences of multiple\n * patterns in a given text.\n */\nclass AhoCorasickTest {\n    private String[] patterns; // The array of patterns to search for\n    private String text; // The input text to search within\n\n    /**\n     * This method sets up the test environment before each test case.\n     * It initializes the patterns and text to be used for testing.\n     */\n    @BeforeEach\n    void setUp() {\n        patterns = new String[] {\"ACC\", \"ATC\", \"CAT\", \"GCG\", \"C\", \"T\"};\n        text = \"GCATCG\";\n    }\n\n    /**\n     * Test searching for multiple patterns in the input text.\n     * The expected results are defined for each pattern.\n     */\n    @Test\n    void testSearch() {\n        // Define the expected results for each pattern\n        final var expected = Map.of(\"ACC\", new ArrayList<>(Arrays.asList()), \"ATC\", new ArrayList<>(Arrays.asList(2)), \"CAT\", new ArrayList<>(Arrays.asList(1)), \"GCG\", new ArrayList<>(Arrays.asList()), \"C\", new ArrayList<>(Arrays.asList(1, 4)), \"T\", new ArrayList<>(Arrays.asList(3)));\n        assertEquals(expected, AhoCorasick.search(text, patterns));\n    }\n\n    /**\n     * Test searching with an empty pattern array.\n     * The result should be an empty map.\n     */\n    @Test\n    void testEmptyPatterns() {\n        // Define an empty pattern array\n        final var emptyPatterns = new String[] {};\n        assertTrue(AhoCorasick.search(text, emptyPatterns).isEmpty());\n    }\n\n    /**\n     * Test searching for patterns that are not present in the input text.\n     * The result should be an empty list for each pattern.\n     */\n    @Test\n    void testPatternNotFound() {\n        // Define patterns that are not present in the text\n        final var searchPatterns = new String[] {\"XYZ\", \"123\"};\n        final var expected = Map.of(\"XYZ\", new ArrayList<Integer>(), \"123\", new ArrayList<Integer>());\n        assertEquals(expected, AhoCorasick.search(text, searchPatterns));\n    }\n\n    /**\n     * Test searching for patterns that start at the beginning of the input text.\n     * The expected position for each pattern is 0.\n     */\n    @Test\n    void testPatternAtBeginning() {\n        // Define patterns that start at the beginning of the text\n        final var searchPatterns = new String[] {\"GC\", \"GCA\", \"GCAT\"};\n        final var expected = Map.of(\"GC\", new ArrayList<Integer>(Arrays.asList(0)), \"GCA\", new ArrayList<Integer>(Arrays.asList(0)), \"GCAT\", new ArrayList<Integer>(Arrays.asList(0)));\n        assertEquals(expected, AhoCorasick.search(text, searchPatterns));\n    }\n\n    /**\n     * Test searching for patterns that end at the end of the input text.\n     * The expected positions are 4, 3, and 2 for the patterns.\n     */\n    @Test\n    void testPatternAtEnd() {\n        // Define patterns that end at the end of the text\n        final var searchPatterns = new String[] {\"CG\", \"TCG\", \"ATCG\"};\n        final var expected = Map.of(\"CG\", new ArrayList<Integer>(Arrays.asList(4)), \"TCG\", new ArrayList<Integer>(Arrays.asList(3)), \"ATCG\", new ArrayList<Integer>(Arrays.asList(2)));\n        assertEquals(expected, AhoCorasick.search(text, searchPatterns));\n    }\n\n    /**\n     * Test searching for patterns with multiple occurrences in the input text.\n     * The expected sizes are 1 and 1, and the expected positions are 2 and 3\n     * for the patterns \"AT\" and \"T\" respectively.\n     */\n    @Test\n    void testMultipleOccurrencesOfPattern() {\n        // Define patterns with multiple occurrences in the text\n        final var searchPatterns = new String[] {\"AT\", \"T\"};\n        final var expected = Map.of(\"AT\", new ArrayList<Integer>(Arrays.asList(2)), \"T\", new ArrayList<Integer>(Arrays.asList(3)));\n        assertEquals(expected, AhoCorasick.search(text, searchPatterns));\n    }\n\n    /**\n     * Test searching for patterns in a case-insensitive manner.\n     * The search should consider patterns regardless of their case.\n     */\n    @Test\n    void testCaseInsensitiveSearch() {\n        // Define patterns with different cases\n        final var searchPatterns = new String[] {\"gca\", \"aTc\", \"C\"};\n        final var expected = Map.of(\"gca\", new ArrayList<Integer>(), \"aTc\", new ArrayList<Integer>(), \"C\", new ArrayList<Integer>(Arrays.asList(1, 4)));\n        assertEquals(expected, AhoCorasick.search(text, searchPatterns));\n    }\n}"
    },
    {
        "product_commit": "aaa2b26ed19477c4e8b8198782c1ee6c560bf8b3",
        "test_commit": "aaa2b26ed19477c4e8b8198782c1ee6c560bf8b3",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RecursiveBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RecursiveBinarySearchTest.java",
        "product_old_content": "// Code by Pronay Debnath\n// Created:- 1/10/2023\n// File Name should be RecursiveBinarySearch.java\n// Explanation:- https://www.tutorialspoint.com/java-program-for-binary-search-recursive\n\nimport java.util.*;\n\n// Create a SearchAlgorithm class with a generic type\nabstract class SearchAlgorithm<T extends Comparable<T>> {\n    // Abstract find method to be implemented by subclasses\n    public abstract int find(T[] arr, T target);\n}\n\npublic class RecursiveBinarySearch<T extends Comparable<T>> extends SearchAlgorithm<T> {\n\n    // Override the find method as required\n    @Override\n    public int find(T[] arr, T target) {\n        // Call the recursive binary search function\n        return binsear(arr, 0, arr.length - 1, target);\n    }\n\n    // Recursive binary search function\n    public int binsear(T[] arr, int left, int right, T target) {\n        if (right >= left) {\n            int mid = left + (right - left) / 2;\n\n            // Compare the element at the middle with the target\n            int comparison = arr[mid].compareTo(target);\n\n            // If the element is equal to the target, return its index\n            if (comparison == 0) {\n                return mid;\n            }\n\n            // If the element is greater than the target, search in the left subarray\n            if (comparison > 0) {\n                return binsear(arr, left, mid - 1, target);\n            }\n\n            // Otherwise, search in the right subarray\n            return binsear(arr, mid + 1, right, target);\n        }\n\n        // Element is not present in the array\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // User inputs\n        System.out.print(\"Enter the number of elements in the array: \");\n        int n = sc.nextInt();\n\n        Integer[] a = new Integer[n]; // You can change the array type as needed\n\n        System.out.println(\"Enter the elements in sorted order:\");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        System.out.print(\"Enter the target element to search for: \");\n        int t = sc.nextInt();\n\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n        int res = searcher.find(a, t);\n\n        if (res == -1)\n            System.out.println(\"Element not found in the array.\");\n        else\n            System.out.println(\"Element found at index \" + res);\n    }\n}",
        "product_new_content": "// Code by Pronay Debnath\n// Created:- 1/10/2023\n// File Name should be RecursiveBinarySearch.java\n// Explanation:- https://www.tutorialspoint.com/java-program-for-binary-search-recursive\npackage com.thealgorithms.searches;\nimport java.util.*;\n\n// Create a SearchAlgorithm class with a generic type\nabstract class SearchAlgorithm<T extends Comparable<T>> {\n    // Abstract find method to be implemented by subclasses\n    public abstract int find(T[] arr, T target);\n}\n\npublic class RecursiveBinarySearch<T extends Comparable<T>> extends SearchAlgorithm<T> {\n\n    // Override the find method as required\n    @Override\n    public int find(T[] arr, T target) {\n        // Call the recursive binary search function\n        return binsear(arr, 0, arr.length - 1, target);\n    }\n\n    // Recursive binary search function\n    public int binsear(T[] arr, int left, int right, T target) {\n        if (right >= left) {\n            int mid = left + (right - left) / 2;\n\n            // Compare the element at the middle with the target\n            int comparison = arr[mid].compareTo(target);\n\n            // If the element is equal to the target, return its index\n            if (comparison == 0) {\n                return mid;\n            }\n\n            // If the element is greater than the target, search in the left subarray\n            if (comparison > 0) {\n                return binsear(arr, left, mid - 1, target);\n            }\n\n            // Otherwise, search in the right subarray\n            return binsear(arr, mid + 1, right, target);\n        }\n\n        // Element is not present in the array\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // User inputs\n        System.out.print(\"Enter the number of elements in the array: \");\n        int n = sc.nextInt();\n\n        Integer[] a = new Integer[n]; // You can change the array type as needed\n\n        System.out.println(\"Enter the elements in sorted order:\");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        System.out.print(\"Enter the target element to search for: \");\n        int t = sc.nextInt();\n\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n        int res = searcher.find(a, t);\n\n        if (res == -1)\n            System.out.println(\"Element not found in the array.\");\n        else\n            System.out.println(\"Element found at index \" + res);\n    }\n}",
        "test_old_content": "// Created by Pronay Debnath\n// Date:- 1/10/2023\n// Test file updated with JUnit tests\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test; // Import the JUnit 5 Test annotation\n\npublic class RecursiveBinarySearchTest {\n\n    @Test\n    public void testBinarySearch() {\n        // Create an instance of GenericBinarySearch\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n\n        // Test case 1: Element found in the array\n        Integer[] arr1 = {1, 2, 3, 4, 5};\n        int target1 = 3;\n        int result1 = searcher.binsear(arr1, 0, arr1.length - 1, target1);\n        assertEquals(2, result1);\n\n        // Test case 2: Element not found in the array\n        Integer[] arr2 = {1, 2, 3, 4, 5};\n        int target2 = 6;\n        int result2 = searcher.binsear(arr2, 0, arr2.length - 1, target2);\n        assertEquals(-1, result2);\n\n        // Test case 3: Element found at the beginning of the array\n        Integer[] arr3 = {10, 20, 30, 40, 50};\n        int target3 = 10;\n        int result3 = searcher.binsear(arr3, 0, arr3.length - 1, target3);\n        assertEquals(0, result3);\n\n        // Test case 4: Element found at the end of the array\n        Integer[] arr4 = {10, 20, 30, 40, 50};\n        int target4 = 50;\n        int result4 = searcher.binsear(arr4, 0, arr4.length - 1, target4);\n        assertEquals(4, result4);\n    }\n}",
        "test_new_content": "// Created by Pronay Debnath\n// Date:- 1/10/2023\n// Test file updated with JUnit tests\npackage com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test; // Import the JUnit 5 Test annotation\n\npublic class RecursiveBinarySearchTest {\n\n    @Test\n    public void testBinarySearch() {\n        // Create an instance of GenericBinarySearch\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n\n        // Test case 1: Element found in the array\n        Integer[] arr1 = {1, 2, 3, 4, 5};\n        int target1 = 3;\n        int result1 = searcher.binsear(arr1, 0, arr1.length - 1, target1);\n        assertEquals(2, result1);\n\n        // Test case 2: Element not found in the array\n        Integer[] arr2 = {1, 2, 3, 4, 5};\n        int target2 = 6;\n        int result2 = searcher.binsear(arr2, 0, arr2.length - 1, target2);\n        assertEquals(-1, result2);\n\n        // Test case 3: Element found at the beginning of the array\n        Integer[] arr3 = {10, 20, 30, 40, 50};\n        int target3 = 10;\n        int result3 = searcher.binsear(arr3, 0, arr3.length - 1, target3);\n        assertEquals(0, result3);\n\n        // Test case 4: Element found at the end of the array\n        Integer[] arr4 = {10, 20, 30, 40, 50};\n        int target4 = 50;\n        int result4 = searcher.binsear(arr4, 0, arr4.length - 1, target4);\n        assertEquals(4, result4);\n    }\n}"
    },
    {
        "product_commit": "081f308b9d7c2a22935eff6f8b7b18258111a3d3",
        "test_commit": "081f308b9d7c2a22935eff6f8b7b18258111a3d3",
        "product_file_path": "src/main/java/com/thealgorithms/strings/ReverseWordsInString.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/ReverseWordsInStringTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic final class ReverseWordsInString {\n\n    private ReverseWordsInString() {\n    }\n\n    /**\n     * @brief Reverses words in the input string\n     * @param s the input string\n     * @return A string created by reversing the order of the words in {@code s}\n     */\n\n    public static String reverseWordsInString(final String s) {\n        var words = s.trim().split(\"\\\\s+\");\n        Collections.reverse(Arrays.asList(words));\n        return String.join(\" \", words);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ReverseWordsInStringTest {\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(String expected, String input) {\n        Assertions.assertEquals(expected, ReverseWordsInString.reverseWordsInString(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(\"blue is Sky\", \"Sky is blue\"), Arguments.of(\"blue is Sky\", \"Sky \\n is \\t \\n  blue \"), Arguments.of(\"\", \"\"), Arguments.of(\"\", \"    \"), Arguments.of(\"\", \"\\t\"));\n    }\n}"
    },
    {
        "product_commit": "064ca8f59124eb3c792d2202ff12260e87e91552",
        "test_commit": "064ca8f59124eb3c792d2202ff12260e87e91552",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMinRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMinRecursion {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* rand size */\n        int size = rand.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with rand numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = rand.nextInt() % 100;\n        }\n\n        assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();\n        assert min(array) == Arrays.stream(array).min().getAsInt();\n    }\n\n    /**\n     * Get min of array using divide and conquer algorithm\n     *\n     * @param array contains elements\n     * @param low the index of the first element\n     * @param high the index of the last element\n     * @return min of {@code array}\n     */\n    public static int min(int[] array, int low, int high) {\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMin = min(array, low, mid); // get min in [low, mid]\n        int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]\n\n        return leftMin > rightMin ? rightMin : leftMin;\n    }\n\n    /**\n     * Get min of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @param len length of given array\n     * @return min value of {@code array}\n     */\n    public static int min(int[] array) {\n        return array.length == 1 ? array[0] : min(array, 0, array.length);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class FindMinRecursion {\n\n    private FindMinRecursion() {\n    }\n    public static int min(final int[] array, final int low, final int high) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMin = min(array, low, mid); // get min in [low, mid]\n        int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]\n\n        return leftMin > rightMin ? rightMin : leftMin;\n    }\n\n    /**\n     * Get min of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @param len length of given array\n     * @return min value of {@code array}\n     */\n    public static int min(final int[] array) {\n        return min(array, 0, array.length - 1);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMinRecursion.min(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(-1, new int[] {-1, 0}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(-4, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMinRecursion.min(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "a3a2d845d563a901946e052eeebba2f6e51e37d8",
        "test_commit": "a3a2d845d563a901946e052eeebba2f6e51e37d8",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Armstrong.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ArmstrongTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * An Armstrong number is equal to the sum of the cubes of its digits. For\n * example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370. An\n * Armstrong number is often called Narcissistic number.\n *\n * @author Vivek\n */\npublic class Armstrong {\n\n    /**\n     * Checks whether a given number is an armstrong number or not.\n     *\n     * @param number number to check\n     * @return {@code true} if given number is armstrong number, {@code false}\n     * otherwise\n     */\n    public boolean isArmstrong(int number) {\n        long sum = 0;\n        long number2 = number;\n        while (number2 > 0) {\n            long mod = number2 % 10;\n            sum += Math.pow(mod, 3);\n            number2 /= 10;\n        }\n        return sum == number;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This class checks whether a given number is an Armstrong number or not.\n * An Armstrong number is a number that is equal to the sum of its own digits,\n * each raised to the power of the number of digits.\n *\n * For example, 370 is an Armstrong number because 3^3 + 7^3 + 0^3 = 370.\n * 1634 is an Armstrong number because 1^4 + 6^4 + 3^4 + 4^4 = 1634.\n * An Armstrong number is often called a Narcissistic number.\n *\n * @author satyabarghav\n */\npublic class Armstrong {\n\n    /**\n     * Checks whether a given number is an Armstrong number or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise\n     */\n    public boolean isArmstrong(int number) {\n        long sum = 0;\n        String temp = Integer.toString(number); // Convert the given number to a string\n        int power = temp.length(); // Extract the length of the number (number of digits)\n        long originalNumber = number;\n\n        while (originalNumber > 0) {\n            long digit = originalNumber % 10;\n            sum += Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n            originalNumber /= 10;\n        }\n\n        return sum == number;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Vivek\n * @since 15/03/22\n */\nclass ArmstrongTest {\n\n    @Test\n    void testIsArmstrong() {\n        Armstrong armstrong = new Armstrong();\n        assertThat(armstrong.isArmstrong(0)).isTrue();\n        assertThat(armstrong.isArmstrong(1)).isTrue();\n        assertThat(armstrong.isArmstrong(153)).isTrue();\n        assertThat(armstrong.isArmstrong(371)).isTrue();\n        assertThat(armstrong.isArmstrong(1634)).isFalse();\n        assertThat(armstrong.isArmstrong(200)).isFalse();\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author satyabarghav\n * @since 4/10/2023\n */\nclass ArmstrongTest {\n\n    @Test\n    void testIsArmstrong() {\n        Armstrong armstrong = new Armstrong();\n        assertThat(armstrong.isArmstrong(0)).isTrue();\n        assertThat(armstrong.isArmstrong(1)).isTrue();\n        assertThat(armstrong.isArmstrong(153)).isTrue();\n        assertThat(armstrong.isArmstrong(371)).isTrue();\n        assertThat(armstrong.isArmstrong(1634)).isTrue();\n        assertThat(armstrong.isArmstrong(200)).isFalse();\n        assertThat(armstrong.isArmstrong(548834)).isTrue();\n        assertThat(armstrong.isArmstrong(9474)).isTrue();\n    }\n}"
    },
    {
        "product_commit": "4fab7adfaa3679d8b41360d169b40ee18b9ed735",
        "test_commit": "4fab7adfaa3679d8b41360d169b40ee18b9ed735",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RabinKarpAlgorithm.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RabinKarpAlgorithmTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\n// Following program is a Java implementation\n// of Rabin Karp Algorithm given in the CLRS book\n\npublic class RabinKarpAlgorithm {\n\n    // d is the number of characters in the input alphabet\n    public static final int d = 256;\n\n    /* pat -> pattern\n        txt -> text\n        q -> A prime number\n    */\n    public int search(String pat, String txt, int q) {\n        int index = -1; // note: -1 here represent not found, it is not an index\n        int M = pat.length();\n        int N = txt.length();\n        int i, j;\n        int p = 0; // hash value for pattern\n        int t = 0; // hash value for txt\n        int h = 1;\n\n        // The value of h would be \"pow(d, M-1)%q\"\n        for (i = 0; i < M - 1; i++) h = (h * d) % q;\n\n        // Calculate the hash value of pattern and first\n        // window of text\n        for (i = 0; i < M; i++) {\n            p = (d * p + pat.charAt(i)) % q;\n            t = (d * t + txt.charAt(i)) % q;\n        }\n\n        // Slide the pattern over text one by one\n        for (i = 0; i <= N - M; i++) {\n            // Check the hash values of current window of text\n            // and pattern. If the hash values match then only\n            // check for characters one by one\n            if (p == t) {\n                /* Check for characters one by one */\n                for (j = 0; j < M; j++) {\n                    if (txt.charAt(i + j) != pat.charAt(j)) break;\n                }\n\n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]\n                if (j == M) {\n                    System.out.println(\"Pattern found at index \" + i);\n                    index = i;\n                    return index;\n                }\n            }\n\n            // Calculate hash value for next window of text: Remove\n            // leading digit, add trailing digit\n            if (i < N - M) {\n                t = (d * (t - txt.charAt(i) * h) + txt.charAt(i + M)) % q;\n\n                // We might get negative value of t, converting it\n                // to positive\n                if (t < 0) t = (t + q);\n            }\n        }\n        return index; // return -1 if pattern does not found\n    }\n}\n// This code is contributed by nuclode",
        "product_new_content": "package com.thealgorithms.searches;\n\n// Implementation of Rabin Karp Algorithm\n\npublic final class RabinKarpAlgorithm {\n    private RabinKarpAlgorithm() {\n    }\n\n    // d is the number of characters in the input alphabet\n    private static final int d = 256;\n\n    public static int search(String pattern, String text, int primeNumber) {\n\n        int index = -1; // -1 here represents not found\n        int patternLength = pattern.length();\n        int textLength = text.length();\n        int hashForPattern = 0;\n        int hashForText = 0;\n        int h = 1;\n\n        // The value of h would be \"pow(d, patternLength-1)%primeNumber\"\n        for (int i = 0; i < patternLength - 1; i++) h = (h * d) % primeNumber;\n\n        // Calculate the hash value of pattern and first\n        // window of text\n        for (int i = 0; i < patternLength; i++) {\n            hashForPattern = (d * hashForPattern + pattern.charAt(i)) % primeNumber;\n            hashForText = (d * hashForText + text.charAt(i)) % primeNumber;\n        }\n\n        // Slide the pattern over text one by one\n        for (int i = 0; i <= textLength - patternLength; i++) {\n            /* Check the hash values of current window of text\n               and pattern. If the hash values match then only\n               check for characters one by one*/\n\n            int j = 0;\n            if (hashForPattern == hashForText) {\n                /* Check for characters one by one */\n                for (j = 0; j < patternLength; j++) {\n                    if (text.charAt(i + j) != pattern.charAt(j)) break;\n                }\n\n                // if hashForPattern == hashForText and pattern[0...patternLength-1] = text[i, i+1, ...i+patternLength-1]\n                if (j == patternLength) {\n                    index = i;\n                    return index;\n                }\n            }\n\n            // Calculate hash value for next window of text: Remove\n            // leading digit, add trailing digit\n            if (i < textLength - patternLength) {\n                hashForText = (d * (hashForText - text.charAt(i) * h) + text.charAt(i + patternLength)) % primeNumber;\n\n                // handling negative hashForText\n                if (hashForText < 0) hashForText = (hashForText + primeNumber);\n            }\n        }\n        return index; // return -1 if pattern does not found\n    }\n}\n// This code is contributed by nuclode",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nclass RabinKarpAlgorithmTest {\n    RabinKarpAlgorithm RKA = new RabinKarpAlgorithm();\n\n    @ParameterizedTest\n    @CsvSource({\"This is an example for rabin karp algorithmn, algorithmn, 101\", \"AAABBDDG, AAA, 137\", \"AAABBCCBB, BBCC, 101\", \"AAABBCCBB, BBCC, 131\", \"AAAABBBBCCC, CCC, 41\", \"ABCBCBCAAB, AADB, 293\", \"Algorithm The Algorithm, Algorithm, 101\"})\n    void RabinKarpAlgorithmTestExample(String txt, String pat, int q) {\n        int indexFromOurAlgorithm = RKA.search(pat, txt, q);\n        int indexFromLinearSearch = txt.indexOf(pat);\n        assertEquals(indexFromOurAlgorithm, indexFromLinearSearch);\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nclass RabinKarpAlgorithmTest {\n\n    @ParameterizedTest\n    @CsvSource({\"This is an example for rabin karp algorithmn, algorithmn, 101\", \"AAABBDDG, AAA, 137\", \"AAABBCCBB, BBCC, 101\", \"AAABBCCBB, BBCC, 131\", \"AAAABBBBCCC, CCC, 41\", \"ABCBCBCAAB, AADB, 293\", \"Algorithm The Algorithm, Algorithm, 101\"})\n    void RabinKarpAlgorithmTestExample(String txt, String pat, int q) {\n        int indexFromOurAlgorithm = RabinKarpAlgorithm.search(pat, txt, q);\n        int indexFromLinearSearch = txt.indexOf(pat);\n        assertEquals(indexFromOurAlgorithm, indexFromLinearSearch);\n    }\n}"
    },
    {
        "product_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "test_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "product_file_path": "src/main/java/com/thealgorithms/greedyalgorithms/ActivitySelection.java",
        "test_file_path": "src/test/java/com/thealgorithms/greedyalgorithms/ActivitySelectionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n// Problem Link:  https://en.wikipedia.org/wiki/Activity_selection_problem\n\npublic class ActivitySelection {\n    // Function to perform activity selection\n    public static ArrayList<Integer> activitySelection(int startTimes[], int endTimes[]) {\n        int n = startTimes.length;\n        int activities[][] = new int[n][3];\n\n        // Create a 2D array to store activities and their start/end times.\n        // Each row: [activity index, start time, end time]\n\n        for (int i = 0; i < n; i++) {\n            activities[i][0] = i; // Assign activity index\n            activities[i][1] = startTimes[i]; // Assign start time\n            activities[i][2] = endTimes[i]; // Assign end time\n        }\n\n        // Sort activities by their end times in ascending order.\n        Arrays.sort(activities, Comparator.comparingDouble(activity -> activity[2]));\n        int lastEndTime;\n        ArrayList<Integer> selectedActivities = new ArrayList<>();\n        selectedActivities.add(activities[0][0]);\n        lastEndTime = activities[0][2];\n\n        // Iterate through sorted activities to select compatible ones.\n        for (int i = 1; i < n; i++) {\n            if (activities[i][1] >= lastEndTime) {\n                selectedActivities.add(activities[i][0]);\n                lastEndTime = activities[i][2];\n            }\n        }\n        return selectedActivities;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class ActivitySelectionTest {\n    @Test\n    public void testActivitySelection() {\n        int start[] = {1, 3, 0, 5, 8, 5};\n        int end[] = {2, 4, 6, 7, 9, 9};\n\n        ArrayList<Integer> result = ActivitySelection.activitySelection(start, end);\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 3, 4));\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSingleActivity() {\n        int start[] = {1};\n        int end[] = {2};\n\n        ArrayList<Integer> result = ActivitySelection.activitySelection(start, end);\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testNoOverlap() {\n        int start[] = {1, 2, 3};\n        int end[] = {2, 3, 4};\n\n        ArrayList<Integer> result = ActivitySelection.activitySelection(start, end);\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 2));\n\n        assertEquals(expected, result);\n    }\n}"
    },
    {
        "product_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "test_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "product_file_path": "src/main/java/com/thealgorithms/greedyalgorithms/CoinChange.java",
        "test_file_path": "src/test/java/com/thealgorithms/greedyalgorithms/CoinChangeTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n// Problem Link : https://en.wikipedia.org/wiki/Change-making_problem\n\npublic class CoinChange {\n    // Function to solve the coin change problem\n    public static ArrayList<Integer> coinChangeProblem(int amount) {\n        // Define an array of coin denominations in descending order\n        Integer coins[] = {1, 2, 5, 10, 20, 50, 100, 500, 2000};\n\n        // Sort the coin denominations in descending order\n        Arrays.sort(coins, Comparator.reverseOrder());\n\n        int count = 0; // Variable to keep track of the total number of coins used\n        ArrayList<Integer> ans = new ArrayList<>(); // List to store selected coins\n\n        // Iterate through the coin denominations\n        for (int i = 0; i < coins.length; i++) {\n            // Check if the current coin denomination can be used to reduce the remaining amount\n            if (coins[i] <= amount) {\n                // Repeatedly subtract the coin denomination from the remaining amount\n                while (coins[i] <= amount) {\n                    count++; // Increment the count of coins used\n                    ans.add(coins[i]); // Add the coin to the list of selected coins\n                    amount -= coins[i]; // Update the remaining amount\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class CoinChangeTest {\n    @Test\n    public void testCoinChangeProblemWithValidAmount() {\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(500, 50, 20, 20, 1));\n        ArrayList<Integer> coins = CoinChange.coinChangeProblem(591);\n        assertEquals(expected, coins);\n    }\n\n    @Test\n    public void testCoinChangeProblemWithLargeAmount() {\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(2000));\n        ArrayList<Integer> coins = CoinChange.coinChangeProblem(2000);\n        assertEquals(expected, coins);\n    }\n\n    @Test\n    public void testCoinChangeProblemWithPartialCoins2() {\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(500, 50, 20));\n        ArrayList<Integer> coins = CoinChange.coinChangeProblem(570);\n        assertEquals(expected, coins);\n    }\n\n    @Test\n    public void testCoinChangeProblemWithSmallAmount() {\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(2, 1));\n        ArrayList<Integer> coins = CoinChange.coinChangeProblem(3);\n        assertEquals(expected, coins);\n    }\n\n    @Test\n    public void testCoinChangeProblemWithLargeAmountAndMultipleDenominations() {\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(2000, 2000, 2000, 2000, 500, 500, 500, 100, 100, 100, 100, 50, 20, 20, 5, 2, 2));\n        ArrayList<Integer> coins = CoinChange.coinChangeProblem(9999);\n        assertEquals(expected, coins);\n    }\n\n    @Test\n    public void testCoinChangeProblemWithAllDenominations() {\n        ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(2000, 500, 100, 100, 100, 50, 20, 10, 5, 2, 1));\n        ArrayList<Integer> coins = CoinChange.coinChangeProblem(2888);\n        assertEquals(expected, coins);\n    }\n\n    @Test\n    public void testCoinChangeProblemWithZeroAmount() {\n        ArrayList<Integer> expected = new ArrayList<>();\n        ArrayList<Integer> coins = CoinChange.coinChangeProblem(0);\n        assertEquals(expected, coins);\n    }\n}"
    },
    {
        "product_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "test_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "product_file_path": "src/main/java/com/thealgorithms/greedyalgorithms/FractionalKnapsack.java",
        "test_file_path": "src/test/java/com/thealgorithms/greedyalgorithms/FractionalKnapsackTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n// Problem Link: https://en.wikipedia.org/wiki/Continuous_knapsack_problem\n\npublic class FractionalKnapsack {\n    // Function to perform fractional knapsack\n    public static int fractionalKnapsack(int weight[], int value[], int capacity) {\n        // Create a 2D array to store item indices and their value-to-weight ratios.\n        double ratio[][] = new double[weight.length][2];\n\n        // Populate the ratio array with item indices and their value-to-weight ratios.\n        for (int i = 0; i < weight.length; i++) {\n            ratio[i][0] = i; // Assign item index.\n            ratio[i][1] = value[i] / (double) weight[i]; // Calculate and assign value-to-weight ratio.\n        }\n\n        // Sort items by their value-to-weight ratios in descending order.\n        Arrays.sort(ratio, Comparator.comparingDouble(o -> o[1]));\n\n        int finalValue = 0; // Variable to store the final knapsack value.\n        double current = capacity; // Variable to track the remaining capacity of the knapsack.\n\n        // Iterate through the sorted items to select items for the knapsack.\n        for (int i = ratio.length - 1; i >= 0; i--) {\n            int index = (int) ratio[i][0]; // Get the item index.\n            if (current >= weight[index]) {\n                // If the entire item can fit in the knapsack, add its value.\n                finalValue += value[index];\n                current -= weight[index];\n            } else {\n                // If only a fraction of the item can fit, add a proportionate value.\n                finalValue += ratio[i][1] * current;\n                break; // Stop adding items to the knapsack since it's full.\n            }\n        }\n        return finalValue;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FractionalKnapsackTest {\n\n    @Test\n    public void testFractionalKnapsackWithExampleCase() {\n        int weight[] = {10, 20, 30};\n        int value[] = {60, 100, 120};\n        int capacity = 50;\n        assertEquals(240, FractionalKnapsack.fractionalKnapsack(weight, value, capacity));\n    }\n\n    @Test\n    public void testFractionalKnapsackWithZeroCapacity() {\n        int weight[] = {10, 20, 30};\n        int value[] = {60, 100, 120};\n        int capacity = 0;\n        assertEquals(0, FractionalKnapsack.fractionalKnapsack(weight, value, capacity));\n    }\n\n    @Test\n    public void testFractionalKnapsackWithEmptyItems() {\n        int weight[] = {};\n        int value[] = {};\n        int capacity = 50;\n        assertEquals(0, FractionalKnapsack.fractionalKnapsack(weight, value, capacity));\n    }\n}"
    },
    {
        "product_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "test_commit": "535230acae939a9bb601a82be6f2c20c75687c4d",
        "product_file_path": "src/main/java/com/thealgorithms/greedyalgorithms/JobSequencing.java",
        "test_file_path": "src/test/java/com/thealgorithms/greedyalgorithms/JobSequencingTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\n// Problem Link: https://en.wikipedia.org/wiki/Job-shop_scheduling\n\npublic class JobSequencing {\n\n    // Define a Job class that implements Comparable for sorting by profit in descending order\n    static class Job implements Comparable<Job> {\n        char id;\n        int deadline;\n        int profit;\n\n        // Compare jobs by profit in descending order\n        @Override\n        public int compareTo(Job otherJob) {\n            return otherJob.profit - this.profit;\n        }\n\n        public Job(char id, int deadline, int profit) {\n            this.id = id;\n            this.deadline = deadline;\n            this.profit = profit;\n        }\n    }\n\n    // Function to print the job sequence\n    public static String findJobSequence(ArrayList<Job> jobs, int size) {\n        Boolean[] slots = new Boolean[size];\n        Arrays.fill(slots, false);\n\n        int result[] = new int[size];\n\n        // Iterate through jobs to find the optimal job sequence\n        for (int i = 0; i < size; i++) {\n            for (int j = jobs.get(i).deadline - 1; j >= 0; j--) {\n                if (!slots[j]) {\n                    result[j] = i;\n                    slots[j] = true;\n                    break;\n                }\n            }\n        }\n\n        // Create a StringBuilder to build the job sequence string\n        StringBuilder jobSequenceBuilder = new StringBuilder();\n        jobSequenceBuilder.append(\"Job Sequence: \");\n        for (int i = 0; i < jobs.size(); i++) {\n            if (slots[i]) {\n                jobSequenceBuilder.append(jobs.get(result[i]).id).append(\" -> \");\n            }\n        }\n\n        // Remove the trailing \" -> \" from the job sequence\n        if (jobSequenceBuilder.length() >= 4) {\n            jobSequenceBuilder.setLength(jobSequenceBuilder.length() - 4);\n        }\n\n        // Return the job sequence as a string\n        return jobSequenceBuilder.toString();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.greedyalgorithms;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\n\npublic class JobSequencingTest {\n    @Test\n    public void testJobSequencingWithExampleCase() {\n        ArrayList<JobSequencing.Job> jobs = new ArrayList<>();\n        jobs.add(new JobSequencing.Job('a', 2, 100));\n        jobs.add(new JobSequencing.Job('b', 1, 19));\n        jobs.add(new JobSequencing.Job('c', 2, 27));\n        jobs.add(new JobSequencing.Job('d', 1, 25));\n        jobs.add(new JobSequencing.Job('e', 3, 15));\n        Collections.sort(jobs);\n        String jobSequence = JobSequencing.findJobSequence(jobs, jobs.size());\n\n        assertEquals(\"Job Sequence: c -> a -> e\", jobSequence);\n    }\n}"
    },
    {
        "product_commit": "329cc3bcf9bc7d43c358f5d7e635a7d9db99890a",
        "test_commit": "329cc3bcf9bc7d43c358f5d7e635a7d9db99890a",
        "product_file_path": "src/main/java/com/thealgorithms/misc/MirrorOfMatrix.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/MirrorOfMatrixTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.misc;\n\n// Problem Statement\n/*\nWe have given an array of m x n (where m is the number of rows and n is the number of columns).\nPrint the new matrix in such a way that the new matrix is the mirror image of the original matrix.\n\nThe Original matrix is:   |   The Mirror matrix is:\n1\t2\t3\t              |   3\t 2\t 1\n4\t5\t6\t              |   6\t 5\t 4\n7\t8\t9\t              |   9\t 8\t 7\n\n@author - Aman (https://github.com/Aman28801)\n*/\n\npublic final class MirrorOfMatrix {\n    private MirrorOfMatrix() {\n    }\n\n    public static int[][] mirrorMatrix(final int[][] originalMatrix) {\n        if (originalMatrix == null) {\n            // Handle invalid input\n            return null;\n        }\n        if (originalMatrix.length == 0) {\n            return new int[0][0];\n        }\n\n        checkInput(originalMatrix);\n\n        int numRows = originalMatrix.length;\n        int numCols = originalMatrix[0].length;\n\n        int[][] mirroredMatrix = new int[numRows][numCols];\n\n        for (int i = 0; i < numRows; i++) {\n            mirroredMatrix[i] = reverseRow(originalMatrix[i]);\n        }\n        return mirroredMatrix;\n    }\n    private static int[] reverseRow(final int[] inRow) {\n        int[] res = new int[inRow.length];\n        for (int i = 0; i < inRow.length; ++i) {\n            res[i] = inRow[inRow.length - 1 - i];\n        }\n        return res;\n    }\n\n    private static void checkInput(final int[][] matrix) {\n        // Check if all rows have the same number of columns\n        for (int i = 1; i < matrix.length; i++) {\n            if (matrix[i].length != matrix[0].length) {\n                throw new IllegalArgumentException(\"The input is not a matrix.\");\n            }\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass MirrorOfMatrixTest {\n\n    @Test\n    void testMirrorMatrixRegularMatrix() {\n        int[][] originalMatrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        int[][] expectedMirrorMatrix = {{3, 2, 1}, {6, 5, 4}, {9, 8, 7}};\n        int[][] mirroredMatrix = MirrorOfMatrix.mirrorMatrix(originalMatrix);\n        assertArrayEquals(expectedMirrorMatrix, mirroredMatrix);\n    }\n\n    @Test\n    void testMirrorMatrixEmptyMatrix() {\n        int[][] originalMatrix = {};\n        int[][] expectedMirrorMatrix = {};\n        int[][] mirroredMatrix = MirrorOfMatrix.mirrorMatrix(originalMatrix);\n        assertArrayEquals(expectedMirrorMatrix, mirroredMatrix);\n    }\n\n    @Test\n    void testMirrorMatrixSingleElementMatrix() {\n        int[][] originalMatrix = {{42}};\n        int[][] expectedMirrorMatrix = {{42}};\n        int[][] mirroredMatrix = MirrorOfMatrix.mirrorMatrix(originalMatrix);\n        assertArrayEquals(expectedMirrorMatrix, mirroredMatrix);\n    }\n\n    @Test\n    void testMirrorMatrixMultipleRowsOneColumnMatrix() {\n        int[][] originalMatrix = {{1}, {2}, {3}, {4}};\n        int[][] expectedMirrorMatrix = {{1}, {2}, {3}, {4}};\n        int[][] mirroredMatrix = MirrorOfMatrix.mirrorMatrix(originalMatrix);\n        assertArrayEquals(expectedMirrorMatrix, mirroredMatrix);\n    }\n\n    @Test\n    void testMirrorMatrixNullInput() {\n        int[][] originalMatrix = null;\n        assertNull(MirrorOfMatrix.mirrorMatrix(originalMatrix));\n    }\n\n    @Test\n    void testMirrotMarixThrows() {\n        assertThrows(IllegalArgumentException.class, () -> MirrorOfMatrix.mirrorMatrix(new int[][] {{1}, {2, 3}}));\n    }\n}"
    },
    {
        "product_commit": "5f5a61de872f5894097564ed769299dc5134f011",
        "test_commit": "5f5a61de872f5894097564ed769299dc5134f011",
        "product_file_path": "src/main/java/com/thealgorithms/misc/MedianOfMatrix.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/MedianOfMatrixtest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.misc;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Median of Matrix (https://medium.com/@vaibhav.yadav8101/median-in-a-row-wise-sorted-matrix-901737f3e116)\n * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic final class MedianOfMatrix {\n\n    public static int median(List<List<Integer>> matrix) {\n        // Flatten the matrix into a 1D list\n        List<Integer> linear = new ArrayList<>();\n        for (List<Integer> row : matrix) {\n            linear.addAll(row);\n        }\n\n        // Sort the 1D list\n        Collections.sort(linear);\n\n        // Calculate the middle index\n        int mid = (0 + linear.size() - 1) / 2;\n\n        // Return the median\n        return linear.get(mid);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class MedianOfMatrixtest {\n\n    @Test\n    public void testMedianWithOddNumberOfElements() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(Arrays.asList(1, 3, 5));\n        matrix.add(Arrays.asList(2, 4, 6));\n        matrix.add(Arrays.asList(7, 8, 9));\n\n        int result = MedianOfMatrix.median(matrix);\n\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testMedianWithEvenNumberOfElements() {\n        List<List<Integer>> matrix = new ArrayList<>();\n        matrix.add(Arrays.asList(2, 4));\n        matrix.add(Arrays.asList(1, 3));\n\n        int result = MedianOfMatrix.median(matrix);\n\n        assertEquals(2, result);\n    }\n}"
    },
    {
        "product_commit": "536978919dc79af9bf25c57ebb90802d1830784e",
        "test_commit": "536978919dc79af9bf25c57ebb90802d1830784e",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/ReverseKGroup.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/ReverseKGroupTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\n/**\n * Reverse K Group LinkedList (https://www.topcoder.com/thrive/articles/reverse-node-in-k-group)\n * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class ReverseKGroup {\n    public int length(Node head) {\n        Node curr = head;\n        int count = 0;\n        while (curr != null) {\n            curr = curr.next;\n            count++;\n        }\n        return count;\n    }\n    // reverse function\n    public Node reverse(Node head, int count, int k) {\n        if (count < k) {\n            return head;\n        }\n        Node prev = null;\n        int count1 = 0;\n        Node curr = head;\n        Node Next = null;\n        while (curr != null && count1 < k) {\n            Next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = Next;\n            count1++;\n        }\n\n        if (Next != null) {\n            head.next = reverse(Next, count - k, k);\n        }\n        return prev;\n    }\n    public Node reverseKGroup(Node head, int k) {\n        int count = length(head);\n        Node ans = reverse(head, count, k);\n        return ans;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\n/**\n * Test cases for Reverse K Group LinkedList\n * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ReverseKGroupTest {\n\n    @Test\n    public void testReverseKGroupWithEmptyList() {\n        ReverseKGroup reverser = new ReverseKGroup();\n        assertNull(reverser.reverseKGroup(null, 3));\n    }\n\n    @Test\n    public void testReverseKGroupWithSingleNodeList() {\n        ReverseKGroup reverser = new ReverseKGroup();\n        Node singleNode = new Node(5);\n        Node result = reverser.reverseKGroup(singleNode, 2);\n        assertEquals(5, result.value);\n        assertNull(result.next);\n    }\n\n    @Test\n    public void testReverseKGroupWithKEqualTo2() {\n        ReverseKGroup reverser = new ReverseKGroup();\n\n        // Create a list with multiple elements (1 -> 2 -> 3 -> 4 -> 5)\n        Node head;\n        head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        // Test reverse with k=2\n        Node result1 = reverser.reverseKGroup(head, 2);\n        assertEquals(2, result1.value);\n        assertEquals(1, result1.next.value);\n        assertEquals(4, result1.next.next.value);\n        assertEquals(3, result1.next.next.next.value);\n        assertEquals(5, result1.next.next.next.next.value);\n        assertNull(result1.next.next.next.next.next);\n    }\n\n    @Test\n    public void testReverseKGroupWithKEqualTo3() {\n        ReverseKGroup reverser = new ReverseKGroup();\n\n        // Create a list with multiple elements (1 -> 2 -> 3 -> 4 -> 5)\n        Node head;\n        head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        // Test reverse with k=3\n        Node result = reverser.reverseKGroup(head, 3);\n        assertEquals(3, result.value);\n        assertEquals(2, result.next.value);\n        assertEquals(1, result.next.next.value);\n        assertEquals(4, result.next.next.next.value);\n        assertEquals(5, result.next.next.next.next.value);\n        assertNull(result.next.next.next.next.next);\n    }\n}"
    },
    {
        "product_commit": "8dc5505323708dc0963ba7871afac85cf9db60f7",
        "test_commit": "8dc5505323708dc0963ba7871afac85cf9db60f7",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMaxRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMaxRecursion {\n\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* rand size */\n        int size = rand.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with rand numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = rand.nextInt() % 100;\n        }\n\n        assert max(array) == Arrays.stream(array).max().getAsInt();\n        assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();\n    }\n\n    /**\n     * Get max of array using divide and conquer algorithm\n     *\n     * @param array contains elements\n     * @param low the index of the first element\n     * @param high the index of the last element\n     * @return max of {@code array}\n     */\n    public static int max(int[] array, int low, int high) {\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMax = max(array, low, mid); // get max in [low, mid]\n        int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]\n\n        return leftMax < rightMax ? rightMax : leftMax;\n    }\n\n    /**\n     * Get max of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @return max value of {@code array}\n     */\n    public static int max(int[] array) {\n        return array.length == 1 ? array[0] : max(array, 0, array.length);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class FindMaxRecursion {\n\n    private FindMaxRecursion() {\n    }\n    /**\n     * Get max of array using divide and conquer algorithm\n     *\n     * @param array contains elements\n     * @param low the index of the first element\n     * @param high the index of the last element\n     * @return max of {@code array}\n     */\n    public static int max(final int[] array, final int low, final int high) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMax = max(array, low, mid); // get max in [low, mid]\n        int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]\n\n        return leftMax < rightMax ? rightMax : leftMax;\n    }\n\n    /**\n     * Get max of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @return max value of {@code array}\n     */\n    public static int max(final int[] array) {\n        return max(array, 0, array.length - 1);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMaxRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMaxRecursion.max(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {-1, 0}), Arguments.of(-1, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(9, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMaxRecursion.max(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "edb0489440814cd45a4001384b00e8b87c30d6a6",
        "test_commit": "edb0489440814cd45a4001384b00e8b87c30d6a6",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/QuickSortLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/QuickSortLinkedListTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n/*\n *\n * @aurthor - Prabhat-Kumar-42\n * @github - https://github.com/Prabhat-Kumar-42\n *\n * Problem :\n *    QuickSort on Linked List\n *\n * Note: Taking head as pivot in current implementation.\n *        N represents NULL node\n *    Example:\n *\n *      -> Given Linked List :\n *            5 -> 3 -> 8 -> 1 -> 10 -> 2 -> 7 -> 4 -> 9 -> 6\n *\n *      -> How Sorting will work according to the QuickSort Algo written below\n *\n *      current pivot : 5\n *      List lessThanPivot : 3 -> 1 -> 2 -> 4\n *      List greaterThanPivot : 5 -> 8 -> 10 -> 7 -> 9 -> 6\n *\n *      -> reccur for lessThanPivot and greaterThanPivot\n *\n *            lessThanPivot :\n *                current pivot : 3\n *                lessThanPivot : 1 -> 2\n *                greaterThanPivot : 4\n *\n *             greaterThanPivot:\n *                 current pivot : 5\n *                 lessThanPivot : null\n *                 greaterThanPivot : 8 -> 10 -> 7 -> 9 -> 6\n *\n *        By following the above pattern, reccuring tree will form like below :\n *\n *        List-> 5 -> 3 -> 8 -> 1 -> 10 -> 2 -> 7 -> 4 -> 9 -> 6\n *\n *        Pivot :                  5\n *                                /\\\n *                               /  \\\n *                              /    \\\n *                             /      \\\n *                            /        \\\n *        List: (3 -> 1 -> 2 -> 4)   (5 -> 8 -> 10 -> 7 -> 9 -> 6)\n *        Pivot :          3               5\n *                        /\\              /\\\n *                       /  \\            /  \\\n *                      /    \\          /    \\\n *                     /      \\        /      \\\n *         List:   (1 -> 2)   (4)   (N)   (8 -> 10 -> 7 -> 9 -> 6)\n *         Pivot:     1        4                8\n *                   /\\       /\\               /\\\n *                  /  \\     /  \\             /  \\\n *                 /    \\   /    \\           /    \\\n *         List:  (N)  (2) (N)   (N)   (6 -> 7)   (9 -> 10)\n *         Pivot:       2                  6         9\n *                     /\\                 /\\        /\\\n *                    /  \\               /  \\      /  \\\n *                   /    \\             /    \\    /    \\\n *         List:   (N)   (N)          (N)   (7) (N)   (10)\n *         Pivot:                            7          10\n *                                          /\\          /\\\n *                                         /  \\        /  \\\n *                                        /    \\      /    \\\n *                                       (N)   (N)   (N)   (N)\n *\n *\n *      -> After this the tree will reccur back (or backtrack)\n *         and the returning list from left and right subtree will attach\n *         themselves around pivot.\n *         i.e. ,\n *                  (listFromLeftSubTree) -> (Pivot) -> (listFromRightSubtree)\n *\n *         This will continue until whole list is merged back\n *\n *          eg :\n *             Megring the above Tree back we get :\n *\n *          List: (1 -> 2)        (4)           (6 -> 7)         (9 -> 10)\n *                  \\             /                  \\             /\n *                   \\           /                    \\           /\n *                    \\         /                      \\         /\n *                     \\       /                        \\       /\n *                      \\     /                          \\     /\n *                       \\   /                            \\   /\n *                        \\ /                              \\ /\n *          Pivot:         3                                8\n *          List:   (1 -> 2 -> 3 -> 4)            (6 -> 7 -> 8 -> 9 -> 10)\n *                                  \\              /\n *                                   \\            /\n *                                    \\          /\n *                                     \\        /\n *                                      \\      /\n *                                       \\    /\n *                                        \\  /\n *                                         \\/\n *          Pivot:                          5\n *          List:      (1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10)\n *\n *\n *      -> This will result in a sorted Linked List\n */\n\npublic class QuickSortLinkedList {\n\n    private SinglyLinkedList list = null; // Linked list\n    private Node head = null; // head of the list\n    // Counstructor\n    public QuickSortLinkedList(SinglyLinkedList list) {\n        this.list = list;\n        this.head = list.getHead();\n    }\n\n    // Function to sort a linked list using the Quick Sort algorithm\n    public void sortList() {\n        head = sortList(head);\n        list.setHead(head);\n    }\n    // helper function to apply QuickSort to the stored list\n    public Node sortList(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // Choose the first element as the pivot\n        Node pivot = head;\n        head = head.next;\n        pivot.next = null;\n\n        Node lessHead = new Node(); // stores the nodes cantaining data less than pivot node\n        Node lessTail = lessHead; // tail of lessHead\n        Node greaterHead = new Node(); // stores the nodes cantaining data greater than pivot node\n        Node greaterTail = greaterHead; // tail of greaterHead\n\n        // Partition the list around the pivot\n        while (head != null) {\n            if (head.value < pivot.value) {\n                lessTail.next = head;\n                lessTail = lessTail.next;\n            } else {\n                greaterTail.next = head;\n                greaterTail = greaterTail.next;\n            }\n            head = head.next;\n        }\n\n        // Seperating lessHead and greaterHead to form two seperate linkedList\n        lessTail.next = null;\n        greaterTail.next = null;\n\n        // Recursively sort the sublists\n        Node sortedLess = sortList(lessHead.next);\n        Node sortedGreater = sortList(greaterHead.next);\n\n        // Combine the sorted sublists and pivot\n        if (sortedLess == null) {\n            pivot.next = sortedGreater;\n            return pivot;\n        } else {\n            Node current = sortedLess;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = pivot;\n            pivot.next = sortedGreater;\n            return sortedLess;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\n/**\n * Test cases for QuickSortLinkedList\n * Author: Prabhat-Kumar-42\n * GitHub: https://github.com/Prabhat-Kumar-42\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class QuickSortLinkedListTest {\n\n    @Test\n    public void testSortEmptyList() {\n        SinglyLinkedList emptyList = new SinglyLinkedList();\n        QuickSortLinkedList sorter = new QuickSortLinkedList(emptyList);\n\n        // Test case: Sorting an empty list should result in an empty list\n        sorter.sortList();\n        assertNull(emptyList.getHead());\n    }\n\n    @Test\n    public void testSortSingleNodeList() {\n        SinglyLinkedList singleNodeList = new SinglyLinkedList();\n        singleNodeList.insert(5);\n        QuickSortLinkedList sorter = new QuickSortLinkedList(singleNodeList);\n\n        // Test case: Sorting a list with a single node should result in the same list\n        sorter.sortList();\n        assertEquals(5, singleNodeList.getHead().value);\n        assertNull(singleNodeList.getHead().next);\n    }\n\n    @Test\n    public void testSortMultipleElementsList() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.insert(5);\n        list.insert(3);\n        list.insert(8);\n        list.insert(1);\n        list.insert(10);\n        list.insert(2);\n        list.insert(7);\n        list.insert(4);\n        list.insert(9);\n        list.insert(6);\n        QuickSortLinkedList sorter = new QuickSortLinkedList(list);\n\n        // Test case: Sorting a list with multiple elements\n        sorter.sortList();\n        assertEquals(1, list.getHead().value);\n        assertEquals(2, list.getHead().next.value);\n        assertEquals(3, list.getHead().next.next.value);\n        assertEquals(4, list.getHead().next.next.next.value);\n        assertEquals(5, list.getHead().next.next.next.next.value);\n        assertEquals(6, list.getHead().next.next.next.next.next.value);\n        assertEquals(7, list.getHead().next.next.next.next.next.next.value);\n        assertEquals(8, list.getHead().next.next.next.next.next.next.next.value);\n        assertEquals(9, list.getHead().next.next.next.next.next.next.next.next.value);\n        assertEquals(10, list.getHead().next.next.next.next.next.next.next.next.next.value);\n        assertNull(list.getHead().next.next.next.next.next.next.next.next.next.next);\n    }\n}"
    },
    {
        "product_commit": "37b3844b98712d2f46ed2296f307cbb8539dd748",
        "test_commit": "37b3844b98712d2f46ed2296f307cbb8539dd748",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SecondMinMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SecondMinMaxTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.function.BiPredicate;\n\npublic final class SecondMinMax {\n\n    /**\n     * Utility class for finding second maximum or minimum based on BiPredicate\n     * @exception IllegalArgumentException => if input array is of length less than 2 also if all elements are same\n     * @return the second minimum / maximum value from the input array\n     * @author Bharath Sanjeevi ( https://github.com/BharathSanjeeviT )\n     */\n\n    private SecondMinMax() {\n    }\n\n    private static int secondBest(final int[] arr, final int initialVal, final BiPredicate<Integer, Integer> isBetter) {\n        checkInput(arr);\n        int best = initialVal;\n        int secBest = initialVal;\n        for (final int num : arr) {\n            if (isBetter.test(num, best)) {\n                secBest = best;\n                best = num;\n            } else if ((isBetter.test(num, secBest)) && (num != best)) {\n                secBest = num;\n            }\n        }\n        checkOutput(secBest, initialVal);\n        return secBest;\n    }\n\n    /**\n     * @brief Finds the Second minimum / maximum value from the array\n     * @param arr the input array\n     * @exception IllegalArgumentException => if input array is of length less than 2 also if all elements are same\n     * @return the second minimum / maximum value from the input array\n     * @author Bharath Sanjeevi ( https://github.com/BharathSanjeeviT )\n     */\n\n    public static int findSecondMin(final int[] arr) {\n        return secondBest(arr, Integer.MAX_VALUE, (a, b) -> a < b);\n    }\n\n    public static int findSecondMax(final int[] arr) {\n        return secondBest(arr, Integer.MIN_VALUE, (a, b) -> a > b);\n    }\n\n    private static void checkInput(final int[] arr) {\n        if (arr.length < 2) {\n            throw new IllegalArgumentException(\"Input array must have length of at least two\");\n        }\n    }\n\n    private static void checkOutput(final int secNum, final int initialVal) {\n        if (secNum == initialVal) {\n            throw new IllegalArgumentException(\"Input array should have at least 2 distinct elements\");\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class SecondMinMaxTest {\n\n    private static final String EXP_MSG_ARR_LEN_LESS_2 = \"Input array must have length of at least two\";\n    private static final String EXP_MSG_ARR_SAME_ELE = \"Input array should have at least 2 distinct elements\";\n\n    public static class TestCase {\n        public TestCase(final int[] inInputArray, final int inSecondMin, final int inSecondMax) {\n            inputArray = inInputArray;\n            secondMin = inSecondMin;\n            secondMax = inSecondMax;\n        }\n        final int[] inputArray;\n        final int secondMin;\n        final int secondMax;\n    }\n\n    @Test\n    public void testForEmptyInputArray() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> SecondMinMax.findSecondMin(new int[] {}));\n        assertEquals(exception.getMessage(), EXP_MSG_ARR_LEN_LESS_2);\n    }\n\n    @Test\n    public void testForArrayWithSingleElement() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> SecondMinMax.findSecondMax(new int[] {1}));\n        assertEquals(exception.getMessage(), EXP_MSG_ARR_LEN_LESS_2);\n    }\n\n    @Test\n    public void testForArrayWithSameElements() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> SecondMinMax.findSecondMin(new int[] {1, 1, 1, 1}));\n        assertEquals(exception.getMessage(), EXP_MSG_ARR_SAME_ELE);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(final TestCase tc) {\n        Assertions.assertEquals(tc.secondMax, SecondMinMax.findSecondMax(tc.inputArray));\n        Assertions.assertEquals(tc.secondMin, SecondMinMax.findSecondMin(tc.inputArray));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(new TestCase(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 2, 9)), Arguments.of(new TestCase(new int[] {5, 4, 5, 5, 5}, 5, 4)), Arguments.of(new TestCase(new int[] {-1, 0}, 0, -1)),\n            Arguments.of(new TestCase(new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}, -9, -2)), Arguments.of(new TestCase(new int[] {3, -2, 3, 9, -4, -4, 8}, -2, 8)));\n    }\n}"
    },
    {
        "product_commit": "da687c11cb35d9c13c8d2681796b512e08f59f27",
        "test_commit": "da687c11cb35d9c13c8d2681796b512e08f59f27",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RecursiveBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RecursiveBinarySearchTest.java",
        "product_old_content": null,
        "product_new_content": "// Code by Pronay Debnath\n// Created:- 1/10/2023\n// File Name should be RecursiveBinarySearch.java\n// Explanation:- https://www.tutorialspoint.com/java-program-for-binary-search-recursive\n\nimport java.util.*;\n\n// Create a SearchAlgorithm class with a generic type\nabstract class SearchAlgorithm<T extends Comparable<T>> {\n    // Abstract find method to be implemented by subclasses\n    public abstract int find(T[] arr, T target);\n}\n\npublic class RecursiveBinarySearch<T extends Comparable<T>> extends SearchAlgorithm<T> {\n\n    // Override the find method as required\n    @Override\n    public int find(T[] arr, T target) {\n        // Call the recursive binary search function\n        return binsear(arr, 0, arr.length - 1, target);\n    }\n\n    // Recursive binary search function\n    public int binsear(T[] arr, int left, int right, T target) {\n        if (right >= left) {\n            int mid = left + (right - left) / 2;\n\n            // Compare the element at the middle with the target\n            int comparison = arr[mid].compareTo(target);\n\n            // If the element is equal to the target, return its index\n            if (comparison == 0) {\n                return mid;\n            }\n\n            // If the element is greater than the target, search in the left subarray\n            if (comparison > 0) {\n                return binsear(arr, left, mid - 1, target);\n            }\n\n            // Otherwise, search in the right subarray\n            return binsear(arr, mid + 1, right, target);\n        }\n\n        // Element is not present in the array\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // User inputs\n        System.out.print(\"Enter the number of elements in the array: \");\n        int n = sc.nextInt();\n\n        Integer[] a = new Integer[n]; // You can change the array type as needed\n\n        System.out.println(\"Enter the elements in sorted order:\");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        System.out.print(\"Enter the target element to search for: \");\n        int t = sc.nextInt();\n\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n        int res = searcher.find(a, t);\n\n        if (res == -1)\n            System.out.println(\"Element not found in the array.\");\n        else\n            System.out.println(\"Element found at index \" + res);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "// Created by Pronay Debnath\n// Date:- 1/10/2023\n// Test file updated with JUnit tests\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test; // Import the JUnit 5 Test annotation\n\npublic class RecursiveBinarySearchTest {\n\n    @Test\n    public void testBinarySearch() {\n        // Create an instance of GenericBinarySearch\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n\n        // Test case 1: Element found in the array\n        Integer[] arr1 = {1, 2, 3, 4, 5};\n        int target1 = 3;\n        int result1 = searcher.binsear(arr1, 0, arr1.length - 1, target1);\n        assertEquals(2, result1);\n\n        // Test case 2: Element not found in the array\n        Integer[] arr2 = {1, 2, 3, 4, 5};\n        int target2 = 6;\n        int result2 = searcher.binsear(arr2, 0, arr2.length - 1, target2);\n        assertEquals(-1, result2);\n\n        // Test case 3: Element found at the beginning of the array\n        Integer[] arr3 = {10, 20, 30, 40, 50};\n        int target3 = 10;\n        int result3 = searcher.binsear(arr3, 0, arr3.length - 1, target3);\n        assertEquals(0, result3);\n\n        // Test case 4: Element found at the end of the array\n        Integer[] arr4 = {10, 20, 30, 40, 50};\n        int target4 = 50;\n        int result4 = searcher.binsear(arr4, 0, arr4.length - 1, target4);\n        assertEquals(4, result4);\n    }\n}"
    },
    {
        "product_commit": "ee2629c8ab5c5c27bd728fb02a92a67a74a76cbc",
        "test_commit": "ee2629c8ab5c5c27bd728fb02a92a67a74a76cbc",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Pangram.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PangramTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if a String is Pangram or not by checking if each alhpabet is present or not\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram2(String s) {\n        if (s.length() < 26) {\n            return false;\n        }\n        s = s.toLowerCase(); // Converting s to Lower-Case\n        for (char i = 'a'; i <= 'z'; i++) {\n            if (s.indexOf(i) == -1) {\n                return false; // if any alphabet is not present, return false\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.HashSet;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    // alternative approach using Java Collection Framework\n    public static boolean isPangramUsingSet(String s) {\n        HashSet<Character> alpha = new HashSet<Character>();\n        s = s.trim().toLowerCase();\n        for (int i = 0; i < s.length(); i++)\n            if (s.charAt(i) != ' ') alpha.add(s.charAt(i));\n        if (alpha.size() == 26) return true;\n        return false;\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if a String is Pangram or not by checking if each alhpabet is present or not\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram2(String s) {\n        if (s.length() < 26) {\n            return false;\n        }\n        s = s.toLowerCase(); // Converting s to Lower-Case\n        for (char i = 'a'; i <= 'z'; i++) {\n            if (s.indexOf(i) == -1) {\n                return false; // if any alphabet is not present, return false\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PangramTest {\n\n    @Test\n    public void testPangram() {\n        assertTrue(Pangram.isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n\n        assertTrue(Pangram.isPangram2(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram2(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram2(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram2(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PangramTest {\n\n    @Test\n    public void testPangram() {\n        assertTrue(Pangram.isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n\n        assertTrue(Pangram.isPangram2(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram2(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram2(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram2(\"\\u0000/\\\\ Invalid characters are alright too\"));\n\n        assertTrue(Pangram.isPangramUsingSet(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangramUsingSet(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangramUsingSet(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangramUsingSet(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}"
    },
    {
        "product_commit": "e5d33f35651e8b46ba2318dbd934dc3eeb81507b",
        "test_commit": "e5d33f35651e8b46ba2318dbd934dc3eeb81507b",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/ClearBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/ClearBitTest.java",
        "product_old_content": "package com.thealgorithms.bitmanipulation;\n/**\n * Clears the bit located at clear from num\n */\n\npublic class ClearBit {\n    public static int clearBit(int num, int clear) {\n        int mask = ~(1 << clear);\n        return num & mask;\n    }\n}",
        "product_new_content": null,
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ClearBitTest {\n    @Test\n    public void clearBitTest() {\n        assertEquals(5, ClearBit.clearBit(7, 1));\n        assertEquals(5, ClearBit.clearBit(5, 1));\n    }\n}",
        "test_new_content": null
    },
    {
        "product_commit": "e5d33f35651e8b46ba2318dbd934dc3eeb81507b",
        "test_commit": "e5d33f35651e8b46ba2318dbd934dc3eeb81507b",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/SetBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/SetBitTest.java",
        "product_old_content": "package com.thealgorithms.bitmanipulation;\n/**\n * Sets a specific bit to 1\n */\n\npublic class SetBit {\n    public static int setBit(int num, int bit) {\n        return num | (1 << bit);\n    }\n}",
        "product_new_content": null,
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SetBitTest {\n    @Test\n    void testSetBit() {\n        assertEquals(5, SetBit.setBit(4, 0));\n        assertEquals(3, SetBit.setBit(3, 1));\n    }\n}",
        "test_new_content": null
    },
    {
        "product_commit": "e5d33f35651e8b46ba2318dbd934dc3eeb81507b",
        "test_commit": "e5d33f35651e8b46ba2318dbd934dc3eeb81507b",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/SingleBitOperations.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/SingleBitOperationsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/*\n * Author: lukasb1b (https://github.com/lukasb1b)\n */\n\npublic final class SingleBitOperations {\n    private SingleBitOperations() {\n    }\n    /**\n     * Flip the bit at position 'bit' in 'num'\n     */\n    public static int flipBit(final int num, final int bit) {\n        return num ^ (1 << bit);\n    }\n    /**\n     * Set the bit at position 'bit' to 1 in the 'num' variable\n     */\n    public static int setBit(final int num, final int bit) {\n        return num | (1 << bit);\n    }\n    /**\n     * Clears the bit located at 'bit' from 'num'\n     */\n    public static int clearBit(final int num, final int bit) {\n        return num & ~(1 << bit);\n    }\n    /**\n     * Get the bit located at 'bit' from 'num'\n     */\n    public static int getBit(final int num, final int bit) {\n        return ((num >> bit) & 1);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SingleBitOperationsTest {\n\n    @Test\n    public void flipBitTest() {\n        assertEquals(1, SingleBitOperations.flipBit(3, 1));\n        assertEquals(11, SingleBitOperations.flipBit(3, 3));\n    }\n\n    @Test\n    public void setBitTest() {\n        assertEquals(5, SingleBitOperations.setBit(4, 0));\n        assertEquals(4, SingleBitOperations.setBit(4, 2));\n    }\n\n    @Test\n    public void clearBitTest() {\n        assertEquals(5, SingleBitOperations.clearBit(7, 1));\n        assertEquals(5, SingleBitOperations.clearBit(5, 1));\n    }\n\n    @Test\n    public void getBitTest() {\n        assertEquals(0, SingleBitOperations.getBit(6, 0));\n        assertEquals(1, SingleBitOperations.getBit(7, 1));\n    }\n}"
    },
    {
        "product_commit": "566c27a996f48a94916170c159ae735546b39c42",
        "test_commit": "566c27a996f48a94916170c159ae735546b39c42",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/WildcardMatching.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/WildcardMatchingTest.java",
        "product_old_content": null,
        "product_new_content": "/**\n *\n * Author: Janmesh Singh\n * Github: https://github.com/janmeshjs\n\n * Problem Statement: To determine if the pattern matches the text.\n * The pattern can include two special wildcard characters:\n *       ' ? ': Matches any single character.\n *       ' * ': Matches zero or more of any character sequence.\n *\n * Use DP to return True if the pattern matches the entire text and False otherwise\n *\n */\n\npackage com.thealgorithms.dynamicprogramming;\n\npublic class WildcardMatching {\n\n    public static boolean isMatch(String text, String pattern) {\n        int m = text.length();\n        int n = pattern.length();\n\n        // Create a DP table to store intermediate results\n        boolean[][] dp = new boolean[m + 1][n + 1];\n\n        // Base case: an empty pattern matches an empty text\n        dp[0][0] = true;\n\n        // Handle patterns starting with '*'\n        for (int j = 1; j <= n; j++) {\n            if (pattern.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n\n        // Fill the DP table\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                char textChar = text.charAt(i - 1);\n                char patternChar = pattern.charAt(j - 1);\n\n                if (patternChar == textChar || patternChar == '?') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (patternChar == '*') {\n                    // '*' can match zero or more characters\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n        // The result is in the bottom-right cell of the DP table\n        return dp[m][n];\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class WildcardMatchingTest {\n\n    @Test\n    public void testMatchingPattern() {\n        assertTrue(WildcardMatching.isMatch(\"aa\", \"a*\"));\n        assertTrue(WildcardMatching.isMatch(\"adceb\", \"*a*b\"));\n    }\n\n    @Test\n    public void testNonMatchingPattern() {\n        assertFalse(WildcardMatching.isMatch(\"cb\", \"?a\"));\n        assertFalse(WildcardMatching.isMatch(\"acdcb\", \"a*c?b\"));\n        assertFalse(WildcardMatching.isMatch(\"mississippi\", \"m*issi*iss?*i\"));\n    }\n\n    @Test\n    public void testEmptyPattern() {\n        assertTrue(WildcardMatching.isMatch(\"\", \"\"));\n        assertFalse(WildcardMatching.isMatch(\"abc\", \"\"));\n    }\n}"
    },
    {
        "product_commit": "9d8a0f36cfa45e96589532b5487b654d4cbb278d",
        "test_commit": "9d8a0f36cfa45e96589532b5487b654d4cbb278d",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/MinimumPathSum.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/MinimumPathSumTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/*\nGiven the following grid with length m and width n:\n\\---\\---\\---\\ (n)\n\\ 1 \\ 3 \\ 1 \\\n\\---\\---\\---\\\n\\ 1 \\ 5 \\ 1 \\\n\\---\\---\\---\\\n\\ 4 \\ 2 \\ 1 \\\n\\---\\---\\---\\\n(m)\nFind the path where its sum is the smallest.\n\nAll numbers given are positive.\nThe Time Complexity of your algorithm should be smaller than or equal to O(mn).\nThe Space Complexity of your algorithm should be smaller than or equal to O(mn).\nYou can only move from the top left corner to the down right corner.\nYou can only move one step down or right.\n\nEXAMPLE:\nINPUT: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOUTPUT: 7\nEXPLANATIONS: 1 + 3 + 1 + 1 + 1 = 7\n\nFor more information see https://www.geeksforgeeks.org/maximum-path-sum-matrix/\n */\npublic class MinimumPathSum {\n\n    public void testRegular() {\n        int[][] grid = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\n        System.out.println(minimumPathSum(grid));\n    }\n\n    public void testLessColumns() {\n        int[][] grid = {{1, 2}, {5, 6}, {1, 1}};\n        System.out.println(minimumPathSum(grid));\n    }\n\n    public void testLessRows() {\n        int[][] grid = {{2, 3, 3}, {7, 2, 1}};\n        System.out.println(minimumPathSum(grid));\n    }\n\n    public void testOneRowOneColumn() {\n        int[][] grid = {{2}};\n        System.out.println(minimumPathSum(grid));\n    }\n\n    public static int minimumPathSum(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        if (n == 0) {\n            return 0;\n        }\n        int[][] dp = new int[m][n];\n        dp[0][0] = grid[0][0];\n        for (int i = 0; i < n - 1; i++) {\n            dp[0][i + 1] = dp[0][i] + grid[0][i + 1];\n        }\n        for (int i = 0; i < m - 1; i++) {\n            dp[i + 1][0] = dp[i][0] + grid[i + 1][0];\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/*\nGiven the following grid with length m and width n:\n\\---\\---\\---\\ (n)\n\\ 1 \\ 3 \\ 1 \\\n\\---\\---\\---\\\n\\ 1 \\ 5 \\ 1 \\\n\\---\\---\\---\\\n\\ 4 \\ 2 \\ 1 \\\n\\---\\---\\---\\\n(m)\nFind the path where its sum is the smallest.\n\nThe Time Complexity of your algorithm should be smaller than or equal to O(mn).\nThe Space Complexity of your algorithm should be smaller than or equal to O(n).\nYou can only move from the top left corner to the down right corner.\nYou can only move one step down or right.\n\nEXAMPLE:\nINPUT: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOUTPUT: 7\nEXPLANATIONS: 1 + 3 + 1 + 1 + 1 = 7\n\nFor more information see https://www.geeksforgeeks.org/maximum-path-sum-matrix/\n */\npublic final class MinimumPathSum {\n\n    private MinimumPathSum() {\n    }\n\n    public static int minimumPathSum(final int[][] grid) {\n        int numRows = grid.length;\n        int numCols = grid[0].length;\n\n        if (numCols == 0) {\n            return 0;\n        }\n\n        int[] dp = new int[numCols];\n\n        // Initialize the first element of the dp array\n        dp[0] = grid[0][0];\n\n        // Calculate the minimum path sums for the first row\n        for (int col = 1; col < numCols; col++) {\n            dp[col] = dp[col - 1] + grid[0][col];\n        }\n\n        // Calculate the minimum path sums for the remaining rows\n        for (int row = 1; row < numRows; row++) {\n            // Update the minimum path sum for the first column\n            dp[0] += grid[row][0];\n\n            for (int col = 1; col < numCols; col++) {\n                // Choose the minimum path sum from the left or above\n                dp[col] = Math.min(dp[col - 1], dp[col]) + grid[row][col];\n            }\n        }\n\n        // Return the minimum path sum for the last cell in the grid\n        return dp[numCols - 1];\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MinimumPathSumTest {\n\n    @Test\n    public void testMinimumPathSumWithRegularGrid() {\n        int[][] grid = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\n        assertEquals(7, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithOneRowOneColumnGrid() {\n        int[][] grid = {{2}};\n        assertEquals(2, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithEmptyGrid() {\n        int[][] grid = {{}};\n        assertEquals(0, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithOneColumnGrid() {\n        int[][] grid = {{1}, {2}, {3}};\n        assertEquals(6, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumGridOneRowGrid() {\n        int[][] grid = {{1, 2, 3}};\n        assertEquals(6, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithDiffRowAndColumnGrid() {\n        int[][] grid = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        assertEquals(30, MinimumPathSum.minimumPathSum(grid));\n    }\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MinimumPathSumTest {\n\n    @Test\n    public void testMinimumPathSumWithRegularGrid() {\n        int[][] grid = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};\n        assertEquals(7, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithOneRowOneColumnGrid() {\n        int[][] grid = {{2}};\n        assertEquals(2, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithEmptyGrid() {\n        int[][] grid = {{}};\n        assertEquals(0, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithOneColumnGrid() {\n        int[][] grid = {{1}, {2}, {3}};\n        assertEquals(6, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumGridOneRowGrid() {\n        int[][] grid = {{1, 2, 3}};\n        assertEquals(6, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithDiffRowAndColumnGrid() {\n        int[][] grid = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        assertEquals(30, MinimumPathSum.minimumPathSum(grid));\n    }\n\n    @Test\n    public void testMinimumPathSumWithNegativeNumberGrid() {\n        int[][] grid = {{1, 3, 1}, {3, 4, 1}, {4, -3, 1}};\n        assertEquals(6, MinimumPathSum.minimumPathSum(grid));\n    }\n}"
    },
    {
        "product_commit": "d3a32135dc9230125599c38d56849228f99a3b11",
        "test_commit": "d3a32135dc9230125599c38d56849228f99a3b11",
        "product_file_path": "src/main/java/com/thealgorithms/misc/MedianOfRunningArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/MedianOfRunningArrayTest.java",
        "product_old_content": "package com.thealgorithms.misc;\n\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/**\n * @author shrutisheoran\n */\npublic class MedianOfRunningArray {\n\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n\n    // Constructor\n    public MedianOfRunningArray() {\n        this.maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\n        this.minHeap = new PriorityQueue<>(); // Min Heap\n    }\n\n    /*\n      Inserting lower half of array to max Heap\n      and upper half to min heap\n     */\n    public void insert(Integer e) {\n        if (!minHeap.isEmpty() && e < minHeap.peek()) {\n            maxHeap.offer(e);\n            if (maxHeap.size() > minHeap.size() + 1) {\n                minHeap.offer(maxHeap.poll());\n            }\n        } else {\n            minHeap.offer(e);\n            if (minHeap.size() > maxHeap.size() + 1) {\n                maxHeap.offer(minHeap.poll());\n            }\n        }\n    }\n\n    /*\n      Returns median at any given point\n     */\n    public double median() {\n        if (maxHeap.isEmpty() && minHeap.isEmpty()) {\n            throw new IllegalArgumentException(\"Enter at least 1 element, Median of empty list is not defined!\");\n        }\n\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() * 1.0 : minHeap.peek() * 1.0;\n    }\n}",
        "product_new_content": "package com.thealgorithms.misc;\n\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/**\n * @author shrutisheoran\n */\npublic abstract class MedianOfRunningArray<T extends Number & Comparable<T>> {\n\n    private PriorityQueue<T> maxHeap;\n    private PriorityQueue<T> minHeap;\n\n    // Constructor\n    public MedianOfRunningArray() {\n        this.maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\n        this.minHeap = new PriorityQueue<>(); // Min Heap\n    }\n\n    /*\n      Inserting lower half of array to max Heap\n      and upper half to min heap\n     */\n    public void insert(final T e) {\n        if (!minHeap.isEmpty() && e.compareTo(minHeap.peek()) < 0) {\n            maxHeap.offer(e);\n            if (maxHeap.size() > minHeap.size() + 1) {\n                minHeap.offer(maxHeap.poll());\n            }\n        } else {\n            minHeap.offer(e);\n            if (minHeap.size() > maxHeap.size() + 1) {\n                maxHeap.offer(minHeap.poll());\n            }\n        }\n    }\n\n    /*\n      Returns median at any given point\n     */\n    public T median() {\n        if (maxHeap.isEmpty() && minHeap.isEmpty()) {\n            throw new IllegalArgumentException(\"Enter at least 1 element, Median of empty list is not defined!\");\n        } else if (maxHeap.size() == minHeap.size()) {\n            T maxHeapTop = maxHeap.peek();\n            T minHeapTop = minHeap.peek();\n            return calculateAverage(maxHeapTop, minHeapTop);\n        }\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek();\n    }\n\n    public abstract T calculateAverage(T a, T b);\n}",
        "test_old_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Two sum Problem.\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class MedianOfRunningArrayTest {\n    private static final String EXCEPTION_MESSAGE = \"Enter at least 1 element, Median of empty list is not defined!\";\n\n    @Test\n    public void testWhenInvalidInoutProvidedShouldThrowException() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> stream.median());\n        assertEquals(exception.getMessage(), EXCEPTION_MESSAGE);\n    }\n\n    @Test\n    public void testWithNegativeValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-2);\n        assertEquals(-1.5, stream.median());\n        stream.insert(-3);\n        assertEquals(-2, stream.median());\n    }\n\n    @Test\n    public void testWithSingleValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithRandomValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        assertEquals(10.0, stream.median());\n\n        stream.insert(5);\n        assertEquals(7.5, stream.median());\n\n        stream.insert(20);\n        assertEquals(10.0, stream.median());\n\n        stream.insert(15);\n        assertEquals(12.5, stream.median());\n\n        stream.insert(25);\n        assertEquals(15.0, stream.median());\n\n        stream.insert(30);\n        assertEquals(17.5, stream.median());\n\n        stream.insert(35);\n        assertEquals(20.0, stream.median());\n\n        stream.insert(1);\n        assertEquals(17.5, stream.median());\n    }\n\n    @Test\n    public void testWithNegativeAndPositiveValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(2);\n        assertEquals(0.5, stream.median());\n        stream.insert(-3);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValuesB() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(0);\n        stream.insert(50);\n        assertEquals(10, stream.median());\n    }\n\n    @Test\n    public void testWithLargeValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(1000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(12000);\n        assertEquals(506000, stream.median());\n        stream.insert(15000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(2300000);\n        assertEquals(1650000.00, stream.median());\n    }\n\n    @Test\n    public void testWithLargeCountOfValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        for (int i = 1; i <= 1000; i++) stream.insert(i);\n        assertEquals(500.5, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInDescendingOrder() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(30);\n        stream.insert(20);\n        stream.insert(10);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInOrder() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(30);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderA() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(30);\n        stream.insert(10);\n        stream.insert(20);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderB() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(30);\n        assertEquals(20.0, stream.median());\n    }\n}",
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Median Of Running Array Problem.\n * @author Ansh Shah (https://github.com/govardhanshah456)\n */\n\npublic class MedianOfRunningArrayTest {\n    private static final String EXCEPTION_MESSAGE = \"Enter at least 1 element, Median of empty list is not defined!\";\n\n    @Test\n    public void testWhenInvalidInoutProvidedShouldThrowException() {\n        var stream = new MedianOfRunningArrayInteger();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> stream.median());\n        assertEquals(exception.getMessage(), EXCEPTION_MESSAGE);\n    }\n\n    @Test\n    public void testWithNegativeValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-2);\n        assertEquals(-1, stream.median());\n        stream.insert(-3);\n        assertEquals(-2, stream.median());\n    }\n\n    @Test\n    public void testWithSingleValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithRandomValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(10);\n        assertEquals(10, stream.median());\n\n        stream.insert(5);\n        assertEquals(7, stream.median());\n\n        stream.insert(20);\n        assertEquals(10, stream.median());\n\n        stream.insert(15);\n        assertEquals(12, stream.median());\n\n        stream.insert(25);\n        assertEquals(15, stream.median());\n\n        stream.insert(30);\n        assertEquals(17, stream.median());\n\n        stream.insert(35);\n        assertEquals(20, stream.median());\n\n        stream.insert(1);\n        assertEquals(17, stream.median());\n    }\n\n    @Test\n    public void testWithNegativeAndPositiveValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(2);\n        assertEquals(0, stream.median());\n        stream.insert(-3);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValuesB() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(0);\n        stream.insert(50);\n        assertEquals(10, stream.median());\n    }\n\n    @Test\n    public void testWithLargeValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(1000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(12000);\n        assertEquals(506000, stream.median());\n        stream.insert(15000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(2300000);\n        assertEquals(1650000, stream.median());\n    }\n\n    @Test\n    public void testWithLargeCountOfValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        for (int i = 1; i <= 1000; i++) stream.insert(i);\n        assertEquals(500, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInDescendingOrder() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(30);\n        stream.insert(20);\n        stream.insert(10);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInOrder() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(30);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderA() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(30);\n        stream.insert(10);\n        stream.insert(20);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderB() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(30);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithFloatValues() {\n        var stream = new MedianOfRunningArrayFloat();\n        stream.insert(20.0f);\n        assertEquals(20.0f, stream.median());\n        stream.insert(10.5f);\n        assertEquals(15.25f, stream.median());\n        stream.insert(30.0f);\n        assertEquals(20.0f, stream.median());\n    }\n\n    @Test\n    public void testWithByteValues() {\n        var stream = new MedianOfRunningArrayByte();\n        stream.insert((byte) 120);\n        assertEquals((byte) 120, stream.median());\n        stream.insert((byte) -120);\n        assertEquals((byte) 0, stream.median());\n        stream.insert((byte) 127);\n        assertEquals((byte) 120, stream.median());\n    }\n\n    @Test\n    public void testWithLongValues() {\n        var stream = new MedianOfRunningArrayLong();\n        stream.insert(120000000L);\n        assertEquals(120000000L, stream.median());\n        stream.insert(92233720368547757L);\n        assertEquals(46116860244273878L, stream.median());\n    }\n\n    @Test\n    public void testWithDoubleValues() {\n        var stream = new MedianOfRunningArrayDouble();\n        stream.insert(12345.67891);\n        assertEquals(12345.67891, stream.median());\n        stream.insert(23456789.98);\n        assertEquals(Double.valueOf(11734567.83), stream.median(), .01);\n    }\n}"
    },
    {
        "product_commit": "8803b1ead59716617b221a8ef92a90cc0ec067c2",
        "test_commit": "8803b1ead59716617b221a8ef92a90cc0ec067c2",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/MinimumSumPartition.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/MinimumSumPartitionTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n// Partition a set into two subsets such that the difference of subset sums is minimum\n\n/*\nInput:  arr[] = {1, 6, 11, 5}\nOutput: 1\nExplanation:\nSubset1 = {1, 5, 6}, sum of Subset1 = 12\nSubset2 = {11}, sum of Subset2 = 11\n\nInput:  arr[] = {36, 7, 46, 40}\nOutput: 23\nExplanation:\nSubset1 = {7, 46} ;  sum of Subset1 = 53\nSubset2 = {36, 40} ; sum of Subset2  = 76\n */\npublic class MinimumSumPartition {\n\n    public static int subSet(int[] arr) {\n        int n = arr.length;\n        int sum = getSum(arr);\n        boolean[][] dp = new boolean[n + 1][sum + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = true;\n        }\n        for (int j = 0; j <= sum; j++) {\n            dp[0][j] = false;\n        }\n\n        // fill dp array\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                if (arr[i - 1] < j) {\n                    dp[i][j] = dp[i - 1][j - arr[i - 1]] || dp[i - 1][j];\n                } else if (arr[i - 1] == j) {\n                    dp[i][j] = true;\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        // fill the index array\n        int[] index = new int[sum];\n        int p = 0;\n        for (int i = 0; i <= sum / 2; i++) {\n            if (dp[n][i]) {\n                index[p++] = i;\n            }\n        }\n\n        return getMin(index, sum);\n    }\n\n    /**\n     * Calculate sum of array elements\n     *\n     * @param arr the array\n     * @return sum of given array\n     */\n    public static int getSum(int[] arr) {\n        int sum = 0;\n        for (int temp : arr) {\n            sum += temp;\n        }\n        return sum;\n    }\n\n    public static int getMin(int[] arr, int sum) {\n        if (arr.length == 0) {\n            return 0;\n        }\n        int min = Integer.MAX_VALUE;\n        for (int temp : arr) {\n            min = Math.min(min, sum - 2 * temp);\n        }\n        return min;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        assert subSet(new int[] {1, 6, 11, 5}) == 1;\n        assert subSet(new int[] {36, 7, 46, 40}) == 23;\n        assert subSet(new int[] {1, 2, 3, 9}) == 3;\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport java.util.Arrays;\n\n/*\nGiven an array of non-negative integers , partition the array in two subset that\ndifference in sum of elements for both subset minimum.\nReturn the minimum difference in sum of these subsets you can achieve.\n\nInput:  array[] = {1, 6, 11, 4}\nOutput: 0\nExplanation:\nSubset1 = {1, 4, 6}, sum of Subset1 = 11\nSubset2 = {11}, sum of Subset2 = 11\n\nInput:  array[] = {36, 7, 46, 40}\nOutput: 23\nExplanation:\nSubset1 = {7, 46} ;  sum of Subset1 = 53\nSubset2 = {36, 40} ; sum of Subset2  = 76\n */\npublic final class MinimumSumPartition {\n    private MinimumSumPartition() {\n    }\n\n    private static void throwIfInvalidInput(final int[] array) {\n        if (Arrays.stream(array).anyMatch(a -> a < 0)) {\n            throw new IllegalArgumentException(\"Input array should not contain negative number(s).\");\n        }\n    }\n\n    public static int minimumSumPartition(final int[] array) {\n        throwIfInvalidInput(array);\n        int sum = Arrays.stream(array).sum();\n        boolean[] dp = new boolean[sum / 2 + 1];\n        dp[0] = true; // Base case , don't select any element from array\n\n        // Find the closest sum of subset array that we can achieve which is closest to half of sum of full array\n        int closestPartitionSum = 0;\n\n        for (int i = 0; i < array.length; i++) {\n            for (int j = sum / 2; j > 0; j--) {\n                if (array[i] <= j) {\n                    dp[j] = dp[j] || dp[j - array[i]];\n                }\n                if (dp[j]) {\n                    closestPartitionSum = Math.max(closestPartitionSum, j);\n                }\n            }\n        }\n        /*\n        Difference in sum = Big partition sum  - Small partition sum\n                          = ( Total sum - Small partition sum) - Small partition sum\n         */\n        return sum - (2 * closestPartitionSum);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass MinimumSumPartitionTest {\n    @Test\n    public void testMinimumSumPartitionWithEvenSum() {\n        int[] array = {1, 6, 11, 4};\n        assertEquals(0, MinimumSumPartition.minimumSumPartition(array));\n    }\n\n    @Test\n    public void testMinimumSumPartitionWithOddSum() {\n        int[] array = {36, 7, 46, 40};\n        assertEquals(23, MinimumSumPartition.minimumSumPartition(array));\n    }\n\n    @Test\n    public void testMinimumSumPartitionWithSingleElement() {\n        int[] array = {7};\n        assertEquals(7, MinimumSumPartition.minimumSumPartition(array));\n    }\n\n    @Test\n    public void testMinimumSumPartitionWithLargeNumbers() {\n        int[] array = {100, 200, 300, 400, 500};\n        assertEquals(100, MinimumSumPartition.minimumSumPartition(array));\n    }\n\n    @Test\n    public void testMinimumSumPartitionWithEmptyArray() {\n        int[] array = {};\n        assertEquals(0, MinimumSumPartition.minimumSumPartition(array));\n    }\n\n    @Test\n    public void testMinimumSumPartitionThrowsForNegativeArray() {\n        int[] array = {4, 1, -6, 7};\n        assertThrows(IllegalArgumentException.class, () -> { MinimumSumPartition.minimumSumPartition(array); });\n    }\n}"
    },
    {
        "product_commit": "fbe348b105a06258a81538023698117e2bb116cb",
        "test_commit": "fbe348b105a06258a81538023698117e2bb116cb",
        "product_file_path": "src/main/java/com/thealgorithms/misc/MedianOfRunningArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/MedianOfRunningArrayTest.java",
        "product_old_content": "package com.thealgorithms.misc;\n\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/**\n * @author shrutisheoran\n */\npublic class MedianOfRunningArray {\n\n    private PriorityQueue<Integer> p1;\n    private PriorityQueue<Integer> p2;\n\n    // Constructor\n    public MedianOfRunningArray() {\n        this.p1 = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\n        this.p2 = new PriorityQueue<>(); // Min Heap\n    }\n\n    /*\n      Inserting lower half of array to max Heap\n      and upper half to min heap\n     */\n    public void insert(Integer e) {\n        p2.add(e);\n        if (p2.size() - p1.size() > 1) {\n            p1.add(p2.remove());\n        }\n    }\n\n    /*\n      Returns median at any given point\n     */\n    public Integer median() {\n        if (p1.size() == p2.size()) {\n            return (p1.peek() + p2.peek()) / 2;\n        }\n        return p1.size() > p2.size() ? p1.peek() : p2.peek();\n    }\n\n    public static void main(String[] args) {\n        /*\n        Testing the median function\n         */\n\n        MedianOfRunningArray p = new MedianOfRunningArray();\n        int[] arr = {10, 7, 4, 9, 2, 3, 11, 17, 14};\n        for (int i = 0; i < 9; i++) {\n            p.insert(arr[i]);\n            System.out.print(p.median() + \" \");\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.misc;\n\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/**\n * @author shrutisheoran\n */\npublic class MedianOfRunningArray {\n\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n\n    // Constructor\n    public MedianOfRunningArray() {\n        this.maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\n        this.minHeap = new PriorityQueue<>(); // Min Heap\n    }\n\n    /*\n      Inserting lower half of array to max Heap\n      and upper half to min heap\n     */\n    public void insert(Integer e) {\n        if (!minHeap.isEmpty() && e < minHeap.peek()) {\n            maxHeap.offer(e);\n            if (maxHeap.size() > minHeap.size() + 1) {\n                minHeap.offer(maxHeap.poll());\n            }\n        } else {\n            minHeap.offer(e);\n            if (minHeap.size() > maxHeap.size() + 1) {\n                maxHeap.offer(minHeap.poll());\n            }\n        }\n    }\n\n    /*\n      Returns median at any given point\n     */\n    public double median() {\n        if (maxHeap.isEmpty() && minHeap.isEmpty()) {\n            throw new IllegalArgumentException(\"Enter at least 1 element, Median of empty list is not defined!\");\n        }\n\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() * 1.0 : minHeap.peek() * 1.0;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Two sum Problem.\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class MedianOfRunningArrayTest {\n    private static final String EXCEPTION_MESSAGE = \"Enter at least 1 element, Median of empty list is not defined!\";\n\n    @Test\n    public void testWhenInvalidInoutProvidedShouldThrowException() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> stream.median());\n        assertEquals(exception.getMessage(), EXCEPTION_MESSAGE);\n    }\n\n    @Test\n    public void testWithNegativeValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-2);\n        assertEquals(-1.5, stream.median());\n        stream.insert(-3);\n        assertEquals(-2, stream.median());\n    }\n\n    @Test\n    public void testWithSingleValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithRandomValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        assertEquals(10.0, stream.median());\n\n        stream.insert(5);\n        assertEquals(7.5, stream.median());\n\n        stream.insert(20);\n        assertEquals(10.0, stream.median());\n\n        stream.insert(15);\n        assertEquals(12.5, stream.median());\n\n        stream.insert(25);\n        assertEquals(15.0, stream.median());\n\n        stream.insert(30);\n        assertEquals(17.5, stream.median());\n\n        stream.insert(35);\n        assertEquals(20.0, stream.median());\n\n        stream.insert(1);\n        assertEquals(17.5, stream.median());\n    }\n\n    @Test\n    public void testWithNegativeAndPositiveValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(2);\n        assertEquals(0.5, stream.median());\n        stream.insert(-3);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValuesB() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(0);\n        stream.insert(50);\n        assertEquals(10, stream.median());\n    }\n\n    @Test\n    public void testWithLargeValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(1000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(12000);\n        assertEquals(506000, stream.median());\n        stream.insert(15000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(2300000);\n        assertEquals(1650000.00, stream.median());\n    }\n\n    @Test\n    public void testWithLargeCountOfValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        for (int i = 1; i <= 1000; i++) stream.insert(i);\n        assertEquals(500.5, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInDescendingOrder() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(30);\n        stream.insert(20);\n        stream.insert(10);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInOrder() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(30);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderA() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(30);\n        stream.insert(10);\n        stream.insert(20);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderB() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(30);\n        assertEquals(20.0, stream.median());\n    }\n}"
    },
    {
        "product_commit": "12b6c292438cac17a19154335bb6066676876b20",
        "test_commit": "12b6c292438cac17a19154335bb6066676876b20",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/Knapsack.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/KnapsackTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * A DynamicProgramming based solution for 0-1 Knapsack problem\n */\npublic class Knapsack {\n\n    private static int knapSack(int W, int[] wt, int[] val, int n) throws IllegalArgumentException {\n        if (wt == null || val == null) {\n            throw new IllegalArgumentException();\n        }\n        int i, w;\n        int[][] rv = new int[n + 1][W + 1]; // rv means return value\n\n        // Build table rv[][] in bottom up manner\n        for (i = 0; i <= n; i++) {\n            for (w = 0; w <= W; w++) {\n                if (i == 0 || w == 0) {\n                    rv[i][w] = 0;\n                } else if (wt[i - 1] <= w) {\n                    rv[i][w] = Math.max(val[i - 1] + rv[i - 1][w - wt[i - 1]], rv[i - 1][w]);\n                } else {\n                    rv[i][w] = rv[i - 1][w];\n                }\n            }\n        }\n\n        return rv[n][W];\n    }\n\n    // Driver program to test above function\n    public static void main(String[] args) {\n        int[] val = new int[] {50, 100, 130};\n        int[] wt = new int[] {10, 20, 40};\n        int W = 50;\n        System.out.println(knapSack(W, wt, val, val.length));\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport java.util.Arrays;\n\n/**\n * A Dynamic Programming based solution for the 0-1 Knapsack problem.\n * This class provides a method, `knapSack`, that calculates the maximum value that can be\n * obtained from a given set of items with weights and values, while not exceeding a\n * given weight capacity.\n *\n * @see <a href=\"https://en.wikipedia.org/?title=0-1_Knapsack_problem\">0-1 Knapsack Problem </a>\n */\npublic final class Knapsack {\n\n    private Knapsack() {\n    }\n\n    private static void throwIfInvalidInput(final int weightCapacity, final int[] weights, final int[] values) {\n        if (weightCapacity < 0) {\n            throw new IllegalArgumentException(\"Weight capacity should not be negative.\");\n        }\n        if (weights == null || values == null || weights.length != values.length) {\n            throw new IllegalArgumentException(\"Input arrays must not be null and must have the same length.\");\n        }\n        if (Arrays.stream(weights).anyMatch(w -> w <= 0)) {\n            throw new IllegalArgumentException(\"Input array should not contain non-positive weight(s).\");\n        }\n    }\n\n    /**\n     * Solves the 0-1 Knapsack problem using Dynamic Programming.\n     *\n     * @param weightCapacity The maximum weight capacity of the knapsack.\n     * @param weights        An array of item weights.\n     * @param values         An array of item values.\n     * @return The maximum value that can be obtained without exceeding the weight capacity.\n     * @throws IllegalArgumentException If the input arrays are null or have different lengths.\n     */\n    public static int knapSack(final int weightCapacity, final int[] weights, final int[] values) throws IllegalArgumentException {\n        throwIfInvalidInput(weightCapacity, weights, values);\n\n        // DP table to store the state of the maximum possible return for a given weight capacity.\n        int[] dp = new int[weightCapacity + 1];\n\n        for (int i = 0; i < values.length; i++) {\n            for (int w = weightCapacity; w > 0; w--) {\n                if (weights[i] <= w) {\n                    dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n                }\n            }\n        }\n\n        return dp[weightCapacity];\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KnapsackTest {\n    @Test\n    public void testKnapSackBasic() {\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3, 4, 5, 6};\n        int weightCapacity = 5;\n        int expected = 7; // Maximum value should be 7 (items 1 and 4).\n        int result = Knapsack.knapSack(weightCapacity, weights, values);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testKnapSackEmpty() {\n        int[] weights = {};\n        int[] values = {};\n        int weightCapacity = 10;\n        int expected = 0; // With no items, the result should be 0.\n        int result = Knapsack.knapSack(weightCapacity, weights, values);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testKnapSackNoCapacity() {\n        int[] weights = {2, 3, 4};\n        int[] values = {3, 4, 5};\n        int weightCapacity = 0;\n        int expected = 0; // With no capacity, the result should be 0.\n        int result = Knapsack.knapSack(weightCapacity, weights, values);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testKnapSackMaxCapacity() {\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3, 4, 5, 6};\n        int weightCapacity = 10;\n        int expected = 13; // Maximum value should be 13 (items 1, 3, and 4).\n        int result = Knapsack.knapSack(weightCapacity, weights, values);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testKnapSackThrowsForInputsOfDifferentLength() {\n        int[] weights = {2, 3, 4};\n        int[] values = {3, 4, 5, 6}; // Different length values array.\n        int weightCapacity = 5;\n        assertThrows(IllegalArgumentException.class, () -> { Knapsack.knapSack(weightCapacity, weights, values); });\n    }\n\n    @Test\n    public void testKnapSackThrowsForNullInputs() {\n        int[] weights = {2, 3, 4};\n        int[] values = {3, 4, 6};\n        int weightCapacity = 5;\n        assertThrows(IllegalArgumentException.class, () -> { Knapsack.knapSack(weightCapacity, null, values); });\n        assertThrows(IllegalArgumentException.class, () -> { Knapsack.knapSack(weightCapacity, weights, null); });\n    }\n\n    @Test\n    public void testKnapSackThrowsForNegativeCapacity() {\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3, 4, 5, 6};\n        int weightCapacity = -5;\n        assertThrows(IllegalArgumentException.class, () -> { Knapsack.knapSack(weightCapacity, weights, values); });\n    }\n\n    @Test\n    public void testKnapSackThrowsForNegativeWeight() {\n        int[] weights = {2, 0, 4};\n        int[] values = {3, 4, 6};\n        int weightCapacity = 5;\n        assertThrows(IllegalArgumentException.class, () -> { Knapsack.knapSack(weightCapacity, weights, values); });\n    }\n}"
    },
    {
        "product_commit": "26c2465328f81379047237b4bf54f134a73a7fd1",
        "test_commit": "26c2465328f81379047237b4bf54f134a73a7fd1",
        "product_file_path": "src/main/java/com/thealgorithms/others/StackPostfixNotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/StackPostfixNotationTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.function.BiFunction;\n\n/**\n * @brief Utility class evaluating postix expressions, cf. https://en.wikipedia.org/wiki/Reverse_Polish_notation\n * @details The computation is done using Integers.\n */\npublic final class StackPostfixNotation {\n    private StackPostfixNotation() {\n    }\n\n    private static BiFunction<Integer, Integer, Integer> getOperator(final String operationSymbol) {\n        // note the order of operands\n        switch (operationSymbol) {\n        case \"+\":\n            return (a, b) -> b + a;\n        case \"-\":\n            return (a, b) -> b - a;\n        case \"*\":\n            return (a, b) -> b * a;\n        case \"/\":\n            return (a, b) -> b / a;\n        default:\n            throw new IllegalArgumentException(\"exp contains an unknown operation.\");\n        }\n    }\n\n    private static void performOperation(Stack<Integer> s, final String operationSymbol) {\n        if (s.size() < 2) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression (too few arguments).\");\n        }\n        s.push(getOperator(operationSymbol).apply(s.pop(), s.pop()));\n    }\n\n    private static void consumeExpression(Stack<Integer> s, final String exp) {\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt());\n            } else {\n                performOperation(s, tokens.next());\n            }\n        }\n        tokens.close();\n    }\n\n    /**\n     * @brief Evaluates the given postfix expression.\n     * @param exp the expression to evaluate.\n     * @return the value of the given expression.\n     * @exception IllegalArgumentException exp is not a valid postix expression.\n     */\n    public static int postfixEvaluate(final String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        consumeExpression(s, exp);\n        if (s.size() != 1) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression.\");\n        }\n        return s.pop();\n    }\n}",
        "product_new_content": null,
        "test_old_content": "package com.thealgorithms.others;\n\nimport static java.util.Map.entry;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class StackPostfixNotationTest {\n    @Test\n    public void testEvaluate() {\n        final Map<String, Integer> testCases = Map.ofEntries(entry(\"1 1 +\", 2), entry(\"2 3 *\", 6), entry(\"6 2 /\", 3), entry(\"-5 -2 -\", -3), entry(\"5 2 + 3 *\", 21), entry(\"-5\", -5));\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), StackPostfixNotation.postfixEvaluate(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInproperInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 3\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithUnknownOperation() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 !\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithTooFewArgsA() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"+\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithTooFewArgsB() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"2 +\"));\n    }\n}",
        "test_new_content": null
    },
    {
        "product_commit": "26c2465328f81379047237b4bf54f134a73a7fd1",
        "test_commit": "26c2465328f81379047237b4bf54f134a73a7fd1",
        "product_file_path": "src/main/java/com/thealgorithms/stacks/CalculateMaxOfMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/stacks/CalculateMaxOfMinTest.java",
        "product_old_content": null,
        "product_new_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/**\n * Program description - Given an integer array. The task is to find the maximum of the minimum of\n * the array\n */\npackage com.thealgorithms.stacks;\n\nimport java.util.*;\n\npublic class CalculateMaxOfMin {\n\n    public static int calculateMaxOfMin(int[] a) {\n        int n = a.length;\n        int[] ans = new int[n];\n        int[] arr2 = Arrays.copyOf(a, n);\n        Arrays.sort(arr2);\n        int maxNum = arr2[arr2.length - 1];\n        ans[0] = maxNum;\n        int index = 1;\n        while (index != ans.length) {\n            int[] minimums = new int[n - index];\n            for (int i = 0; i < n - index; i++) {\n                int[] windowArray = Arrays.copyOfRange(a, i, i + index + 1);\n                Arrays.sort(windowArray);\n                int minNum = windowArray[0];\n                minimums[i] = minNum;\n            }\n            Arrays.sort(minimums);\n            ans[index] = minimums[minimums.length - 1];\n            index += 1;\n        }\n        return ans[0];\n    }\n}\n/**\n * Given an integer array. The task is to find the maximum of the minimum of the\n * given array\n */",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.stacks;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CalculateMaxOfMinTest {\n\n    @Test\n    void testForOneElement() {\n        int[] a = {10, 20, 30, 50, 10, 70, 30};\n        int k = CalculateMaxOfMin.calculateMaxOfMin(a);\n        assertEquals(70, k);\n    }\n\n    @Test\n    void testForTwoElements() {\n        int[] a = {5, 3, 2, 6, 3, 2, 6};\n        int k = CalculateMaxOfMin.calculateMaxOfMin(a);\n        assertEquals(6, k);\n    }\n\n    @Test\n    void testForThreeElements() {\n        int[] a = {10, 10, 10, 10, 10, 10, 10};\n        int k = CalculateMaxOfMin.calculateMaxOfMin(a);\n        assertEquals(10, k);\n    }\n\n    @Test\n    void testForFourElements() {\n        int[] a = {70, 60, 50, 40, 30, 20};\n        int k = CalculateMaxOfMin.calculateMaxOfMin(a);\n        assertEquals(70, k);\n    }\n\n    @Test\n    void testForFiveElements() {\n        int[] a = {50};\n        int k = CalculateMaxOfMin.calculateMaxOfMin(a);\n        assertEquals(50, k);\n    }\n\n    @Test\n    void testForSixElements() {\n        int[] a = {1, 4, 7, 9, 2, 4, 6};\n        int k = CalculateMaxOfMin.calculateMaxOfMin(a);\n        assertEquals(9, k);\n    }\n\n    @Test\n    void testForSevenElements() {\n        int[] a = {-1, -5, -7, -9, -12, -14};\n        int k = CalculateMaxOfMin.calculateMaxOfMin(a);\n        assertEquals(-1, k);\n    }\n}"
    },
    {
        "product_commit": "26c2465328f81379047237b4bf54f134a73a7fd1",
        "test_commit": "26c2465328f81379047237b4bf54f134a73a7fd1",
        "product_file_path": "src/main/java/com/thealgorithms/stacks/StackPostfixNotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/stacks/StackPostfixNotationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.stacks;\n\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.function.BiFunction;\n\n/**\n * @brief Utility class evaluating postix expressions, cf. https://en.wikipedia.org/wiki/Reverse_Polish_notation\n * @details The computation is done using Integers.\n */\npublic final class StackPostfixNotation {\n    private StackPostfixNotation() {\n    }\n\n    private static BiFunction<Integer, Integer, Integer> getOperator(final String operationSymbol) {\n        // note the order of operands\n        switch (operationSymbol) {\n        case \"+\":\n            return (a, b) -> b + a;\n        case \"-\":\n            return (a, b) -> b - a;\n        case \"*\":\n            return (a, b) -> b * a;\n        case \"/\":\n            return (a, b) -> b / a;\n        default:\n            throw new IllegalArgumentException(\"exp contains an unknown operation.\");\n        }\n    }\n\n    private static void performOperation(Stack<Integer> s, final String operationSymbol) {\n        if (s.size() < 2) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression (too few arguments).\");\n        }\n        s.push(getOperator(operationSymbol).apply(s.pop(), s.pop()));\n    }\n\n    private static void consumeExpression(Stack<Integer> s, final String exp) {\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt());\n            } else {\n                performOperation(s, tokens.next());\n            }\n        }\n        tokens.close();\n    }\n\n    /**\n     * @brief Evaluates the given postfix expression.\n     * @param exp the expression to evaluate.\n     * @return the value of the given expression.\n     * @exception IllegalArgumentException exp is not a valid postix expression.\n     */\n    public static int postfixEvaluate(final String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        consumeExpression(s, exp);\n        if (s.size() != 1) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression.\");\n        }\n        return s.pop();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.stacks;\n\nimport static java.util.Map.entry;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class StackPostfixNotationTest {\n    @Test\n    public void testEvaluate() {\n        final Map<String, Integer> testCases = Map.ofEntries(entry(\"1 1 +\", 2), entry(\"2 3 *\", 6), entry(\"6 2 /\", 3), entry(\"-5 -2 -\", -3), entry(\"5 2 + 3 *\", 21), entry(\"-5\", -5));\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), StackPostfixNotation.postfixEvaluate(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInproperInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 3\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithUnknownOperation() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 !\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithTooFewArgsA() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"+\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithTooFewArgsB() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"2 +\"));\n    }\n}"
    },
    {
        "product_commit": "58c21c57561a577c9e398aafcc104d1bf495e7bf",
        "test_commit": "58c21c57561a577c9e398aafcc104d1bf495e7bf",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ParseInteger.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ParseIntegerTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class ParseInteger {\n    /**\n     * Parse a string to integer\n     *\n     * @param s the string\n     * @return the integer value represented by the argument in decimal.\n     * @throws NumberFormatException if the {@code string} does not contain a\n     *                               parsable integer.\n     */\n    public static int parseInt(String s) {\n        if (s == null || s.length() == 0) {\n            throw new NumberFormatException(\"Input parameter must not be null!\");\n        }\n        boolean isNegative = s.charAt(0) == '-';\n        boolean isPositive = s.charAt(0) == '+';\n        int number = 0;\n        for (int i = isNegative ? 1 : isPositive ? 1 : 0, length = s.length(); i < length; ++i) {\n            if (!Character.isDigit(s.charAt(i))) {\n                throw new NumberFormatException(\"Input parameter of incorrect format: \" + s);\n            }\n            number = number * 10 + s.charAt(i) - '0';\n        }\n        return isNegative ? -number : number;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class ParseInteger {\n    private ParseInteger() {\n    }\n\n    private static void checkInput(final String s) {\n        if (s == null) {\n            throw new NumberFormatException(\"Input parameter must not be null!\");\n        }\n        if (s.isEmpty()) {\n            throw new NumberFormatException(\"Input parameter must not be empty!\");\n        }\n    }\n\n    private static void checkDigitAt(final String s, final int pos) {\n        if (!Character.isDigit(s.charAt(pos))) {\n            throw new NumberFormatException(\"Input parameter of incorrect format: \" + s);\n        }\n    }\n\n    private static int digitToInt(final char digit) {\n        return digit - '0';\n    }\n\n    /**\n     * Parse a string to integer\n     *\n     * @param s the string\n     * @return the integer value represented by the argument in decimal.\n     * @throws NumberFormatException if the {@code string} does not contain a\n     *                               parsable integer.\n     */\n    public static int parseInt(final String s) {\n        checkInput(s);\n\n        final boolean isNegative = s.charAt(0) == '-';\n        final boolean isPositive = s.charAt(0) == '+';\n        int number = 0;\n        for (int i = isNegative || isPositive ? 1 : 0, length = s.length(); i < length; ++i) {\n            checkDigitAt(s, i);\n            number = number * 10 + digitToInt(s.charAt(i));\n        }\n        return isNegative ? -number : number;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 01/07/2023\n */\npublic class ParseIntegerTest {\n    private static final String NULL_PARAMETER_MESSAGE = \"Input parameter must not be null!\";\n    private static final String INCORRECT_FORMAT_MESSAGE = \"Input parameter of incorrect format\";\n\n    @Test\n    public void testNullInput() {\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> ParseInteger.parseInt(null));\n        Assertions.assertEquals(exception.getMessage(), NULL_PARAMETER_MESSAGE);\n    }\n\n    @Test\n    public void testInputOfIncorrectFormat() {\n        IllegalArgumentException exception = Assertions.assertThrows(NumberFormatException.class, () -> ParseInteger.parseInt(\"+0a123\"));\n        Assertions.assertTrue(exception.getMessage().contains(INCORRECT_FORMAT_MESSAGE));\n\n        exception = Assertions.assertThrows(NumberFormatException.class, () -> ParseInteger.parseInt(\"b\"));\n        Assertions.assertTrue(exception.getMessage().contains(INCORRECT_FORMAT_MESSAGE));\n    }\n\n    @Test\n    public void testPositiveValueIsSuccessfullyConverted() {\n        Assertions.assertEquals(ParseInteger.parseInt(\"0\"), Integer.parseInt(\"0\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"123\"), Integer.parseInt(\"123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"0123\"), Integer.parseInt(\"0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"+0123\"), Integer.parseInt(\"+0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"+123\"), Integer.parseInt(\"+123\"));\n    }\n\n    @Test\n    public void testNegativeValueIsSuccessfullyConverted() {\n        Assertions.assertEquals(ParseInteger.parseInt(\"-1\"), Integer.parseInt(\"-1\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-123\"), Integer.parseInt(\"-123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-0123\"), Integer.parseInt(\"-0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-00123\"), Integer.parseInt(\"-00123\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 01/07/2023\n */\npublic class ParseIntegerTest {\n    private static final String NULL_PARAMETER_MESSAGE = \"Input parameter must not be null!\";\n    private static final String EMPTY_PARAMETER_MESSAGE = \"Input parameter must not be empty!\";\n    private static final String INCORRECT_FORMAT_MESSAGE = \"Input parameter of incorrect format\";\n\n    @Test\n    public void testNullInput() {\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> ParseInteger.parseInt(null));\n        Assertions.assertEquals(exception.getMessage(), NULL_PARAMETER_MESSAGE);\n    }\n\n    @Test\n    public void testEmptyInput() {\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> ParseInteger.parseInt(\"\"));\n        Assertions.assertEquals(exception.getMessage(), EMPTY_PARAMETER_MESSAGE);\n    }\n\n    @Test\n    public void testInputOfIncorrectFormat() {\n        IllegalArgumentException exception = Assertions.assertThrows(NumberFormatException.class, () -> ParseInteger.parseInt(\"+0a123\"));\n        Assertions.assertTrue(exception.getMessage().contains(INCORRECT_FORMAT_MESSAGE));\n\n        exception = Assertions.assertThrows(NumberFormatException.class, () -> ParseInteger.parseInt(\"b\"));\n        Assertions.assertTrue(exception.getMessage().contains(INCORRECT_FORMAT_MESSAGE));\n    }\n\n    @Test\n    public void testPositiveValueIsSuccessfullyConverted() {\n        Assertions.assertEquals(ParseInteger.parseInt(\"0\"), Integer.parseInt(\"0\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"123\"), Integer.parseInt(\"123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"0123\"), Integer.parseInt(\"0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"+0123\"), Integer.parseInt(\"+0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"+123\"), Integer.parseInt(\"+123\"));\n    }\n\n    @Test\n    public void testNegativeValueIsSuccessfullyConverted() {\n        Assertions.assertEquals(ParseInteger.parseInt(\"-1\"), Integer.parseInt(\"-1\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-123\"), Integer.parseInt(\"-123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-0123\"), Integer.parseInt(\"-0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-00123\"), Integer.parseInt(\"-00123\"));\n    }\n}"
    },
    {
        "product_commit": "5bb54977fe63107c22116215023cb18fc5500113",
        "test_commit": "5bb54977fe63107c22116215023cb18fc5500113",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/UniquePaths.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/UniquePathsTests.java",
        "product_old_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/**\n * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n * The robot can only move either down or right at any point in time.\n * The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram\n * below). How many possible unique paths are there?\n */\n\n/** Program description - To find the number of unique paths possible */\n\npackage com.thealgorithms.dynamicprogramming;\n\nimport java.util.*;\n\npublic class UniquePaths {\n\n    public static boolean uniquePaths(int m, int n, int ans) {\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] += dp[j - 1];\n            }\n        }\n        return dp[n - 1] == ans;\n        // return true if predicted answer matches with expected answer\n    }\n\n    // The above method runs in O(n) time\n    public static boolean uniquePaths2(int m, int n, int ans) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j < n; j++) {\n            dp[0][j] = 1;\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1] == ans;\n        // return true if predicted answer matches with expected answer\n    }\n    // The above mthod takes O(m*n) time\n}\n/**\n * OUTPUT :\n * Input - m = 3, n = 7\n * Output: it returns either true if expected answer matches with the predicted answer else it\n * returns false 1st approach Time Complexity : O(n) Auxiliary Space Complexity : O(n) Input - m =\n * 3, n = 7 Output: it returns either true if expected answer matches with the predicted answer else\n * it returns false 2nd approach Time Complexity : O(m*n) Auxiliary Space Complexity : O(m*n)\n */",
        "product_new_content": "/**\n * Author: Siddhant Swarup Mallick\n * Github: https://github.com/siddhant2002\n * <p>\n * Problem Description:\n * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n * The robot can only move either down or right at any point in time.\n * The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n * How many possible unique paths are there?\n * <p>\n * Program Description:\n * This program calculates the number of unique paths possible for a robot to reach the bottom-right corner\n * of an m x n grid using dynamic programming.\n */\n\npackage com.thealgorithms.dynamicprogramming;\n\nimport java.util.Arrays;\n\npublic final class UniquePaths {\n\n    private UniquePaths(){};\n\n    /**\n     * Calculates the number of unique paths using a 1D dynamic programming array.\n     * Time complexity O(n*m)\n     * Space complexity O(min(n,m))\n     *\n     * @param m The number of rows in the grid.\n     * @param n The number of columns in the grid.\n     * @return The number of unique paths.\n     */\n    public static int uniquePaths(final int m, final int n) {\n        if (m > n) {\n            return uniquePaths(n, m); // Recursive call to handle n > m cases\n        }\n        int[] dp = new int[n]; // Create a 1D array to store unique paths for each column\n        Arrays.fill(dp, 1); // Initialize all values to 1 (one way to reach each cell)\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] = Math.addExact(dp[j], dp[j - 1]); // Update the number of unique paths for each cell\n            }\n        }\n        return dp[n - 1]; // The result is stored in the last column of the array\n    }\n\n    /**\n     * Calculates the number of unique paths using a 2D dynamic programming array.\n     * Time complexity O(n*m)\n     * Space complexity O(n*m)\n     *\n     * @param m The number of rows in the grid.\n     * @param n The number of columns in the grid.\n     * @return The number of unique paths.\n     */\n    public static int uniquePaths2(final int m, final int n) {\n        int[][] dp = new int[m][n]; // Create a 2D array to store unique paths for each cell\n        for (int i = 0; i < m; i++) {\n            dp[i][0] = 1; // Initialize the first column to 1 (one way to reach each cell)\n        }\n        for (int j = 0; j < n; j++) {\n            dp[0][j] = 1; // Initialize the first row to 1 (one way to reach each cell)\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = Math.addExact(dp[i - 1][j], dp[i][j - 1]); // Update the number of unique paths for each cell\n            }\n        }\n        return dp[m - 1][n - 1]; // The result is stored in the bottom-right cell of the array\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class UniquePathsTests {\n\n    @Test\n    public void testUniquePaths_3x3() {\n        assertEquals(6, UniquePaths.uniquePaths(3, 3));\n    }\n\n    @Test\n    public void testUniquePaths_1x1() {\n        assertEquals(1, UniquePaths.uniquePaths(1, 1));\n    }\n\n    @Test\n    public void testUniquePaths_3x7() {\n        assertEquals(28, UniquePaths.uniquePaths(3, 7));\n    }\n\n    @Test\n    public void testUniquePaths_7x3() {\n        assertEquals(28, UniquePaths.uniquePaths(7, 3));\n    }\n\n    @Test\n    public void testUniquePaths_100x100() {\n        assertThrows(ArithmeticException.class, () -> UniquePaths.uniquePaths(100, 100));\n    }\n\n    @Test\n    public void testUniquePaths2_3x3() {\n        assertEquals(6, UniquePaths.uniquePaths2(3, 3));\n    }\n\n    @Test\n    public void testUniquePaths2_1x1() {\n        assertEquals(1, UniquePaths.uniquePaths2(1, 1));\n    }\n\n    @Test\n    public void testUniquePaths2_3x7() {\n        assertEquals(28, UniquePaths.uniquePaths2(3, 7));\n    }\n\n    @Test\n    public void testUniquePaths2_7x3() {\n        assertEquals(28, UniquePaths.uniquePaths2(7, 3));\n    }\n\n    @Test\n    public void testUniquePaths2_100x100() {\n        assertThrows(ArithmeticException.class, () -> UniquePaths.uniquePaths2(100, 100));\n    }\n}"
    },
    {
        "product_commit": "34cf6dab28ee2271fbf228d345bcf14db85c211c",
        "test_commit": "34cf6dab28ee2271fbf228d345bcf14db85c211c",
        "product_file_path": "src/main/java/com/thealgorithms/misc/TwoSumProblem.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/TwoSumProblemTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.misc;\n\nimport java.util.HashMap;\nimport java.util.Optional;\nimport org.apache.commons.lang3.tuple.Pair;\n\npublic final class TwoSumProblem {\n    private TwoSumProblem() {\n    }\n\n    /**\n     * The function \"twoSum\" takes an array of integers and a target integer as input, and returns an\n     * array of two indices where the corresponding elements in the input array add up to the target.\n     * @param values An array of integers.\n     * @param target The target is the sum that we are trying to find using two numbers from the given array.\n     * @return A pair or indexes such that sum of values at these indexes equals to the target\n     * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n     */\n\n    public static Optional<Pair<Integer, Integer>> twoSum(final int[] values, final int target) {\n        HashMap<Integer, Integer> valueToIndex = new HashMap<>();\n        for (int i = 0; i < values.length; i++) {\n            final var rem = target - values[i];\n            if (valueToIndex.containsKey(rem)) {\n                return Optional.of(Pair.of(valueToIndex.get(rem), i));\n            }\n            if (!valueToIndex.containsKey(values[i])) {\n                valueToIndex.put(values[i], i);\n            }\n        }\n        return Optional.empty();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Two sum Problem.\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class TwoSumProblemTest {\n\n    @Test\n    void testTwoSumExists() {\n        final int[] values = new int[] {2, 7, 11, 15};\n        final int target = 9;\n        final var expected = Pair.of(0, 1); // values[0] + values[1] = 2 + 7 = 9\n        assertEquals(expected, TwoSumProblem.twoSum(values, target).get());\n    }\n\n    @Test\n    void testTwoSumNoSolution() {\n        final int[] values = new int[] {2, 7, 11, 15};\n        final int target = 3;\n        assertFalse(TwoSumProblem.twoSum(values, target).isPresent());\n    }\n\n    @Test\n    void testTwoSumMultipleSolutions() {\n        final int[] values = {3, 3};\n        final int target = 6;\n        final var expected = Pair.of(0, 1); // values[0] + values[1] = 3 + 3 = 6\n        assertEquals(expected, TwoSumProblem.twoSum(values, target).get());\n    }\n\n    @Test\n    void testTwoSumMultipleSolution() {\n        final int[] values = {3, 4, 3, 3};\n        final int target = 6;\n        final var expected = Pair.of(0, 2); // values[0] + values[2] = 3 + 3 = 6\n        assertEquals(expected, TwoSumProblem.twoSum(values, target).get());\n    }\n\n    @Test\n    void testTwoSumNegativeNumbers() {\n        final int[] values = {-1, -2, -3, -4, -5};\n        final int target = -8;\n        final var expected = Pair.of(2, 4); // values[2] + values[4] = -3 + (-5) = -8\n        assertEquals(expected, TwoSumProblem.twoSum(values, target).get());\n    }\n\n    @Test\n    void testTwoSumNoSolutionDuplicatedInputs() {\n        final int[] values = {0, 0, 0};\n        final int target = 100;\n        assertFalse(TwoSumProblem.twoSum(values, target).isPresent());\n    }\n}"
    },
    {
        "product_commit": "94621fb63eafcf18666dfad176fffc28f82b439a",
        "test_commit": "94621fb63eafcf18666dfad176fffc28f82b439a",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/disjointsetunion/DisjointSetUnion.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/disjointsetunion/DisjointSetUnionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.disjointsetunion;\n\n/**\n * Disjoint Set Union or DSU is useful for solving problems related to connected components,\n * cycle detection in graphs, and maintaining relationships in disjoint sets of data.\n * It is commonly employed in graph algorithms and problems.\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\">Disjoint Set Union</a>\n */\npublic class DisjointSetUnion<T> {\n\n    /**\n     * Creates a new node of DSU with parent initialised as same node\n     */\n    public Node<T> makeSet(final T x) {\n        return new Node<T>(x);\n    }\n\n    /**\n     * Finds and returns the representative (root) element of the set to which a given element belongs.\n     * This operation uses path compression to optimize future findSet operations.\n     */\n    public Node<T> findSet(Node<T> node) {\n        while (node != node.parent) {\n            node = node.parent;\n        }\n        return node;\n    }\n\n    /**\n     * Unions two sets by merging their representative elements. The merge is performed based on the rank of each set\n     * to ensure efficient merging and path compression to optimize future findSet operations.\n     */\n    public void unionSets(final Node<T> x, final Node<T> y) {\n        Node<T> nx = findSet(x);\n        Node<T> ny = findSet(y);\n\n        if (nx == ny) {\n            return; // Both elements already belong to the same set.\n        }\n        // Merging happens based on rank of node, this is done to avoid long chaining of nodes and reduce time\n        // to find root of the component. Idea is to attach small components in big, instead of other way around.\n        if (nx.rank > ny.rank) {\n            ny.parent = nx;\n        } else if (ny.rank > nx.rank) {\n            nx.parent = ny;\n        } else {\n            // Both sets have the same rank; choose one as the parent and increment the rank.\n            ny.parent = nx;\n            nx.rank++;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.disjointsetunion;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DisjointSetUnionTest {\n\n    @Test\n    public void testMakeSet() {\n        DisjointSetUnion<Integer> dsu = new DisjointSetUnion<>();\n        Node<Integer> node = dsu.makeSet(1);\n        assertNotNull(node);\n        Assertions.assertEquals(node, node.parent);\n    }\n\n    @Test\n    public void testUnionFindSet() {\n        DisjointSetUnion<Integer> dsu = new DisjointSetUnion<>();\n        Node<Integer> node1 = dsu.makeSet(1);\n        Node<Integer> node2 = dsu.makeSet(2);\n        Node<Integer> node3 = dsu.makeSet(3);\n        Node<Integer> node4 = dsu.makeSet(4);\n\n        dsu.unionSets(node1, node2);\n        dsu.unionSets(node3, node2);\n        dsu.unionSets(node3, node4);\n        dsu.unionSets(node1, node3);\n\n        Node<Integer> root1 = dsu.findSet(node1);\n        Node<Integer> root2 = dsu.findSet(node2);\n        Node<Integer> root3 = dsu.findSet(node3);\n        Node<Integer> root4 = dsu.findSet(node4);\n\n        Assertions.assertEquals(node1, node1.parent);\n        Assertions.assertEquals(node1, node2.parent);\n        Assertions.assertEquals(node1, node3.parent);\n        Assertions.assertEquals(node1, node4.parent);\n\n        Assertions.assertEquals(node1, root1);\n        Assertions.assertEquals(node1, root2);\n        Assertions.assertEquals(node1, root3);\n        Assertions.assertEquals(node1, root4);\n\n        Assertions.assertEquals(1, node1.rank);\n        Assertions.assertEquals(0, node2.rank);\n        Assertions.assertEquals(0, node3.rank);\n        Assertions.assertEquals(0, node4.rank);\n    }\n}"
    },
    {
        "product_commit": "c54b8cddf38dec124a4b23b4512ea363286d8570",
        "test_commit": "a88abb7ac238b111446b9998c8abf6775d54e24d",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/FloodFill.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/FloodFillTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (<a href=\"https://github.com/itsAkshayDubey\">Git-Akshay Dubey</a>)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */\n    public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {\n        if (newColor == oldColor) return;\n        if (x < 0 || x >= image.length) return;\n        if (y < 0 || y >= image[x].length) return;\n        if (getPixel(image, x, y) != oldColor) return;\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (<a href=\"https://github.com/itsAkshayDubey\">Git-Akshay Dubey</a>)\n */\npublic final class FloodFill {\n    private FloodFill() {\n    }\n\n    /**\n     * Get the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(final int[][] image, final int x, final int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(final int[][] image, final int x, final int y, final int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */\n    public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n        if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n            return;\n        }\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage() {\n        int[][] image = {};\n        int[][] expected = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSingleElementImage() {\n        int[][] image = {{1}};\n        int[][] expected = {{3}};\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageOne() {\n        int[][] image = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageTwo() {\n        int[][] image = {\n            {0, 0, 1, 1, 0, 0, 0},\n            {1, 1, 3, 3, 3, 0, 0},\n            {1, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 1, 3, 1, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 2, 2, 0, 0, 0},\n            {2, 2, 3, 3, 3, 0, 0},\n            {2, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 2, 3, 2, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageThree() {\n        int[][] image = {\n            {1, 1, 2, 3, 1, 1, 1},\n            {1, 0, 0, 1, 0, 0, 1},\n            {1, 1, 1, 0, 3, 1, 2},\n        };\n\n        int[][] expected = {\n            {4, 4, 2, 3, 4, 4, 4},\n            {4, 0, 0, 4, 0, 0, 4},\n            {4, 4, 4, 0, 3, 4, 2},\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage() {\n        int[][] image = {};\n        int[][] expected = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSingleElementImage() {\n        int[][] image = {{1}};\n        int[][] expected = {{3}};\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageOne() {\n        int[][] image = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageTwo() {\n        int[][] image = {\n            {0, 0, 1, 1, 0, 0, 0},\n            {1, 1, 3, 3, 3, 0, 0},\n            {1, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 1, 3, 1, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 2, 2, 0, 0, 0},\n            {2, 2, 3, 3, 3, 0, 0},\n            {2, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 2, 3, 2, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageThree() {\n        int[][] image = {\n            {1, 1, 2, 3, 1, 1, 1},\n            {1, 0, 0, 1, 0, 0, 1},\n            {1, 1, 1, 0, 3, 1, 2},\n        };\n\n        int[][] expected = {\n            {4, 4, 2, 3, 4, 4, 4},\n            {4, 0, 0, 4, 0, 0, 4},\n            {4, 4, 4, 0, 3, 4, 2},\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSameNewAndOldColor() {\n        int[][] image = {{1, 1, 2}, {1, 0, 0}, {1, 1, 1}};\n\n        int[][] expected = {{1, 1, 2}, {1, 0, 0}, {1, 1, 1}};\n\n        FloodFill.floodFill(image, 0, 1, 1, 1);\n        assertArrayEquals(expected, image);\n    }\n}"
    },
    {
        "product_commit": "a88abb7ac238b111446b9998c8abf6775d54e24d",
        "test_commit": "a88abb7ac238b111446b9998c8abf6775d54e24d",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/FloodFill.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/FloodFillTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (<a href=\"https://github.com/itsAkshayDubey\">Git-Akshay Dubey</a>)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */\n    public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {\n        if (x < 0 || x >= image.length) return;\n        if (y < 0 || y >= image[x].length) return;\n        if (getPixel(image, x, y) != oldColor) return;\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (<a href=\"https://github.com/itsAkshayDubey\">Git-Akshay Dubey</a>)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */\n    public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {\n        if (newColor == oldColor) return;\n        if (x < 0 || x >= image.length) return;\n        if (y < 0 || y >= image[x].length) return;\n        if (getPixel(image, x, y) != oldColor) return;\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage() {\n        int[][] image = {};\n        int[][] expected = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSingleElementImage() {\n        int[][] image = {{1}};\n        int[][] expected = {{3}};\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageOne() {\n        int[][] image = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageTwo() {\n        int[][] image = {\n            {0, 0, 1, 1, 0, 0, 0},\n            {1, 1, 3, 3, 3, 0, 0},\n            {1, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 1, 3, 1, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 2, 2, 0, 0, 0},\n            {2, 2, 3, 3, 3, 0, 0},\n            {2, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 2, 3, 2, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageThree() {\n        int[][] image = {\n            {1, 1, 2, 3, 1, 1, 1},\n            {1, 0, 0, 1, 0, 0, 1},\n            {1, 1, 1, 0, 3, 1, 2},\n        };\n\n        int[][] expected = {\n            {4, 4, 2, 3, 4, 4, 4},\n            {4, 0, 0, 4, 0, 0, 4},\n            {4, 4, 4, 0, 3, 4, 2},\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage() {\n        int[][] image = {};\n        int[][] expected = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSingleElementImage() {\n        int[][] image = {{1}};\n        int[][] expected = {{3}};\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageOne() {\n        int[][] image = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageTwo() {\n        int[][] image = {\n            {0, 0, 1, 1, 0, 0, 0},\n            {1, 1, 3, 3, 3, 0, 0},\n            {1, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 1, 3, 1, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 2, 2, 0, 0, 0},\n            {2, 2, 3, 3, 3, 0, 0},\n            {2, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 2, 3, 2, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageThree() {\n        int[][] image = {\n            {1, 1, 2, 3, 1, 1, 1},\n            {1, 0, 0, 1, 0, 0, 1},\n            {1, 1, 1, 0, 3, 1, 2},\n        };\n\n        int[][] expected = {\n            {4, 4, 2, 3, 4, 4, 4},\n            {4, 0, 0, 4, 0, 0, 4},\n            {4, 4, 4, 0, 3, 4, 2},\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSameNewAndOldColor() {\n        int[][] image = {{1, 1, 2}, {1, 0, 0}, {1, 1, 1}};\n\n        int[][] expected = {{1, 1, 2}, {1, 0, 0}, {1, 1, 1}};\n\n        FloodFill.floodFill(image, 0, 1, 1, 1);\n        assertArrayEquals(expected, image);\n    }\n}"
    },
    {
        "product_commit": "fbef4023d5f53b61e77df441a552e67968133730",
        "test_commit": "fbef4023d5f53b61e77df441a552e67968133730",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/ClearBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/ClearBitTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n/**\n * Clears the bit located at clear from num\n */\n\npublic class ClearBit {\n    public static int clearBit(int num, int clear) {\n        int mask = ~(1 << clear);\n        return num & mask;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ClearBitTest {\n    @Test\n    public void clearBitTest() {\n        assertEquals(5, ClearBit.clearBit(7, 1));\n        assertEquals(5, ClearBit.clearBit(5, 1));\n    }\n}"
    },
    {
        "product_commit": "29a864b5b345c163f7aef20d1fa24a9cbde18593",
        "test_commit": "29a864b5b345c163f7aef20d1fa24a9cbde18593",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/SetBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/SetBit.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n/**\n * Sets a specific bit to 1\n */\n\npublic class SetBit {\n    public static int setBit(int num, int bit) {\n        return num | (1 << bit);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SetBitTest {\n    @Test\n    void testSetBit() {\n        assertEquals(5, SetBit.setBit(4, 0));\n        assertEquals(3, SetBit.setBit(3, 1));\n    }\n}"
    },
    {
        "product_commit": "fc693e8b514f83c043c9b7cb9456f9f6f9bd2f6b",
        "test_commit": "fc693e8b514f83c043c9b7cb9456f9f6f9bd2f6b",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/HighestSetBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/HighestSetBitTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\nimport java.util.Optional;\n\n/**\n * Find Highest Set Bit\n * This class provides a function calculating the position (or index)\n * of the most significant bit being set to 1 in a given integer.\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic final class HighestSetBit {\n    private HighestSetBit() {\n    }\n\n    public final static Optional<Integer> findHighestSetBit(int num) {\n        if (num < 0) {\n            throw new IllegalArgumentException(\"Input cannot be negative\");\n        }\n\n        if (num == 0) {\n            return Optional.empty();\n        }\n\n        int position = 0;\n        while (num > 0) {\n            num >>= 1;\n            position++;\n        }\n\n        return Optional.of(position - 1);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Highest Set Bit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass HighestSetBitTest {\n\n    @Test\n    void testHighestSetBit() {\n        assertFalse(HighestSetBit.findHighestSetBit(0).isPresent());\n        assertEquals(0, HighestSetBit.findHighestSetBit(1).get());\n        assertEquals(1, HighestSetBit.findHighestSetBit(2).get());\n        assertEquals(1, HighestSetBit.findHighestSetBit(3).get());\n        assertEquals(2, HighestSetBit.findHighestSetBit(4).get());\n        assertEquals(2, HighestSetBit.findHighestSetBit(5).get());\n        assertEquals(2, HighestSetBit.findHighestSetBit(7).get());\n        assertEquals(3, HighestSetBit.findHighestSetBit(8).get());\n        assertEquals(3, HighestSetBit.findHighestSetBit(9).get());\n        assertEquals(3, HighestSetBit.findHighestSetBit(15).get());\n        assertEquals(4, HighestSetBit.findHighestSetBit(16).get());\n        assertEquals(4, HighestSetBit.findHighestSetBit(17).get());\n        assertEquals(4, HighestSetBit.findHighestSetBit(31).get());\n        assertEquals(5, HighestSetBit.findHighestSetBit(32).get());\n        assertEquals(5, HighestSetBit.findHighestSetBit(33).get());\n        assertEquals(7, HighestSetBit.findHighestSetBit(255).get());\n        assertEquals(8, HighestSetBit.findHighestSetBit(256).get());\n        assertEquals(8, HighestSetBit.findHighestSetBit(511).get());\n        assertEquals(9, HighestSetBit.findHighestSetBit(512).get());\n        assertThrows(IllegalArgumentException.class, () -> HighestSetBit.findHighestSetBit(-37));\n    }\n}"
    },
    {
        "product_commit": "09950d6097ea7b2590fb80336d144ee402e61226",
        "test_commit": "09950d6097ea7b2590fb80336d144ee402e61226",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/RotateSinglyLinkedLists.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/RotateSinglyLinkedListsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\n/**\n * Rotate a list\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class RotateSinglyLinkedLists {\n    public Node rotateRight(Node head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        Node curr = head;\n        int len = 1;\n        while (curr.next != null) {\n            curr = curr.next;\n            len++;\n        }\n\n        curr.next = head;\n        k = k % len;\n        k = len - k;\n        while (k > 0) {\n            curr = curr.next;\n            k--;\n        }\n\n        head = curr.next;\n        curr.next = null;\n        return head;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\n/**\n * Test cases for RotateSinglyLinkedLists\n * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RotateSinglyLinkedListsTest {\n\n    @Test\n    public void testRotateRightEmptyList() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate an empty list\n        assertNull(rotator.rotateRight(null, 2));\n    }\n\n    @Test\n    public void testRotateRightSingleNodeList() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate a list with one element\n        Node singleNode = new Node(5);\n        Node rotatedSingleNode = rotator.rotateRight(singleNode, 3);\n        assertEquals(5, rotatedSingleNode.value);\n        assertNull(rotatedSingleNode.next);\n    }\n\n    @Test\n    public void testRotateRightMultipleElementsList() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate a list with multiple elements (Rotate by 2)\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        Node rotated1 = rotator.rotateRight(head, 2);\n        assertEquals(4, rotated1.value);\n        assertEquals(5, rotated1.next.value);\n        assertEquals(1, rotated1.next.next.value);\n        assertEquals(2, rotated1.next.next.next.value);\n        assertEquals(3, rotated1.next.next.next.next.value);\n        assertNull(rotated1.next.next.next.next.next);\n    }\n\n    @Test\n    public void testRotateRightFullRotation() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate a list with multiple elements (Full rotation)\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        Node rotated3 = rotator.rotateRight(head, 7);\n        assertEquals(4, rotated3.value);\n        assertEquals(5, rotated3.next.value);\n        assertEquals(1, rotated3.next.next.value);\n        assertEquals(2, rotated3.next.next.next.value);\n        assertEquals(3, rotated3.next.next.next.next.value);\n        assertNull(rotated3.next.next.next.next.next);\n    }\n}"
    },
    {
        "product_commit": "a96ad84faceb9efb51eccbeb95863b79c2e6de9d",
        "test_commit": "a96ad84faceb9efb51eccbeb95863b79c2e6de9d",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Means.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MeansTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.StreamSupport;\nimport org.apache.commons.collections4.IterableUtils;\n\n/**\n * https://en.wikipedia.org/wiki/Mean\n * <p>\n * by: Punit Patel\n */\npublic final class Means {\n\n    private Means() {\n    }\n\n    /**\n     * @brief computes the [Arithmetic Mean](https://en.wikipedia.org/wiki/Arithmetic_mean) of the input\n     * @param numbers the input numbers\n     * @throws IllegalArgumentException empty input\n     * @return the arithmetic mean of the input numbers\n     */\n    public static Double arithmetic(final Iterable<Double> numbers) {\n        checkIfNotEmpty(numbers);\n        return StreamSupport.stream(numbers.spliterator(), false).reduce((x, y) -> x + y).get() / IterableUtils.size(numbers);\n    }\n\n    /**\n     * @brief computes the [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) of the input\n     * @param numbers the input numbers\n     * @throws IllegalArgumentException empty input\n     * @return the geometric mean of the input numbers\n     */\n    public static Double geometric(final Iterable<Double> numbers) {\n        checkIfNotEmpty(numbers);\n        return Math.pow(StreamSupport.stream(numbers.spliterator(), false).reduce((x, y) -> x * y).get(), 1d / IterableUtils.size(numbers));\n    }\n\n    /**\n     * @brief computes the [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) of the input\n     * @param numbers the input numbers\n     * @throws IllegalArgumentException empty input\n     * @return the harmonic mean of the input numbers\n     */\n    public static Double harmonic(final Iterable<Double> numbers) {\n        checkIfNotEmpty(numbers);\n        return IterableUtils.size(numbers) / StreamSupport.stream(numbers.spliterator(), false).reduce(0d, (x, y) -> x + 1d / y);\n    }\n\n    private static void checkIfNotEmpty(final Iterable<Double> numbers) {\n        if (!numbers.iterator().hasNext()) {\n            throw new IllegalArgumentException(\"Emtpy list given for Mean computation.\");\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Vector;\nimport org.assertj.core.util.Lists;\nimport org.assertj.core.util.Sets;\nimport org.junit.jupiter.api.Test;\n\nclass MeansTest {\n\n    @Test\n    void arithmeticMeanZeroNumbers() throws IllegalArgumentException {\n        List<Double> numbers = new ArrayList<>();\n        assertThrows(IllegalArgumentException.class, () -> Means.arithmetic(numbers));\n    }\n\n    @Test\n    void geometricMeanZeroNumbers() throws IllegalArgumentException {\n        List<Double> numbers = new ArrayList<>();\n        assertThrows(IllegalArgumentException.class, () -> Means.geometric(numbers));\n    }\n\n    @Test\n    void harmonicMeanZeroNumbers() throws IllegalArgumentException {\n        List<Double> numbers = new ArrayList<>();\n        assertThrows(IllegalArgumentException.class, () -> Means.harmonic(numbers));\n    }\n\n    @Test\n    void arithmeticMeanSingleNumber() {\n        List<Double> numbers = Lists.newArrayList(2.5);\n        assertEquals(2.5, Means.arithmetic(numbers));\n    }\n\n    @Test\n    void geometricMeanSingleNumber() {\n        Set<Double> numbers = Sets.newHashSet(Lists.newArrayList(2.5));\n        assertEquals(2.5, Means.geometric(numbers));\n    }\n\n    @Test\n    void harmonicMeanSingleNumber() {\n        LinkedHashSet<Double> numbers = Sets.newLinkedHashSet(2.5);\n        assertEquals(2.5, Means.harmonic(numbers));\n    }\n\n    @Test\n    void arithmeticMeanMultipleNumbers() {\n        Set<Double> numbers = Sets.newTreeSet(1d, 2.5, 83.3, 25.9999, 46.0001, 74.7, 74.5);\n        assertEquals(44, Means.arithmetic(numbers));\n    }\n\n    @Test\n    void geometricMeanMultipleNumbers() {\n        LinkedList<Double> numbers = new LinkedList<>() {};\n        numbers.addAll(Lists.newArrayList(1d, 2d, 3d, 4d, 5d, 6d, 1.25));\n        assertEquals(2.6426195539300585, Means.geometric(numbers));\n    }\n\n    @Test\n    void harmonicMeanMultipleNumbers() {\n        Vector<Double> numbers = new Vector<>(Lists.newArrayList(1d, 2.5, 83.3, 25.9999, 46.0001, 74.7, 74.5));\n        assertEquals(4.6697322801074135, Means.harmonic(numbers));\n    }\n}"
    },
    {
        "product_commit": "cfdbc413f12dd20dbc37d5ba04c781ce59db6868",
        "test_commit": "cfdbc413f12dd20dbc37d5ba04c781ce59db6868",
        "product_file_path": "src/main/java/com/thealgorithms/misc/PalindromeSinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/PalindromeSinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.misc;\n\nimport com.thealgorithms.datastructures.lists.SinglyLinkedList;\nimport java.util.Stack;\n\n/**\n * A simple way of knowing if a singly linked list is palindrome is to push all\n * the values into a Stack and then compare the list to popped vales from the\n * Stack.\n *\n * See more:\n * https://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/\n */\npublic class PalindromeSinglyLinkedList {\n\n    public static void main(String[] args) {\n        SinglyLinkedList linkedList = new SinglyLinkedList();\n\n        linkedList.insertHead(3);\n        linkedList.insertNth(2, 1);\n        linkedList.insertNth(1, 2);\n        linkedList.insertNth(2, 3);\n        linkedList.insertNth(3, 4);\n\n        if (isPalindrome(linkedList)) {\n            System.out.println(\"It's a palindrome list\");\n        } else {\n            System.out.println(\"It's NOT a palindrome list\");\n        }\n    }\n\n    public static boolean isPalindrome(SinglyLinkedList linkedList) {\n        boolean ret = true;\n        Stack<Integer> linkedListValues = new Stack<>();\n\n        for (int i = 0; i < linkedList.size(); i++) {\n            linkedListValues.push(linkedList.getNth(i));\n        }\n\n        for (int i = 0; i < linkedList.size(); i++) {\n            if (linkedList.getNth(i) != linkedListValues.pop()) {\n                ret = false;\n                break;\n            }\n        }\n\n        return ret;\n    }\n}",
        "product_new_content": "package com.thealgorithms.misc;\n\nimport com.thealgorithms.datastructures.lists.SinglyLinkedList;\nimport java.util.Stack;\n\n/**\n * A simple way of knowing if a singly linked list is palindrome is to push all\n * the values into a Stack and then compare the list to popped vales from the\n * Stack.\n *\n * See more:\n * https://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/\n */\npublic final class PalindromeSinglyLinkedList {\n    private PalindromeSinglyLinkedList() {\n    }\n\n    public static boolean isPalindrome(final SinglyLinkedList linkedList) {\n        Stack<Integer> linkedListValues = new Stack<>();\n\n        for (final var x : linkedList) {\n            linkedListValues.push(x);\n        }\n\n        for (final var x : linkedList) {\n            if (x != linkedListValues.pop()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport com.thealgorithms.datastructures.lists.SinglyLinkedList;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeSinglyLinkedListTest {\n    @Test\n    public void testWithEmptyList() {\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(new SinglyLinkedList()));\n    }\n\n    @Test\n    public void testWithSingleElement() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(100);\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithOddLengthPositive() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(1);\n        exampleList.insert(2);\n        exampleList.insert(1);\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithEvenLengthPositive() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(10);\n        exampleList.insert(20);\n        exampleList.insert(20);\n        exampleList.insert(10);\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithOddLengthNegative() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(1);\n        exampleList.insert(2);\n        exampleList.insert(2);\n        assertFalse(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithEvenLengthNegative() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(10);\n        exampleList.insert(20);\n        exampleList.insert(20);\n        exampleList.insert(20);\n        assertFalse(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n}",
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport com.thealgorithms.datastructures.lists.SinglyLinkedList;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeSinglyLinkedListTest {\n    @Test\n    public void testWithEmptyList() {\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(new SinglyLinkedList()));\n    }\n\n    @Test\n    public void testWithSingleElement() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(100);\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithOddLengthPositive() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(1);\n        exampleList.insert(2);\n        exampleList.insert(1);\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithOddLengthPositive2() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(3);\n        exampleList.insert(2);\n        exampleList.insert(1);\n        exampleList.insert(2);\n        exampleList.insert(3);\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithEvenLengthPositive() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(10);\n        exampleList.insert(20);\n        exampleList.insert(20);\n        exampleList.insert(10);\n        assertTrue(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithOddLengthNegative() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(1);\n        exampleList.insert(2);\n        exampleList.insert(2);\n        assertFalse(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n\n    @Test\n    public void testWithListWithEvenLengthNegative() {\n        var exampleList = new SinglyLinkedList();\n        exampleList.insert(10);\n        exampleList.insert(20);\n        exampleList.insert(20);\n        exampleList.insert(20);\n        assertFalse(PalindromeSinglyLinkedList.isPalindrome(exampleList));\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/AllPathsFromSourceToTarget.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java",
        "product_old_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private final int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm = new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices) {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList() {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v) {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n    public void storeAllPaths(int s, int d) {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path\n    private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList) {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n\n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int[][] a, int source, int destination) {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for (int[] i : a) {\n            g.addEdge(i[0], i[1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "product_new_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private final int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm = new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices) {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList() {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v) {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n    public void storeAllPaths(int s, int d) {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path\n    private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList) {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n\n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int[][] a, int source, int destination) {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for (int[] i : a) {\n            g.addEdge(i[0], i[1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3), List.of(2, 0, 3), List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}, {1, 4}, {3, 4}, {2, 4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4), List.of(0, 1, 4), List.of(0, 2, 1, 3, 4), List.of(0, 2, 1, 4), List.of(0, 2, 4), List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int[][] a = {{1, 0}, {2, 3}, {0, 4}, {1, 5}, {4, 3}, {0, 2}, {0, 3}, {1, 2}, {0, 5}, {3, 4}, {2, 5}, {2, 4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5), List.of(1, 0, 5), List.of(1, 5), List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int[][] a = {{0, 1}, {0, 2}, {1, 2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2), List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3), List.of(2, 0, 3), List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}, {1, 4}, {3, 4}, {2, 4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4), List.of(0, 1, 4), List.of(0, 2, 1, 3, 4), List.of(0, 2, 1, 4), List.of(0, 2, 4), List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int[][] a = {{1, 0}, {2, 3}, {0, 4}, {1, 5}, {4, 3}, {0, 2}, {0, 3}, {1, 2}, {0, 5}, {3, 4}, {2, 5}, {2, 4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5), List.of(1, 0, 5), List.of(1, 5), List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int[][] a = {{0, 1}, {0, 2}, {1, 2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2), List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBitTest.java",
        "product_old_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find The Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class IndexOfRightMostSetBit {\n    public static int indexOfRightMostSetBit(int n) {\n        if (n == 0) {\n            return -1; // No set bits\n        }\n\n        // Handle negative numbers by finding the two's complement\n        if (n < 0) {\n            n = -n;\n            n = n & (~n + 1); // Get the rightmost set bit in positive form\n        }\n\n        int index = 0;\n        while ((n & 1) == 0) {\n            n = n >> 1;\n            index++;\n        }\n\n        return index;\n    }\n}",
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find The Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class IndexOfRightMostSetBit {\n    public static int indexOfRightMostSetBit(int n) {\n        if (n == 0) {\n            return -1; // No set bits\n        }\n\n        // Handle negative numbers by finding the two's complement\n        if (n < 0) {\n            n = -n;\n            n = n & (~n + 1); // Get the rightmost set bit in positive form\n        }\n\n        int index = 0;\n        while ((n & 1) == 0) {\n            n = n >> 1;\n            index++;\n        }\n\n        return index;\n    }\n}",
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass IndexOfRightMostSetBitTest {\n\n    @Test\n    void testIndexOfRightMostSetBit() {\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));\n        assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));\n    }\n}",
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass IndexOfRightMostSetBitTest {\n\n    @Test\n    void testIndexOfRightMostSetBit() {\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));\n        assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinder.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinderTest.java",
        "product_old_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find Non Repeating Number\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class NonRepeatingNumberFinder {\n\n    public static int findNonRepeatingNumber(int[] arr) {\n        int result = 0;\n        for (int num : arr) {\n            result ^= num;\n        }\n        return result;\n    }\n}",
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find Non Repeating Number\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class NonRepeatingNumberFinder {\n\n    public static int findNonRepeatingNumber(int[] arr) {\n        int result = 0;\n        for (int num : arr) {\n            result ^= num;\n        }\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Non Repeating Number Finder\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass NonRepeatingNumberFinderTest {\n\n    @Test\n    void testNonRepeatingNumberFinder() {\n        int arr[] = {1, 2, 1, 2, 6};\n        assertEquals(6, NonRepeatingNumberFinder.findNonRepeatingNumber(arr));\n        int arr1[] = {1, 2, 1, 2};\n        assertEquals(0, NonRepeatingNumberFinder.findNonRepeatingNumber(arr1));\n        int arr2[] = {12};\n        assertEquals(12, NonRepeatingNumberFinder.findNonRepeatingNumber(arr2));\n    }\n}",
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Non Repeating Number Finder\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass NonRepeatingNumberFinderTest {\n\n    @Test\n    void testNonRepeatingNumberFinder() {\n        int arr[] = {1, 2, 1, 2, 6};\n        assertEquals(6, NonRepeatingNumberFinder.findNonRepeatingNumber(arr));\n        int arr1[] = {1, 2, 1, 2};\n        assertEquals(0, NonRepeatingNumberFinder.findNonRepeatingNumber(arr1));\n        int arr2[] = {12};\n        assertEquals(12, NonRepeatingNumberFinder.findNonRepeatingNumber(arr2));\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/NumbersDifferentSigns.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/NumbersDifferentSignsTest.java",
        "product_old_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\npublic class NumbersDifferentSigns {\n\n    public static boolean differentSigns(int num1, int num2) {\n        return (num1 ^ num2) < 0;\n    }\n}",
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\npublic class NumbersDifferentSigns {\n\n    public static boolean differentSigns(int num1, int num2) {\n        return (num1 ^ num2) < 0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * test Cases of Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass NumbersDifferentSignsTest {\n\n    @Test\n    void testDifferentSignsPositiveNegative() {\n        assertTrue(NumbersDifferentSigns.differentSigns(2, -1));\n    }\n\n    @Test\n    void testDifferentSignsNegativePositive() {\n        assertTrue(NumbersDifferentSigns.differentSigns(-3, 7));\n    }\n\n    @Test\n    void testSameSignsPositive() {\n        assertFalse(NumbersDifferentSigns.differentSigns(10, 20));\n    }\n\n    @Test\n    void testSameSignsNegative() {\n        assertFalse(NumbersDifferentSigns.differentSigns(-5, -8));\n    }\n}",
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * test Cases of Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass NumbersDifferentSignsTest {\n\n    @Test\n    void testDifferentSignsPositiveNegative() {\n        assertTrue(NumbersDifferentSigns.differentSigns(2, -1));\n    }\n\n    @Test\n    void testDifferentSignsNegativePositive() {\n        assertTrue(NumbersDifferentSigns.differentSigns(-3, 7));\n    }\n\n    @Test\n    void testSameSignsPositive() {\n        assertFalse(NumbersDifferentSigns.differentSigns(10, 20));\n    }\n\n    @Test\n    void testSameSignsNegative() {\n        assertFalse(NumbersDifferentSigns.differentSigns(-5, -8));\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.heaps;\n\nimport java.util.ArrayList;\n\n/*\n * This is a leftist heap that follows the same operations as a\n * binary min heap, but may be unbalanced at times and follows a\n * leftist property, in which the left side is more heavy on the\n * right based on the null-path length (npl) values.\n *\n * Source: https://iq.opengenus.org/leftist-heap/\n *\n */\n\npublic class LeftistHeap {\n    private class Node {\n        private int element, npl;\n        private Node left, right;\n\n        // Node constructor setting the data element and left/right pointers to null\n        private Node(int element) {\n            this.element = element;\n            left = right = null;\n            npl = 0;\n        }\n    }\n\n    private Node root;\n\n    // Constructor\n    public LeftistHeap() {\n        root = null;\n    }\n\n    // Checks if heap is empty\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    // Resets structure to initial state\n    public void clear() {\n        // We will put head is null\n        root = null;\n    }\n\n    // Merge function that merges the contents of another leftist heap with the\n    // current one\n    public void merge(LeftistHeap h1) {\n        // If the present function is rhs then we ignore the merge\n        root = merge(root, h1.root);\n        h1.root = null;\n    }\n\n    // Function merge with two Nodes a and b\n    public Node merge(Node a, Node b) {\n        if (a == null) return b;\n\n        if (b == null) return a;\n\n        // Violates leftist property, so must do a swap\n        if (a.element > b.element) {\n            Node temp = a;\n            a = b;\n            b = temp;\n        }\n\n        // Now we call the function merge to merge a and b\n        a.right = merge(a.right, b);\n\n        // Violates leftist property so must swap here\n        if (a.left == null) {\n            a.left = a.right;\n            a.right = null;\n        } else {\n            if (a.left.npl < a.right.npl) {\n                Node temp = a.left;\n                a.left = a.right;\n                a.right = temp;\n            }\n            a.npl = a.right.npl + 1;\n        }\n        return a;\n    }\n\n    // Function insert. Uses the merge function to add the data\n    public void insert(int a) {\n        root = merge(new Node(a), root);\n    }\n\n    // Returns and removes the minimum element in the heap\n    public int extract_min() {\n        // If is empty return -1\n        if (isEmpty()) return -1;\n\n        int min = root.element;\n        root = merge(root.left, root.right);\n        return min;\n    }\n\n    // Function returning a list of an in order traversal of the data structure\n    public ArrayList<Integer> in_order() {\n        ArrayList<Integer> lst = new ArrayList<>();\n        in_order_aux(root, lst);\n        return new ArrayList<>(lst);\n    }\n\n    // Auxiliary function for in_order\n    private void in_order_aux(Node n, ArrayList<Integer> lst) {\n        if (n == null) return;\n        in_order_aux(n.left, lst);\n        lst.add(n.element);\n        in_order_aux(n.right, lst);\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport java.util.ArrayList;\n\n/*\n * This is a leftist heap that follows the same operations as a\n * binary min heap, but may be unbalanced at times and follows a\n * leftist property, in which the left side is more heavy on the\n * right based on the null-path length (npl) values.\n *\n * Source: https://iq.opengenus.org/leftist-heap/\n *\n */\n\npublic class LeftistHeap {\n    private class Node {\n        private int element, npl;\n        private Node left, right;\n\n        // Node constructor setting the data element and left/right pointers to null\n        private Node(int element) {\n            this.element = element;\n            left = right = null;\n            npl = 0;\n        }\n    }\n\n    private Node root;\n\n    // Constructor\n    public LeftistHeap() {\n        root = null;\n    }\n\n    // Checks if heap is empty\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    // Resets structure to initial state\n    public void clear() {\n        // We will put head is null\n        root = null;\n    }\n\n    // Merge function that merges the contents of another leftist heap with the\n    // current one\n    public void merge(LeftistHeap h1) {\n        // If the present function is rhs then we ignore the merge\n        root = merge(root, h1.root);\n        h1.root = null;\n    }\n\n    // Function merge with two Nodes a and b\n    public Node merge(Node a, Node b) {\n        if (a == null) return b;\n\n        if (b == null) return a;\n\n        // Violates leftist property, so must do a swap\n        if (a.element > b.element) {\n            Node temp = a;\n            a = b;\n            b = temp;\n        }\n\n        // Now we call the function merge to merge a and b\n        a.right = merge(a.right, b);\n\n        // Violates leftist property so must swap here\n        if (a.left == null) {\n            a.left = a.right;\n            a.right = null;\n        } else {\n            if (a.left.npl < a.right.npl) {\n                Node temp = a.left;\n                a.left = a.right;\n                a.right = temp;\n            }\n            a.npl = a.right.npl + 1;\n        }\n        return a;\n    }\n\n    // Function insert. Uses the merge function to add the data\n    public void insert(int a) {\n        root = merge(new Node(a), root);\n    }\n\n    // Returns and removes the minimum element in the heap\n    public int extract_min() {\n        // If is empty return -1\n        if (isEmpty()) return -1;\n\n        int min = root.element;\n        root = merge(root.left, root.right);\n        return min;\n    }\n\n    // Function returning a list of an in order traversal of the data structure\n    public ArrayList<Integer> in_order() {\n        ArrayList<Integer> lst = new ArrayList<>();\n        in_order_aux(root, lst);\n        return new ArrayList<>(lst);\n    }\n\n    // Auxiliary function for in_order\n    private void in_order_aux(Node n, ArrayList<Integer> lst) {\n        if (n == null) return;\n        in_order_aux(n.left, lst);\n        lst.add(n.element);\n        in_order_aux(n.right, lst);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeftistHeapTest {\n\n    @Test\n    void testLeftistHeap() {\n        LeftistHeap heap = new LeftistHeap();\n        Assertions.assertTrue(heap.isEmpty());\n        heap.insert(6);\n        Assertions.assertTrue(!heap.isEmpty());\n        heap.insert(2);\n        heap.insert(3);\n        heap.insert(1);\n        heap.in_order();\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3, 1]\"));\n        Assertions.assertTrue(heap.extract_min() == 1);\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3]\"));\n        heap.insert(8);\n        heap.insert(12);\n        heap.insert(4);\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[8, 3, 12, 2, 6, 4]\"));\n        heap.clear();\n        Assertions.assertTrue(heap.isEmpty());\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeftistHeapTest {\n\n    @Test\n    void testLeftistHeap() {\n        LeftistHeap heap = new LeftistHeap();\n        Assertions.assertTrue(heap.isEmpty());\n        heap.insert(6);\n        Assertions.assertTrue(!heap.isEmpty());\n        heap.insert(2);\n        heap.insert(3);\n        heap.insert(1);\n        heap.in_order();\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3, 1]\"));\n        Assertions.assertTrue(heap.extract_min() == 1);\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3]\"));\n        heap.insert(8);\n        heap.insert(12);\n        heap.insert(4);\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[8, 3, 12, 2, 6, 4]\"));\n        heap.clear();\n        Assertions.assertTrue(heap.isEmpty());\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/OptimalJobScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/OptimalJobSchedulingTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * This class refers to the Optimal Job Scheduling problem with the following constrains:\n *  - precedence relation between the processes\n *  - machine pair dependent transportation delays\n *\n * https://en.wikipedia.org/wiki/Optimal_job_scheduling\n *\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobScheduling {\n\n    private final int numberProcesses;\n    private final int numberMachines;\n    private final int[][] Run;\n    private final int[][] Transfer;\n    private final int[][] Cost;\n\n    /**\n     * Constructor of the class.\n     * @param numberProcesses ,refers to the number of precedent processes(N)\n     * @param numberMachines ,refers to the number of different machines in our disposal(M)\n     * @param Run , N*M matrix refers to the cost of running each process to each machine\n     * @param Transfer ,M*M symmetric matrix refers to the transportation delay for each pair of\n     *     machines\n     */\n    public OptimalJobScheduling(int numberProcesses, int numberMachines, int[][] Run, int[][] Transfer) {\n        this.numberProcesses = numberProcesses;\n        this.numberMachines = numberMachines;\n        this.Run = Run;\n        this.Transfer = Transfer;\n        this.Cost = new int[numberProcesses][numberMachines];\n    }\n\n    /**\n     * Function which computes the cost of process scheduling to a number of VMs.\n     */\n    public void execute() {\n        this.calculateCost();\n        this.showResults();\n    }\n\n    /**\n     * Function which computes the cost of running each Process to each and every Machine\n     */\n    private void calculateCost() {\n\n        for (int i = 0; i < numberProcesses; i++) { // for each Process\n\n            for (int j = 0; j < numberMachines; j++) { // for each Machine\n\n                Cost[i][j] = runningCost(i, j);\n            }\n        }\n    }\n\n    /**\n     * Function which returns the minimum cost of running a certain Process to a certain Machine.In\n     * order for the Machine to execute the Process ,he requires the output of the previously\n     * executed Process, which may have been executed to the same Machine or some other.If the\n     * previous Process has been executed to another Machine,we have to transfer her result, which\n     * means extra cost for transferring the data from one Machine to another(if the previous\n     * Process has been executed to the same Machine, there is no transport cost).\n     *\n     * @param process ,refers to the Process\n     * @param machine ,refers to the Machine\n     * @return the minimum cost of executing the process to the certain machine.\n     */\n    private int runningCost(int process, int machine) {\n\n        if (process == 0) // refers to the first process,which does not require for a previous one\n                          // to have been executed\n            return Run[process][machine];\n        else {\n\n            int[] runningCosts = new int[numberMachines]; // stores the costs of executing our Process depending on\n                                                          // the Machine the previous one was executed\n\n            for (int k = 0; k < numberMachines; k++) // computes the cost of executing the previous\n                                                     // process to each and every Machine\n                runningCosts[k] = Cost[process - 1][k] + Transfer[k][machine] + Run[process][machine]; // transferring the result to our Machine and executing\n                                                                                                       // the Process to our Machine\n\n            return findMin(runningCosts); // returns the minimum running cost\n        }\n    }\n\n    /**\n     * Function used in order to return the minimum Cost.\n     * @param cost ,an Array of size M which refers to the costs of executing a Process to each\n     *     Machine\n     * @return the minimum cost\n     */\n    private int findMin(int[] cost) {\n\n        int min = 0;\n\n        for (int i = 1; i < cost.length; i++) {\n\n            if (cost[i] < cost[min]) min = i;\n        }\n        return cost[min];\n    }\n\n    /**\n     * Method used in order to present the overall costs.\n     */\n    private void showResults() {\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n                System.out.print(Cost[i][j]);\n                System.out.print(\" \");\n            }\n\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    /**\n     * Getter for the running Cost of i process on j machine.\n     */\n    public int getCost(int process, int machine) {\n        return Cost[process][machine];\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * This class refers to the Optimal Job Scheduling problem with the following constrains:\n *  - precedence relation between the processes\n *  - machine pair dependent transportation delays\n *\n * https://en.wikipedia.org/wiki/Optimal_job_scheduling\n *\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobScheduling {\n\n    private final int numberProcesses;\n    private final int numberMachines;\n    private final int[][] Run;\n    private final int[][] Transfer;\n    private final int[][] Cost;\n\n    /**\n     * Constructor of the class.\n     * @param numberProcesses ,refers to the number of precedent processes(N)\n     * @param numberMachines ,refers to the number of different machines in our disposal(M)\n     * @param Run , N*M matrix refers to the cost of running each process to each machine\n     * @param Transfer ,M*M symmetric matrix refers to the transportation delay for each pair of\n     *     machines\n     */\n    public OptimalJobScheduling(int numberProcesses, int numberMachines, int[][] Run, int[][] Transfer) {\n        this.numberProcesses = numberProcesses;\n        this.numberMachines = numberMachines;\n        this.Run = Run;\n        this.Transfer = Transfer;\n        this.Cost = new int[numberProcesses][numberMachines];\n    }\n\n    /**\n     * Function which computes the cost of process scheduling to a number of VMs.\n     */\n    public void execute() {\n        this.calculateCost();\n        this.showResults();\n    }\n\n    /**\n     * Function which computes the cost of running each Process to each and every Machine\n     */\n    private void calculateCost() {\n\n        for (int i = 0; i < numberProcesses; i++) { // for each Process\n\n            for (int j = 0; j < numberMachines; j++) { // for each Machine\n\n                Cost[i][j] = runningCost(i, j);\n            }\n        }\n    }\n\n    /**\n     * Function which returns the minimum cost of running a certain Process to a certain Machine.In\n     * order for the Machine to execute the Process ,he requires the output of the previously\n     * executed Process, which may have been executed to the same Machine or some other.If the\n     * previous Process has been executed to another Machine,we have to transfer her result, which\n     * means extra cost for transferring the data from one Machine to another(if the previous\n     * Process has been executed to the same Machine, there is no transport cost).\n     *\n     * @param process ,refers to the Process\n     * @param machine ,refers to the Machine\n     * @return the minimum cost of executing the process to the certain machine.\n     */\n    private int runningCost(int process, int machine) {\n\n        if (process == 0) // refers to the first process,which does not require for a previous one\n                          // to have been executed\n            return Run[process][machine];\n        else {\n\n            int[] runningCosts = new int[numberMachines]; // stores the costs of executing our Process depending on\n                                                          // the Machine the previous one was executed\n\n            for (int k = 0; k < numberMachines; k++) // computes the cost of executing the previous\n                                                     // process to each and every Machine\n                runningCosts[k] = Cost[process - 1][k] + Transfer[k][machine] + Run[process][machine]; // transferring the result to our Machine and executing\n                                                                                                       // the Process to our Machine\n\n            return findMin(runningCosts); // returns the minimum running cost\n        }\n    }\n\n    /**\n     * Function used in order to return the minimum Cost.\n     * @param cost ,an Array of size M which refers to the costs of executing a Process to each\n     *     Machine\n     * @return the minimum cost\n     */\n    private int findMin(int[] cost) {\n\n        int min = 0;\n\n        for (int i = 1; i < cost.length; i++) {\n\n            if (cost[i] < cost[min]) min = i;\n        }\n        return cost[min];\n    }\n\n    /**\n     * Method used in order to present the overall costs.\n     */\n    private void showResults() {\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n                System.out.print(Cost[i][j]);\n                System.out.print(\" \");\n            }\n\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    /**\n     * Getter for the running Cost of i process on j machine.\n     */\n    public int getCost(int process, int machine) {\n        return Cost[process][machine];\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobSchedulingTest {\n\n    @Test\n    public void testOptimalJobScheduling1() {\n\n        int numberProcesses = 5;\n        int numberMachines = 4;\n\n        int[][] Run = {{5, 1, 3, 2}, {4, 2, 1, 3}, {1, 5, 2, 1}, {2, 3, 4, 2}, {1, 1, 3, 1}};\n\n        int[][] Transfer = {{0, 1, 2, 4}, {1, 0, 2, 3}, {2, 2, 0, 1}, {4, 3, 1, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 5}, {5, 8, 6, 6}, {7, 9, 10, 8}, {8, 9, 12, 9}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling2() {\n\n        int numberProcesses = 3;\n        int numberMachines = 3;\n\n        int[][] Run = {{5, 1, 3}, {4, 2, 1}, {1, 5, 2}};\n\n        int[][] Transfer = {{0, 1, 2}, {1, 0, 2}, {2, 2, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3}, {6, 3, 4}, {5, 8, 6}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling3() {\n\n        int numberProcesses = 6;\n        int numberMachines = 4;\n\n        int[][] Run = {\n            {5, 1, 3, 2},\n            {4, 2, 1, 1},\n            {1, 5, 2, 6},\n            {1, 1, 2, 3},\n            {2, 1, 4, 6},\n            {3, 2, 2, 3},\n        };\n\n        int[][] Transfer = {\n            {0, 1, 2, 1},\n            {1, 0, 2, 3},\n            {2, 2, 0, 2},\n            {1, 3, 2, 0},\n        };\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 3}, {5, 8, 6, 9}, {6, 7, 8, 9}, {8, 8, 12, 13}, {11, 10, 12, 12}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobSchedulingTest {\n\n    @Test\n    public void testOptimalJobScheduling1() {\n\n        int numberProcesses = 5;\n        int numberMachines = 4;\n\n        int[][] Run = {{5, 1, 3, 2}, {4, 2, 1, 3}, {1, 5, 2, 1}, {2, 3, 4, 2}, {1, 1, 3, 1}};\n\n        int[][] Transfer = {{0, 1, 2, 4}, {1, 0, 2, 3}, {2, 2, 0, 1}, {4, 3, 1, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 5}, {5, 8, 6, 6}, {7, 9, 10, 8}, {8, 9, 12, 9}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling2() {\n\n        int numberProcesses = 3;\n        int numberMachines = 3;\n\n        int[][] Run = {{5, 1, 3}, {4, 2, 1}, {1, 5, 2}};\n\n        int[][] Transfer = {{0, 1, 2}, {1, 0, 2}, {2, 2, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3}, {6, 3, 4}, {5, 8, 6}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling3() {\n\n        int numberProcesses = 6;\n        int numberMachines = 4;\n\n        int[][] Run = {\n            {5, 1, 3, 2},\n            {4, 2, 1, 1},\n            {1, 5, 2, 6},\n            {1, 1, 2, 3},\n            {2, 1, 4, 6},\n            {3, 2, 2, 3},\n        };\n\n        int[][] Transfer = {\n            {0, 1, 2, 1},\n            {1, 0, 2, 3},\n            {2, 2, 0, 2},\n            {1, 3, 2, 0},\n        };\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 3}, {5, 8, 6, 9}, {6, 7, 8, 9}, {8, 8, 12, 13}, {11, 10, 12, 12}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PowerUsingRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PowerUsingRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * calculate Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class PowerUsingRecursion {\n\n    public static double power(double base, int exponent) {\n        // Base case: anything raised to the power of 0 is 1\n        if (exponent == 0) {\n            return 1;\n        }\n\n        // Recursive case: base ^ exponent = base * base ^ (exponent - 1)\n        // Recurse with a smaller exponent and multiply with base\n        return base * power(base, exponent - 1);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * calculate Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class PowerUsingRecursion {\n\n    public static double power(double base, int exponent) {\n        // Base case: anything raised to the power of 0 is 1\n        if (exponent == 0) {\n            return 1;\n        }\n\n        // Recursive case: base ^ exponent = base * base ^ (exponent - 1)\n        // Recurse with a smaller exponent and multiply with base\n        return base * power(base, exponent - 1);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass PowerUsingRecursionTest {\n\n    @Test\n    void testPowerUsingRecursion() {\n        assertEquals(32.0, PowerUsingRecursion.power(2.0, 5));\n        assertEquals(97.65625, PowerUsingRecursion.power(2.5, 5));\n        assertEquals(81, PowerUsingRecursion.power(3, 4));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass PowerUsingRecursionTest {\n\n    @Test\n    void testPowerUsingRecursion() {\n        assertEquals(32.0, PowerUsingRecursion.power(2.0, 5));\n        assertEquals(97.65625, PowerUsingRecursion.power(2.5, 5));\n        assertEquals(81, PowerUsingRecursion.power(3, 4));\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/PreemptivePriorityScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/PreemptivePrioritySchedulingTest.java",
        "product_old_content": "package com.thealgorithms.scheduling;\n\nimport java.util.*;\n\n/**\n * Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nclass Process {\n    String name;\n    int arrivalTime;\n    int burstTime;\n    int priority;\n\n    public Process(String name, int arrivalTime, int burstTime, int priority) {\n        this.name = name;\n        this.arrivalTime = arrivalTime;\n        this.burstTime = burstTime;\n        this.priority = priority;\n    }\n}\n\npublic class PreemptivePriorityScheduling {\n    public static List<String> preemptivePriorityScheduling(List<Process> processes) {\n        List<String> ganttChart = new ArrayList<>();\n        PriorityQueue<Process> readyQueue = new PriorityQueue<>(Comparator.comparingInt(p -> - p.priority));\n\n        int currentTime = 0;\n\n        while (!processes.isEmpty() || !readyQueue.isEmpty()) {\n            while (!processes.isEmpty() && processes.get(0).arrivalTime <= currentTime) {\n                readyQueue.add(processes.remove(0));\n            }\n\n            if (!readyQueue.isEmpty()) {\n                Process currentProcess = readyQueue.poll();\n\n                ganttChart.add(currentProcess.name);\n                currentProcess.burstTime--;\n\n                if (currentProcess.burstTime > 0) {\n                    readyQueue.add(currentProcess);\n                }\n            } else {\n                ganttChart.add(\"Idle\");\n            }\n\n            currentTime++;\n        }\n\n        return ganttChart;\n    }\n}",
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport java.util.*;\n\n/**\n * Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nclass Process {\n    String name;\n    int arrivalTime;\n    int burstTime;\n    int priority;\n\n    public Process(String name, int arrivalTime, int burstTime, int priority) {\n        this.name = name;\n        this.arrivalTime = arrivalTime;\n        this.burstTime = burstTime;\n        this.priority = priority;\n    }\n}\n\npublic class PreemptivePriorityScheduling {\n    public static List<String> preemptivePriorityScheduling(List<Process> processes) {\n        List<String> ganttChart = new ArrayList<>();\n        PriorityQueue<Process> readyQueue = new PriorityQueue<>(Comparator.comparingInt(p -> - p.priority));\n\n        int currentTime = 0;\n\n        while (!processes.isEmpty() || !readyQueue.isEmpty()) {\n            while (!processes.isEmpty() && processes.get(0).arrivalTime <= currentTime) {\n                readyQueue.add(processes.remove(0));\n            }\n\n            if (!readyQueue.isEmpty()) {\n                Process currentProcess = readyQueue.poll();\n\n                ganttChart.add(currentProcess.name);\n                currentProcess.burstTime--;\n\n                if (currentProcess.burstTime > 0) {\n                    readyQueue.add(currentProcess);\n                }\n            } else {\n                ganttChart.add(\"Idle\");\n            }\n\n            currentTime++;\n        }\n\n        return ganttChart;\n    }\n}",
        "test_old_content": "package com.thealgorithms.scheduling;\n\n/**\n * Test Cases of Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\nclass PreemptivePrioritySchedulingTest {\n\n    @Test\n    void testPreemptivePriorityScheduling() {\n        // Arrange\n        List<Process> processes = new ArrayList<>();\n        processes.add(new Process(\"P1\", 0, 5, 10));\n        processes.add(new Process(\"P2\", 1, 4, 20));\n        processes.add(new Process(\"P3\", 2, 2, 30));\n        processes.add(new Process(\"P4\", 4, 1, 40));\n\n        List<String> expectedGanttChart = Arrays.asList(\"P1\", \"P2\", \"P3\", \"P3\", \"P4\", \"P2\", \"P2\", \"P2\", \"P1\", \"P1\", \"P1\", \"P1\");\n\n        // Act\n        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);\n\n        // Assert\n        assertEquals(expectedGanttChart, actualGanttChart);\n    }\n}",
        "test_new_content": "package com.thealgorithms.scheduling;\n\n/**\n * Test Cases of Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\nclass PreemptivePrioritySchedulingTest {\n\n    @Test\n    void testPreemptivePriorityScheduling() {\n        // Arrange\n        List<Process> processes = new ArrayList<>();\n        processes.add(new Process(\"P1\", 0, 5, 10));\n        processes.add(new Process(\"P2\", 1, 4, 20));\n        processes.add(new Process(\"P3\", 2, 2, 30));\n        processes.add(new Process(\"P4\", 4, 1, 40));\n\n        List<String> expectedGanttChart = Arrays.asList(\"P1\", \"P2\", \"P3\", \"P3\", \"P4\", \"P2\", \"P2\", \"P2\", \"P1\", \"P1\", \"P1\", \"P1\");\n\n        // Act\n        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);\n\n        // Assert\n        assertEquals(expectedGanttChart, actualGanttChart);\n    }\n}"
    },
    {
        "product_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/DualPivotQuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DualPivotQuickSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * Dual Pivot Quick Sort Algorithm\n *\n * @author Debasish Biswas (https://github.com/debasishbsws) *\n * @see SortAlgorithm\n */\npublic class DualPivotQuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Dual pivot Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        dualPivotQuicksort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left  The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void dualPivotQuicksort(T[] array, int left, int right) {\n        if (left < right) {\n            int[] pivots = partition(array, left, right);\n\n            dualPivotQuicksort(array, left, pivots[0] - 1);\n            dualPivotQuicksort(array, pivots[0] + 1, pivots[1] - 1);\n            dualPivotQuicksort(array, pivots[1] + 1, right);\n        }\n    }\n\n    /**\n     * This method finds the partition indices for an array\n     *\n     * @param array The array to be sorted\n     * @param left  The first index of an array\n     * @param right The last index of an array Finds the partition index of an array\n     */\n    private static <T extends Comparable<T>> int[] partition(T[] array, int left, int right) {\n        if (array[left].compareTo(array[right]) > 0) swap(array, left, right);\n\n        T pivot1 = array[left];\n        T pivot2 = array[right];\n\n        int j = left + 1;\n        int less = left + 1;\n        int great = right - 1;\n\n        while (less <= great) {\n            // If element is less than pivot1\n            if (array[less].compareTo(pivot1) < 0) {\n                swap(array, less, left++);\n            }\n\n            // If element is greater or equal to pivot2\n            else if (array[less].compareTo(pivot2) >= 0) {\n                while (less < great && array[great].compareTo(pivot2) > 0) great--;\n\n                swap(array, less, great--);\n\n                if (array[less].compareTo(pivot1) < 0) swap(array, less, left++);\n            }\n\n            less++;\n        }\n        j--;\n        great++;\n        // Bring the pivots to their appropriate positions\n        swap(array, left, j);\n        swap(array, right, great);\n\n        // return the pivots' indices\n        return new int[] {less, great};\n    }\n\n    private static <T extends Comparable<T>> void swap(T[] array, int left, int right) {\n        T temp = array[left];\n        array[left] = array[right];\n        array[right] = temp;\n    }\n\n    /**\n     * Main method\n     *\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Integer[] array = {24, 8, -42, 75, -29, -77, 38, 57};\n        DualPivotQuickSort dualPivotQuickSort = new DualPivotQuickSort();\n        dualPivotQuickSort.sort(array);\n        for (int i = 0; i < array.length; i++) {\n            System.out.print(array[i] + \" \");\n        }\n    }\n\n    /*\n     * References: https://www.geeksforgeeks.org/dual-pivot-quicksort/\n     */\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * Dual Pivot Quick Sort Algorithm\n *\n * @author Debasish Biswas (https://github.com/debasishbsws) *\n * @see SortAlgorithm\n */\npublic class DualPivotQuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Dual pivot Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        dualPivotQuicksort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left  The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void dualPivotQuicksort(T[] array, int left, int right) {\n        if (left < right) {\n            int[] pivots = partition(array, left, right);\n\n            dualPivotQuicksort(array, left, pivots[0] - 1);\n            dualPivotQuicksort(array, pivots[0] + 1, pivots[1] - 1);\n            dualPivotQuicksort(array, pivots[1] + 1, right);\n        }\n    }\n\n    /**\n     * This method finds the partition indices for an array\n     *\n     * @param array The array to be sorted\n     * @param left  The first index of an array\n     * @param right The last index of an array Finds the partition index of an array\n     */\n    private static <T extends Comparable<T>> int[] partition(T[] array, int left, int right) {\n        if (array[left].compareTo(array[right]) > 0) swap(array, left, right);\n\n        T pivot1 = array[left];\n        T pivot2 = array[right];\n\n        int j = left + 1;\n        int less = left + 1;\n        int great = right - 1;\n\n        while (less <= great) {\n            // If element is less than pivot1\n            if (array[less].compareTo(pivot1) < 0) {\n                swap(array, less, left++);\n            }\n\n            // If element is greater or equal to pivot2\n            else if (array[less].compareTo(pivot2) >= 0) {\n                while (less < great && array[great].compareTo(pivot2) > 0) great--;\n\n                swap(array, less, great--);\n\n                if (array[less].compareTo(pivot1) < 0) swap(array, less, left++);\n            }\n\n            less++;\n        }\n        j--;\n        great++;\n        // Bring the pivots to their appropriate positions\n        swap(array, left, j);\n        swap(array, right, great);\n\n        // return the pivots' indices\n        return new int[] {less, great};\n    }\n\n    private static <T extends Comparable<T>> void swap(T[] array, int left, int right) {\n        T temp = array[left];\n        array[left] = array[right];\n        array[right] = temp;\n    }\n\n    /**\n     * Main method\n     *\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Integer[] array = {24, 8, -42, 75, -29, -77, 38, 57};\n        DualPivotQuickSort dualPivotQuickSort = new DualPivotQuickSort();\n        dualPivotQuickSort.sort(array);\n        for (int i = 0; i < array.length; i++) {\n            System.out.print(array[i] + \" \");\n        }\n    }\n\n    /*\n     * References: https://www.geeksforgeeks.org/dual-pivot-quicksort/\n     */\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = {7};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = {49, -36, -124, -49, 12, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {-124, -49, -36, 9, 12, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = {\"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\"};\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = {\"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\"};\n        assertArrayEquals(expected, sorted);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = {7};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = {49, -36, -124, -49, 12, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {-124, -49, -36, 9, 12, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = {\"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\"};\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = {\"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\"};\n        assertArrayEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "ea15f2bd98c24150b590fac800e386d2f98b203d",
        "test_commit": "ea15f2bd98c24150b590fac800e386d2f98b203d",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list[Iterative] from a given node till the end\n     *\n     */\n    public Node reverseListIter(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n    /**\n     * Reverse a singly linked list[Recursive] from a given node till the end\n     *\n     */\n    public Node reverseListRec(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Node prev = null;\n        Node h2 = reverseListRec(head.next);\n\n        head.next.next = head;\n        head.next = prev;\n\n        return h2;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList implements Iterable<Integer> {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list[Iterative] from a given node till the end\n     *\n     */\n    public Node reverseListIter(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n    /**\n     * Reverse a singly linked list[Recursive] from a given node till the end\n     *\n     */\n    public Node reverseListRec(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Node prev = null;\n        Node h2 = reverseListRec(head.next);\n\n        head.next.next = head;\n        head.next = prev;\n\n        return h2;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        for (final var element : this) {\n            ++count;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(final int key) {\n        for (final var element : this) {\n            if (element == key) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        for (final var element : this) {\n            joiner.add(element + \"\");\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return new SinglyLinkedListIterator();\n    }\n\n    private class SinglyLinkedListIterator implements Iterator<Integer> {\n        private Node current;\n\n        SinglyLinkedListIterator() {\n            current = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return current != null;\n        }\n\n        @Override\n        public Integer next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            final var value = current.value;\n            current = current.next;\n            return value;\n        }\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseListIter(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseListIter(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseListIter(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n    // This is Recursive Reverse List Test\n    // Test to check whether the method reverseListRec() works fine\n    void RecursiveReverseList() {\n        // Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\n        SinglyLinkedList list = createSampleList(5);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list is: 5 -> 4 -> 3 -> 2 -> 1\n        assertEquals(5, head.value);\n        assertEquals(4, head.next.value);\n        assertEquals(3, head.next.next.value);\n        assertEquals(2, head.next.next.next.value);\n        assertEquals(1, head.next.next.next.next.value);\n    }\n\n    @Test\n    void RecursiveReverseListNullPointer() {\n        // Create an empty linked list\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the empty linked list\n        Node head = list.reverseListRec(first);\n\n        // Check if the head remains the same (null)\n        assertNull(head);\n    }\n\n    @Test\n    void RecursiveReverseListTest() {\n        // Create a linked list with values from 1 to 20\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list has the correct values\n        int i = 20;\n        Node temp = head;\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseListIter(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseListIter(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseListIter(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n    // This is Recursive Reverse List Test\n    // Test to check whether the method reverseListRec() works fine\n    void RecursiveReverseList() {\n        // Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\n        SinglyLinkedList list = createSampleList(5);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list is: 5 -> 4 -> 3 -> 2 -> 1\n        assertEquals(5, head.value);\n        assertEquals(4, head.next.value);\n        assertEquals(3, head.next.next.value);\n        assertEquals(2, head.next.next.next.value);\n        assertEquals(1, head.next.next.next.next.value);\n    }\n\n    @Test\n    void RecursiveReverseListNullPointer() {\n        // Create an empty linked list\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the empty linked list\n        Node head = list.reverseListRec(first);\n\n        // Check if the head remains the same (null)\n        assertNull(head);\n    }\n\n    @Test\n    void RecursiveReverseListTest() {\n        // Create a linked list with values from 1 to 20\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list has the correct values\n        int i = 20;\n        Node temp = head;\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n\n    @Test\n    void readWithEnhancedForLoopTest() {\n        final var expeced = new ArrayList<Integer>(Arrays.asList(10, 20, 30));\n\n        SinglyLinkedList list = new SinglyLinkedList();\n        for (final var x : expeced) {\n            list.insert(x);\n        }\n\n        var readElements = new ArrayList<Integer>();\n        for (final var x : list) {\n            readElements.add(x);\n        }\n\n        assertEquals(readElements, expeced);\n    }\n\n    @Test\n    void toStringTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n        assertEquals(\"1->2->3\", list.toString());\n    }\n\n    @Test\n    void toStringForEmptyListTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assertEquals(\"\", list.toString());\n    }\n\n    @Test\n    void countTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.insert(10);\n        list.insert(20);\n        assertEquals(2, list.count());\n    }\n\n    @Test\n    void countForEmptyListTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assertEquals(0, list.count());\n    }\n}"
    },
    {
        "product_commit": "80a443503895b7514e5e9466914e06a1a9fee1fd",
        "test_commit": "80a443503895b7514e5e9466914e06a1a9fee1fd",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PowerUsingRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PowerUsingRecursionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * calculate Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class PowerUsingRecursion {\n\n    public static double power(double base, int exponent) {\n        // Base case: anything raised to the power of 0 is 1\n        if (exponent == 0) {\n            return 1;\n        }\n\n        // Recursive case: base ^ exponent = base * base ^ (exponent - 1)\n        // Recurse with a smaller exponent and multiply with base\n        return base * power(base, exponent - 1);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass PowerUsingRecursionTest {\n\n    @Test\n    void testPowerUsingRecursion() {\n        assertEquals(32.0, PowerUsingRecursion.power(2.0, 5));\n        assertEquals(97.65625, PowerUsingRecursion.power(2.5, 5));\n        assertEquals(81, PowerUsingRecursion.power(3, 4));\n    }\n}"
    },
    {
        "product_commit": "ebd356e182910a457a867e743f22eb213fc00bb0",
        "test_commit": "ebd356e182910a457a867e743f22eb213fc00bb0",
        "product_file_path": "src/main/java/com/thealgorithms/maths/MillerRabinPrimalityCheck.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MillerRabinPrimalityCheckTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Random;\n\npublic class MillerRabinPrimalityCheck {\n\n    /**\n     * Check whether the given number is prime or not\n     * MillerRabin algorithm is probabilistic. There is also an altered version which is deterministic.\n     * https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n     * https://cp-algorithms.com/algebra/primality_tests.html\n     *\n     * @param n Whole number which is tested on primality\n     * @param k Number of iterations\n     *       If n is composite then running k iterations of the Miller\u2013Rabin\n     *       test will declare n probably prime with a probability at most 4^(\u2212k)\n     * @return true or false whether the given number is probably prime or not\n     */\n\n    public static boolean millerRabin(long n, int k) { // returns true if n is probably prime, else returns false.\n        if (n < 4) return n == 2 || n == 3;\n\n        int s = 0;\n        long d = n - 1;\n        while ((d & 1) == 0) {\n            d >>= 1;\n            s++;\n        }\n        Random rnd = new Random();\n        for (int i = 0; i < k; i++) {\n            long a = 2 + rnd.nextLong(n) % (n - 3);\n            if (checkComposite(n, a, d, s)) return false;\n        }\n        return true;\n    }\n\n    public static boolean deterministicMillerRabin(long n) { // returns true if n is prime, else returns false.\n        if (n < 2) return false;\n\n        int r = 0;\n        long d = n - 1;\n        while ((d & 1) == 0) {\n            d >>= 1;\n            r++;\n        }\n\n        for (int a : new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n            if (n == a) return true;\n            if (checkComposite(n, a, d, r)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Check if number n is composite (probabilistic)\n     *\n     * @param n Whole number which is tested for compositeness\n     * @param a Random number (prime base) to check if it holds certain equality\n     * @param d Number which holds this equation: 'n - 1 = 2^s * d'\n     * @param s Number of twos in (n - 1) factorization\n     *\n     * @return true or false whether the numbers hold the equation or not\n     *          the equations are described on the websites mentioned at the beginning of the class\n     */\n    private static boolean checkComposite(long n, long a, long d, int s) {\n        long x = powerModP(a, d, n);\n        if (x == 1 || x == n - 1) return false;\n        for (int r = 1; r < s; r++) {\n            x = powerModP(x, 2, n);\n            if (x == n - 1) return false;\n        }\n        return true;\n    }\n\n    private static long powerModP(long x, long y, long p) {\n        long res = 1; // Initialize result\n\n        x = x % p; // Update x if it is more than or equal to p\n\n        if (x == 0) return 0; // In case x is divisible by p;\n\n        while (y > 0) {\n            // If y is odd, multiply x with result\n            if ((y & 1) == 1) res = multiplyModP(res, x, p);\n\n            // y must be even now\n            y = y >> 1; // y = y/2\n            x = multiplyModP(x, x, p);\n        }\n        return res;\n    }\n\n    private static long multiplyModP(long a, long b, long p) {\n        long aHi = a >> 24;\n        long aLo = a & ((1 << 24) - 1);\n        long bHi = b >> 24;\n        long bLo = b & ((1 << 24) - 1);\n        long result = ((((aHi * bHi << 16) % p) << 16) % p) << 16;\n        result += ((aLo * bHi + aHi * bLo) << 24) + aLo * bLo;\n        return result % p;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static com.thealgorithms.maths.MillerRabinPrimalityCheck.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass MillerRabinPrimalityCheckTest {\n    @Test\n    void testDeterministicMillerRabinForPrimes() {\n        assertTrue(deterministicMillerRabin(2));\n        assertTrue(deterministicMillerRabin(37));\n        assertTrue(deterministicMillerRabin(123457));\n        assertTrue(deterministicMillerRabin(6472601713L));\n    }\n    @Test\n    void testDeterministicMillerRabinForNotPrimes() {\n        assertFalse(deterministicMillerRabin(1));\n        assertFalse(deterministicMillerRabin(35));\n        assertFalse(deterministicMillerRabin(123453));\n        assertFalse(deterministicMillerRabin(647260175));\n    }\n    @Test\n    void testMillerRabinForPrimes() {\n        assertTrue(millerRabin(11, 5));\n        assertTrue(millerRabin(97, 5));\n        assertTrue(millerRabin(6720589, 5));\n        assertTrue(millerRabin(9549401549L, 5));\n    }\n}"
    },
    {
        "product_commit": "b4f786369bc013221371dcd708e4cb2eb82c3956",
        "test_commit": "b4f786369bc013221371dcd708e4cb2eb82c3956",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinder.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinderTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find Non Repeating Number\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class NonRepeatingNumberFinder {\n\n    public static int findNonRepeatingNumber(int[] arr) {\n        int result = 0;\n        for (int num : arr) {\n            result ^= num;\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Non Repeating Number Finder\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass NonRepeatingNumberFinderTest {\n\n    @Test\n    void testNonRepeatingNumberFinder() {\n        int arr[] = {1, 2, 1, 2, 6};\n        assertEquals(6, NonRepeatingNumberFinder.findNonRepeatingNumber(arr));\n        int arr1[] = {1, 2, 1, 2};\n        assertEquals(0, NonRepeatingNumberFinder.findNonRepeatingNumber(arr1));\n        int arr2[] = {12};\n        assertEquals(12, NonRepeatingNumberFinder.findNonRepeatingNumber(arr2));\n    }\n}"
    },
    {
        "product_commit": "52f365a915d9d7bd3967fc11e61c7592ad28dea9",
        "test_commit": "52f365a915d9d7bd3967fc11e61c7592ad28dea9",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBitTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find The Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class IndexOfRightMostSetBit {\n    public static int indexOfRightMostSetBit(int n) {\n        if (n == 0) {\n            return -1; // No set bits\n        }\n\n        // Handle negative numbers by finding the two's complement\n        if (n < 0) {\n            n = -n;\n            n = n & (~n + 1); // Get the rightmost set bit in positive form\n        }\n\n        int index = 0;\n        while ((n & 1) == 0) {\n            n = n >> 1;\n            index++;\n        }\n\n        return index;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass IndexOfRightMostSetBitTest {\n\n    @Test\n    void testIndexOfRightMostSetBit() {\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));\n        assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));\n    }\n}"
    },
    {
        "product_commit": "4bcddd323ca11db87f25af053053390467ddc53e",
        "test_commit": "4bcddd323ca11db87f25af053053390467ddc53e",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/PreemptivePriorityScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/PreemptivePrioritySchedulingTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport java.util.*;\n\n/**\n * Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nclass Process {\n    String name;\n    int arrivalTime;\n    int burstTime;\n    int priority;\n\n    public Process(String name, int arrivalTime, int burstTime, int priority) {\n        this.name = name;\n        this.arrivalTime = arrivalTime;\n        this.burstTime = burstTime;\n        this.priority = priority;\n    }\n}\n\npublic class PreemptivePriorityScheduling {\n    public static List<String> preemptivePriorityScheduling(List<Process> processes) {\n        List<String> ganttChart = new ArrayList<>();\n        PriorityQueue<Process> readyQueue = new PriorityQueue<>(Comparator.comparingInt(p -> - p.priority));\n\n        int currentTime = 0;\n\n        while (!processes.isEmpty() || !readyQueue.isEmpty()) {\n            while (!processes.isEmpty() && processes.get(0).arrivalTime <= currentTime) {\n                readyQueue.add(processes.remove(0));\n            }\n\n            if (!readyQueue.isEmpty()) {\n                Process currentProcess = readyQueue.poll();\n\n                ganttChart.add(currentProcess.name);\n                currentProcess.burstTime--;\n\n                if (currentProcess.burstTime > 0) {\n                    readyQueue.add(currentProcess);\n                }\n            } else {\n                ganttChart.add(\"Idle\");\n            }\n\n            currentTime++;\n        }\n\n        return ganttChart;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.scheduling;\n\n/**\n * Test Cases of Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\nclass PreemptivePrioritySchedulingTest {\n\n    @Test\n    void testPreemptivePriorityScheduling() {\n        // Arrange\n        List<Process> processes = new ArrayList<>();\n        processes.add(new Process(\"P1\", 0, 5, 10));\n        processes.add(new Process(\"P2\", 1, 4, 20));\n        processes.add(new Process(\"P3\", 2, 2, 30));\n        processes.add(new Process(\"P4\", 4, 1, 40));\n\n        List<String> expectedGanttChart = Arrays.asList(\"P1\", \"P2\", \"P3\", \"P3\", \"P4\", \"P2\", \"P2\", \"P2\", \"P1\", \"P1\", \"P1\", \"P1\");\n\n        // Act\n        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);\n\n        // Assert\n        assertEquals(expectedGanttChart, actualGanttChart);\n    }\n}"
    },
    {
        "product_commit": "af80c8005d4481642ca6fc8ff11d945f1600ea8b",
        "test_commit": "af80c8005d4481642ca6fc8ff11d945f1600ea8b",
        "product_file_path": "src/main/java/com/thealgorithms/others/MaximumSumOfDistinctSubarraysWithLengthK.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/MaximumSumOfDistinctSubarraysWithLengthKTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.HashSet;\n\n/*\nReferences: https://en.wikipedia.org/wiki/Streaming_algorithm\n* In this model, the function of interest is computing over a fixed-size window in the stream. As the stream progresses,\n* items from the end of the window are removed from consideration while new items from the stream take their place.\n* @author Swarga-codes (https://github.com/Swarga-codes)\n*/\npublic class MaximumSumOfDistinctSubarraysWithLengthK {\n    /*\n     * Returns the maximum sum of subarray of size K consisting of distinct\n     * elements.\n     *\n     * @param k size of the subarray which should be considered from the given\n     * array.\n     *\n     * @param nums is the array from which we would be finding the required\n     * subarray.\n     *\n     * @return the maximum sum of distinct subarray of size K.\n     */\n    public static long maximumSubarraySum(int k, int... nums) {\n        if (nums.length < k) return 0;\n        long max = 0; // this will store the max sum which will be our result\n        long s = 0; // this will store the sum of every k elements which can be used to compare with\n                    // max\n        HashSet<Integer> set = new HashSet<>(); // this can be used to store unique elements in our subarray\n        // Looping through k elements to get the sum of first k elements\n        for (int i = 0; i < k; i++) {\n            s += nums[i];\n            set.add(nums[i]);\n        }\n        // Checking if the first kth subarray contains unique elements or not if so then\n        // we assign that to max\n        if (set.size() == k) {\n            max = s;\n        }\n        // Looping through the rest of the array to find different subarrays and also\n        // utilising the sliding window algorithm to find the sum\n        // in O(n) time complexity\n        for (int i = 1; i < nums.length - k + 1; i++) {\n            s = s - nums[i - 1];\n            s = s + nums[i + k - 1];\n            int j = i;\n            boolean flag = false; // flag value which says that the subarray contains distinct elements\n            while (j < i + k && set.size() < k) {\n                if (nums[i - 1] == nums[j]) {\n                    flag = true;\n                    break;\n                } else {\n                    j++;\n                }\n            }\n            if (!flag) {\n                set.remove(nums[i - 1]);\n            }\n            set.add(nums[i + k - 1]);\n            // if the subarray contains distinct elements then we compare and update the max\n            // value\n            if (set.size() == k) {\n                if (max < s) {\n                    max = s;\n                }\n            }\n        }\n        return max; // the final maximum sum\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MaximumSumOfDistinctSubarraysWithLengthKTest {\n    @Test\n    public void SampleTestCase1() {\n        assertEquals(15, MaximumSumOfDistinctSubarraysWithLengthK.maximumSubarraySum(3, 1, 5, 4, 2, 9, 9, 9));\n    }\n\n    @Test\n    public void SampleTestCase2() {\n        assertEquals(0, MaximumSumOfDistinctSubarraysWithLengthK.maximumSubarraySum(3, 4, 4, 4));\n    }\n\n    @Test\n    public void SampleTestCase3() {\n        assertEquals(12, MaximumSumOfDistinctSubarraysWithLengthK.maximumSubarraySum(3, 9, 9, 9, 1, 2, 3));\n    }\n\n    @Test\n    public void EdgeCase1() {\n        assertEquals(0, MaximumSumOfDistinctSubarraysWithLengthK.maximumSubarraySum(0, 9, 9, 9));\n    }\n\n    @Test\n    public void EdgeCase2() {\n        assertEquals(0, MaximumSumOfDistinctSubarraysWithLengthK.maximumSubarraySum(5, 9, 9, 9));\n    }\n}"
    },
    {
        "product_commit": "b61faf4ede146998892e8582f81ff2290a0836fd",
        "test_commit": "b61faf4ede146998892e8582f81ff2290a0836fd",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/IsPowerTwo.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/IsPowerTwoTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Is number power of 2\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class IsPowerTwo {\n    public static boolean isPowerTwo(int number) {\n        if (number <= 0) {\n            return false;\n        }\n        int ans = number & (number - 1);\n        return ans == 0;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for IsPowerTwo class\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class IsPowerTwoTest {\n    @Test\n    public void testIsPowerTwo() {\n        // test some positive powers of 2\n        assertTrue(IsPowerTwo.isPowerTwo(1));\n        assertTrue(IsPowerTwo.isPowerTwo(2));\n        assertTrue(IsPowerTwo.isPowerTwo(4));\n        assertTrue(IsPowerTwo.isPowerTwo(16));\n        assertTrue(IsPowerTwo.isPowerTwo(1024));\n\n        // test some negative numbers\n        assertFalse(IsPowerTwo.isPowerTwo(-1));\n        assertFalse(IsPowerTwo.isPowerTwo(-2));\n        assertFalse(IsPowerTwo.isPowerTwo(-4));\n\n        // test some numbers that are not powers of 2\n        assertFalse(IsPowerTwo.isPowerTwo(0));\n        assertFalse(IsPowerTwo.isPowerTwo(3));\n        assertFalse(IsPowerTwo.isPowerTwo(5));\n        assertFalse(IsPowerTwo.isPowerTwo(15));\n        assertFalse(IsPowerTwo.isPowerTwo(1000));\n    }\n}"
    },
    {
        "product_commit": "2c16c8605455117e1bc6557430830961a3df97e2",
        "test_commit": "2c16c8605455117e1bc6557430830961a3df97e2",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/NumbersDifferentSigns.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/NumbersDifferentSignsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\npublic class NumbersDifferentSigns {\n\n    public static boolean differentSigns(int num1, int num2) {\n        return (num1 ^ num2) < 0;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * test Cases of Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass NumbersDifferentSignsTest {\n\n    @Test\n    void testDifferentSignsPositiveNegative() {\n        assertTrue(NumbersDifferentSigns.differentSigns(2, -1));\n    }\n\n    @Test\n    void testDifferentSignsNegativePositive() {\n        assertTrue(NumbersDifferentSigns.differentSigns(-3, 7));\n    }\n\n    @Test\n    void testSameSignsPositive() {\n        assertFalse(NumbersDifferentSigns.differentSigns(10, 20));\n    }\n\n    @Test\n    void testSameSignsNegative() {\n        assertFalse(NumbersDifferentSigns.differentSigns(-5, -8));\n    }\n}"
    },
    {
        "product_commit": "18848574be543d01245b0e871c264f06592cc2b9",
        "test_commit": "18848574be543d01245b0e871c264f06592cc2b9",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BreadthFirstSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.searches.DepthFirstSearch.Node;\nimport java.util.ArrayDeque;\nimport java.util.Optional;\nimport java.util.Queue;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n */\npublic class BreadthFirstSearch {\n    public static Optional<Node> search(final Node node, final String name) {\n        if (node.getName().equals(name)) {\n            return Optional.of(node);\n        }\n\n        Queue<Node> queue = new ArrayDeque<>(node.getSubNodes());\n\n        while (!queue.isEmpty()) {\n            final Node current = queue.poll();\n\n            if (current.getName().equals(name)) {\n                return Optional.of(current);\n            }\n\n            queue.addAll(current.getSubNodes());\n        }\n\n        return Optional.empty();\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.datastructures.Node;\nimport java.util.*;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n * @wiki: https://en.wikipedia.org/wiki/Breadth-first_search\n */\npublic class BreadthFirstSearch<T> {\n\n    private final List<T> visited = new ArrayList<>();\n\n    public Optional<Node<T>> search(final Node<T> node, final T value) {\n        if (node == null) {\n            return Optional.empty();\n        }\n        if (node.getValue().equals(value)) {\n            // add root node to visited\n            visited.add(value);\n            return Optional.of(node);\n        }\n        visited.add(node.getValue());\n\n        Queue<Node<T>> queue = new ArrayDeque<>(node.getChildren());\n\n        while (!queue.isEmpty()) {\n            final Node<T> current = queue.poll();\n            visited.add(current.getValue());\n\n            if (current.getValue().equals(value)) {\n                return Optional.of(current);\n            }\n\n            queue.addAll(current.getChildren());\n        }\n\n        return Optional.empty();\n    }\n\n    public List<T> getVisited() {\n        return visited;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport java.util.Optional;\nimport org.junit.jupiter.api.Test;\n\nclass BreadthFirstSearchTest {\n\n    private static final DepthFirstSearch.Node rootNode = new DepthFirstSearch.Node(\"A\",\n        List.of(new DepthFirstSearch.Node(\"B\", List.of(new DepthFirstSearch.Node(\"D\"), new DepthFirstSearch.Node(\"F\", List.of(new DepthFirstSearch.Node(\"H\"), new DepthFirstSearch.Node(\"I\"))))), new DepthFirstSearch.Node(\"C\", List.of(new DepthFirstSearch.Node(\"G\"))), new DepthFirstSearch.Node(\"E\")));\n\n    @Test\n    void searchI() {\n        Optional<DepthFirstSearch.Node> Inode = BreadthFirstSearch.search(rootNode, \"I\");\n        assertTrue(Inode.isPresent());\n        assertEquals(Inode.get().getName(), \"I\");\n    }\n\n    @Test\n    void searchG() {\n        Optional<DepthFirstSearch.Node> Gnode = BreadthFirstSearch.search(rootNode, \"G\");\n        assertTrue(Gnode.isPresent());\n        assertEquals(Gnode.get().getName(), \"G\");\n    }\n\n    @Test\n    void searchE() {\n        Optional<DepthFirstSearch.Node> Enode = BreadthFirstSearch.search(rootNode, \"E\");\n        assertTrue(Enode.isPresent());\n        assertEquals(Enode.get().getName(), \"E\");\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.datastructures.Node;\nimport java.util.List;\nimport java.util.Optional;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class BreadthFirstSearchTest {\n    private Node<String> root;\n    private BreadthFirstSearch<String> bfs;\n\n    // Tree structure:\n    //\n    //        A\n    //      / | \\\n    //     B  C  D\n    //    / \\\n    //   E   F\n\n    @BeforeEach\n    public void setUp() {\n        // nodes declaration\n        root = new Node<>(\"A\");\n\n        var nodeB = new Node<>(\"B\");\n        var nodeC = new Node<>(\"C\");\n        var nodeD = new Node<>(\"D\");\n\n        var nodeE = new Node<>(\"E\");\n        var nodeF = new Node<>(\"F\");\n\n        // tree initialization\n        root.addChild(nodeB);\n        root.addChild(nodeC);\n        root.addChild(nodeD);\n\n        nodeB.addChild(nodeE);\n        nodeB.addChild(nodeF);\n\n        // create an instance to monitor the visited nodes\n        bfs = new BreadthFirstSearch<>();\n    }\n\n    @Test\n    public void testSearchRoot() {\n        String expectedValue = \"A\";\n        List<String> expectedPath = List.of(\"A\");\n\n        // check value\n        Optional<Node<String>> value = bfs.search(root, expectedValue);\n        assertEquals(expectedValue, value.orElse(new Node<>(\"\")).getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    public void testSearchF() {\n        String expectedValue = \"F\";\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n\n        // check value\n        Optional<Node<String>> value = Optional.of(bfs.search(root, expectedValue).orElse(new Node<>(null)));\n        assertEquals(expectedValue, value.get().getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    void testSearchNull() {\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n        Optional<Node<String>> node = bfs.search(root, null);\n\n        // check value\n        assertTrue(node.isEmpty());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    void testNullRoot() {\n        var value = bfs.search(null, \"B\");\n        assertTrue(value.isEmpty());\n    }\n\n    @Test\n    void testSearchValueThatNotExists() {\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n        var value = bfs.search(root, \"Z\");\n\n        // check that the value is empty because it's not exists in the tree\n        assertTrue(value.isEmpty());\n\n        // check path is the whole list\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n}"
    },
    {
        "product_commit": "18848574be543d01245b0e871c264f06592cc2b9",
        "test_commit": "18848574be543d01245b0e871c264f06592cc2b9",
        "product_file_path": "src/main/java/com/thealgorithms/searches/DepthFirstSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/DepthFirstSearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n */\npublic class DepthFirstSearch {\n\n    static class Node {\n\n        private final String name;\n        private final List<Node> subNodes;\n\n        public Node(final String name) {\n            this.name = name;\n            this.subNodes = new ArrayList<>();\n        }\n\n        public Node(final String name, final List<Node> subNodes) {\n            this.name = name;\n            this.subNodes = subNodes;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public List<Node> getSubNodes() {\n            return subNodes;\n        }\n    }\n\n    public static Optional<Node> search(final Node node, final String name) {\n        if (node.getName().equals(name)) {\n            return Optional.of(node);\n        }\n\n        return node.getSubNodes().stream().map(value -> search(value, name)).flatMap(Optional::stream).findAny();\n    }\n\n    public static void assertThat(final Object actual, final Object expected) {\n        if (!Objects.equals(actual, expected)) {\n            throw new AssertionError(String.format(\"expected=%s but was actual=%s\", expected, actual));\n        }\n    }\n\n    public static void main(final String[] args) {\n        final Node rootNode = new Node(\"A\", List.of(new Node(\"B\", List.of(new Node(\"D\"), new Node(\"F\", List.of(new Node(\"H\"), new Node(\"I\"))))), new Node(\"C\", List.of(new Node(\"G\"))), new Node(\"E\")));\n\n        {\n            final String expected = \"I\";\n\n            final Node result = search(rootNode, expected).orElseThrow(() -> new AssertionError(\"Node not found!\"));\n\n            assertThat(result.getName(), expected);\n        }\n\n        {\n            final String expected = \"G\";\n\n            final Node result = search(rootNode, expected).orElseThrow(() -> new AssertionError(\"Node not found!\"));\n\n            assertThat(result.getName(), expected);\n        }\n\n        {\n            final String expected = \"E\";\n\n            final Node result = search(rootNode, expected).orElseThrow(() -> new AssertionError(\"Node not found!\"));\n\n            assertThat(result.getName(), expected);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.datastructures.Node;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n * @wiki: https://en.wikipedia.org/wiki/Depth-first_search\n */\npublic class DepthFirstSearch<T> {\n\n    private final List<T> visited = new ArrayList<>();\n\n    public Optional<Node<T>> recursiveSearch(final Node<T> node, final Integer value) {\n        if (node == null) {\n            return Optional.empty();\n        }\n        visited.add(node.getValue());\n        if (node.getValue().equals(value)) {\n            return Optional.of(node);\n        }\n\n        return node.getChildren().stream().map(v -> recursiveSearch(v, value)).flatMap(Optional::stream).findAny();\n    }\n\n    public List<T> getVisited() {\n        return visited;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.datastructures.Node;\nimport java.util.List;\nimport java.util.Optional;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class DepthFirstSearchTest {\n\n    private Node<Integer> root;\n    private DepthFirstSearch<Integer> dfs;\n\n    //\n    // Tree structure:\n    //          1\n    //        / | \\\n    //       2  3  4\n    //      / \\\n    //     5   6\n\n    @BeforeEach\n    public void setUp() {\n        // nodes declaration\n        root = new Node<>(1);\n\n        var nodeB = new Node<>(2);\n        var nodeC = new Node<>(3);\n        var nodeD = new Node<>(4);\n\n        var nodeE = new Node<>(5);\n        var nodeF = new Node<>(6);\n\n        // tree initialization\n        root.addChild(nodeB);\n        root.addChild(nodeC);\n        root.addChild(nodeD);\n\n        nodeB.addChild(nodeE);\n        nodeB.addChild(nodeF);\n\n        // create an instance to monitor the visited nodes\n        dfs = new DepthFirstSearch<>();\n    }\n\n    @Test\n    public void testSearchRoot() {\n        Integer expectedValue = 1;\n        List<Integer> expectedPath = List.of(1);\n\n        // check value\n        Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);\n        assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());\n    }\n\n    @Test\n    public void testSearch4() {\n        Integer expectedValue = 4;\n        List<Integer> expectedPath = List.of(1, 2, 5, 6, 3, 4);\n\n        // check value\n        Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);\n        assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());\n    }\n\n    @Test\n    void testNullRoot() {\n        var value = dfs.recursiveSearch(null, 4);\n        assertTrue(value.isEmpty());\n    }\n\n    @Test\n    void testSearchValueThatNotExists() {\n        List<Integer> expectedPath = List.of(1, 2, 5, 6, 3, 4);\n        var value = dfs.recursiveSearch(root, 10);\n\n        // check that the value is empty because it's not exists in the tree\n        assertTrue(value.isEmpty());\n\n        // check path is the whole list\n        assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());\n    }\n}"
    },
    {
        "product_commit": "1ef700e8505e90e1df468f9e8164ed7e35e40a39",
        "test_commit": "1ef700e8505e90e1df468f9e8164ed7e35e40a39",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/IsEven.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/IsEvenTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Converts any Octal Number to a Binary Number\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class IsEven {\n    public static boolean isEven(int number) {\n        return (number & 1) == 0;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass IsEvenTest {\n    @Test\n    void testIsEven() {\n        assertEquals(true, IsEven.isEven(2));\n        assertEquals(true, IsEven.isEven(-12));\n        assertEquals(false, IsEven.isEven(21));\n    }\n}"
    },
    {
        "product_commit": "251157059c98ae6de54f85a9998094a0dbaedb63",
        "test_commit": "251157059c98ae6de54f85a9998094a0dbaedb63",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/ReverseBits.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/ReverseBitsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Converts any Octal Number to a Binary Number\n * @author Bama Charan Chhandogi\n */\n\npublic class ReverseBits {\n\n    public static int reverseBits(int n) {\n        int result = 0;\n        int bitCount = 32;\n        for (int i = 0; i < bitCount; i++) {\n            result <<= 1; // Left shift the result to make space for the next bit\n            result |= (n & 1); // OR operation to set the least significant bit of result with the current bit of n\n            n >>= 1; // Right shift n to move on to the next bit\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass ReverseBitsTest {\n\n    @Test\n    void testReverseBits() {\n        assertEquals(0, ReverseBits.reverseBits(0));\n        assertEquals(-1, ReverseBits.reverseBits(-1));\n        assertEquals(964176192, ReverseBits.reverseBits(43261596));\n    }\n}"
    },
    {
        "product_commit": "07945c77042614ae8d86de3048753f990c249f6e",
        "test_commit": "07945c77042614ae8d86de3048753f990c249f6e",
        "product_file_path": "src/main/java/com/thealgorithms/maths/StrobogrammaticNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/StrobogrammaticNumberTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A strobogrammatic number is a number that remains the same when rotated 180 degrees.\n * In other words, the number looks the same when rotated upside down.\n * Examples of strobogrammatic numbers are \"69\", \"88\", \"818\", and \"101\".\n * Numbers like \"609\" or \"120\" are not strobogrammatic because they do not look the same when rotated.\n */\npublic class StrobogrammaticNumber {\n    /**\n     * Check if a number is strobogrammatic\n     * @param number the number to be checked\n     * @return true if the number is strobogrammatic, false otherwise\n     */\n    public boolean isStrobogrammatic(String number) {\n        Map<Character, Character> strobogrammaticMap = new HashMap<>();\n        strobogrammaticMap.put('0', '0');\n        strobogrammaticMap.put('1', '1');\n        strobogrammaticMap.put('6', '9');\n        strobogrammaticMap.put('8', '8');\n        strobogrammaticMap.put('9', '6');\n\n        int left = 0;\n        int right = number.length() - 1;\n\n        while (left <= right) {\n            char leftChar = number.charAt(left);\n            char rightChar = number.charAt(right);\n\n            if (!strobogrammaticMap.containsKey(leftChar) || strobogrammaticMap.get(leftChar) != rightChar) {\n                return false;\n            }\n\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\nclass StrobogrammaticNumberTest {\n\n    @Test\n    void testIsStrobogrammatic() {\n        StrobogrammaticNumber strobogrammaticNumber = new StrobogrammaticNumber();\n        assertThat(strobogrammaticNumber.isStrobogrammatic(\"69\")).isTrue();\n        assertThat(strobogrammaticNumber.isStrobogrammatic(\"88\")).isTrue();\n        assertThat(strobogrammaticNumber.isStrobogrammatic(\"818\")).isTrue();\n        assertThat(strobogrammaticNumber.isStrobogrammatic(\"101\")).isTrue();\n        assertThat(strobogrammaticNumber.isStrobogrammatic(\"609\")).isTrue();\n        assertThat(strobogrammaticNumber.isStrobogrammatic(\"120\")).isFalse();\n    }\n}"
    },
    {
        "product_commit": "4fe419ebd894ba178e2f00cebef2157594f5042e",
        "test_commit": "4fe419ebd894ba178e2f00cebef2157594f5042e",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    public Node reverseList(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list[Iterative] from a given node till the end\n     *\n     */\n    public Node reverseListIter(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n    /**\n     * Reverse a singly linked list[Recursive] from a given node till the end\n     *\n     */\n    public Node reverseListRec(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Node prev = null;\n        Node h2 = reverseListRec(head.next);\n\n        head.next.next = head;\n        head.next = prev;\n\n        return h2;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseList(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseList(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseList(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseListIter(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseListIter(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseListIter(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n    // This is Recursive Reverse List Test\n    // Test to check whether the method reverseListRec() works fine\n    void RecursiveReverseList() {\n        // Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\n        SinglyLinkedList list = createSampleList(5);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list is: 5 -> 4 -> 3 -> 2 -> 1\n        assertEquals(5, head.value);\n        assertEquals(4, head.next.value);\n        assertEquals(3, head.next.next.value);\n        assertEquals(2, head.next.next.next.value);\n        assertEquals(1, head.next.next.next.next.value);\n    }\n\n    @Test\n    void RecursiveReverseListNullPointer() {\n        // Create an empty linked list\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the empty linked list\n        Node head = list.reverseListRec(first);\n\n        // Check if the head remains the same (null)\n        assertNull(head);\n    }\n\n    @Test\n    void RecursiveReverseListTest() {\n        // Create a linked list with values from 1 to 20\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list has the correct values\n        int i = 20;\n        Node temp = head;\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n}"
    },
    {
        "product_commit": "1ef5208b75553778c539f54642525b3644c67d4f",
        "test_commit": "1ef5208b75553778c539f54642525b3644c67d4f",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/MColoring.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/MColoringTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\nclass Node {\n    int color = 1;\n    Set<Integer> edges = new HashSet<Integer>();\n}\n\npublic class MColoring {\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n        // Create a visited array of n nodes\n        ArrayList<Integer> visited = new ArrayList<Integer>();\n        for (int i = 0; i < n + 1; i++) {\n            visited.add(0);\n        }\n\n        // maxColors used till now are 1 as\n        // all nodes are painted color 1\n        int maxColors = 1;\n\n        for (int sv = 1; sv <= n; sv++) {\n            if (visited.get(sv) > 0) {\n                continue;\n            }\n\n            // If the starting point is unvisited,\n            // mark it visited and push it in queue\n            visited.set(sv, 1);\n            Queue<Integer> q = new LinkedList<>();\n            q.add(sv);\n\n            // BFS\n            while (q.size() != 0) {\n                int top = q.peek();\n                q.remove();\n\n                // Checking all adjacent nodes\n                // to \"top\" edge in our queue\n                for (int it : nodes.get(top).edges) {\n\n                    // If the color of the\n                    // adjacent node is same, increase it by\n                    // 1\n                    if (nodes.get(top).color == nodes.get(it).color) {\n                        nodes.get(it).color += 1;\n                    }\n\n                    // If number of colors used exceeds m,\n                    // return 0\n                    maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                    if (maxColors > m) return 0;\n\n                    // If the adjacent node is not visited,\n                    // mark it visited and push it in queue\n                    if (visited.get(it) == 0) {\n                        visited.set(it, 1);\n                        q.add(it);\n                    }\n                }\n            }\n        }\n        return 1;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\nclass MColoringTest {\n\n    @Test\n    void testGraphColoring1() {\n        int n = 4;\n        int[][] graph = {{0, 1, 1, 1}, {1, 0, 1, 0}, {1, 1, 0, 1}, {1, 0, 1, 0}};\n        int m = 3; // Number of colors\n\n        assertEquals(1, MColoring.possiblePaint(createGraph(graph), n, m));\n    }\n\n    @Test\n    void testGraphColoring2() {\n        int n = 5;\n        int[][] graph = {{0, 1, 1, 1, 0}, {1, 0, 0, 1, 0}, {1, 0, 0, 1, 1}, {1, 1, 1, 0, 1}, {0, 0, 1, 1, 0}};\n        int m = 2; // Number of colors\n\n        assertEquals(0, MColoring.possiblePaint(createGraph(graph), n, m));\n    }\n\n    @Test\n    void testGraphColoring3() {\n        int n = 3;\n        int[][] graph = {{0, 1, 1}, {1, 0, 1}, {1, 1, 0}};\n        int m = 2; // Number of colors\n\n        assertEquals(0, MColoring.possiblePaint(createGraph(graph), n, m));\n    }\n\n    private ArrayList<Node> createGraph(int[][] graph) {\n        int n = graph.length;\n        ArrayList<Node> nodes = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            nodes.add(new Node());\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) { // Use j = i + 1 to avoid setting edges twice\n                if (graph[i][j] > 0) {\n                    nodes.get(i + 1).edges.add(j + 1);\n                    nodes.get(j + 1).edges.add(i + 1);\n                }\n            }\n        }\n        return nodes;\n    }\n}"
    },
    {
        "product_commit": "c4a9ef1566b290c3d30c72abbd8cda54ceb1270c",
        "test_commit": "c4a9ef1566b290c3d30c72abbd8cda54ceb1270c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PowerOfTwoOrNot.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PowerOfTwoOrNotTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * A utility to check if a given number is power of two or not. For example 8,16\n * etc.\n */\npublic class PowerOfTwoOrNot {\n\n    public static void main(String[] args) {\n        assert !checkIfPowerOfTwoOrNot(0);\n        assert checkIfPowerOfTwoOrNot(1);\n        assert checkIfPowerOfTwoOrNot(8);\n        assert checkIfPowerOfTwoOrNot(16);\n        assert checkIfPowerOfTwoOrNot(1024);\n    }\n\n    /**\n     * Checks whether given number is power of two or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if given number is power of two, otherwise\n     * {@code false}\n     */\n    public static boolean checkIfPowerOfTwoOrNot(int number) {\n        return number != 0 && ((number & (number - 1)) == 0);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * A utility to check if a given number is power of two or not. For example 8,16\n * etc.\n */\npublic final class PowerOfTwoOrNot {\n    private PowerOfTwoOrNot() {\n    }\n\n    /**\n     * Checks whether given number is power of two or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if given number is power of two, otherwise\n     * {@code false}\n     */\n    public static boolean checkIfPowerOfTwoOrNot(final int number) {\n        return number != 0 && ((number & (number - 1)) == 0);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class PowerOfTwoOrNotTest {\n    @Test\n    public void testPowerOfTwoOrNotForPowersOfTwo() {\n        final var powersOfTwo = new int[] {1, 2, 4, 8, 16, 32, 64};\n        for (final var n : powersOfTwo) {\n            assertTrue(PowerOfTwoOrNot.checkIfPowerOfTwoOrNot(n));\n        }\n    }\n\n    @Test\n    public void testPowerOfTwoOrNotForNotPowersOfTwo() {\n        final var notPowersOfTwo = new int[] {-16, -8, -6, -5, -4, -3, -2, -1, 0, 3, 5, 6, 7, 9, 10, 11, 33, 63, 65, 1000, 9999};\n        for (final var n : notPowersOfTwo) {\n            assertFalse(PowerOfTwoOrNot.checkIfPowerOfTwoOrNot(n));\n        }\n    }\n}"
    },
    {
        "product_commit": "ee23b6c2e5ef8023ec17e9a3634e61fd0eb80ea1",
        "test_commit": "ee23b6c2e5ef8023ec17e9a3634e61fd0eb80ea1",
        "product_file_path": "src/main/java/com/thealgorithms/maths/GenericRoot.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GenericRootTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Algorithm explanation:\n * https://technotip.com/6774/c-program-to-find-generic-root-of-a-number/#:~:text=Generic%20Root%3A%20of%20a%20number,get%20a%20single%2Ddigit%20output.&text=For%20Example%3A%20If%20user%20input,%2B%204%20%2B%205%20%3D%2015.\n */\npublic class GenericRoot {\n\n    public static void main(String[] args) {\n        int number1 = 1234;\n        int number2 = 12345;\n        int result1 = genericRoot(number1);\n        int result2 = genericRoot(number2);\n        System.out.println(\"Generic root of \" + number1 + \" is: \" + result1);\n        System.out.println(\"Generic root of \" + number2 + \" is: \" + result2);\n    }\n\n    private static int genericRoot(int n) {\n        int root = 0;\n        while (n > 0 || root > 9) {\n            if (n == 0) {\n                n = root;\n                root = 0;\n            }\n            root += n % 10;\n            n /= 10;\n        }\n        return root;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Algorithm explanation:\n * https://technotip.com/6774/c-program-to-find-generic-root-of-a-number/#:~:text=Generic%20Root%3A%20of%20a%20number,get%20a%20single%2Ddigit%20output.&text=For%20Example%3A%20If%20user%20input,%2B%204%20%2B%205%20%3D%2015.\n */\npublic final class GenericRoot {\n    private GenericRoot() {\n    }\n\n    private static int base = 10;\n\n    private static int sumOfDigits(final int n) {\n        assert n >= 0;\n        if (n < base) {\n            return n;\n        }\n        return n % base + sumOfDigits(n / base);\n    }\n\n    public static int genericRoot(final int n) {\n        if (n < 0) {\n            return genericRoot(-n);\n        }\n        if (n > base) {\n            return genericRoot(sumOfDigits(n));\n        }\n        return n;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static java.util.Map.entry;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class GenericRootTest {\n    private final Map<Integer, Integer> testCases = Map.ofEntries(entry(0, 0), entry(1, 1), entry(12345, 6), entry(123, 6), entry(15937, 7), entry(222222, 3), entry(99999, 9));\n    @Test\n    public void testGenericRoot() {\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), GenericRoot.genericRoot(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testGenericRootWithNegativeInputs() {\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), GenericRoot.genericRoot(-tc.getKey()));\n        }\n    }\n}"
    },
    {
        "product_commit": "f83008d80a7729dc73948886b1879b1d4d93a894",
        "test_commit": "f83008d80a7729dc73948886b1879b1d4d93a894",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Factorial.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FactorialTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class Factorial {\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        assert factorial(0) == 1;\n        assert factorial(1) == 1;\n        assert factorial(5) == 120;\n        assert factorial(10) == 3628800;\n    }\n\n    /**\n     * Calculate factorial N using iteration\n     *\n     * @param n the number\n     * @return the factorial of {@code n}\n     */\n    public static long factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"number is negative\");\n        }\n        long factorial = 1;\n        for (int i = 1; i <= n; factorial *= i, ++i)\n            ;\n        return factorial;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class Factorial {\n    /**\n     * Calculate factorial N using iteration\n     *\n     * @param n the number\n     * @return the factorial of {@code n}\n     */\n    public static long factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"Input number cannot be negative\");\n        }\n        long factorial = 1;\n        for (int i = 1; i <= n; ++i) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FactorialTest {\n\n    @Test\n    public void test() {\n        assertEquals(120, Factorial.factorial(5));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FactorialTest {\n    private static final String EXCEPTION_MESSAGE = \"Input number cannot be negative\";\n\n    @Test\n    public void testWhenInvalidInoutProvidedShouldThrowException() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> Factorial.factorial(-1));\n        assertEquals(exception.getMessage(), EXCEPTION_MESSAGE);\n    }\n\n    @Test\n    public void testCorrectFactorialCalculation() {\n        assertEquals(1, Factorial.factorial(0));\n        assertEquals(1, Factorial.factorial(1));\n        assertEquals(120, Factorial.factorial(5));\n        assertEquals(3628800, Factorial.factorial(10));\n    }\n}"
    },
    {
        "product_commit": "fc274c84f8f64ad4a874342736696c6293c78121",
        "test_commit": "fc274c84f8f64ad4a874342736696c6293c78121",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AmicableNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AmicableNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Amicable numbers are two different numbers so related that the sum of the\n * proper divisors of each is equal to the other number. (A proper divisor of a\n * number is a positive factor of that number other than the number itself. For\n * example, the proper divisors of 6 are 1, 2, and 3.) A pair of amicable\n * numbers constitutes an aliquot sequence of period 2. It is unknown if there\n * are infinitely many pairs of amicable numbers. *\n *\n * <p>\n * link: https://en.wikipedia.org/wiki/Amicable_numbers *\n *\n * <p>\n * Simple Example : (220,284) 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110\n * } <- Sum = 284\n * 284 is divisible by -> 1,2,4,71,142 and the Sum of that is. Yes right you\n * probably expected it 220\n */\npublic class AmicableNumber {\n\n    public static void main(String[] args) {\n        AmicableNumber.findAllInRange(1, 3000);\n        /* Res -> Int Range of 1 till 3000there are 3Amicable_numbers These are  1: = ( 220,284)\n    2: = ( 1184,1210) 3: = ( 2620,2924) So it worked\t*/\n    }\n\n    /**\n     * @param startValue\n     * @param stopValue\n     * @return\n     */\n    static void findAllInRange(int startValue, int stopValue) {\n        /* the 2 for loops are to avoid to double check tuple. For example (200,100) and (100,200)\n         * is the same calculation also to avoid is to check the number with it self. a number with\n         * itself is always a AmicableNumber\n         * */\n        StringBuilder res = new StringBuilder();\n        int countofRes = 0;\n\n        for (int i = startValue; i < stopValue; i++) {\n            for (int j = i + 1; j <= stopValue; j++) {\n                if (isAmicableNumber(i, j)) {\n                    countofRes++;\n                    res.append(\"\" + countofRes + \": = ( \" + i + \",\" + j + \")\"\n                        + \"\\t\");\n                }\n            }\n        }\n        res.insert(0, \"Int Range of \" + startValue + \" till \" + stopValue + \" there are \" + countofRes + \" Amicable_numbers.These are \\n \");\n        System.out.println(res);\n    }\n\n    /**\n     * Check if {@code numberOne and numberTwo } are AmicableNumbers or not\n     *\n     * @param numberOne numberTwo\n     * @return {@code true} if {@code numberOne numberTwo} isAmicableNumbers\n     * otherwise false\n     */\n    static boolean isAmicableNumber(int numberOne, int numberTwo) {\n        return ((recursiveCalcOfDividerSum(numberOne, numberOne) == numberTwo && numberOne == recursiveCalcOfDividerSum(numberTwo, numberTwo)));\n    }\n\n    /**\n     * calculated in recursive calls the Sum of all the Dividers beside it self\n     *\n     * @param number div = the next to test dividely by using the modulo\n     * operator\n     * @return sum of all the dividers\n     */\n    static int recursiveCalcOfDividerSum(int number, int div) {\n        if (div == 1) {\n            return 0;\n        } else if (number % --div == 0) {\n            return recursiveCalcOfDividerSum(number, div) + div;\n        } else {\n            return recursiveCalcOfDividerSum(number, div);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport org.apache.commons.lang3.tuple.Pair;\n\n/**\n * Amicable numbers are two different natural numbers that the sum of the\n * proper divisors of each is equal to the other number.\n * (A proper divisor of a number is a positive factor of that number other than the number itself.\n * For example, the proper divisors of 6 are 1, 2, and 3.)\n * A pair of amicable numbers constitutes an aliquot sequence of period 2.\n * It is unknown if there are infinitely many pairs of amicable numbers.\n *\n * <p>\n * link: https://en.wikipedia.org/wiki/Amicable_numbers\n * <p>\n * Simple Example : (220, 284)\n * 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110} <- SUM = 284\n * 284 is divisible by {1,2,4,71,142} <- SUM = 220.\n */\npublic class AmicableNumber {\n    /**\n     * Finds all the amicable numbers in a given range.\n     *\n     * @param from range start value\n     * @param to   range end value (inclusive)\n     * @return list with amicable numbers found in given range.\n     */\n    public static Set<Pair<Integer, Integer>> findAllInRange(int from, int to) {\n        if (from <= 0 || to <= 0 || to < from) {\n            throw new IllegalArgumentException(\"Given range of values is invalid!\");\n        }\n\n        Set<Pair<Integer, Integer>> result = new LinkedHashSet<>();\n\n        for (int i = from; i < to; i++) {\n            for (int j = i + 1; j <= to; j++) {\n                if (isAmicableNumber(i, j)) {\n                    result.add(Pair.of(i, j));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether 2 numbers are AmicableNumbers or not.\n     */\n    public static boolean isAmicableNumber(int a, int b) {\n        if (a <= 0 || b <= 0) {\n            throw new IllegalArgumentException(\"Input numbers must be natural!\");\n        }\n        return sumOfDividers(a, a) == b && sumOfDividers(b, b) == a;\n    }\n\n    /**\n     * Recursively calculates the sum of all dividers for a given number excluding the divider itself.\n     */\n    private static int sumOfDividers(int number, int divisor) {\n        if (divisor == 1) {\n            return 0;\n        } else if (number % --divisor == 0) {\n            return sumOfDividers(number, divisor) + divisor;\n        } else {\n            return sumOfDividers(number, divisor);\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AmicableNumberTest {\n\n    @Test\n    void testAmicableNumber() {\n        assertThat(AmicableNumber.isAmicableNumber(220, 284)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(1184, 1210)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(2620, 2924)).isTrue();\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Set;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class AmicableNumberTest {\n    private static final String INVALID_RANGE_EXCEPTION_MESSAGE = \"Given range of values is invalid!\";\n    private static final String INVALID_NUMBERS_EXCEPTION_MESSAGE = \"Input numbers must be natural!\";\n\n    @Test\n    public void testShouldThrowExceptionWhenInvalidRangeProvided() {\n        checkInvalidRange(0, 0);\n        checkInvalidRange(0, 1);\n        checkInvalidRange(1, 0);\n        checkInvalidRange(10, -1);\n        checkInvalidRange(-1, 10);\n    }\n\n    @Test\n    public void testShouldThrowExceptionWhenInvalidNumbersProvided() {\n        checkInvalidNumbers(0, 0);\n        checkInvalidNumbers(0, 1);\n        checkInvalidNumbers(1, 0);\n    }\n\n    @Test\n    public void testAmicableNumbers() {\n        assertThat(AmicableNumber.isAmicableNumber(220, 284)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(1184, 1210)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(2620, 2924)).isTrue();\n    }\n\n    @Test\n    public void testShouldFindAllAmicableNumbersInRange() {\n        // given\n        var expectedResult = Set.of(Pair.of(220, 284), Pair.of(1184, 1210), Pair.of(2620, 2924));\n\n        // when\n        Set<Pair<Integer, Integer>> result = AmicableNumber.findAllInRange(1, 3000);\n\n        // then\n        Assertions.assertTrue(result.containsAll(expectedResult));\n    }\n\n    private static void checkInvalidRange(int from, int to) {\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> AmicableNumber.findAllInRange(from, to));\n        Assertions.assertEquals(exception.getMessage(), INVALID_RANGE_EXCEPTION_MESSAGE);\n    }\n\n    private static void checkInvalidNumbers(int a, int b) {\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> AmicableNumber.isAmicableNumber(a, b));\n        Assertions.assertEquals(exception.getMessage(), INVALID_NUMBERS_EXCEPTION_MESSAGE);\n    }\n}"
    },
    {
        "product_commit": "e5c7a08874a6c7ff043ec5e3f44b3aac553f4e53",
        "test_commit": "44dcebb6996b39b5a1a67a8633f95b6e4c1bd0f0",
        "product_file_path": "src/main/java/com/thealgorithms/others/StackPostfixNotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/StackPostfixNotationTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic final class StackPostfixNotation {\n    private StackPostfixNotation() {\n    }\n\n    // Evaluates the given postfix expression string and returns the result.\n    public static int postfixEvaluate(final String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt()); // If int then push to stack\n            } else { // else pop top two values and perform the operation\n                int num2 = s.pop();\n                int num1 = s.pop();\n                String op = tokens.next();\n\n                switch (op) {\n                    case \"+\" -> s.push(num1 + num2);\n                    case \"-\" -> s.push(num1 - num2);\n                    case \"*\" -> s.push(num1 * num2);\n                    case \"/\" -> s.push(num1 / num2);\n                    default -> throw new IllegalArgumentException(\"exp contains an unknown operation.\");\n                }\n                //  \"+\", \"-\", \"*\", \"/\"\n            }\n        }\n        tokens.close();\n        if (s.size() != 1) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression.\");\n        }\n        return s.pop();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic final class StackPostfixNotation {\n    private StackPostfixNotation() {\n    }\n\n    // Evaluates the given postfix expression string and returns the result.\n    public static int postfixEvaluate(final String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt()); // If int then push to stack\n            } else { // else pop top two values and perform the operation\n                if (s.size() < 2) {\n                    throw new IllegalArgumentException(\"exp is not a proper postfix expression (too few arguments).\");\n                }\n                int num2 = s.pop();\n                int num1 = s.pop();\n                String op = tokens.next();\n\n                switch (op) {\n                    case \"+\" -> s.push(num1 + num2);\n                    case \"-\" -> s.push(num1 - num2);\n                    case \"*\" -> s.push(num1 * num2);\n                    case \"/\" -> s.push(num1 / num2);\n                    default -> throw new IllegalArgumentException(\"exp contains an unknown operation.\");\n                }\n                //  \"+\", \"-\", \"*\", \"/\"\n            }\n        }\n        tokens.close();\n        if (s.size() != 1) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression.\");\n        }\n        return s.pop();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static java.util.Map.entry;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class StackPostfixNotationTest {\n    @Test\n    public void testEvaluate() {\n        final Map<String, Integer> testCases = Map.ofEntries(entry(\"1 1 +\", 2), entry(\"2 3 *\", 6), entry(\"6 2 /\", 3), entry(\"-5 -2 -\", -3), entry(\"5 2 + 3 *\", 21), entry(\"-5\", -5));\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), StackPostfixNotation.postfixEvaluate(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInproperInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 3\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithUnknownOperation() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 !\"));\n    }\n}"
    },
    {
        "product_commit": "44dcebb6996b39b5a1a67a8633f95b6e4c1bd0f0",
        "test_commit": "44dcebb6996b39b5a1a67a8633f95b6e4c1bd0f0",
        "product_file_path": "src/main/java/com/thealgorithms/others/StackPostfixNotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/StackPostfixNotationTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.*;\n\npublic class StackPostfixNotation {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String post = scanner.nextLine(); // Takes input with spaces in between eg. \"1 21 +\"\n        System.out.println(postfixEvaluate(post));\n        scanner.close();\n    }\n\n    // Evaluates the given postfix expression string and returns the result.\n    public static int postfixEvaluate(String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt()); // If int then push to stack\n            } else { // else pop top two values and perform the operation\n                int num2 = s.pop();\n                int num1 = s.pop();\n                String op = tokens.next();\n\n                switch (op) {\n                    case \"+\" -> s.push(num1 + num2);\n                    case \"-\" -> s.push(num1 - num2);\n                    case \"*\" -> s.push(num1 * num2);\n                    default -> s.push(num1 / num2);\n                }\n                //  \"+\", \"-\", \"*\", \"/\"\n            }\n        }\n        tokens.close();\n        return s.pop();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic final class StackPostfixNotation {\n    private StackPostfixNotation() {\n    }\n\n    // Evaluates the given postfix expression string and returns the result.\n    public static int postfixEvaluate(final String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt()); // If int then push to stack\n            } else { // else pop top two values and perform the operation\n                int num2 = s.pop();\n                int num1 = s.pop();\n                String op = tokens.next();\n\n                switch (op) {\n                    case \"+\" -> s.push(num1 + num2);\n                    case \"-\" -> s.push(num1 - num2);\n                    case \"*\" -> s.push(num1 * num2);\n                    case \"/\" -> s.push(num1 / num2);\n                    default -> throw new IllegalArgumentException(\"exp contains an unknown operation.\");\n                }\n                //  \"+\", \"-\", \"*\", \"/\"\n            }\n        }\n        tokens.close();\n        if (s.size() != 1) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression.\");\n        }\n        return s.pop();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static java.util.Map.entry;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class StackPostfixNotationTest {\n    @Test\n    public void testEvaluate() {\n        final Map<String, Integer> testCases = Map.ofEntries(entry(\"1 1 +\", 2), entry(\"2 3 *\", 6), entry(\"6 2 /\", 3), entry(\"-5 -2 -\", -3), entry(\"5 2 + 3 *\", 21), entry(\"-5\", -5));\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), StackPostfixNotation.postfixEvaluate(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInproperInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 3\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithUnknownOperation() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 !\"));\n    }\n}"
    },
    {
        "product_commit": "dec3b98e4b701322f8e2a6fc05d7e4f0e472daf9",
        "test_commit": "dec3b98e4b701322f8e2a6fc05d7e4f0e472daf9",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FibonacciJavaStreams.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FibonacciJavaStreamsTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.stream.Stream;\n\n/**\n * @author: caos321\n * @date: 14 October 2021 (Thursday)\n */\npublic class FibonacciJavaStreams {\n\n    public static Optional<BigDecimal> calculate(final BigDecimal index) {\n        if (index == null || index.compareTo(BigDecimal.ZERO) < 0) {\n            return Optional.empty();\n        }\n\n        if (index.compareTo(BigDecimal.ONE) < 0) {\n            return Optional.of(BigDecimal.ZERO);\n        }\n\n        if (index.compareTo(new BigDecimal(2)) < 0) {\n            return Optional.of(BigDecimal.ONE);\n        }\n\n        final List<BigDecimal> results = Stream.iterate(index, x -> x.compareTo(BigDecimal.ZERO) > 0, x -> x.subtract(BigDecimal.ONE))\n                                             .reduce(List.of(), (list, current) -> list.isEmpty() || list.size() < 2 ? List.of(BigDecimal.ZERO, BigDecimal.ONE) : List.of(list.get(1), list.get(0).add(list.get(1))), (list1, list2) -> list1);\n\n        return results.isEmpty() ? Optional.empty() : Optional.of(results.get(results.size() - 1));\n    }\n\n    public static void assertThat(final Object actual, final Object expected) {\n        if (!Objects.equals(actual, expected)) {\n            throw new AssertionError(String.format(\"expected=%s but was actual=%s\", expected, actual));\n        }\n    }\n\n    public static void main(final String[] args) {\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(-1));\n            assertThat(result.isEmpty(), true);\n        }\n        {\n            final Optional<BigDecimal> result = calculate(BigDecimal.ZERO);\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, BigDecimal.ZERO));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(BigDecimal.ONE);\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(2));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(3));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(2)));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(10));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(55)));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(20));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(6765)));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(30));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(832040)));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(40));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(102334155)));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(50));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(12586269025L)));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(100));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(\"354224848179261915075\")));\n        }\n        {\n            final Optional<BigDecimal> result = calculate(new BigDecimal(200));\n            assertThat(result.isPresent(), true);\n            result.ifPresent(value -> assertThat(value, new BigDecimal(\"280571172992510140037611932413038677189525\")));\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Stream;\n\n/**\n * @author: caos321\n * @date: 14 October 2021 (Thursday)\n */\npublic class FibonacciJavaStreams {\n\n    public static Optional<BigDecimal> calculate(final BigDecimal index) {\n        if (index == null || index.compareTo(BigDecimal.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Input index cannot be null or negative!\");\n        }\n\n        if (index.compareTo(BigDecimal.ONE) < 0) {\n            return Optional.of(BigDecimal.ZERO);\n        }\n\n        if (index.compareTo(new BigDecimal(2)) < 0) {\n            return Optional.of(BigDecimal.ONE);\n        }\n\n        final List<BigDecimal> results = Stream.iterate(index, x -> x.compareTo(BigDecimal.ZERO) > 0, x -> x.subtract(BigDecimal.ONE))\n                                             .reduce(List.of(), (list, current) -> list.isEmpty() || list.size() < 2 ? List.of(BigDecimal.ZERO, BigDecimal.ONE) : List.of(list.get(1), list.get(0).add(list.get(1))), (list1, list2) -> list1);\n\n        return results.isEmpty() ? Optional.empty() : Optional.of(results.get(results.size() - 1));\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport java.math.BigDecimal;\nimport java.util.Optional;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 25/07/2023\n */\npublic class FibonacciJavaStreamsTest {\n    private static final String EXCEPTION_MESSAGE = \"Input index cannot be null or negative!\";\n\n    @Test\n    public void testWithNegativeIndexShouldThrowException() {\n        Exception exception = Assertions.assertThrows(IllegalArgumentException.class, () -> FibonacciJavaStreams.calculate(new BigDecimal(-1)));\n        Assertions.assertEquals(EXCEPTION_MESSAGE, exception.getMessage());\n    }\n\n    @Test\n    public void testCheckTheFirst4SequenceElements() {\n        checkElement(BigDecimal.ZERO, BigDecimal.ZERO);\n        checkElement(BigDecimal.ONE, BigDecimal.ONE);\n        checkElement(new BigDecimal(2), BigDecimal.ONE);\n        checkElement(new BigDecimal(3), new BigDecimal(2));\n    }\n\n    @Test\n    public void testCheck10thSequenceElement() {\n        checkElement(new BigDecimal(10), new BigDecimal(55));\n    }\n\n    @Test\n    public void testCheck20thSequenceElement() {\n        checkElement(new BigDecimal(20), new BigDecimal(6765));\n    }\n\n    @Test\n    public void testCheck30thSequenceElement() {\n        checkElement(new BigDecimal(30), new BigDecimal(832040));\n    }\n\n    @Test\n    public void testCheck40thSequenceElement() {\n        checkElement(new BigDecimal(40), new BigDecimal(102334155));\n    }\n\n    @Test\n    public void testCheck50thSequenceElement() {\n        checkElement(new BigDecimal(50), new BigDecimal(12586269025L));\n    }\n\n    @Test\n    public void testCheck100thSequenceElement() {\n        checkElement(new BigDecimal(100), new BigDecimal(\"354224848179261915075\"));\n    }\n\n    @Test\n    public void testCheck200thSequenceElement() {\n        checkElement(new BigDecimal(200), new BigDecimal(\"280571172992510140037611932413038677189525\"));\n    }\n\n    private static void checkElement(BigDecimal index, BigDecimal expected) {\n        // when\n        Optional<BigDecimal> result = FibonacciJavaStreams.calculate(index);\n\n        // then\n        Assertions.assertTrue(result.isPresent());\n        Assertions.assertEquals(result.get(), expected);\n    }\n}"
    },
    {
        "product_commit": "06ef351987706c6fba2786c8024545376b42485a",
        "test_commit": "06ef351987706c6fba2786c8024545376b42485a",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SumOfArithmeticSeries.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SumOfArithmeticSeriesTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * In mathematics, an arithmetic progression (AP) or arithmetic sequence is a\n * sequence of numbers such that the difference between the consecutive terms is\n * constant. Difference here means the second minus the first. For instance, the\n * sequence 5, 7, 9, 11, 13, 15, . . . is an arithmetic progression with common\n * difference of 2.\n *\n * <p>\n * Wikipedia: https://en.wikipedia.org/wiki/Arithmetic_progression\n */\npublic class SumOfArithmeticSeries {\n\n    public static void main(String[] args) {\n        /* 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 */\n        assert Double.compare(55.0, sumOfSeries(1, 1, 10)) == 0;\n\n        /* 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17 + 19 */\n        assert Double.compare(100.0, sumOfSeries(1, 2, 10)) == 0;\n\n        /* 1 + 11 + 21 + 31 + 41 + 51 + 61 + 71 + 81 + 91 */\n        assert Double.compare(460.0, sumOfSeries(1, 10, 10)) == 0;\n\n        /* 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 0.6 + 0.7 + 0.8 + 0.9 + 1.0 */\n        assert Double.compare(5.5, sumOfSeries(0.1, 0.1, 10)) == 0;\n\n        assert Double.compare(49600.0, sumOfSeries(1, 10, 100)) == 0;\n    }\n\n    /**\n     * Calculate sum of arithmetic series\n     *\n     * @param firstTerm the initial term of an arithmetic series\n     * @param commonDiff the common difference of an arithmetic series\n     * @param numOfTerms the total terms of an arithmetic series\n     * @return sum of given arithmetic series\n     */\n    private static double sumOfSeries(double firstTerm, double commonDiff, int numOfTerms) {\n        return (numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * In mathematics, an arithmetic progression (AP) or arithmetic sequence is a\n * sequence of numbers such that the difference between the consecutive terms is\n * constant. Difference here means the second minus the first. For instance, the\n * sequence 5, 7, 9, 11, 13, 15, . . . is an arithmetic progression with common\n * difference of 2.\n *\n * <p>\n * Wikipedia: https://en.wikipedia.org/wiki/Arithmetic_progression\n */\npublic final class SumOfArithmeticSeries {\n    private SumOfArithmeticSeries() {\n    }\n\n    /**\n     * Calculate sum of arithmetic series\n     *\n     * @param firstTerm the initial term of an arithmetic series\n     * @param commonDiff the common difference of an arithmetic series\n     * @param numOfTerms the total terms of an arithmetic series\n     * @return sum of given arithmetic series\n     */\n    public static double sumOfSeries(final double firstTerm, final double commonDiff, final int numOfTerms) {\n        if (numOfTerms < 0) {\n            throw new IllegalArgumentException(\"numOfTerms nonnegative.\");\n        }\n        return (numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff));\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SumOfArithmeticSeriesTest {\n    @Test\n    public void testSumFrom1To10() {\n        assertEquals(55.0, SumOfArithmeticSeries.sumOfSeries(1.0, 1.0, 10));\n    }\n\n    @Test\n    public void testSumOfOddNumbers1To19() {\n        assertEquals(100.0, SumOfArithmeticSeries.sumOfSeries(1.0, 2.0, 10));\n    }\n\n    @Test\n    public void testA() {\n        assertEquals(460.0, SumOfArithmeticSeries.sumOfSeries(1.0, 10.0, 10));\n    }\n\n    @Test\n    public void testB() {\n        assertEquals(5.5, SumOfArithmeticSeries.sumOfSeries(0.1, 0.1, 10));\n    }\n\n    @Test\n    public void testC() {\n        assertEquals(49600.0, SumOfArithmeticSeries.sumOfSeries(1, 10, 100));\n    }\n\n    @Test\n    public void testForZeroTerms() {\n        assertEquals(0.0, SumOfArithmeticSeries.sumOfSeries(1.0, 100.0, 0), 0.00001);\n    }\n\n    @Test\n    public void testIfThrowsExceptionForNegativeNumberOfTerms() {\n        assertThrows(IllegalArgumentException.class, () -> SumOfArithmeticSeries.sumOfSeries(1.0, 1.0, -1));\n    }\n\n    @Test\n    public void testWithSingleTerm() {\n        assertEquals(123.0, SumOfArithmeticSeries.sumOfSeries(123.0, 5.0, 1));\n    }\n\n    @Test\n    public void testWithZeroCommonDiff() {\n        assertEquals(100.0, SumOfArithmeticSeries.sumOfSeries(1.0, 0.0, 100));\n    }\n}"
    },
    {
        "product_commit": "2488a2ad51bd4d15309449b6d88bbf8eb33fd29b",
        "test_commit": "2488a2ad51bd4d15309449b6d88bbf8eb33fd29b",
        "product_file_path": "src/main/java/com/thealgorithms/others/cn/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/cn/HammingDistanceTest.java",
        "product_old_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nfinal public class HammingDistance {\n    private HammingDistance() {\n    }\n\n    private static void checkChar(char inChar) {\n        if (inChar != '0' && inChar != '1') {\n            throw new IllegalArgumentException(\"Input must be a binary string.\");\n        }\n    }\n\n    public static int compute(char charA, char charB) {\n        checkChar(charA);\n        checkChar(charB);\n        return charA == charB ? 0 : 1;\n    }\n\n    public static int compute(String bitsStrA, String bitsStrB) {\n        if (bitsStrA.length() != bitsStrB.length()) {\n            throw new IllegalArgumentException(\"Input strings must have the same length.\");\n        }\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < bitsStrA.length(); i++) {\n            totalErrorBitCount += compute(bitsStrA.charAt(i), bitsStrB.charAt(i));\n        }\n\n        return totalErrorBitCount;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others.cn;\n\nfinal public class HammingDistance {\n    private HammingDistance() {\n    }\n\n    private static void checkChar(char inChar) {\n        if (inChar != '0' && inChar != '1') {\n            throw new IllegalArgumentException(\"Input must be a binary string.\");\n        }\n    }\n\n    public static int compute(char charA, char charB) {\n        checkChar(charA);\n        checkChar(charB);\n        return charA == charB ? 0 : 1;\n    }\n\n    public static int compute(String bitsStrA, String bitsStrB) {\n        if (bitsStrA.length() != bitsStrB.length()) {\n            throw new IllegalArgumentException(\"Input strings must have the same length.\");\n        }\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < bitsStrA.length(); i++) {\n            totalErrorBitCount += compute(bitsStrA.charAt(i), bitsStrB.charAt(i));\n        }\n\n        return totalErrorBitCount;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n    @Test\n    public void checkForDifferentBits() {\n        int answer = HammingDistance.compute(\"000\", \"011\");\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        int answer = HammingDistance.compute(\"10101\", \"11110\");\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String someBits = \"111\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        int answer = HammingDistance.compute(\"10010101101010000100110100\", \"00110100001011001100110101\");\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"100010\", \"00011\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void mismatchDataBits2() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"1\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String someBits = \"10010101101010000100110100\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForEmptyInput() {\n        String someBits = \"\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForInputOfLength1() {\n        String someBits = \"0\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void computeThrowsExceptionWhenInputsAreNotBitStrs() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"1A\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must be a binary string\");\n    }\n}",
        "test_new_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n    @Test\n    public void checkForDifferentBits() {\n        int answer = HammingDistance.compute(\"000\", \"011\");\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        int answer = HammingDistance.compute(\"10101\", \"11110\");\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String someBits = \"111\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        int answer = HammingDistance.compute(\"10010101101010000100110100\", \"00110100001011001100110101\");\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { HammingDistance.compute(\"100010\", \"00011\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void mismatchDataBits2() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { HammingDistance.compute(\"1\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String someBits = \"10010101101010000100110100\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForEmptyInput() {\n        String someBits = \"\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForInputOfLength1() {\n        String someBits = \"0\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void computeThrowsExceptionWhenInputsAreNotBitStrs() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { HammingDistance.compute(\"1A\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must be a binary string\");\n    }\n}"
    },
    {
        "product_commit": "9ecc3aae59fd97929449974267015f2c0f158a4a",
        "test_commit": "9ecc3aae59fd97929449974267015f2c0f158a4a",
        "product_file_path": "src/main/java/com/thealgorithms/strings/CheckAnagrams.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/CheckAnagramsTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Two strings are anagrams if they are made of the same letters arranged\n * differently (ignoring the case).\n */\npublic class CheckAnagrams {\n\n    public static void main(String[] args) {\n        assert isAnagrams(\"Silent\", \"Listen\");\n        assert isAnagrams(\"This is a string\", \"Is this a string\");\n        assert !isAnagrams(\"There\", \"Their\");\n    }\n\n    /**\n     * Check if two strings are anagrams or not\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code true} if two string are anagrams, otherwise {@code false}\n     */\n    public static boolean isAnagrams(String s1, String s2) {\n        int l1 = s1.length();\n        int l2 = s2.length();\n        s1 = s1.toLowerCase();\n        s2 = s2.toLowerCase();\n        Map<Character, Integer> charAppearances = new HashMap<>();\n\n        for (int i = 0; i < l1; i++) {\n            char c = s1.charAt(i);\n            int numOfAppearances = charAppearances.getOrDefault(c, 0);\n            charAppearances.put(c, numOfAppearances + 1);\n        }\n\n        for (int i = 0; i < l2; i++) {\n            char c = s2.charAt(i);\n            if (!charAppearances.containsKey(c)) {\n                return false;\n            }\n            charAppearances.put(c, charAppearances.get(c) - 1);\n        }\n\n        for (int cnt : charAppearances.values()) {\n            if (cnt != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Two strings are anagrams if they are made of the same letters arranged\n * differently (ignoring the case).\n */\npublic class CheckAnagrams {\n    /**\n     * Check if two strings are anagrams or not\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code true} if two string are anagrams, otherwise {@code false}\n     */\n    public static boolean isAnagrams(String s1, String s2) {\n        int l1 = s1.length();\n        int l2 = s2.length();\n        s1 = s1.toLowerCase();\n        s2 = s2.toLowerCase();\n        Map<Character, Integer> charAppearances = new HashMap<>();\n\n        for (int i = 0; i < l1; i++) {\n            char c = s1.charAt(i);\n            int numOfAppearances = charAppearances.getOrDefault(c, 0);\n            charAppearances.put(c, numOfAppearances + 1);\n        }\n\n        for (int i = 0; i < l2; i++) {\n            char c = s2.charAt(i);\n            if (!charAppearances.containsKey(c)) {\n                return false;\n            }\n            charAppearances.put(c, charAppearances.get(c) - 1);\n        }\n\n        for (int cnt : charAppearances.values()) {\n            if (cnt != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If given strings contain Unicode symbols.\n     * The first 128 ASCII codes are identical to Unicode.\n     * This algorithm is case-sensitive.\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return true if two string are anagrams, otherwise false\n     */\n    public static boolean isAnagramsUnicode(String s1, String s2) {\n        int[] dict = new int[128];\n        for (char ch : s1.toCharArray()) {\n            dict[ch]++;\n        }\n        for (char ch : s2.toCharArray()) {\n            dict[ch]--;\n        }\n        for (int e : dict) {\n            if (e != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * If given strings contain only lowercase English letters.\n     * <p>\n     * The main \"trick\":\n     * To map each character from the first string 's1' we need to subtract an integer value of 'a' character\n     * as 'dict' array starts with 'a' character.\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return true if two string are anagrams, otherwise false\n     */\n    public static boolean isAnagramsOptimised(String s1, String s2) {\n        // 26 - English alphabet length\n        int[] dict = new int[26];\n        for (char ch : s1.toCharArray()) {\n            checkLetter(ch);\n            dict[ch - 'a']++;\n        }\n        for (char ch : s2.toCharArray()) {\n            checkLetter(ch);\n            dict[ch - 'a']--;\n        }\n        for (int e : dict) {\n            if (e != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static void checkLetter(char ch) {\n        int index = ch - 'a';\n        if (index < 0 || index >= 26) {\n            throw new IllegalArgumentException(\"Strings must contain only lowercase English letters!\");\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CheckAnagramsTest {\n\n    @Test\n    public void CheckAnagrams() {\n        String testString1 = \"STUDY\";\n        String testString2 = \"DUSTY\";\n        assertTrue(CheckAnagrams.isAnagrams(testString1, testString2));\n    }\n\n    @Test\n    public void CheckFalseAnagrams() {\n        String testString1 = \"STUDY\";\n        String testString2 = \"random\";\n        assertFalse(CheckAnagrams.isAnagrams(testString1, testString2));\n    }\n\n    @Test\n    public void CheckSameWordAnagrams() {\n        String testString1 = \"STUDY\";\n        assertTrue(CheckAnagrams.isAnagrams(testString1, testString1));\n    }\n\n    @Test\n    public void CheckDifferentCasesAnagram() {\n        String testString1 = \"STUDY\";\n        String testString2 = \"dusty\";\n        assertTrue(CheckAnagrams.isAnagrams(testString1, testString2));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class CheckAnagramsTest {\n    private static final String MESSAGE = \"Strings must contain only lowercase English letters!\";\n\n    // CHECK METHOD isAnagrams()\n    @Test\n    public void testCheckAnagrams() {\n        String testString1 = \"STUDY\";\n        String testString2 = \"DUSTY\";\n        Assertions.assertTrue(CheckAnagrams.isAnagrams(testString1, testString2));\n    }\n\n    @Test\n    public void testCheckFalseAnagrams() {\n        String testString1 = \"STUDY\";\n        String testString2 = \"random\";\n        Assertions.assertFalse(CheckAnagrams.isAnagrams(testString1, testString2));\n    }\n\n    @Test\n    public void testCheckSameWordAnagrams() {\n        String testString1 = \"STUDY\";\n        Assertions.assertTrue(CheckAnagrams.isAnagrams(testString1, testString1));\n    }\n\n    @Test\n    public void testCheckDifferentCasesAnagram() {\n        String testString1 = \"STUDY\";\n        String testString2 = \"dusty\";\n        Assertions.assertTrue(CheckAnagrams.isAnagrams(testString1, testString2));\n    }\n\n    // CHECK METHOD isAnagramsUnicode()\n    // Below tests work with strings which consist of Unicode symbols & the algorithm is case-sensitive.\n    @Test\n    public void testStringAreValidAnagramsCaseSensitive() {\n        Assertions.assertTrue(CheckAnagrams.isAnagramsUnicode(\"Silent\", \"liSten\"));\n        Assertions.assertTrue(CheckAnagrams.isAnagramsUnicode(\"This is a string\", \"is This a string\"));\n    }\n\n    @Test\n    public void testStringAreNotAnagramsCaseSensitive() {\n        Assertions.assertFalse(CheckAnagrams.isAnagramsUnicode(\"Silent\", \"Listen\"));\n        Assertions.assertFalse(CheckAnagrams.isAnagramsUnicode(\"This is a string\", \"Is this a string\"));\n    }\n\n    // CHECK METHOD isAnagramsOptimised()\n    // Below tests work with strings which consist of only lowercase English letters\n    @Test\n    public void testOptimisedAlgorithmStringsAreValidAnagrams() {\n        Assertions.assertTrue(CheckAnagrams.isAnagramsOptimised(\"silent\", \"listen\"));\n        Assertions.assertTrue(CheckAnagrams.isAnagramsOptimised(\"mam\", \"amm\"));\n    }\n\n    @Test\n    public void testOptimisedAlgorithmShouldThrowExceptionWhenStringsContainUppercaseLetters() {\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> CheckAnagrams.isAnagramsOptimised(\"Silent\", \"Listen\"));\n        Assertions.assertEquals(exception.getMessage(), MESSAGE);\n\n        exception = assertThrows(IllegalArgumentException.class, () -> Assertions.assertFalse(CheckAnagrams.isAnagramsOptimised(\"This is a string\", \"Is this a string\")));\n        Assertions.assertEquals(exception.getMessage(), MESSAGE);\n    }\n}"
    },
    {
        "product_commit": "2456d86432613c84ec1a33c52b1349c904341520",
        "test_commit": "2456d86432613c84ec1a33c52b1349c904341520",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ParseInteger.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ParseIntegerTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class ParseInteger {\n\n    public static void main(String[] args) {\n        assert parseInt(\"123\") == Integer.parseInt(\"123\");\n        assert parseInt(\"-123\") == Integer.parseInt(\"-123\");\n        assert parseInt(\"0123\") == Integer.parseInt(\"0123\");\n        assert parseInt(\"+123\") == Integer.parseInt(\"+123\");\n    }\n\n    /**\n     * Parse a string to integer\n     *\n     * @param s the string\n     * @return the integer value represented by the argument in decimal.\n     * @throws NumberFormatException if the {@code string} does not contain a\n     * parsable integer.\n     */\n    public static int parseInt(String s) {\n        if (s == null || s.length() == 0) {\n            throw new NumberFormatException(\"null\");\n        }\n        boolean isNegative = s.charAt(0) == '-';\n        boolean isPositive = s.charAt(0) == '+';\n        int number = 0;\n        for (int i = isNegative ? 1 : isPositive ? 1 : 0, length = s.length(); i < length; ++i) {\n            if (!Character.isDigit(s.charAt(i))) {\n                throw new NumberFormatException(\"s=\" + s);\n            }\n            number = number * 10 + s.charAt(i) - '0';\n        }\n        return isNegative ? -number : number;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class ParseInteger {\n    /**\n     * Parse a string to integer\n     *\n     * @param s the string\n     * @return the integer value represented by the argument in decimal.\n     * @throws NumberFormatException if the {@code string} does not contain a\n     *                               parsable integer.\n     */\n    public static int parseInt(String s) {\n        if (s == null || s.length() == 0) {\n            throw new NumberFormatException(\"Input parameter must not be null!\");\n        }\n        boolean isNegative = s.charAt(0) == '-';\n        boolean isPositive = s.charAt(0) == '+';\n        int number = 0;\n        for (int i = isNegative ? 1 : isPositive ? 1 : 0, length = s.length(); i < length; ++i) {\n            if (!Character.isDigit(s.charAt(i))) {\n                throw new NumberFormatException(\"Input parameter of incorrect format: \" + s);\n            }\n            number = number * 10 + s.charAt(i) - '0';\n        }\n        return isNegative ? -number : number;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 01/07/2023\n */\npublic class ParseIntegerTest {\n    private static final String NULL_PARAMETER_MESSAGE = \"Input parameter must not be null!\";\n    private static final String INCORRECT_FORMAT_MESSAGE = \"Input parameter of incorrect format\";\n\n    @Test\n    public void testNullInput() {\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> ParseInteger.parseInt(null));\n        Assertions.assertEquals(exception.getMessage(), NULL_PARAMETER_MESSAGE);\n    }\n\n    @Test\n    public void testInputOfIncorrectFormat() {\n        IllegalArgumentException exception = Assertions.assertThrows(NumberFormatException.class, () -> ParseInteger.parseInt(\"+0a123\"));\n        Assertions.assertTrue(exception.getMessage().contains(INCORRECT_FORMAT_MESSAGE));\n\n        exception = Assertions.assertThrows(NumberFormatException.class, () -> ParseInteger.parseInt(\"b\"));\n        Assertions.assertTrue(exception.getMessage().contains(INCORRECT_FORMAT_MESSAGE));\n    }\n\n    @Test\n    public void testPositiveValueIsSuccessfullyConverted() {\n        Assertions.assertEquals(ParseInteger.parseInt(\"0\"), Integer.parseInt(\"0\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"123\"), Integer.parseInt(\"123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"0123\"), Integer.parseInt(\"0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"+0123\"), Integer.parseInt(\"+0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"+123\"), Integer.parseInt(\"+123\"));\n    }\n\n    @Test\n    public void testNegativeValueIsSuccessfullyConverted() {\n        Assertions.assertEquals(ParseInteger.parseInt(\"-1\"), Integer.parseInt(\"-1\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-123\"), Integer.parseInt(\"-123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-0123\"), Integer.parseInt(\"-0123\"));\n        Assertions.assertEquals(ParseInteger.parseInt(\"-00123\"), Integer.parseInt(\"-00123\"));\n    }\n}"
    },
    {
        "product_commit": "4b45ac7e710f49014dab5b70dfa51eddbf8e1b0b",
        "test_commit": "4b45ac7e710f49014dab5b70dfa51eddbf8e1b0b",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PalindromeNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PalindromeNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class PalindromeNumber {\n\n    public static void main(String[] args) {\n        assert isPalindrome(12321);\n        assert !isPalindrome(1234);\n        assert isPalindrome(1);\n    }\n\n    /**\n     * Check if {@code n} is palindrome number or not\n     *\n     * @param number the number\n     * @return {@code true} if {@code n} is palindrome number, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(number + \"\");\n        }\n        int numberCopy = number;\n        int reverseNumber = 0;\n        while (numberCopy != 0) {\n            int remainder = numberCopy % 10;\n            reverseNumber = reverseNumber * 10 + remainder;\n            numberCopy /= 10;\n        }\n        return number == reverseNumber;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class PalindromeNumber {\n    /**\n     * Check if {@code n} is palindrome number or not\n     *\n     * @param number the number\n     * @return {@code true} if {@code n} is palindrome number, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"Input parameter must not be negative!\");\n        }\n        int numberCopy = number;\n        int reverseNumber = 0;\n        while (numberCopy != 0) {\n            int remainder = numberCopy % 10;\n            reverseNumber = reverseNumber * 10 + remainder;\n            numberCopy /= 10;\n        }\n        return number == reverseNumber;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 01/07/2023\n */\npublic class PalindromeNumberTest {\n    @Test\n    public void testNumbersArePalindromes() {\n        Assertions.assertTrue(PalindromeNumber.isPalindrome(0));\n        Assertions.assertTrue(PalindromeNumber.isPalindrome(1));\n        Assertions.assertTrue(PalindromeNumber.isPalindrome(2332));\n        Assertions.assertTrue(PalindromeNumber.isPalindrome(12321));\n    }\n\n    @Test\n    public void testNumbersAreNotPalindromes() {\n        Assertions.assertFalse(PalindromeNumber.isPalindrome(12));\n        Assertions.assertFalse(PalindromeNumber.isPalindrome(990));\n        Assertions.assertFalse(PalindromeNumber.isPalindrome(1234));\n    }\n\n    @Test\n    public void testIfNegativeInputThenExceptionExpected() {\n        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () -> PalindromeNumber.isPalindrome(-1));\n        Assertions.assertEquals(exception.getMessage(), \"Input parameter must not be negative!\");\n    }\n}"
    },
    {
        "product_commit": "8862a4dea5bb5d1278a74ea2a0a4015a65275e10",
        "test_commit": "8862a4dea5bb5d1278a74ea2a0a4015a65275e10",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FibonacciNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FibonacciNumberCheckTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Fibonacci: 0 1 1 2 3 5 8 13 21 ...\n */\npublic class FibonacciNumber {\n\n    public static void main(String[] args) {\n        assert isFibonacciNumber(1);\n        assert isFibonacciNumber(2);\n        assert isFibonacciNumber(21);\n        assert !isFibonacciNumber(9);\n        assert !isFibonacciNumber(10);\n    }\n\n    /**\n     * Check if a number is perfect square number\n     *\n     * @param number the number to be checked\n     * @return <tt>true</tt> if {@code number} is a perfect square, otherwise\n     *         <tt>false</tt>\n     */\n    public static boolean isPerfectSquare(int number) {\n        int sqrt = (int) Math.sqrt(number);\n        return sqrt * sqrt == number;\n    }\n\n    /**\n     * Check if a number is a Fibonacci number. This is true if and only if at\n     * least one of 5x^2+4 or 5x^2-4 is a perfect square\n     *\n     * @param number the number\n     * @return <tt>true</tt> if {@code number} is a Fibonacci number, otherwise\n     *         <tt>false</tt>\n     * @link https://en.wikipedia.org/wiki/Fibonacci_number#Identification\n     */\n    public static boolean isFibonacciNumber(int number) {\n        int value1 = 5 * number * number + 4;\n        int value2 = 5 * number * number - 4;\n        return isPerfectSquare(value1) || isPerfectSquare(value2);\n    }\n}",
        "product_new_content": null,
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Fibonacci Sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144...\n *\n * @author Albina Gimaletdinova on 01/07/2023\n */\npublic class FibonacciNumberCheckTest {\n    @Test\n    public void testNumberIsFibonacciNumber() {\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(1));\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(2));\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(21));\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(6765)); // 20th number\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(832040)); // 30th number\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(102334155)); // 40th number\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(701408733)); // 45th number\n    }\n\n    @Test\n    public void testNumberIsNotFibonacciNumber() {\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(9));\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(10));\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(145));\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(701408734));\n    }\n}"
    },
    {
        "product_commit": "8862a4dea5bb5d1278a74ea2a0a4015a65275e10",
        "test_commit": "8862a4dea5bb5d1278a74ea2a0a4015a65275e10",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FibonacciNumberCheck.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FibonacciNumberCheckTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Fibonacci: 0 1 1 2 3 5 8 13 21 ...\n * This code checks Fibonacci Numbers up to 45th number.\n * Other checks fail because of 'long'-type overflow.\n */\npublic class FibonacciNumberCheck {\n    /**\n     * Check if a number is perfect square number\n     *\n     * @param number the number to be checked\n     * @return <tt>true</tt> if {@code number} is a perfect square, otherwise\n     *         <tt>false</tt>\n     */\n    public static boolean isPerfectSquare(long number) {\n        long sqrt = (long) Math.sqrt(number);\n        return sqrt * sqrt == number;\n    }\n\n    /**\n     * Check if a number is a Fibonacci number. This is true if and only if at\n     * least one of 5x^2+4 or 5x^2-4 is a perfect square\n     *\n     * @param number the number\n     * @return <tt>true</tt> if {@code number} is a Fibonacci number, otherwise\n     *         <tt>false</tt>\n     * @link https://en.wikipedia.org/wiki/Fibonacci_number#Identification\n     */\n    public static boolean isFibonacciNumber(long number) {\n        long value1 = 5 * number * number + 4;\n        long value2 = 5 * number * number - 4;\n        return isPerfectSquare(value1) || isPerfectSquare(value2);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Fibonacci Sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144...\n *\n * @author Albina Gimaletdinova on 01/07/2023\n */\npublic class FibonacciNumberCheckTest {\n    @Test\n    public void testNumberIsFibonacciNumber() {\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(1));\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(2));\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(21));\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(6765)); // 20th number\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(832040)); // 30th number\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(102334155)); // 40th number\n        Assertions.assertTrue(FibonacciNumberCheck.isFibonacciNumber(701408733)); // 45th number\n    }\n\n    @Test\n    public void testNumberIsNotFibonacciNumber() {\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(9));\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(10));\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(145));\n        Assertions.assertFalse(FibonacciNumberCheck.isFibonacciNumber(701408734));\n    }\n}"
    },
    {
        "product_commit": "bc699b86e5719cd897fb182121f6c23b03bc6caf",
        "test_commit": "bc699b86e5719cd897fb182121f6c23b03bc6caf",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalanced.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalancedTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * This class will check if a BinaryTree is balanced. A balanced binary tree is\n * defined as a binary tree where the differenced in height between the left and\n * right subtree of each node differs by at most one.\n *\n * This can be done in both an iterative and recursive fashion. Below,\n * `isBalancedRecursive()` is implemented in a recursive fashion, and\n * `isBalancedIterative()` is implemented in an iterative fashion.\n *\n * @author [Ian Cowan](https://github.com/iccowan)\n */\npublic class CheckIfBinaryTreeBalanced {\n\n    /**\n     * This class implements the BinaryTree for these algorithms\n     */\n    class BinaryTree {\n\n        /**\n         * The root node of the binary tree\n         */\n        BTNode root = null;\n    }\n\n    /**\n     * This class implements the nodes for the binary tree\n     */\n    class BTNode {\n\n        /**\n         * The value of the node\n         */\n        int value;\n\n        /**\n         * The left child of the node\n         */\n        BTNode left = null;\n\n        /**\n         * The right child of the node\n         */\n        BTNode right = null;\n\n        /**\n         * Constructor\n         */\n        BTNode(int value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * Recursive is BT balanced implementation\n     *\n     * @param binaryTree The binary tree to check if balanced\n     */\n    public boolean isBalancedRecursive(BinaryTree binaryTree) {\n        // Create an array of length 1 to keep track of our balance\n        // Default to true. We use an array so we have an efficient mutable object\n        boolean[] isBalanced = new boolean[1];\n        isBalanced[0] = true;\n\n        // Check for balance and return whether or not we are balanced\n        isBalancedRecursive(binaryTree.root, 0, isBalanced);\n        return isBalanced[0];\n    }\n\n    /**\n     * Private helper method to keep track of the depth and balance during\n     * recursion. We effectively perform a modified post-order traversal where\n     * we are looking at the heights of both children of each node in the tree\n     *\n     * @param node The current node to explore\n     * @param depth The current depth of the node\n     * @param isBalanced The array of length 1 keeping track of our balance\n     */\n    private int isBalancedRecursive(BTNode node, int depth, boolean[] isBalanced) {\n        // If the node is null, we should not explore it and the height is 0\n        // If the tree is already not balanced, might as well stop because we\n        // can't make it balanced now!\n        if (node == null || !isBalanced[0]) {\n            return 0;\n        }\n\n        // Visit the left and right children, incrementing their depths by 1\n        int leftHeight = isBalancedRecursive(node.left, depth + 1, isBalanced);\n        int rightHeight = isBalancedRecursive(node.right, depth + 1, isBalanced);\n\n        // If the height of either of the left or right subtrees differ by more\n        // than 1, we cannot be balanced\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            isBalanced[0] = false;\n        }\n\n        // The height of our tree is the maximum of the heights of the left\n        // and right subtrees plus one\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    /**\n     * Iterative is BT balanced implementation\n     */\n    public boolean isBalancedIterative(BinaryTree binaryTree) {\n        // Default that we are balanced and our algo will prove it wrong\n        boolean isBalanced = true;\n\n        // Create a stack for our post order traversal\n        Stack<BTNode> nodeStack = new Stack<BTNode>();\n\n        // For post order traversal, we'll have to keep track of where we\n        // visited last\n        BTNode lastVisited = null;\n\n        // Create a HashMap to keep track of the subtree heights for each node\n        HashMap<BTNode, Integer> subtreeHeights = new HashMap<BTNode, Integer>();\n\n        // We begin at the root of the tree\n        BTNode node = binaryTree.root;\n\n        // We loop while:\n        // - the node stack is empty and the node we explore is null\n        // AND\n        // - the tree is still balanced\n        while (!(nodeStack.isEmpty() && node == null) && isBalanced) {\n            // If the node is not null, we push it to the stack and continue\n            // to the left\n            if (node != null) {\n                nodeStack.push(node);\n                node = node.left;\n                // Once we hit a node that is null, we are as deep as we can go\n                // to the left\n            } else {\n                // Find the last node we put on the stack\n                node = nodeStack.peek();\n\n                // If the right child of the node has either been visited or\n                // is null, we visit this node\n                if (node.right == null || node.right == lastVisited) {\n                    // We assume the left and right heights are 0\n                    int leftHeight = 0;\n                    int rightHeight = 0;\n\n                    // If the right and left children are not null, we must\n                    // have already explored them and have a height\n                    // for them so let's get that\n                    if (node.left != null) {\n                        leftHeight = subtreeHeights.get(node.left);\n                    }\n\n                    if (node.right != null) {\n                        rightHeight = subtreeHeights.get(node.right);\n                    }\n\n                    // If the difference in the height of the right subtree\n                    // and left subtree differs by more than 1, we cannot be\n                    // balanced\n                    if (Math.abs(rightHeight - leftHeight) > 1) {\n                        isBalanced = false;\n                    }\n\n                    // The height of the subtree containing this node is the\n                    // max of the left and right subtree heighs plus 1\n                    subtreeHeights.put(node, Math.max(rightHeight, leftHeight) + 1);\n\n                    // We've now visited this node, so we pop it from the stack\n                    nodeStack.pop();\n                    lastVisited = node;\n\n                    // Current visiting node is now null\n                    node = null;\n                    // If the right child node of this node has not been visited\n                    // and is not null, we need to get that child node on the stack\n                } else {\n                    node = node.right;\n                }\n            }\n        }\n\n        // Return whether or not the tree is balanced\n        return isBalanced;\n    }\n\n    /**\n     * Generates the following unbalanced binary tree for testing 0 / \\ / \\ 0 0\n     * / / \\ / / \\ 0 0 0 / \\ / \\ 0 0 / / 0\n     */\n    private BinaryTree buildUnbalancedTree() {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new BTNode(0);\n\n        BTNode root = tree.root;\n        root.left = new BTNode(0);\n        root.right = new BTNode(0);\n\n        BTNode left = root.left;\n        BTNode right = root.right;\n\n        left.left = new BTNode(0);\n        right.left = new BTNode(0);\n        right.right = new BTNode(0);\n        right.left.right = new BTNode(0);\n\n        left = left.left;\n        left.left = new BTNode(0);\n        left.left.left = new BTNode(0);\n        left.left.left.left = new BTNode(0);\n\n        return tree;\n    }\n\n    /**\n     * Generates the following balanced binary tree for testing 0 / \\ / \\ 0 0 /\n     * \\ / \\ / 0 / \\ 0 0 0 / / / / 0 0\n     */\n    private BinaryTree buildBalancedTree() {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new BTNode(0);\n\n        BTNode root = tree.root;\n        root.left = new BTNode(0);\n        root.right = new BTNode(0);\n\n        BTNode left = root.left;\n        BTNode right = root.right;\n\n        left.left = new BTNode(0);\n        left.right = new BTNode(0);\n        right.left = new BTNode(0);\n        right.right = new BTNode(0);\n\n        right.right.left = new BTNode(0);\n\n        left.left.left = new BTNode(0);\n\n        return tree;\n    }\n\n    /**\n     * Main\n     */\n    public static void main(String[] args) {\n        // We create a new object to check the binary trees for balance\n        CheckIfBinaryTreeBalanced balanceCheck = new CheckIfBinaryTreeBalanced();\n\n        // Build a balanced and unbalanced binary tree\n        BinaryTree balancedTree = balanceCheck.buildBalancedTree();\n        BinaryTree unbalancedTree = balanceCheck.buildUnbalancedTree();\n\n        // Run basic tests on the algorithms to check for balance\n        boolean isBalancedRB = balanceCheck.isBalancedRecursive(balancedTree); // true\n        boolean isBalancedRU = balanceCheck.isBalancedRecursive(unbalancedTree); // false\n        boolean isBalancedIB = balanceCheck.isBalancedIterative(balancedTree); // true\n        boolean isBalancedIU = balanceCheck.isBalancedIterative(unbalancedTree); // false\n\n        // Print the results\n        System.out.println(\"isBalancedRB: \" + isBalancedRB);\n        System.out.println(\"isBalancedRU: \" + isBalancedRU);\n        System.out.println(\"isBalancedIB: \" + isBalancedIB);\n        System.out.println(\"isBalancedIU: \" + isBalancedIU);\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * This class will check if a BinaryTree is balanced. A balanced binary tree is\n * defined as a binary tree where the difference in height between the left and\n * right subtree of each node differs by at most one.\n * <p>\n * This can be done in both an iterative and recursive fashion. Below,\n * `isBalancedRecursive()` is implemented in a recursive fashion, and\n * `isBalancedIterative()` is implemented in an iterative fashion.\n *\n * @author [Ian Cowan](https://github.com/iccowan)\n */\npublic class CheckIfBinaryTreeBalanced {\n    /**\n     * Recursive is BT balanced implementation\n     *\n     * @param root The binary tree to check if balanced\n     */\n    public static boolean isBalancedRecursive(BinaryTree.Node root) {\n        if (root == null) {\n            return true;\n        }\n        // Create an array of length 1 to keep track of our balance\n        // Default to true. We use an array, so we have an efficient mutable object\n        boolean[] isBalanced = new boolean[1];\n        isBalanced[0] = true;\n\n        // Check for balance and return whether we are balanced\n        isBalancedRecursive(root, 0, isBalanced);\n        return isBalanced[0];\n    }\n\n    /**\n     * Private helper method to keep track of the depth and balance during\n     * recursion. We effectively perform a modified post-order traversal where\n     * we are looking at the heights of both children of each node in the tree\n     *\n     * @param node       The current node to explore\n     * @param depth      The current depth of the node\n     * @param isBalanced The array of length 1 keeping track of our balance\n     */\n    private static int isBalancedRecursive(BinaryTree.Node node, int depth, boolean[] isBalanced) {\n        // If the node is null, we should not explore it and the height is 0\n        // If the tree is already not balanced, might as well stop because we\n        // can't make it balanced now!\n        if (node == null || !isBalanced[0]) {\n            return 0;\n        }\n\n        // Visit the left and right children, incrementing their depths by 1\n        int leftHeight = isBalancedRecursive(node.left, depth + 1, isBalanced);\n        int rightHeight = isBalancedRecursive(node.right, depth + 1, isBalanced);\n\n        // If the height of either of the left or right subtrees differ by more\n        // than 1, we cannot be balanced\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            isBalanced[0] = false;\n        }\n\n        // The height of our tree is the maximum of the heights of the left\n        // and right subtrees plus one\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    /**\n     * Iterative is BT balanced implementation\n     */\n    public static boolean isBalancedIterative(BinaryTree.Node root) {\n        if (root == null) {\n            return true;\n        }\n\n        // Default that we are balanced and our algo will prove it wrong\n        boolean isBalanced = true;\n\n        // Create a stack for our post order traversal\n        Stack<BinaryTree.Node> nodeStack = new Stack<>();\n\n        // For post order traversal, we'll have to keep track of where we\n        // visited last\n        BinaryTree.Node lastVisited = null;\n\n        // Create a HashMap to keep track of the subtree heights for each node\n        HashMap<BinaryTree.Node, Integer> subtreeHeights = new HashMap<>();\n\n        // We begin at the root of the tree\n        BinaryTree.Node node = root;\n\n        // We loop while:\n        // - the node stack is empty and the node we explore is null\n        // AND\n        // - the tree is still balanced\n        while (!(nodeStack.isEmpty() && node == null) && isBalanced) {\n            // If the node is not null, we push it to the stack and continue\n            // to the left\n            if (node != null) {\n                nodeStack.push(node);\n                node = node.left;\n                // Once we hit a node that is null, we are as deep as we can go\n                // to the left\n            } else {\n                // Find the last node we put on the stack\n                node = nodeStack.peek();\n\n                // If the right child of the node has either been visited or\n                // is null, we visit this node\n                if (node.right == null || node.right == lastVisited) {\n                    // We assume the left and right heights are 0\n                    int leftHeight = 0;\n                    int rightHeight = 0;\n\n                    // If the right and left children are not null, we must\n                    // have already explored them and have a height\n                    // for them so let's get that\n                    if (node.left != null) {\n                        leftHeight = subtreeHeights.get(node.left);\n                    }\n\n                    if (node.right != null) {\n                        rightHeight = subtreeHeights.get(node.right);\n                    }\n\n                    // If the difference in the height of the right subtree\n                    // and left subtree differs by more than 1, we cannot be\n                    // balanced\n                    if (Math.abs(rightHeight - leftHeight) > 1) {\n                        isBalanced = false;\n                    }\n\n                    // The height of the subtree containing this node is the\n                    // max of the left and right subtree heights plus 1\n                    subtreeHeights.put(node, Math.max(rightHeight, leftHeight) + 1);\n\n                    // We've now visited this node, so we pop it from the stack\n                    nodeStack.pop();\n                    lastVisited = node;\n\n                    // Current visiting node is now null\n                    node = null;\n                    // If the right child node of this node has not been visited\n                    // and is not null, we need to get that child node on the stack\n                } else {\n                    node = node.right;\n                }\n            }\n        }\n\n        // Return whether the tree is balanced\n        return isBalanced;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test check both implemented ways, iterative and recursive algorithms.\n *\n * @author Albina Gimaletdinova on 26/06/2023\n */\npublic class CheckIfBinaryTreeBalancedTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(null));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {Integer.MIN_VALUE});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n     9    <-- Math.abs(height(left) - height(right)) == 0\n    / \\\n   7   13\n  /\\   / \\\n 3  8 10 20\n*/\n    @Test\n    public void testBinaryTreeIsBalancedEqualSubtreeHeights() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n     9    <-- Math.abs(height(left) - height(right)) == 1\n    / \\\n   7   13\n  /\\\n 3  8\n*/\n    @Test\n    public void testBinaryTreeIsBalancedWithDifferentHeights() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n         9  <-- only left tree exists, Math.abs(height(left) - height(right)) > 1\n        /\n       7\n      /\\\n     3  8\n    */\n    @Test\n    public void testBinaryTreeNotBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, null, 3, 8});\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n         9    <-- Math.abs(height(left) - height(right)) > 1\n        / \\\n       7   13\n      /\\\n     3  8\n    /\n   11\n*/\n    @Test\n    public void testBinaryTreeNotBalancedBecauseLeftTreeNotBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, null, null, 11});\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n}"
    },
    {
        "product_commit": "05ca93eace893a75e886a19739778a67bd3a18bc",
        "test_commit": "05ca93eace893a75e886a19739778a67bd3a18bc",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Area.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AreaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(()\n                      -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(()\n                      -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangle(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangle(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}"
    },
    {
        "product_commit": "63739f493368b76d1b426a30deb2de06e9a9cd7e",
        "test_commit": "63739f493368b76d1b426a30deb2de06e9a9cd7e",
        "product_file_path": "src/main/java/com/thealgorithms/others/cn/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/cn/HammingDistanceTest.java",
        "product_old_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n    public int getHammingDistanceBetweenBits(String senderBits, String receiverBits) {\n        if (senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\"Sender and Receiver bits should be same\");\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < senderData.length; i++) {\n            totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if (totalErrorBitCount == 0) {\n            System.out.println(\"No Error bit in data segments\");\n        } else {\n            System.out.println(\"Total Error bit count \" + totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nfinal public class HammingDistance {\n    private HammingDistance() {\n    }\n\n    private static void checkChar(char inChar) {\n        if (inChar != '0' && inChar != '1') {\n            throw new IllegalArgumentException(\"Input must be a binary string.\");\n        }\n    }\n\n    public static int compute(char charA, char charB) {\n        checkChar(charA);\n        checkChar(charB);\n        return charA == charB ? 0 : 1;\n    }\n\n    public static int compute(String bitsStrA, String bitsStrB) {\n        if (bitsStrA.length() != bitsStrB.length()) {\n            throw new IllegalArgumentException(\"Input strings must have the same length.\");\n        }\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < bitsStrA.length(); i++) {\n            totalErrorBitCount += compute(bitsStrA.charAt(i), bitsStrB.charAt(i));\n        }\n\n        return totalErrorBitCount;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n    void initialize() {\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits() {\n        String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n}",
        "test_new_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n    @Test\n    public void checkForDifferentBits() {\n        int answer = HammingDistance.compute(\"000\", \"011\");\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        int answer = HammingDistance.compute(\"10101\", \"11110\");\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String someBits = \"111\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        int answer = HammingDistance.compute(\"10010101101010000100110100\", \"00110100001011001100110101\");\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"100010\", \"00011\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void mismatchDataBits2() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"1\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String someBits = \"10010101101010000100110100\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForEmptyInput() {\n        String someBits = \"\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForInputOfLength1() {\n        String someBits = \"0\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void computeThrowsExceptionWhenInputsAreNotBitStrs() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"1A\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must be a binary string\");\n    }\n}"
    },
    {
        "product_commit": "7a3273ae1db2a652b80a4b655e642f06331937cb",
        "test_commit": "7a3273ae1db2a652b80a4b655e642f06331937cb",
        "product_file_path": "src/main/java/com/thealgorithms/others/SieveOfEratosthenes.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/SieveOfEratosthenesTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers\n * up to any given limit.\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Wiki</a>\n */\npublic class SieveOfEratosthenes {\n\n    /**\n     * Finds all prime numbers till n.\n     *\n     * @param n The number till which we have to check for primes. Should be more than 1.\n     * @return Array of all prime numbers between 0 to n.\n     */\n    public static int[] findPrimesTill(int n) {\n        Type[] numbers = new Type[n + 1];\n        Arrays.fill(numbers, Type.PRIME);\n        numbers[0] = numbers[1] = Type.NOT_PRIME;\n\n        double cap = Math.sqrt(n);\n        for (int i = 2; i <= cap; i++) {\n            if (numbers[i] == Type.PRIME) {\n                for (int j = 2; i * j <= n; j++) {\n                    numbers[i * j] = Type.NOT_PRIME;\n                }\n            }\n        }\n\n        int primesCount = (int) Arrays.stream(numbers).filter(element -> element == Type.PRIME).count();\n        int[] primes = new int[primesCount];\n\n        int primeIndex = 0;\n        for (int i = 0; i < n + 1; i++) {\n            if (numbers[i] == Type.PRIME) {\n                primes[primeIndex++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    private enum Type {\n        PRIME,\n        NOT_PRIME,\n    }\n\n    public static void main(String[] args) {\n        int n = 100;\n        System.out.println(\"Searching for all primes from zero to \" + n);\n        int[] primes = findPrimesTill(n);\n        System.out.println(\"Found: \" + Arrays.toString(primes));\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * @brief utility class implementing <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Sieve of Eratosthenes</a>\n */\nfinal public class SieveOfEratosthenes {\n    private SieveOfEratosthenes() {\n    }\n\n    private static void checkInput(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"n must be positive.\");\n        }\n    }\n\n    private static Type[] sievePrimesTill(int n) {\n        checkInput(n);\n        Type[] isPrimeArray = new Type[n + 1];\n        Arrays.fill(isPrimeArray, Type.PRIME);\n        isPrimeArray[0] = isPrimeArray[1] = Type.NOT_PRIME;\n\n        double cap = Math.sqrt(n);\n        for (int i = 2; i <= cap; i++) {\n            if (isPrimeArray[i] == Type.PRIME) {\n                for (int j = 2; i * j <= n; j++) {\n                    isPrimeArray[i * j] = Type.NOT_PRIME;\n                }\n            }\n        }\n        return isPrimeArray;\n    }\n\n    private static int countPrimes(Type[] isPrimeArray) {\n        return (int) Arrays.stream(isPrimeArray).filter(element -> element == Type.PRIME).count();\n    }\n\n    private static int[] extractPrimes(Type[] isPrimeArray) {\n        int numberOfPrimes = countPrimes(isPrimeArray);\n        int[] primes = new int[numberOfPrimes];\n        int primeIndex = 0;\n        for (int curNumber = 0; curNumber < isPrimeArray.length; ++curNumber) {\n            if (isPrimeArray[curNumber] == Type.PRIME) {\n                primes[primeIndex++] = curNumber;\n            }\n        }\n        return primes;\n    }\n\n    /**\n     * @brief finds all of the prime numbers up to the given upper (inclusive) limit\n     * @param n upper (inclusive) limit\n     * @exception IllegalArgumentException n is non-positive\n     * @return the array of all primes up to the given number (inclusive)\n     */\n    public static int[] findPrimesTill(int n) {\n        return extractPrimes(sievePrimesTill(n));\n    }\n\n    private enum Type {\n        PRIME,\n        NOT_PRIME,\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass SieveOfEratosthenesTest {\n    @Test\n    public void testfFindPrimesTill1() {\n        assertArrayEquals(new int[] {}, SieveOfEratosthenes.findPrimesTill(1));\n    }\n\n    @Test\n    public void testfFindPrimesTill2() {\n        assertArrayEquals(new int[] {2}, SieveOfEratosthenes.findPrimesTill(2));\n    }\n\n    @Test\n    public void testfFindPrimesTill4() {\n        var primesTill4 = new int[] {2, 3};\n        assertArrayEquals(primesTill4, SieveOfEratosthenes.findPrimesTill(3));\n        assertArrayEquals(primesTill4, SieveOfEratosthenes.findPrimesTill(4));\n    }\n\n    @Test\n    public void testfFindPrimesTill40() {\n        var primesTill40 = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(37));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(38));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(39));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(40));\n    }\n\n    @Test\n    public void testfFindPrimesTill240() {\n        var primesTill240 = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239};\n        assertArrayEquals(primesTill240, SieveOfEratosthenes.findPrimesTill(239));\n        assertArrayEquals(primesTill240, SieveOfEratosthenes.findPrimesTill(240));\n    }\n\n    @Test\n    public void testFindPrimesTillThrowsExceptionForNonPositiveInput() {\n        assertThrows(IllegalArgumentException.class, () -> SieveOfEratosthenes.findPrimesTill(0));\n    }\n}"
    },
    {
        "product_commit": "87d6083bac1cc92d022c7865812f709449b3fe6e",
        "test_commit": "87d6083bac1cc92d022c7865812f709449b3fe6e",
        "product_file_path": "src/main/java/com/thealgorithms/others/EulersFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/EulersFunctionTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\n/**\n * You can read more about Euler's totient function\n *\n * <p>\n * See https://en.wikipedia.org/wiki/Euler%27s_totient_function\n */\npublic class EulersFunction {\n\n    // This method returns us number of x that (x < n) and gcd(x, n) == 1 in O(sqrt(n)) time\n    // complexity;\n\n    public static int getEuler(int n) {\n        int result = n;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                while (n % i == 0) {\n                    n /= i;\n                }\n                result -= result / i;\n            }\n        }\n        if (n > 1) {\n            result -= result / n;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 1; i < 100; i++) {\n            System.out.println(getEuler(i));\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\n/**\n * @brief utility class for <a href=\"https://en.wikipedia.org/wiki/Euler%27s_totient_function\">Euler's totient function</a>\n */\nfinal public class EulersFunction {\n    private EulersFunction() {\n    }\n\n    private static void checkInput(int n) {\n        if (n <= 0) {\n            throw new IllegalArgumentException(\"n must be positive.\");\n        }\n    }\n\n    /**\n     * @brief computes the value of Euler's totient function for given input\n     * @details has time complexity of O(sqrt(n))\n     * @param n the input\n     * @exception IllegalArgumentException n is non-positive\n     * @return the value of Euler's totient function for the input\n     */\n    public static int getEuler(int n) {\n        checkInput(n);\n        int result = n;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                while (n % i == 0) {\n                    n /= i;\n                }\n                result -= result / i;\n            }\n        }\n        if (n > 1) {\n            result -= result / n;\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\nclass EulersFunctionTest {\n    @Test\n    public void testGetEuler() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(1, 1);\n        testCases.put(2, 1);\n        testCases.put(3, 2);\n        testCases.put(4, 2);\n        testCases.put(5, 4);\n        testCases.put(6, 2);\n        testCases.put(10, 4);\n        testCases.put(21, 12);\n        testCases.put(69, 44);\n        testCases.put(47, 46);\n        testCases.put(46, 22);\n        testCases.put(55, 40);\n        testCases.put(34, 16);\n        testCases.put(20, 8);\n        testCases.put(20, 8);\n        testCases.put(1024, 512);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), EulersFunction.getEuler(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testGetEulerThrowsExceptionForNonPositiveInput() {\n        assertThrows(IllegalArgumentException.class, () -> EulersFunction.getEuler(0));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/AllPathsFromSourceToTarget.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java",
        "product_old_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm = new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices) {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList() {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v) {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n    public void storeAllPaths(int s, int d) {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path\n    private void storeAllPathsUtil(\n        Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList) {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n\n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(\n        int vertices, int[][] a, int source, int destination) {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for (int i = 0; i < a.length; i++) {\n            g.addEdge(a[i][0], a[i][1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "product_new_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm = new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices) {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList() {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v) {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n    public void storeAllPaths(int s, int d) {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path\n    private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList) {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n\n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int[][] a, int source, int destination) {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for (int i = 0; i < a.length; i++) {\n            g.addEdge(a[i][0], a[i][1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2\n            = List.of(List.of(2, 0, 1, 3), List.of(2, 0, 3), List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}, {1, 4}, {3, 4}, {2, 4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4), List.of(0, 1, 4),\n            List.of(0, 2, 1, 3, 4), List.of(0, 2, 1, 4), List.of(0, 2, 4), List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int[][] a = {{1, 0}, {2, 3}, {0, 4}, {1, 5}, {4, 3}, {0, 2}, {0, 3}, {1, 2}, {0, 5}, {3, 4},\n            {2, 5}, {2, 4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2\n            = List.of(List.of(1, 0, 2, 5), List.of(1, 0, 5), List.of(1, 5), List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int[][] a = {{0, 1}, {0, 2}, {1, 2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2), List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3), List.of(2, 0, 3), List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}, {1, 4}, {3, 4}, {2, 4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4), List.of(0, 1, 4), List.of(0, 2, 1, 3, 4), List.of(0, 2, 1, 4), List.of(0, 2, 4), List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int[][] a = {{1, 0}, {2, 3}, {0, 4}, {1, 5}, {4, 3}, {0, 2}, {0, 3}, {1, 2}, {0, 5}, {3, 4}, {2, 5}, {2, 4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5), List.of(1, 0, 5), List.of(1, 5), List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int[][] a = {{0, 1}, {0, 2}, {1, 2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2), List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SkipList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SkipListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            if (current.next(i) != null) {\n                current.next(i).setPrevious(i, current.previous(i));\n            }\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                            .map(layer -> {\n                                StringBuilder acc = new StringBuilder();\n                                for (boolean b : layer) {\n                                    if (b) {\n                                        acc.append(\"[ ]\");\n                                    } else {\n                                        acc.append(\"---\");\n                                    }\n                                    acc.append(\" \");\n                                }\n                                return acc.toString();\n                            })\n                            .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1)\n                               .mapToObj(i -> String.format(\"%3d\", i))\n                               .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\n                    \"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            if (current.next(i) != null) {\n                current.next(i).setPrevious(i, current.previous(i));\n            }\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                            .map(layer -> {\n                                StringBuilder acc = new StringBuilder();\n                                for (boolean b : layer) {\n                                    if (b) {\n                                        acc.append(\"[ ]\");\n                                    } else {\n                                        acc.append(\"---\");\n                                    }\n                                    acc.append(\" \");\n                                }\n                                return acc.toString();\n                            })\n                            .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1).mapToObj(i -> String.format(\"%3d\", i)).collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\nimport org.junit.jupiter.api.Test;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder\n            = IntStream.range(0, values.length).mapToObj(skipList::get).toArray(String[] ::new);\n\n        assertArrayEquals(new String[] {\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n            \"f\",\n            \"g\",\n            \"h\",\n            \"i\",\n            \"j\",\n            \"k\",\n        };\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\nimport org.junit.jupiter.api.Test;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream.range(0, values.length).mapToObj(skipList::get).toArray(String[] ::new);\n\n        assertArrayEquals(new String[] {\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n            \"f\",\n            \"g\",\n            \"h\",\n            \"i\",\n            \"j\",\n            \"k\",\n        };\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CheckBinaryTreeIsValidBST.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckBinaryTreeIsValidBSTTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n * This code recursively validates whether given Binary Search Tree (BST) is balanced or not.\n * Trees with only distinct values are supported.\n * Key points:\n * 1. According to the definition of a BST, each node in a tree must be in range [min, max],\n *    where 'min' and 'max' values represent the child nodes (left, right).\n * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE.\n */\npublic class CheckBinaryTreeIsValidBST {\n    public static boolean isBST(BinaryTree.Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) {\n        // empty tree is a BST\n        if (node == null) {\n            return true;\n        }\n\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        return (\n            isBSTUtil(node.left, min, node.data - 1) && isBSTUtil(node.right, node.data + 1, max));\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n * This code recursively validates whether given Binary Search Tree (BST) is balanced or not.\n * Trees with only distinct values are supported.\n * Key points:\n * 1. According to the definition of a BST, each node in a tree must be in range [min, max],\n *    where 'min' and 'max' values represent the child nodes (left, right).\n * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE.\n */\npublic class CheckBinaryTreeIsValidBST {\n    public static boolean isBST(BinaryTree.Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) {\n        // empty tree is a BST\n        if (node == null) {\n            return true;\n        }\n\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        return (isBSTUtil(node.left, min, node.data - 1) && isBSTUtil(node.right, node.data + 1, max));\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class CheckBinaryTreeIsValidBSTTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {Integer.MIN_VALUE});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root\n            = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root\n            = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 13});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root\n            = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 12});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class CheckBinaryTreeIsValidBSTTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {Integer.MIN_VALUE});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 13});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 12});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CreateBinaryTreeFromInorderPreorder.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CreateBinaryTreeFromInorderPreorderTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Approach: Naive Solution: Create root node from first value present in\n * preorder traversal. Look for the index of root node's value in inorder\n * traversal. That will tell total nodes present in left subtree and right\n * subtree. Based on that index create left and right subtree. Complexity: Time:\n * O(n^2) for each node there is iteration to find index in inorder array Space:\n * Stack size = O(height) = O(lg(n))\n * <p>\n * Optimized Solution: Instead of iterating over inorder array to find index of\n * root value, create a hashmap and find out the index of root value.\n * Complexity: Time: O(n) hashmap reduced iteration to find index in inorder\n * array Space: O(n) space taken by hashmap\n */\npublic class CreateBinaryTreeFromInorderPreorder {\n    public static Node createTree(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        return createTree(preorder, inorder, 0, 0, inorder.length);\n    }\n\n    public static Node createTreeOptimized(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        return createTreeOptimized(preorder, inorderMap, 0, 0, inorder.length);\n    }\n\n    private static Node createTree(final Integer[] preorder, final Integer[] inorder,\n        final int preStart, final int inStart, final int size) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inStart;\n        while (!preorder[preStart].equals(inorder[i])) {\n            i++;\n        }\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left = createTree(preorder, inorder, preStart + 1, inStart, leftNodesCount);\n        root.right\n            = createTree(preorder, inorder, preStart + leftNodesCount + 1, i + 1, rightNodesCount);\n        return root;\n    }\n\n    private static Node createTreeOptimized(final Integer[] preorder,\n        final Map<Integer, Integer> inorderMap, final int preStart, final int inStart,\n        final int size) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inorderMap.get(preorder[preStart]);\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left\n            = createTreeOptimized(preorder, inorderMap, preStart + 1, inStart, leftNodesCount);\n        root.right = createTreeOptimized(\n            preorder, inorderMap, preStart + leftNodesCount + 1, i + 1, rightNodesCount);\n        return root;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Approach: Naive Solution: Create root node from first value present in\n * preorder traversal. Look for the index of root node's value in inorder\n * traversal. That will tell total nodes present in left subtree and right\n * subtree. Based on that index create left and right subtree. Complexity: Time:\n * O(n^2) for each node there is iteration to find index in inorder array Space:\n * Stack size = O(height) = O(lg(n))\n * <p>\n * Optimized Solution: Instead of iterating over inorder array to find index of\n * root value, create a hashmap and find out the index of root value.\n * Complexity: Time: O(n) hashmap reduced iteration to find index in inorder\n * array Space: O(n) space taken by hashmap\n */\npublic class CreateBinaryTreeFromInorderPreorder {\n    public static Node createTree(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        return createTree(preorder, inorder, 0, 0, inorder.length);\n    }\n\n    public static Node createTreeOptimized(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        return createTreeOptimized(preorder, inorderMap, 0, 0, inorder.length);\n    }\n\n    private static Node createTree(final Integer[] preorder, final Integer[] inorder, final int preStart, final int inStart, final int size) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inStart;\n        while (!preorder[preStart].equals(inorder[i])) {\n            i++;\n        }\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left = createTree(preorder, inorder, preStart + 1, inStart, leftNodesCount);\n        root.right = createTree(preorder, inorder, preStart + leftNodesCount + 1, i + 1, rightNodesCount);\n        return root;\n    }\n\n    private static Node createTreeOptimized(final Integer[] preorder, final Map<Integer, Integer> inorderMap, final int preStart, final int inStart, final int size) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inorderMap.get(preorder[preStart]);\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left = createTreeOptimized(preorder, inorderMap, preStart + 1, inStart, leftNodesCount);\n        root.right = createTreeOptimized(preorder, inorderMap, preStart + leftNodesCount + 1, i + 1, rightNodesCount);\n        return root;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 14/05/2023\n */\npublic class CreateBinaryTreeFromInorderPreorderTest {\n    @Test\n    public void testOnNullArraysShouldReturnNullTree() {\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(null, null);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(null, null);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnEmptyArraysShouldCreateNullTree() {\n        // given\n        Integer[] preorder = {};\n        Integer[] inorder = {};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnSingleNodeTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1};\n        Integer[] inorder = {1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnRightSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {1, 2, 3, 4};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnLeftSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {4, 3, 2, 1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnNormalTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {3, 9, 20, 15, 7};\n        Integer[] inorder = {9, 3, 15, 20, 7};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    private static void checkTree(Integer[] preorder, Integer[] inorder, BinaryTree.Node root) {\n        Assertions.assertNotNull(root);\n        Assertions.assertEquals(PreOrderTraversal.iterativePreOrder(root), Arrays.asList(preorder));\n        Assertions.assertEquals(InorderTraversal.iterativeInorder(root), Arrays.asList(inorder));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 14/05/2023\n */\npublic class CreateBinaryTreeFromInorderPreorderTest {\n    @Test\n    public void testOnNullArraysShouldReturnNullTree() {\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(null, null);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(null, null);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnEmptyArraysShouldCreateNullTree() {\n        // given\n        Integer[] preorder = {};\n        Integer[] inorder = {};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnSingleNodeTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1};\n        Integer[] inorder = {1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnRightSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {1, 2, 3, 4};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnLeftSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {4, 3, 2, 1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnNormalTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {3, 9, 20, 15, 7};\n        Integer[] inorder = {9, 3, 15, 20, 7};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    private static void checkTree(Integer[] preorder, Integer[] inorder, BinaryTree.Node root) {\n        Assertions.assertNotNull(root);\n        Assertions.assertEquals(PreOrderTraversal.iterativePreOrder(root), Arrays.asList(preorder));\n        Assertions.assertEquals(InorderTraversal.iterativeInorder(root), Arrays.asList(inorder));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/OptimalJobScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/OptimalJobSchedulingTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * This class refers to the Optimal Job Scheduling problem with the following constrains:\n *  - precedence relation between the processes\n *  - machine pair dependent transportation delays\n *\n * https://en.wikipedia.org/wiki/Optimal_job_scheduling\n *\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobScheduling {\n\n    private final int numberProcesses;\n    private final int numberMachines;\n    private final int[][] Run;\n    private final int[][] Transfer;\n    private final int[][] Cost;\n\n    /**\n     * Constructor of the class.\n     * @param numberProcesses ,refers to the number of precedent processes(N)\n     * @param numberMachines ,refers to the number of different machines in our disposal(M)\n     * @param Run , N*M matrix refers to the cost of running each process to each machine\n     * @param Transfer ,M*M symmetric matrix refers to the transportation delay for each pair of\n     *     machines\n     */\n    public OptimalJobScheduling(\n        int numberProcesses, int numberMachines, int[][] Run, int[][] Transfer) {\n        this.numberProcesses = numberProcesses;\n        this.numberMachines = numberMachines;\n        this.Run = Run;\n        this.Transfer = Transfer;\n        this.Cost = new int[numberProcesses][numberMachines];\n    }\n\n    /**\n     * Function which computes the cost of process scheduling to a number of VMs.\n     */\n    public void execute() {\n        this.calculateCost();\n        this.showResults();\n    }\n\n    /**\n     * Function which computes the cost of running each Process to each and every Machine\n     */\n    private void calculateCost() {\n\n        for (int i = 0; i < numberProcesses; i++) { // for each Process\n\n            for (int j = 0; j < numberMachines; j++) { // for each Machine\n\n                Cost[i][j] = runningCost(i, j);\n            }\n        }\n    }\n\n    /**\n     * Function which returns the minimum cost of running a certain Process to a certain Machine.In\n     * order for the Machine to execute the Process ,he requires the output of the previously\n     * executed Process, which may have been executed to the same Machine or some other.If the\n     * previous Process has been executed to another Machine,we have to transfer her result, which\n     * means extra cost for transferring the data from one Machine to another(if the previous\n     * Process has been executed to the same Machine, there is no transport cost).\n     *\n     * @param process ,refers to the Process\n     * @param machine ,refers to the Machine\n     * @return the minimum cost of executing the process to the certain machine.\n     */\n    private int runningCost(int process, int machine) {\n\n        if (process == 0) // refers to the first process,which does not require for a previous one\n                          // to have been executed\n            return Run[process][machine];\n        else {\n\n            int[] runningCosts\n                = new int[numberMachines]; // stores the costs of executing our Process depending on\n                                           // the Machine the previous one was executed\n\n            for (int k = 0; k < numberMachines; k++) // computes the cost of executing the previous\n                                                     // process to each and every Machine\n                runningCosts[k] = Cost[process - 1][k] + Transfer[k][machine]\n                    + Run[process][machine]; // transferring the result to our Machine and executing\n                                             // the Process to our Machine\n\n            return findMin(runningCosts); // returns the minimum running cost\n        }\n    }\n\n    /**\n     * Function used in order to return the minimum Cost.\n     * @param cost ,an Array of size M which refers to the costs of executing a Process to each\n     *     Machine\n     * @return the minimum cost\n     */\n    private int findMin(int[] cost) {\n\n        int min = 0;\n\n        for (int i = 1; i < cost.length; i++) {\n\n            if (cost[i] < cost[min]) min = i;\n        }\n        return cost[min];\n    }\n\n    /**\n     * Method used in order to present the overall costs.\n     */\n    private void showResults() {\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n                System.out.print(Cost[i][j]);\n                System.out.print(\" \");\n            }\n\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    /**\n     * Getter for the running Cost of i process on j machine.\n     */\n    public int getCost(int process, int machine) {\n        return Cost[process][machine];\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * This class refers to the Optimal Job Scheduling problem with the following constrains:\n *  - precedence relation between the processes\n *  - machine pair dependent transportation delays\n *\n * https://en.wikipedia.org/wiki/Optimal_job_scheduling\n *\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobScheduling {\n\n    private final int numberProcesses;\n    private final int numberMachines;\n    private final int[][] Run;\n    private final int[][] Transfer;\n    private final int[][] Cost;\n\n    /**\n     * Constructor of the class.\n     * @param numberProcesses ,refers to the number of precedent processes(N)\n     * @param numberMachines ,refers to the number of different machines in our disposal(M)\n     * @param Run , N*M matrix refers to the cost of running each process to each machine\n     * @param Transfer ,M*M symmetric matrix refers to the transportation delay for each pair of\n     *     machines\n     */\n    public OptimalJobScheduling(int numberProcesses, int numberMachines, int[][] Run, int[][] Transfer) {\n        this.numberProcesses = numberProcesses;\n        this.numberMachines = numberMachines;\n        this.Run = Run;\n        this.Transfer = Transfer;\n        this.Cost = new int[numberProcesses][numberMachines];\n    }\n\n    /**\n     * Function which computes the cost of process scheduling to a number of VMs.\n     */\n    public void execute() {\n        this.calculateCost();\n        this.showResults();\n    }\n\n    /**\n     * Function which computes the cost of running each Process to each and every Machine\n     */\n    private void calculateCost() {\n\n        for (int i = 0; i < numberProcesses; i++) { // for each Process\n\n            for (int j = 0; j < numberMachines; j++) { // for each Machine\n\n                Cost[i][j] = runningCost(i, j);\n            }\n        }\n    }\n\n    /**\n     * Function which returns the minimum cost of running a certain Process to a certain Machine.In\n     * order for the Machine to execute the Process ,he requires the output of the previously\n     * executed Process, which may have been executed to the same Machine or some other.If the\n     * previous Process has been executed to another Machine,we have to transfer her result, which\n     * means extra cost for transferring the data from one Machine to another(if the previous\n     * Process has been executed to the same Machine, there is no transport cost).\n     *\n     * @param process ,refers to the Process\n     * @param machine ,refers to the Machine\n     * @return the minimum cost of executing the process to the certain machine.\n     */\n    private int runningCost(int process, int machine) {\n\n        if (process == 0) // refers to the first process,which does not require for a previous one\n                          // to have been executed\n            return Run[process][machine];\n        else {\n\n            int[] runningCosts = new int[numberMachines]; // stores the costs of executing our Process depending on\n                                                          // the Machine the previous one was executed\n\n            for (int k = 0; k < numberMachines; k++) // computes the cost of executing the previous\n                                                     // process to each and every Machine\n                runningCosts[k] = Cost[process - 1][k] + Transfer[k][machine] + Run[process][machine]; // transferring the result to our Machine and executing\n                                                                                                       // the Process to our Machine\n\n            return findMin(runningCosts); // returns the minimum running cost\n        }\n    }\n\n    /**\n     * Function used in order to return the minimum Cost.\n     * @param cost ,an Array of size M which refers to the costs of executing a Process to each\n     *     Machine\n     * @return the minimum cost\n     */\n    private int findMin(int[] cost) {\n\n        int min = 0;\n\n        for (int i = 1; i < cost.length; i++) {\n\n            if (cost[i] < cost[min]) min = i;\n        }\n        return cost[min];\n    }\n\n    /**\n     * Method used in order to present the overall costs.\n     */\n    private void showResults() {\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n                System.out.print(Cost[i][j]);\n                System.out.print(\" \");\n            }\n\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    /**\n     * Getter for the running Cost of i process on j machine.\n     */\n    public int getCost(int process, int machine) {\n        return Cost[process][machine];\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobSchedulingTest {\n\n    @Test\n    public void testOptimalJobScheduling1() {\n\n        int numberProcesses = 5;\n        int numberMachines = 4;\n\n        int[][] Run = {{5, 1, 3, 2}, {4, 2, 1, 3}, {1, 5, 2, 1}, {2, 3, 4, 2}, {1, 1, 3, 1}};\n\n        int[][] Transfer = {{0, 1, 2, 4}, {1, 0, 2, 3}, {2, 2, 0, 1}, {4, 3, 1, 0}};\n\n        OptimalJobScheduling opt\n            = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 5}, {5, 8, 6, 6}, {7, 9, 10, 8}, {8, 9, 12, 9}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling2() {\n\n        int numberProcesses = 3;\n        int numberMachines = 3;\n\n        int[][] Run = {{5, 1, 3}, {4, 2, 1}, {1, 5, 2}};\n\n        int[][] Transfer = {{0, 1, 2}, {1, 0, 2}, {2, 2, 0}};\n\n        OptimalJobScheduling opt\n            = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3}, {6, 3, 4}, {5, 8, 6}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling3() {\n\n        int numberProcesses = 6;\n        int numberMachines = 4;\n\n        int[][] Run = {\n            {5, 1, 3, 2},\n            {4, 2, 1, 1},\n            {1, 5, 2, 6},\n            {1, 1, 2, 3},\n            {2, 1, 4, 6},\n            {3, 2, 2, 3},\n        };\n\n        int[][] Transfer = {\n            {0, 1, 2, 1},\n            {1, 0, 2, 3},\n            {2, 2, 0, 2},\n            {1, 3, 2, 0},\n        };\n\n        OptimalJobScheduling opt\n            = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 3}, {5, 8, 6, 9}, {6, 7, 8, 9}, {8, 8, 12, 13},\n            {11, 10, 12, 12}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobSchedulingTest {\n\n    @Test\n    public void testOptimalJobScheduling1() {\n\n        int numberProcesses = 5;\n        int numberMachines = 4;\n\n        int[][] Run = {{5, 1, 3, 2}, {4, 2, 1, 3}, {1, 5, 2, 1}, {2, 3, 4, 2}, {1, 1, 3, 1}};\n\n        int[][] Transfer = {{0, 1, 2, 4}, {1, 0, 2, 3}, {2, 2, 0, 1}, {4, 3, 1, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 5}, {5, 8, 6, 6}, {7, 9, 10, 8}, {8, 9, 12, 9}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling2() {\n\n        int numberProcesses = 3;\n        int numberMachines = 3;\n\n        int[][] Run = {{5, 1, 3}, {4, 2, 1}, {1, 5, 2}};\n\n        int[][] Transfer = {{0, 1, 2}, {1, 0, 2}, {2, 2, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3}, {6, 3, 4}, {5, 8, 6}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling3() {\n\n        int numberProcesses = 6;\n        int numberMachines = 4;\n\n        int[][] Run = {\n            {5, 1, 3, 2},\n            {4, 2, 1, 1},\n            {1, 5, 2, 6},\n            {1, 1, 2, 3},\n            {2, 1, 4, 6},\n            {3, 2, 2, 3},\n        };\n\n        int[][] Transfer = {\n            {0, 1, 2, 1},\n            {1, 0, 2, 3},\n            {2, 2, 0, 2},\n            {1, 3, 2, 0},\n        };\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 3}, {5, 8, 6, 9}, {6, 7, 8, 9}, {8, 8, 12, 13}, {11, 10, 12, 12}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ADTFraction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ADTFractionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic record ADTFraction(int numerator, int denominator) {\n    /**\n     * Initializes a newly created {@code ADTFraction} object so that it represents\n     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.\n     *\n     * @param numerator   The fraction numerator\n     * @param denominator The fraction denominator\n     */\n    public ADTFraction {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be 0\");\n        }\n    }\n\n    /**\n     * Add two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to add\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction plus(ADTFraction fraction) {\n        var numerator\n            = this.denominator * fraction.numerator + this.numerator * fraction.denominator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Multiply fraction by a number.\n     *\n     * @param number the number to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(int number) {\n        return times(new ADTFraction(number, 1));\n    }\n\n    /**\n     * Multiply two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(ADTFraction fraction) {\n        var numerator = this.numerator * fraction.numerator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Generates the reciprocal of the fraction.\n     *\n     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched\n     */\n    public ADTFraction reciprocal() {\n        return new ADTFraction(this.denominator, this.numerator);\n    }\n\n    /**\n     * Calculates the result of the fraction.\n     *\n     * @return The numerical result of the division between {@code numerator} and {@code\n     *     denominator}\n     */\n    public float value() {\n        return (float) this.numerator / this.denominator;\n    }\n\n    /**\n     * Returns a string representation of this {@code ADTFraction} in the format\n     * {@code numerator}/{@code denominator}.\n     *\n     * @return A string representation of this {@code ADTFraction}\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%d/%d\", this.numerator, this.denominator);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic record ADTFraction(int numerator, int denominator) {\n    /**\n     * Initializes a newly created {@code ADTFraction} object so that it represents\n     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.\n     *\n     * @param numerator   The fraction numerator\n     * @param denominator The fraction denominator\n     */\n    public ADTFraction {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be 0\");\n        }\n    }\n\n    /**\n     * Add two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to add\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction plus(ADTFraction fraction) {\n        var numerator = this.denominator * fraction.numerator + this.numerator * fraction.denominator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Multiply fraction by a number.\n     *\n     * @param number the number to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(int number) {\n        return times(new ADTFraction(number, 1));\n    }\n\n    /**\n     * Multiply two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(ADTFraction fraction) {\n        var numerator = this.numerator * fraction.numerator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Generates the reciprocal of the fraction.\n     *\n     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched\n     */\n    public ADTFraction reciprocal() {\n        return new ADTFraction(this.denominator, this.numerator);\n    }\n\n    /**\n     * Calculates the result of the fraction.\n     *\n     * @return The numerical result of the division between {@code numerator} and {@code\n     *     denominator}\n     */\n    public float value() {\n        return (float) this.numerator / this.denominator;\n    }\n\n    /**\n     * Returns a string representation of this {@code ADTFraction} in the format\n     * {@code numerator}/{@code denominator}.\n     *\n     * @return A string representation of this {@code ADTFraction}\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%d/%d\", this.numerator, this.denominator);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ADTFractionTest {\n\n    private final ADTFraction fraction1 = new ADTFraction(3, 5);\n    private final ADTFraction fraction2 = new ADTFraction(7, 8);\n\n    @Test\n    void testConstructorWithDenominatorEqualToZero() {\n        Exception exception\n            = assertThrows(IllegalArgumentException.class, () -> new ADTFraction(1, 0));\n        assertEquals(\"Denominator cannot be 0\", exception.getMessage());\n    }\n\n    @Test\n    public void testPlus() {\n        assertEquals(new ADTFraction(59, 40), fraction1.plus(fraction2));\n    }\n\n    @Test\n    public void testTimes() {\n        assertEquals(new ADTFraction(12, 5), fraction1.times(4));\n        assertEquals(new ADTFraction(21, 40), fraction1.times(fraction2));\n    }\n\n    @Test\n    public void testReciprocal() {\n        assertEquals(new ADTFraction(5, 3), fraction1.reciprocal());\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(0.6F, fraction1.value());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        ADTFraction fraction3 = new ADTFraction(3, 5);\n        assertTrue(fraction1.equals(fraction3) && fraction3.equals(fraction1));\n        assertEquals(fraction1.hashCode(), fraction3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"3/5\", fraction1.toString());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ADTFractionTest {\n\n    private final ADTFraction fraction1 = new ADTFraction(3, 5);\n    private final ADTFraction fraction2 = new ADTFraction(7, 8);\n\n    @Test\n    void testConstructorWithDenominatorEqualToZero() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> new ADTFraction(1, 0));\n        assertEquals(\"Denominator cannot be 0\", exception.getMessage());\n    }\n\n    @Test\n    public void testPlus() {\n        assertEquals(new ADTFraction(59, 40), fraction1.plus(fraction2));\n    }\n\n    @Test\n    public void testTimes() {\n        assertEquals(new ADTFraction(12, 5), fraction1.times(4));\n        assertEquals(new ADTFraction(21, 40), fraction1.times(fraction2));\n    }\n\n    @Test\n    public void testReciprocal() {\n        assertEquals(new ADTFraction(5, 3), fraction1.reciprocal());\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(0.6F, fraction1.value());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        ADTFraction fraction3 = new ADTFraction(3, 5);\n        assertTrue(fraction1.equals(fraction3) && fraction3.equals(fraction1));\n        assertEquals(fraction1.hashCode(), fraction3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"3/5\", fraction1.toString());\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMin {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute min value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute min value\n     */\n    public static int getMinValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMinWrapper = new Object() { int value = numbers[0]; };\n\n        Arrays.stream(numbers)\n            .skip(1)\n            .filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value))\n            .forEach(number -> absMinWrapper.value = number);\n\n        return absMinWrapper.value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMin {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute min value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute min value\n     */\n    public static int getMinValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMinWrapper = new Object() { int value = numbers[0]; };\n\n        Arrays.stream(numbers).skip(1).filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value)).forEach(number -> absMinWrapper.value = number);\n\n        return absMinWrapper.value;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMinTest {\n\n    @Test\n    void testGetMinValue() {\n        assertEquals(0, AbsoluteMin.getMinValue(4, 0, 16));\n        assertEquals(-2, AbsoluteMin.getMinValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMinValueWithNoArguments() {\n        Exception exception\n            = assertThrows(IllegalArgumentException.class, () -> AbsoluteMin.getMinValue());\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMinTest {\n\n    @Test\n    void testGetMinValue() {\n        assertEquals(0, AbsoluteMin.getMinValue(4, 0, 16));\n        assertEquals(-2, AbsoluteMin.getMinValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMinValueWithNoArguments() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> AbsoluteMin.getMinValue());\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Area.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AreaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(\n        final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(()\n                      -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AutomorphicNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Wikipedia link for Automorphic Number : https://en.wikipedia.org/wiki/Automorphic_number\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\n\nimport java.math.BigInteger;\n\npublic class AutomorphicNumber {\n\n    /**\n     * A function to check if a number is Automorphic number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic(long n) {\n        if (n < 0) return false;\n        long square = n * n; // Calculating square of the number\n        long t = n, numberOfdigits = 0;\n        while (t > 0) {\n            numberOfdigits++; // Calculating number of digits in n\n            t /= 10;\n        }\n        long lastDigits\n            = square % (long) Math.pow(10, numberOfdigits); // Extracting last Digits of square\n        return n == lastDigits;\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using String functions\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic2(long n) {\n        if (n < 0) return false;\n        long square = n * n; // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using BigInteger\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic3(String s) {\n        BigInteger n = new BigInteger(s);\n        if (n.signum() == -1) return false; // if number is negative, return false\n        BigInteger square = n.multiply(n); // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Wikipedia link for Automorphic Number : https://en.wikipedia.org/wiki/Automorphic_number\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\n\nimport java.math.BigInteger;\n\npublic class AutomorphicNumber {\n\n    /**\n     * A function to check if a number is Automorphic number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic(long n) {\n        if (n < 0) return false;\n        long square = n * n; // Calculating square of the number\n        long t = n, numberOfdigits = 0;\n        while (t > 0) {\n            numberOfdigits++; // Calculating number of digits in n\n            t /= 10;\n        }\n        long lastDigits = square % (long) Math.pow(10, numberOfdigits); // Extracting last Digits of square\n        return n == lastDigits;\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using String functions\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic2(long n) {\n        if (n < 0) return false;\n        long square = n * n; // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using BigInteger\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic3(String s) {\n        BigInteger n = new BigInteger(s);\n        if (n.signum() == -1) return false; // if number is negative, return false\n        BigInteger square = n.multiply(n); // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AutomorphicNumberTest {\n\n    @Test\n    void testAutomorphicNumber() {\n        int[] trueTestCases = {0, 1, 25, 625, 12890625};\n        int[] falseTestCases = {-5, 2, 26, 1234};\n        for (Integer n : trueTestCases) {\n            assertTrue(AutomorphicNumber.isAutomorphic(n));\n            assertTrue(AutomorphicNumber.isAutomorphic2(n));\n            assertTrue(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(AutomorphicNumber.isAutomorphic(n));\n            assertFalse(AutomorphicNumber.isAutomorphic2(n));\n            assertFalse(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        assertTrue(\n            AutomorphicNumber.isAutomorphic3(\"59918212890625\")); // Special case for BigInteger\n        assertFalse(\n            AutomorphicNumber.isAutomorphic3(\"12345678912345\")); // Special case for BigInteger\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AutomorphicNumberTest {\n\n    @Test\n    void testAutomorphicNumber() {\n        int[] trueTestCases = {0, 1, 25, 625, 12890625};\n        int[] falseTestCases = {-5, 2, 26, 1234};\n        for (Integer n : trueTestCases) {\n            assertTrue(AutomorphicNumber.isAutomorphic(n));\n            assertTrue(AutomorphicNumber.isAutomorphic2(n));\n            assertTrue(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(AutomorphicNumber.isAutomorphic(n));\n            assertFalse(AutomorphicNumber.isAutomorphic2(n));\n            assertFalse(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        assertTrue(AutomorphicNumber.isAutomorphic3(\"59918212890625\")); // Special case for BigInteger\n        assertFalse(AutomorphicNumber.isAutomorphic3(\"12345678912345\")); // Special case for BigInteger\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/RRScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/RRSchedulingTest.java",
        "product_old_content": "/**\n * @author Md Asif Joardar\n */\n\npackage com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/**\n * The Round-robin scheduling algorithm is a kind of preemptive First come, First Serve CPU\n * Scheduling algorithm. This can be understood here -\n * https://www.scaler.com/topics/round-robin-scheduling-in-os/\n */\n\npublic class RRScheduling {\n    private List<ProcessDetails> processes;\n    private int quantumTime;\n\n    RRScheduling(final List<ProcessDetails> processes, int quantumTime) {\n        this.processes = processes;\n        this.quantumTime = quantumTime;\n    }\n\n    public void scheduleProcesses() {\n        evaluateTurnAroundTime();\n        evaluateWaitingTime();\n    }\n\n    private void evaluateTurnAroundTime() {\n        int processesNumber = processes.size();\n\n        if (processesNumber == 0) {\n            return;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        int currentTime = 0; // keep track of the time\n        int completed = 0;\n        int[] mark = new int[processesNumber];\n        Arrays.fill(mark, 0);\n        mark[0] = 1;\n\n        // a copy of burst time to store the remaining burst time\n        int[] remainingBurstTime = new int[processesNumber];\n        for (int i = 0; i < processesNumber; i++) {\n            remainingBurstTime[i] = processes.get(i).getBurstTime();\n        }\n\n        while (completed != processesNumber) {\n            int index = queue.poll();\n\n            if (remainingBurstTime[index] == processes.get(index).getBurstTime()) {\n                currentTime = Math.max(currentTime, processes.get(index).getArrivalTime());\n            }\n\n            if (remainingBurstTime[index] - quantumTime > 0) {\n                remainingBurstTime[index] -= quantumTime;\n                currentTime += quantumTime;\n            } else {\n                currentTime += remainingBurstTime[index];\n                processes.get(index).setTurnAroundTimeTime(\n                    currentTime - processes.get(index).getArrivalTime());\n                completed++;\n                remainingBurstTime[index] = 0;\n            }\n\n            // If some process has arrived when this process was executing, insert them into the\n            // queue.\n            for (int i = 1; i < processesNumber; i++) {\n                if (remainingBurstTime[i] > 0 && processes.get(i).getArrivalTime() <= currentTime\n                    && mark[i] == 0) {\n                    mark[i] = 1;\n                    queue.add(i);\n                }\n            }\n\n            // If the current process has burst time remaining, push the process into the queue\n            // again.\n            if (remainingBurstTime[index] > 0) queue.add(index);\n\n            // If the queue is empty, pick the first process from the list that is not completed.\n            if (queue.isEmpty()) {\n                for (int i = 1; i < processesNumber; i++) {\n                    if (remainingBurstTime[i] > 0) {\n                        mark[i] = 1;\n                        queue.add(i);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    private void evaluateWaitingTime() {\n        for (int i = 0; i < processes.size(); i++)\n            processes.get(i).setWaitingTime(\n                processes.get(i).getTurnAroundTimeTime() - processes.get(i).getBurstTime());\n    }\n}",
        "product_new_content": "/**\n * @author Md Asif Joardar\n */\n\npackage com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/**\n * The Round-robin scheduling algorithm is a kind of preemptive First come, First Serve CPU\n * Scheduling algorithm. This can be understood here -\n * https://www.scaler.com/topics/round-robin-scheduling-in-os/\n */\n\npublic class RRScheduling {\n    private List<ProcessDetails> processes;\n    private int quantumTime;\n\n    RRScheduling(final List<ProcessDetails> processes, int quantumTime) {\n        this.processes = processes;\n        this.quantumTime = quantumTime;\n    }\n\n    public void scheduleProcesses() {\n        evaluateTurnAroundTime();\n        evaluateWaitingTime();\n    }\n\n    private void evaluateTurnAroundTime() {\n        int processesNumber = processes.size();\n\n        if (processesNumber == 0) {\n            return;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        int currentTime = 0; // keep track of the time\n        int completed = 0;\n        int[] mark = new int[processesNumber];\n        Arrays.fill(mark, 0);\n        mark[0] = 1;\n\n        // a copy of burst time to store the remaining burst time\n        int[] remainingBurstTime = new int[processesNumber];\n        for (int i = 0; i < processesNumber; i++) {\n            remainingBurstTime[i] = processes.get(i).getBurstTime();\n        }\n\n        while (completed != processesNumber) {\n            int index = queue.poll();\n\n            if (remainingBurstTime[index] == processes.get(index).getBurstTime()) {\n                currentTime = Math.max(currentTime, processes.get(index).getArrivalTime());\n            }\n\n            if (remainingBurstTime[index] - quantumTime > 0) {\n                remainingBurstTime[index] -= quantumTime;\n                currentTime += quantumTime;\n            } else {\n                currentTime += remainingBurstTime[index];\n                processes.get(index).setTurnAroundTimeTime(currentTime - processes.get(index).getArrivalTime());\n                completed++;\n                remainingBurstTime[index] = 0;\n            }\n\n            // If some process has arrived when this process was executing, insert them into the\n            // queue.\n            for (int i = 1; i < processesNumber; i++) {\n                if (remainingBurstTime[i] > 0 && processes.get(i).getArrivalTime() <= currentTime && mark[i] == 0) {\n                    mark[i] = 1;\n                    queue.add(i);\n                }\n            }\n\n            // If the current process has burst time remaining, push the process into the queue\n            // again.\n            if (remainingBurstTime[index] > 0) queue.add(index);\n\n            // If the queue is empty, pick the first process from the list that is not completed.\n            if (queue.isEmpty()) {\n                for (int i = 1; i < processesNumber; i++) {\n                    if (remainingBurstTime[i] > 0) {\n                        mark[i] = 1;\n                        queue.add(i);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    private void evaluateWaitingTime() {\n        for (int i = 0; i < processes.size(); i++) processes.get(i).setWaitingTime(processes.get(i).getTurnAroundTimeTime() - processes.get(i).getBurstTime());\n    }\n}",
        "test_old_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\nclass RRSchedulingTest {\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForRR();\n        final RRScheduling rrScheduling\n            = new RRScheduling(processes, 4); // for sending to RR with quantum value 4\n\n        rrScheduling.scheduleProcesses();\n\n        assertEquals(6, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(12, processes.get(0).getWaitingTime());\n        assertEquals(17, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(16, processes.get(1).getWaitingTime());\n        assertEquals(22, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(6, processes.get(2).getWaitingTime());\n        assertEquals(9, processes.get(2).getTurnAroundTimeTime());\n\n        assertEquals(\"P4\", processes.get(3).getProcessId());\n        assertEquals(8, processes.get(3).getWaitingTime());\n        assertEquals(9, processes.get(3).getTurnAroundTimeTime());\n\n        assertEquals(\"P5\", processes.get(4).getProcessId());\n        assertEquals(15, processes.get(4).getWaitingTime());\n        assertEquals(20, processes.get(4).getTurnAroundTimeTime());\n\n        assertEquals(\"P6\", processes.get(5).getProcessId());\n        assertEquals(11, processes.get(5).getWaitingTime());\n        assertEquals(15, processes.get(5).getTurnAroundTimeTime());\n    }\n\n    private List<ProcessDetails> addProcessesForRR() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 5);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 6);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 3);\n        final ProcessDetails process4 = new ProcessDetails(\"P4\", 3, 1);\n        final ProcessDetails process5 = new ProcessDetails(\"P5\", 4, 5);\n        final ProcessDetails process6 = new ProcessDetails(\"P6\", 6, 4);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n        processDetails.add(process4);\n        processDetails.add(process5);\n        processDetails.add(process6);\n\n        return processDetails;\n    }\n}",
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\nclass RRSchedulingTest {\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForRR();\n        final RRScheduling rrScheduling = new RRScheduling(processes, 4); // for sending to RR with quantum value 4\n\n        rrScheduling.scheduleProcesses();\n\n        assertEquals(6, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(12, processes.get(0).getWaitingTime());\n        assertEquals(17, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(16, processes.get(1).getWaitingTime());\n        assertEquals(22, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(6, processes.get(2).getWaitingTime());\n        assertEquals(9, processes.get(2).getTurnAroundTimeTime());\n\n        assertEquals(\"P4\", processes.get(3).getProcessId());\n        assertEquals(8, processes.get(3).getWaitingTime());\n        assertEquals(9, processes.get(3).getTurnAroundTimeTime());\n\n        assertEquals(\"P5\", processes.get(4).getProcessId());\n        assertEquals(15, processes.get(4).getWaitingTime());\n        assertEquals(20, processes.get(4).getTurnAroundTimeTime());\n\n        assertEquals(\"P6\", processes.get(5).getProcessId());\n        assertEquals(11, processes.get(5).getWaitingTime());\n        assertEquals(15, processes.get(5).getTurnAroundTimeTime());\n    }\n\n    private List<ProcessDetails> addProcessesForRR() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 5);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 6);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 3);\n        final ProcessDetails process4 = new ProcessDetails(\"P4\", 3, 1);\n        final ProcessDetails process5 = new ProcessDetails(\"P5\", 4, 5);\n        final ProcessDetails process6 = new ProcessDetails(\"P6\", 6, 4);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n        processDetails.add(process4);\n        processDetails.add(process5);\n        processDetails.add(process6);\n\n        return processDetails;\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BinarySearch2dArrayTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream.generate(() -> r.nextInt(maxElement))\n                                 .limit(size)\n                                 .sorted()\n                                 .boxed()\n                                 .toArray(Integer[] ::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.printf(\"Should be found: %d. Found %d at index %d. An array length %d%n\",\n            shouldBeFound, integers[atIndex], atIndex, size);\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.printf(\n            \"Found by system method at an index: %d. Is equal: %b%n\", toCheck, toCheck == atIndex);\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().boxed().toArray(Integer[] ::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.printf(\"Should be found: %d. Found %d at index %d. An array length %d%n\", shouldBeFound, integers[atIndex], atIndex, size);\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.printf(\"Found by system method at an index: %d. Is equal: %b%n\", toCheck, toCheck == atIndex);\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1, -1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = {{1, 2, 3, 4}};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is\n        // fulfilled.\n        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length / 2 - 1][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class,\n            () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1, -1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = {{1, 2, 3, 4}};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is\n        // fulfilled.\n        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length / 2 - 1][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch2dArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BinarySearch2dArrayTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\n/*\nTo apply this method, the provided array must be strictly sorted. In this method, two pointers, one\nat 0th row & the other at the last row are taken & the searching is done on the basis of the middle\nelement of the middle column. If that element is equal to target, its coordinates are returned, else\nif it is smaller than the target, the rows above that element are ignored (because the elements\nabove it will also be smaller than the target), else that element is greater than the target, then\nthe rows below it are ignored.\n */\npublic class BinarySearch2dArray {\n\n    static int[] BinarySearch(int[][] arr, int target) {\n        int rowCount = arr.length, colCount = arr[0].length;\n\n        if (rowCount == 1) {\n            return binarySearch(arr, target, 0, 0, colCount);\n        }\n\n        int startRow = 0, endRow = rowCount - 1, midCol = colCount / 2;\n\n        while (startRow < endRow - 1) {\n            int midRow = startRow + (endRow - startRow) / 2; // getting the index of middle row\n\n            if (arr[midRow][midCol] == target) {\n                return new int[] {midRow, midCol};\n            } else if (arr[midRow][midCol] < target)\n                startRow = midRow;\n            else\n                endRow = midRow;\n        }\n        /*\n            if the above search fails to find the target element, these conditions will be used to\n           find the target element, which further uses the binary search algorithm in the places\n           which were left unexplored.\n             */\n        if (arr[startRow][midCol] == target)\n            return new int[] {\n                startRow,\n                midCol,\n            };\n\n        if (arr[endRow][midCol] == target) return new int[] {endRow, midCol};\n\n        if (target <= arr[startRow][midCol - 1])\n            return binarySearch(arr, target, startRow, 0, midCol - 1);\n\n        if (target >= arr[startRow][midCol + 1] && target <= arr[startRow][colCount - 1])\n            return binarySearch(arr, target, startRow, midCol + 1, colCount - 1);\n\n        if (target <= arr[endRow][midCol - 1])\n            return binarySearch(arr, target, endRow, 0, midCol - 1);\n        else\n            return binarySearch(arr, target, endRow, midCol + 1, colCount - 1);\n    }\n\n    static int[] binarySearch(int[][] arr, int target, int row, int colStart, int colEnd) {\n        while (colStart <= colEnd) {\n            int midIndex = colStart + (colEnd - colStart) / 2;\n\n            if (arr[row][midIndex] == target)\n                return new int[] {\n                    row,\n                    midIndex,\n                };\n            else if (arr[row][midIndex] < target)\n                colStart = midIndex + 1;\n            else\n                colEnd = midIndex - 1;\n        }\n\n        return new int[] {-1, -1};\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\n/*\nTo apply this method, the provided array must be strictly sorted. In this method, two pointers, one\nat 0th row & the other at the last row are taken & the searching is done on the basis of the middle\nelement of the middle column. If that element is equal to target, its coordinates are returned, else\nif it is smaller than the target, the rows above that element are ignored (because the elements\nabove it will also be smaller than the target), else that element is greater than the target, then\nthe rows below it are ignored.\n */\npublic class BinarySearch2dArray {\n\n    static int[] BinarySearch(int[][] arr, int target) {\n        int rowCount = arr.length, colCount = arr[0].length;\n\n        if (rowCount == 1) {\n            return binarySearch(arr, target, 0, 0, colCount);\n        }\n\n        int startRow = 0, endRow = rowCount - 1, midCol = colCount / 2;\n\n        while (startRow < endRow - 1) {\n            int midRow = startRow + (endRow - startRow) / 2; // getting the index of middle row\n\n            if (arr[midRow][midCol] == target) {\n                return new int[] {midRow, midCol};\n            } else if (arr[midRow][midCol] < target)\n                startRow = midRow;\n            else\n                endRow = midRow;\n        }\n        /*\n            if the above search fails to find the target element, these conditions will be used to\n           find the target element, which further uses the binary search algorithm in the places\n           which were left unexplored.\n             */\n        if (arr[startRow][midCol] == target)\n            return new int[] {\n                startRow,\n                midCol,\n            };\n\n        if (arr[endRow][midCol] == target) return new int[] {endRow, midCol};\n\n        if (target <= arr[startRow][midCol - 1]) return binarySearch(arr, target, startRow, 0, midCol - 1);\n\n        if (target >= arr[startRow][midCol + 1] && target <= arr[startRow][colCount - 1]) return binarySearch(arr, target, startRow, midCol + 1, colCount - 1);\n\n        if (target <= arr[endRow][midCol - 1])\n            return binarySearch(arr, target, endRow, 0, midCol - 1);\n        else\n            return binarySearch(arr, target, endRow, midCol + 1, colCount - 1);\n    }\n\n    static int[] binarySearch(int[][] arr, int target, int row, int colStart, int colEnd) {\n        while (colStart <= colEnd) {\n            int midIndex = colStart + (colEnd - colStart) / 2;\n\n            if (arr[row][midIndex] == target)\n                return new int[] {\n                    row,\n                    midIndex,\n                };\n            else if (arr[row][midIndex] < target)\n                colStart = midIndex + 1;\n            else\n                colEnd = midIndex - 1;\n        }\n\n        return new int[] {-1, -1};\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1, -1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = {{1, 2, 3, 4}};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is\n        // fulfilled.\n        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length / 2 - 1][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class,\n            () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1, -1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = {{1, 2, 3, 4}};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is\n        // fulfilled.\n        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length / 2 - 1][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/searches/QuickSelect.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/QuickSelectTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/**\n * An implementation of the Quickselect algorithm as described\n * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>.\n */\npublic final class QuickSelect {\n\n    /**\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\n     * be at index n if the list was sorted.\n     * <p>\n     * Calling this function might change the order of elements in {@code list}.\n     *\n     * @param list the list of elements\n     * @param n    the index\n     * @param <T>  the type of list elements\n     * @return the n-th largest element in the list\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\n     *                                   the number of elements in the list\n     * @throws IllegalArgumentException  if the list is empty\n     * @throws NullPointerException      if {@code list} is null\n     */\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\n        Objects.requireNonNull(list, \"The list of elements must not be null.\");\n\n        if (list.size() == 0) {\n            String msg = \"The list of elements must not be empty.\";\n            throw new IllegalArgumentException(msg);\n        }\n\n        if (n < 0) {\n            String msg = \"The index must not be negative.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        if (n >= list.size()) {\n            String msg = \"The index must be less than the number of elements.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        int index = selectIndex(list, n);\n        return list.get(index);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {\n        return selectIndex(list, 0, list.size() - 1, n);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n        List<T> list, int left, int right, int n) {\n        while (true) {\n            if (left == right) return left;\n            int pivotIndex = pivot(list, left, right);\n            pivotIndex = partition(list, left, right, pivotIndex, n);\n            if (n == pivotIndex) {\n                return n;\n            } else if (n < pivotIndex) {\n                right = pivotIndex - 1;\n            } else {\n                left = pivotIndex + 1;\n            }\n        }\n    }\n\n    private static <T extends Comparable<T>> int partition(\n        List<T> list, int left, int right, int pivotIndex, int n) {\n        T pivotValue = list.get(pivotIndex);\n        Collections.swap(list, pivotIndex, right);\n        int storeIndex = left;\n\n        for (int i = left; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) < 0) {\n                Collections.swap(list, storeIndex, i);\n                storeIndex++;\n            }\n        }\n\n        int storeIndexEq = storeIndex;\n\n        for (int i = storeIndex; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) == 0) {\n                Collections.swap(list, storeIndexEq, i);\n                storeIndexEq++;\n            }\n        }\n\n        Collections.swap(list, right, storeIndexEq);\n\n        return (n < storeIndex) ? storeIndex : Math.min(n, storeIndexEq);\n    }\n\n    private static <T extends Comparable<T>> int pivot(List<T> list, int left, int right) {\n        if (right - left < 5) {\n            return partition5(list, left, right);\n        }\n\n        for (int i = left; i < right; i += 5) {\n            int subRight = i + 4;\n            if (subRight > right) {\n                subRight = right;\n            }\n            int median5 = partition5(list, i, subRight);\n            int rightIndex = left + (i - left) / 5;\n            Collections.swap(list, median5, rightIndex);\n        }\n\n        int mid = (right - left) / 10 + left + 1;\n        int rightIndex = left + (right - left) / 5;\n        return selectIndex(list, left, rightIndex, mid);\n    }\n\n    private static <T extends Comparable<T>> int partition5(List<T> list, int left, int right) {\n        List<T> ts = list.subList(left, right);\n        ts.sort(Comparator.naturalOrder());\n        return (left + right) >>> 1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/**\n * An implementation of the Quickselect algorithm as described\n * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>.\n */\npublic final class QuickSelect {\n\n    /**\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\n     * be at index n if the list was sorted.\n     * <p>\n     * Calling this function might change the order of elements in {@code list}.\n     *\n     * @param list the list of elements\n     * @param n    the index\n     * @param <T>  the type of list elements\n     * @return the n-th largest element in the list\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\n     *                                   the number of elements in the list\n     * @throws IllegalArgumentException  if the list is empty\n     * @throws NullPointerException      if {@code list} is null\n     */\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\n        Objects.requireNonNull(list, \"The list of elements must not be null.\");\n\n        if (list.size() == 0) {\n            String msg = \"The list of elements must not be empty.\";\n            throw new IllegalArgumentException(msg);\n        }\n\n        if (n < 0) {\n            String msg = \"The index must not be negative.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        if (n >= list.size()) {\n            String msg = \"The index must be less than the number of elements.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        int index = selectIndex(list, n);\n        return list.get(index);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {\n        return selectIndex(list, 0, list.size() - 1, n);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(List<T> list, int left, int right, int n) {\n        while (true) {\n            if (left == right) return left;\n            int pivotIndex = pivot(list, left, right);\n            pivotIndex = partition(list, left, right, pivotIndex, n);\n            if (n == pivotIndex) {\n                return n;\n            } else if (n < pivotIndex) {\n                right = pivotIndex - 1;\n            } else {\n                left = pivotIndex + 1;\n            }\n        }\n    }\n\n    private static <T extends Comparable<T>> int partition(List<T> list, int left, int right, int pivotIndex, int n) {\n        T pivotValue = list.get(pivotIndex);\n        Collections.swap(list, pivotIndex, right);\n        int storeIndex = left;\n\n        for (int i = left; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) < 0) {\n                Collections.swap(list, storeIndex, i);\n                storeIndex++;\n            }\n        }\n\n        int storeIndexEq = storeIndex;\n\n        for (int i = storeIndex; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) == 0) {\n                Collections.swap(list, storeIndexEq, i);\n                storeIndexEq++;\n            }\n        }\n\n        Collections.swap(list, right, storeIndexEq);\n\n        return (n < storeIndex) ? storeIndex : Math.min(n, storeIndexEq);\n    }\n\n    private static <T extends Comparable<T>> int pivot(List<T> list, int left, int right) {\n        if (right - left < 5) {\n            return partition5(list, left, right);\n        }\n\n        for (int i = left; i < right; i += 5) {\n            int subRight = i + 4;\n            if (subRight > right) {\n                subRight = right;\n            }\n            int median5 = partition5(list, i, subRight);\n            int rightIndex = left + (i - left) / 5;\n            Collections.swap(list, median5, rightIndex);\n        }\n\n        int mid = (right - left) / 10 + left + 1;\n        int rightIndex = left + (right - left) / 5;\n        return selectIndex(list, left, rightIndex, mid);\n    }\n\n    private static <T extends Comparable<T>> int partition5(List<T> list, int left, int right) {\n        List<T> ts = list.subList(left, right);\n        ts.sort(Comparator.naturalOrder());\n        return (left + right) >>> 1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport org.junit.jupiter.api.Test;\n\nclass QuickSelectTest {\n\n    @Test\n    void quickSelectMinimumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int minimum = QuickSelect.select(elements, 0);\n        assertEquals(42, minimum);\n    }\n\n    @Test\n    void quickSelectMinimumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n\n        assertEquals(42, minimum1);\n        assertEquals(42, minimum2);\n    }\n\n    @Test\n    void quickSelectMinimumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n        int minimum3 = QuickSelect.select(elements3, 0);\n\n        assertEquals(1, minimum1);\n        assertEquals(1, minimum2);\n        assertEquals(1, minimum3);\n    }\n\n    @Test\n    void quickSelectMinimumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, 0);\n        int expected = elements.stream().min(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMaximumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int maximum = QuickSelect.select(elements, 0);\n        assertEquals(42, maximum);\n    }\n\n    @Test\n    void quickSelectMaximumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int maximum1 = QuickSelect.select(elements1, 1);\n        int maximum2 = QuickSelect.select(elements2, 1);\n\n        assertEquals(90, maximum1);\n        assertEquals(90, maximum2);\n    }\n\n    @Test\n    void quickSelectMaximumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int maximum1 = QuickSelect.select(elements1, 2);\n        int maximum2 = QuickSelect.select(elements2, 2);\n        int maximum3 = QuickSelect.select(elements3, 2);\n\n        assertEquals(3, maximum1);\n        assertEquals(3, maximum2);\n        assertEquals(3, maximum3);\n    }\n\n    @Test\n    void quickSelectMaximumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, NUM_RND_ELEMENTS - 1);\n        int expected = elements.stream().max(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMedianOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int median = QuickSelect.select(elements, 0);\n        assertEquals(42, median);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int median1 = QuickSelect.select(elements1, 1);\n        int median2 = QuickSelect.select(elements2, 1);\n        int median3 = QuickSelect.select(elements3, 1);\n\n        assertEquals(2, median1);\n        assertEquals(2, median2);\n        assertEquals(2, median3);\n    }\n\n    @Test\n    void quickSelectMedianOfManyElements() {\n        int medianIndex = NUM_RND_ELEMENTS / 2;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, medianIndex);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(medianIndex), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 2);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(2), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOfManyElements() {\n        int percentile30th = NUM_RND_ELEMENTS / 10 * 3;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile30th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile30th), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 6);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(6), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOfManyElements() {\n        int percentile70th = NUM_RND_ELEMENTS / 10 * 7;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile70th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile70th), actual);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeCharacters() {\n        List<Character> elements = Arrays.asList('X', 'Z', 'Y');\n        char actual = QuickSelect.select(elements, 1);\n        assertEquals(actual, 'Y');\n    }\n\n    @Test\n    void quickSelectMedianOfManyCharacters() {\n        List<Character> elements = generateRandomCharacters(NUM_RND_ELEMENTS);\n        char actual = QuickSelect.select(elements, NUM_RND_ELEMENTS / 30);\n\n        List<Character> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(NUM_RND_ELEMENTS / 30), actual);\n    }\n\n    @Test\n    void quickSelectNullList() {\n        NullPointerException exception\n            = assertThrows(NullPointerException.class, () -> QuickSelect.select(null, 0));\n        String expectedMsg = \"The list of elements must not be null.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectEmptyList() {\n        List<String> objects = Collections.emptyList();\n        IllegalArgumentException exception\n            = assertThrows(IllegalArgumentException.class, () -> QuickSelect.select(objects, 0));\n        String expectedMsg = \"The list of elements must not be empty.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfLeftBound() {\n        IndexOutOfBoundsException exception = assertThrows(IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), -1));\n        String expectedMsg = \"The index must not be negative.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfRightBound() {\n        IndexOutOfBoundsException exception = assertThrows(IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), 1));\n        String expectedMsg = \"The index must be less than the number of elements.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    private static final int NUM_RND_ELEMENTS = 99;\n    private static final Random RANDOM = new Random(42);\n    private static final int ASCII_A = 0x41;\n    private static final int ASCII_Z = 0x5A;\n\n    private static List<Integer> generateRandomIntegers(int n) {\n        return RANDOM.ints(n).boxed().collect(Collectors.toList());\n    }\n\n    private static List<Character> generateRandomCharacters(int n) {\n        return RANDOM.ints(n, ASCII_A, ASCII_Z)\n            .mapToObj(i -> (char) i)\n            .collect(Collectors.toList());\n    }\n\n    private static <T extends Comparable<T>> List<T> getSortedCopyOfList(List<T> list) {\n        return list.stream().sorted().collect(Collectors.toList());\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport org.junit.jupiter.api.Test;\n\nclass QuickSelectTest {\n\n    @Test\n    void quickSelectMinimumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int minimum = QuickSelect.select(elements, 0);\n        assertEquals(42, minimum);\n    }\n\n    @Test\n    void quickSelectMinimumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n\n        assertEquals(42, minimum1);\n        assertEquals(42, minimum2);\n    }\n\n    @Test\n    void quickSelectMinimumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n        int minimum3 = QuickSelect.select(elements3, 0);\n\n        assertEquals(1, minimum1);\n        assertEquals(1, minimum2);\n        assertEquals(1, minimum3);\n    }\n\n    @Test\n    void quickSelectMinimumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, 0);\n        int expected = elements.stream().min(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMaximumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int maximum = QuickSelect.select(elements, 0);\n        assertEquals(42, maximum);\n    }\n\n    @Test\n    void quickSelectMaximumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int maximum1 = QuickSelect.select(elements1, 1);\n        int maximum2 = QuickSelect.select(elements2, 1);\n\n        assertEquals(90, maximum1);\n        assertEquals(90, maximum2);\n    }\n\n    @Test\n    void quickSelectMaximumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int maximum1 = QuickSelect.select(elements1, 2);\n        int maximum2 = QuickSelect.select(elements2, 2);\n        int maximum3 = QuickSelect.select(elements3, 2);\n\n        assertEquals(3, maximum1);\n        assertEquals(3, maximum2);\n        assertEquals(3, maximum3);\n    }\n\n    @Test\n    void quickSelectMaximumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, NUM_RND_ELEMENTS - 1);\n        int expected = elements.stream().max(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMedianOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int median = QuickSelect.select(elements, 0);\n        assertEquals(42, median);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int median1 = QuickSelect.select(elements1, 1);\n        int median2 = QuickSelect.select(elements2, 1);\n        int median3 = QuickSelect.select(elements3, 1);\n\n        assertEquals(2, median1);\n        assertEquals(2, median2);\n        assertEquals(2, median3);\n    }\n\n    @Test\n    void quickSelectMedianOfManyElements() {\n        int medianIndex = NUM_RND_ELEMENTS / 2;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, medianIndex);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(medianIndex), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 2);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(2), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOfManyElements() {\n        int percentile30th = NUM_RND_ELEMENTS / 10 * 3;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile30th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile30th), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 6);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(6), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOfManyElements() {\n        int percentile70th = NUM_RND_ELEMENTS / 10 * 7;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile70th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile70th), actual);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeCharacters() {\n        List<Character> elements = Arrays.asList('X', 'Z', 'Y');\n        char actual = QuickSelect.select(elements, 1);\n        assertEquals(actual, 'Y');\n    }\n\n    @Test\n    void quickSelectMedianOfManyCharacters() {\n        List<Character> elements = generateRandomCharacters(NUM_RND_ELEMENTS);\n        char actual = QuickSelect.select(elements, NUM_RND_ELEMENTS / 30);\n\n        List<Character> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(NUM_RND_ELEMENTS / 30), actual);\n    }\n\n    @Test\n    void quickSelectNullList() {\n        NullPointerException exception = assertThrows(NullPointerException.class, () -> QuickSelect.select(null, 0));\n        String expectedMsg = \"The list of elements must not be null.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectEmptyList() {\n        List<String> objects = Collections.emptyList();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> QuickSelect.select(objects, 0));\n        String expectedMsg = \"The list of elements must not be empty.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfLeftBound() {\n        IndexOutOfBoundsException exception = assertThrows(IndexOutOfBoundsException.class, () -> QuickSelect.select(Collections.singletonList(1), -1));\n        String expectedMsg = \"The index must not be negative.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfRightBound() {\n        IndexOutOfBoundsException exception = assertThrows(IndexOutOfBoundsException.class, () -> QuickSelect.select(Collections.singletonList(1), 1));\n        String expectedMsg = \"The index must be less than the number of elements.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    private static final int NUM_RND_ELEMENTS = 99;\n    private static final Random RANDOM = new Random(42);\n    private static final int ASCII_A = 0x41;\n    private static final int ASCII_Z = 0x5A;\n\n    private static List<Integer> generateRandomIntegers(int n) {\n        return RANDOM.ints(n).boxed().collect(Collectors.toList());\n    }\n\n    private static List<Character> generateRandomCharacters(int n) {\n        return RANDOM.ints(n, ASCII_A, ASCII_Z).mapToObj(i -> (char) i).collect(Collectors.toList());\n    }\n\n    private static <T extends Comparable<T>> List<T> getSortedCopyOfList(List<T> list) {\n        return list.stream().sorted().collect(Collectors.toList());\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/MergeSortRecursive.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/MergeSortRecursiveTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MergeSortRecursive {\n\n    List<Integer> arr;\n\n    public MergeSortRecursive(List<Integer> arr) {\n        this.arr = arr;\n    }\n\n    public List<Integer> mergeSort() {\n        return merge(arr);\n    }\n\n    private static List<Integer> merge(List<Integer> arr) {\n        // base condition\n        if (arr.size() <= 1) {\n            return arr;\n        }\n\n        int arrLength = arr.size();\n        int half = arrLength / 2;\n        List<Integer> arrA = arr.subList(0, half);\n        List<Integer> arrB = arr.subList(half, arr.size());\n\n        // recursion\n        arrA = merge(arrA);\n        arrB = merge(arrB);\n\n        return sort(arrA, arrB);\n    }\n\n    private static List<Integer> sort(List<Integer> unsortedA, List<Integer> unsortedB) {\n        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {\n            return new ArrayList<>();\n        }\n        if (unsortedA.size() <= 0) {\n            return unsortedB;\n        }\n        if (unsortedB.size() <= 0) {\n            return unsortedA;\n        }\n        if (unsortedA.get(0) <= unsortedB.get(0)) {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                { add(unsortedA.get(0)); }\n            };\n            newAl.addAll(sort(unsortedA.subList(1, unsortedA.size()), unsortedB));\n            return newAl;\n        } else {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                { add(unsortedB.get(0)); }\n            };\n            newAl.addAll(sort(unsortedA, unsortedB.subList(1, unsortedB.size())));\n            return newAl;\n        }\n    }\n}\n\nclass App {\n\n    public static void main(String[] args) {\n        MergeSortRecursive sort = new MergeSortRecursive(\n            new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9)));\n        sort.mergeSort();\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MergeSortRecursive {\n\n    List<Integer> arr;\n\n    public MergeSortRecursive(List<Integer> arr) {\n        this.arr = arr;\n    }\n\n    public List<Integer> mergeSort() {\n        return merge(arr);\n    }\n\n    private static List<Integer> merge(List<Integer> arr) {\n        // base condition\n        if (arr.size() <= 1) {\n            return arr;\n        }\n\n        int arrLength = arr.size();\n        int half = arrLength / 2;\n        List<Integer> arrA = arr.subList(0, half);\n        List<Integer> arrB = arr.subList(half, arr.size());\n\n        // recursion\n        arrA = merge(arrA);\n        arrB = merge(arrB);\n\n        return sort(arrA, arrB);\n    }\n\n    private static List<Integer> sort(List<Integer> unsortedA, List<Integer> unsortedB) {\n        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {\n            return new ArrayList<>();\n        }\n        if (unsortedA.size() <= 0) {\n            return unsortedB;\n        }\n        if (unsortedB.size() <= 0) {\n            return unsortedA;\n        }\n        if (unsortedA.get(0) <= unsortedB.get(0)) {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                { add(unsortedA.get(0)); }\n            };\n            newAl.addAll(sort(unsortedA.subList(1, unsortedA.size()), unsortedB));\n            return newAl;\n        } else {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                { add(unsortedB.get(0)); }\n            };\n            newAl.addAll(sort(unsortedA, unsortedB.subList(1, unsortedB.size())));\n            return newAl;\n        }\n    }\n}\n\nclass App {\n\n    public static void main(String[] args) {\n        MergeSortRecursive sort = new MergeSortRecursive(new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9)));\n        sort.mergeSort();\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class MergeSortRecursiveTest {\n\n    //\tprivate MergeSortRecursive mergeSortRecursive = new MergeSortRecursive();\n\n    @Test\n    void testMergeSortRecursiveCase1() {\n        MergeSortRecursive mergeSortRecursive\n            = new MergeSortRecursive(Arrays.asList(5, 12, 9, 3, 15, 88));\n\n        List<Integer> expected = Arrays.asList(3, 5, 9, 12, 15, 88);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n\n    @Test\n    void testMergeSortRecursiveCase2() {\n        MergeSortRecursive mergeSortRecursive\n            = new MergeSortRecursive(Arrays.asList(-3, 5, 3, 4, 3, 7, 40, -20, 30, 0));\n\n        List<Integer> expected = Arrays.asList(-20, -3, 0, 3, 3, 4, 5, 7, 30, 40);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class MergeSortRecursiveTest {\n\n    //\tprivate MergeSortRecursive mergeSortRecursive = new MergeSortRecursive();\n\n    @Test\n    void testMergeSortRecursiveCase1() {\n        MergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(5, 12, 9, 3, 15, 88));\n\n        List<Integer> expected = Arrays.asList(3, 5, 9, 12, 15, 88);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n\n    @Test\n    void testMergeSortRecursiveCase2() {\n        MergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(-3, 5, 3, 4, 3, 7, 40, -20, 30, 0));\n\n        List<Integer> expected = Arrays.asList(-20, -3, 0, 3, 3, 4, 5, 7, 30, 40);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/StrandSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/StrandSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class StrandSort {\n\n    // note: the input list is destroyed\n    public static <E extends Comparable<? super E>> LinkedList<E> strandSort(LinkedList<E> list) {\n        if (list.size() <= 1) return list;\n\n        LinkedList<E> result = new LinkedList<E>();\n        while (list.size() > 0) {\n            LinkedList<E> sorted = new LinkedList<E>();\n            sorted.add(list.removeFirst()); // same as remove() or remove(0)\n            for (Iterator<E> it = list.iterator(); it.hasNext();) {\n                E elem = it.next();\n                if (sorted.peekLast().compareTo(elem) <= 0) {\n                    sorted.addLast(elem); // same as add(elem) or add(0, elem)\n                    it.remove();\n                }\n            }\n            result = merge(sorted, result);\n        }\n        return result;\n    }\n\n    private static <E extends Comparable<? super E>> LinkedList<E> merge(\n        LinkedList<E> left, LinkedList<E> right) {\n        LinkedList<E> result = new LinkedList<E>();\n        while (!left.isEmpty() && !right.isEmpty()) {\n            // change the direction of this comparison to change the direction of the sort\n            if (left.peek().compareTo(right.peek()) <= 0)\n                result.add(left.remove());\n            else\n                result.add(right.remove());\n        }\n        result.addAll(left);\n        result.addAll(right);\n        return result;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class StrandSort {\n\n    // note: the input list is destroyed\n    public static <E extends Comparable<? super E>> LinkedList<E> strandSort(LinkedList<E> list) {\n        if (list.size() <= 1) return list;\n\n        LinkedList<E> result = new LinkedList<E>();\n        while (list.size() > 0) {\n            LinkedList<E> sorted = new LinkedList<E>();\n            sorted.add(list.removeFirst()); // same as remove() or remove(0)\n            for (Iterator<E> it = list.iterator(); it.hasNext();) {\n                E elem = it.next();\n                if (sorted.peekLast().compareTo(elem) <= 0) {\n                    sorted.addLast(elem); // same as add(elem) or add(0, elem)\n                    it.remove();\n                }\n            }\n            result = merge(sorted, result);\n        }\n        return result;\n    }\n\n    private static <E extends Comparable<? super E>> LinkedList<E> merge(LinkedList<E> left, LinkedList<E> right) {\n        LinkedList<E> result = new LinkedList<E>();\n        while (!left.isEmpty() && !right.isEmpty()) {\n            // change the direction of this comparison to change the direction of the sort\n            if (left.peek().compareTo(right.peek()) <= 0)\n                result.add(left.remove());\n            else\n                result.add(right.remove());\n        }\n        result.addAll(left);\n        result.addAll(right);\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass StrandSortTest {\n\n    @Test\n    // valid test case\n    public void StrandSortNonDuplicateTest() {\n        int[] expectedArray = {1, 2, 3, 4, 5};\n        LinkedList<Integer> actualList\n            = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(3, 1, 2, 4, 5)));\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortDuplicateTest() {\n        int[] expectedArray = {2, 2, 2, 5, 7};\n        LinkedList<Integer> actualList\n            = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(7, 2, 2, 2, 5)));\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass StrandSortTest {\n\n    @Test\n    // valid test case\n    public void StrandSortNonDuplicateTest() {\n        int[] expectedArray = {1, 2, 3, 4, 5};\n        LinkedList<Integer> actualList = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(3, 1, 2, 4, 5)));\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortDuplicateTest() {\n        int[] expectedArray = {2, 2, 2, 5, 7};\n        LinkedList<Integer> actualList = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(7, 2, 2, 2, 5)));\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/TreeSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/TreeSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nimport com.thealgorithms.datastructures.trees.BSTRecursiveGeneric;\nimport java.util.List;\n\n/**\n * <h1> Implementation of the Tree Sort algorithm</h1>\n *\n * <p>\n * Tree Sort: A sorting algorithm which constructs a Binary Search Tree using\n * the unsorted data and then outputs the data by inorder traversal of the tree.\n *\n * Reference: https://en.wikipedia.org/wiki/Tree_sort\n * </p>\n *\n * @author Madhur Panwar (https://github.com/mdrpanwar)\n */\npublic class TreeSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        return doTreeSortArray(unsortedArray);\n    }\n\n    @Override\n    public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) {\n        return doTreeSortList(unsortedList);\n    }\n\n    private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedArray) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree\n        List<T> sortedList = tree.inorderSort();\n\n        // add the elements back to the initial array\n        int i = 0;\n        for (T element : sortedList) {\n            unsortedArray[i++] = element;\n        }\n\n        // return the array\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> List<T> doTreeSortList(List<T> unsortedList) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedList) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree and return it\n        return tree.inorderSort();\n    }\n\n    public static void main(String[] args) {\n        TreeSort treeSort = new TreeSort();\n\n        // ==== Integer Array =======\n        System.out.println(\"Testing for Integer Array....\");\n        Integer[] a = {3, -7, 45, 1, 343, -5, 2, 9};\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(a);\n        a = treeSort.sort(a);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(a);\n        System.out.println();\n\n        // ==== Integer List =======\n        System.out.println(\"Testing for Integer List....\");\n        List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9);\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(intList);\n        intList = treeSort.sort(intList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(intList);\n        System.out.println();\n\n        // ==== String Array =======\n        System.out.println(\"Testing for String Array....\");\n        String[] b = {\n            \"banana\",\n            \"berry\",\n            \"orange\",\n            \"grape\",\n            \"peach\",\n            \"cherry\",\n            \"apple\",\n            \"pineapple\",\n        };\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(b);\n        b = treeSort.sort(b);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(b);\n        System.out.println();\n\n        // ==== String List =======\n        System.out.println(\"Testing for String List....\");\n        List<String> stringList = List.of(\n            \"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\");\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(stringList);\n        stringList = treeSort.sort(stringList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(stringList);\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nimport com.thealgorithms.datastructures.trees.BSTRecursiveGeneric;\nimport java.util.List;\n\n/**\n * <h1> Implementation of the Tree Sort algorithm</h1>\n *\n * <p>\n * Tree Sort: A sorting algorithm which constructs a Binary Search Tree using\n * the unsorted data and then outputs the data by inorder traversal of the tree.\n *\n * Reference: https://en.wikipedia.org/wiki/Tree_sort\n * </p>\n *\n * @author Madhur Panwar (https://github.com/mdrpanwar)\n */\npublic class TreeSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        return doTreeSortArray(unsortedArray);\n    }\n\n    @Override\n    public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) {\n        return doTreeSortList(unsortedList);\n    }\n\n    private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedArray) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree\n        List<T> sortedList = tree.inorderSort();\n\n        // add the elements back to the initial array\n        int i = 0;\n        for (T element : sortedList) {\n            unsortedArray[i++] = element;\n        }\n\n        // return the array\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> List<T> doTreeSortList(List<T> unsortedList) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedList) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree and return it\n        return tree.inorderSort();\n    }\n\n    public static void main(String[] args) {\n        TreeSort treeSort = new TreeSort();\n\n        // ==== Integer Array =======\n        System.out.println(\"Testing for Integer Array....\");\n        Integer[] a = {3, -7, 45, 1, 343, -5, 2, 9};\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(a);\n        a = treeSort.sort(a);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(a);\n        System.out.println();\n\n        // ==== Integer List =======\n        System.out.println(\"Testing for Integer List....\");\n        List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9);\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(intList);\n        intList = treeSort.sort(intList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(intList);\n        System.out.println();\n\n        // ==== String Array =======\n        System.out.println(\"Testing for String Array....\");\n        String[] b = {\n            \"banana\",\n            \"berry\",\n            \"orange\",\n            \"grape\",\n            \"peach\",\n            \"cherry\",\n            \"apple\",\n            \"pineapple\",\n        };\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(b);\n        b = treeSort.sort(b);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(b);\n        System.out.println();\n\n        // ==== String List =======\n        System.out.println(\"Testing for String List....\");\n        List<String> stringList = List.of(\"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\");\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(stringList);\n        stringList = treeSort.sort(stringList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(stringList);\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see TreeSort\n */\n\npublic class TreeSortTest {\n    private TreeSort treeSort = new TreeSort();\n\n    @Test\n    public void treeSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void treeSortSingleStringElement() {\n        String[] inputArray = {\"Test\"};\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray = {\"Test\"};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortStringArray() {\n        String[] inputArray\n            = {\"F6w9\", \"l1qz\", \"dIxH\", \"larj\", \"kRzy\", \"vnNH\", \"3ftM\", \"hc4n\", \"C5Qi\", \"btGF\"};\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray\n            = {\"3ftM\", \"C5Qi\", \"F6w9\", \"btGF\", \"dIxH\", \"hc4n\", \"kRzy\", \"l1qz\", \"larj\", \"vnNH\"};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortIntegerArray() {\n        Integer[] inputArray = {-97, -44, -4, -85, -92, 74, 79, -26, 76, -5};\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedArray = {-97, -92, -85, -44, -26, -5, -4, 74, 76, 79};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortDoubleArray() {\n        Double[] inputArray = {0.8047485045, 0.4493112337, 0.8298433723, 0.2691406748, 0.2482782839,\n            0.5976243420, 0.6746235284, 0.0552623569, 0.3515624123, 0.0536747336};\n        Double[] outputArray = treeSort.sort(inputArray);\n        Double[] expectedArray = {0.0536747336, 0.0552623569, 0.2482782839, 0.2691406748,\n            0.3515624123, 0.4493112337, 0.5976243420, 0.6746235284, 0.8047485045, 0.8298433723};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see TreeSort\n */\n\npublic class TreeSortTest {\n    private TreeSort treeSort = new TreeSort();\n\n    @Test\n    public void treeSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void treeSortSingleStringElement() {\n        String[] inputArray = {\"Test\"};\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray = {\"Test\"};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortStringArray() {\n        String[] inputArray = {\"F6w9\", \"l1qz\", \"dIxH\", \"larj\", \"kRzy\", \"vnNH\", \"3ftM\", \"hc4n\", \"C5Qi\", \"btGF\"};\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray = {\"3ftM\", \"C5Qi\", \"F6w9\", \"btGF\", \"dIxH\", \"hc4n\", \"kRzy\", \"l1qz\", \"larj\", \"vnNH\"};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortIntegerArray() {\n        Integer[] inputArray = {-97, -44, -4, -85, -92, 74, 79, -26, 76, -5};\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedArray = {-97, -92, -85, -44, -26, -5, -4, 74, 76, 79};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortDoubleArray() {\n        Double[] inputArray = {0.8047485045, 0.4493112337, 0.8298433723, 0.2691406748, 0.2482782839, 0.5976243420, 0.6746235284, 0.0552623569, 0.3515624123, 0.0536747336};\n        Double[] outputArray = treeSort.sort(inputArray);\n        Double[] expectedArray = {0.0536747336, 0.0552623569, 0.2482782839, 0.2691406748, 0.3515624123, 0.4493112337, 0.5976243420, 0.6746235284, 0.8047485045, 0.8298433723};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/strings/HorspoolSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/HorspoolSearchTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\n/**\n * This class is not thread safe<br>\n * <br>\n * (From wikipedia) In computer science, the Boyer\u2013Moore\u2013Horspool algorithm or\n * Horspool's algorithm is an algorithm for finding substrings in strings. It\n * was published by Nigel Horspool in 1980.\n * <br>\n * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia\n * page</a><br>\n * <br>\n *\n * <p>\n * An explanation:<br>\n *\n * <p>\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\n * that it uses only one of the two heuristic methods for increasing the number\n * of characters shifted when finding a bad match in the text. This method is\n * usually called the \"bad symbol\" or \"bad character\" shift. The bad symbol\n * shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that\n * processing a given input to a problem and altering it in a specific way will\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\n * to match the pattern and text comparing the pattern symbols to the text's\n * from right to left.<br>\n * <br>\n *\n * <p>\n * In the bad symbol shift method, a table is created prior to the search,\n * called the \"bad symbol table\". The bad symbol table contains the shift values\n * for any symbol in the text and pattern. For these symbols, the value is the\n * length of the pattern, if the symbol is not in the first (length - 1) of the\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values\n * for the ones that exist in the first (length - 1) of the pattern.<br>\n * <br>\n *\n * <p>\n * For more details on the algorithm and the more advanced Boyer-Moore I\n * recommend checking out the wikipedia page and professor Anany Levitin's book:\n * Introduction To The Design And Analysis Of Algorithms.\n */\npublic class HorspoolSearch {\n\n    private static HashMap<Character, Integer> shiftValues; // bad symbol table\n    private static Integer patternLength;\n    private static int comparisons = 0; // total comparisons in the current/last search\n\n    /**\n     * Case sensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirst(String pattern, String text) {\n        return firstOccurrence(pattern, text, true);\n    }\n\n    /**\n     * Case insensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirstInsensitive(String pattern, String text) {\n        return firstOccurrence(pattern, text, false);\n    }\n\n    /**\n     * Utility method that returns comparisons made by last run (mainly for\n     * tests)\n     *\n     * @return number of character comparisons of the last search\n     */\n    public static Integer getLastComparisons() {\n        return HorspoolSearch.comparisons;\n    }\n\n    /**\n     * Fairly standard implementation of the Horspool algorithm. Only the index\n     * of the last character of the pattern on the text is saved and shifted by\n     * the appropriate amount when a mismatch is found. The algorithm stops at\n     * the first match or when the entire text has been exhausted.\n     *\n     * @param pattern String to be matched in the text\n     * @param text text String\n     * @return index of first occurrence of the pattern in the text\n     */\n    private static int firstOccurrence(String pattern, String text, boolean caseSensitive) {\n        shiftValues = calcShiftValues(pattern); // build the bad symbol table\n        comparisons = 0; // reset comparisons\n\n        if (pattern.length() == 0) { // return failure, if pattern empty\n            return -1;\n        }\n\n        int textIndex = pattern.length()\n            - 1; // align pattern with text start and get index of the last character\n\n        // while pattern is not out of text bounds\n        while (textIndex < text.length()) {\n            // try to match pattern with current part of the text starting from last character\n            int i = pattern.length() - 1;\n            while (i >= 0) {\n                comparisons++;\n                char patternChar = pattern.charAt(i);\n                char textChar = text.charAt((textIndex + i) - (pattern.length() - 1));\n                if (!charEquals(\n                        patternChar, textChar, caseSensitive)) { // bad character, shift pattern\n                    textIndex += getShiftValue(text.charAt(textIndex));\n                    break;\n                }\n                i--;\n            }\n\n            // check for full match\n            if (i == -1) {\n                return textIndex - pattern.length() + 1;\n            }\n        }\n\n        // text exhausted, return failure\n        return -1;\n    }\n\n    /**\n     * Compares the argument characters\n     *\n     * @param c1 first character\n     * @param c2 second character\n     * @param caseSensitive boolean determining case sensitivity of comparison\n     * @return truth value of the equality comparison\n     */\n    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {\n        if (caseSensitive) {\n            return c1 == c2;\n        }\n        return Character.toLowerCase(c1) == Character.toLowerCase(c2);\n    }\n\n    /**\n     * Builds the bad symbol table required to run the algorithm. The method\n     * starts from the second to last character of the pattern and moves to the\n     * left. When it meets a new character, it is by definition its rightmost\n     * occurrence and therefore puts the distance from the current index to the\n     * index of the last character into the table. If the character is already\n     * in the table, then it is not a rightmost occurrence, so it continues.\n     *\n     * @param pattern basis for the bad symbol table\n     * @return the bad symbol table\n     */\n    private static HashMap<Character, Integer> calcShiftValues(String pattern) {\n        patternLength = pattern.length();\n        HashMap<Character, Integer> table = new HashMap<>();\n\n        for (int i = pattern.length() - 2; i >= 0;\n             i--) { // length - 2 is the index of the second to last character\n            char c = pattern.charAt(i);\n            int finalI = i;\n            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);\n        }\n\n        return table;\n    }\n\n    /**\n     * Helper function that uses the bad symbol shift table to return the\n     * appropriate shift value for a given character\n     *\n     * @param c character\n     * @return shift value that corresponds to the character argument\n     */\n    private static Integer getShiftValue(char c) {\n        if (shiftValues.get(c) != null) {\n            return shiftValues.get(c);\n        } else {\n            return patternLength;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\n/**\n * This class is not thread safe<br>\n * <br>\n * (From wikipedia) In computer science, the Boyer\u2013Moore\u2013Horspool algorithm or\n * Horspool's algorithm is an algorithm for finding substrings in strings. It\n * was published by Nigel Horspool in 1980.\n * <br>\n * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia\n * page</a><br>\n * <br>\n *\n * <p>\n * An explanation:<br>\n *\n * <p>\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\n * that it uses only one of the two heuristic methods for increasing the number\n * of characters shifted when finding a bad match in the text. This method is\n * usually called the \"bad symbol\" or \"bad character\" shift. The bad symbol\n * shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that\n * processing a given input to a problem and altering it in a specific way will\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\n * to match the pattern and text comparing the pattern symbols to the text's\n * from right to left.<br>\n * <br>\n *\n * <p>\n * In the bad symbol shift method, a table is created prior to the search,\n * called the \"bad symbol table\". The bad symbol table contains the shift values\n * for any symbol in the text and pattern. For these symbols, the value is the\n * length of the pattern, if the symbol is not in the first (length - 1) of the\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values\n * for the ones that exist in the first (length - 1) of the pattern.<br>\n * <br>\n *\n * <p>\n * For more details on the algorithm and the more advanced Boyer-Moore I\n * recommend checking out the wikipedia page and professor Anany Levitin's book:\n * Introduction To The Design And Analysis Of Algorithms.\n */\npublic class HorspoolSearch {\n\n    private static HashMap<Character, Integer> shiftValues; // bad symbol table\n    private static Integer patternLength;\n    private static int comparisons = 0; // total comparisons in the current/last search\n\n    /**\n     * Case sensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirst(String pattern, String text) {\n        return firstOccurrence(pattern, text, true);\n    }\n\n    /**\n     * Case insensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirstInsensitive(String pattern, String text) {\n        return firstOccurrence(pattern, text, false);\n    }\n\n    /**\n     * Utility method that returns comparisons made by last run (mainly for\n     * tests)\n     *\n     * @return number of character comparisons of the last search\n     */\n    public static Integer getLastComparisons() {\n        return HorspoolSearch.comparisons;\n    }\n\n    /**\n     * Fairly standard implementation of the Horspool algorithm. Only the index\n     * of the last character of the pattern on the text is saved and shifted by\n     * the appropriate amount when a mismatch is found. The algorithm stops at\n     * the first match or when the entire text has been exhausted.\n     *\n     * @param pattern String to be matched in the text\n     * @param text text String\n     * @return index of first occurrence of the pattern in the text\n     */\n    private static int firstOccurrence(String pattern, String text, boolean caseSensitive) {\n        shiftValues = calcShiftValues(pattern); // build the bad symbol table\n        comparisons = 0; // reset comparisons\n\n        if (pattern.length() == 0) { // return failure, if pattern empty\n            return -1;\n        }\n\n        int textIndex = pattern.length() - 1; // align pattern with text start and get index of the last character\n\n        // while pattern is not out of text bounds\n        while (textIndex < text.length()) {\n            // try to match pattern with current part of the text starting from last character\n            int i = pattern.length() - 1;\n            while (i >= 0) {\n                comparisons++;\n                char patternChar = pattern.charAt(i);\n                char textChar = text.charAt((textIndex + i) - (pattern.length() - 1));\n                if (!charEquals(patternChar, textChar, caseSensitive)) { // bad character, shift pattern\n                    textIndex += getShiftValue(text.charAt(textIndex));\n                    break;\n                }\n                i--;\n            }\n\n            // check for full match\n            if (i == -1) {\n                return textIndex - pattern.length() + 1;\n            }\n        }\n\n        // text exhausted, return failure\n        return -1;\n    }\n\n    /**\n     * Compares the argument characters\n     *\n     * @param c1 first character\n     * @param c2 second character\n     * @param caseSensitive boolean determining case sensitivity of comparison\n     * @return truth value of the equality comparison\n     */\n    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {\n        if (caseSensitive) {\n            return c1 == c2;\n        }\n        return Character.toLowerCase(c1) == Character.toLowerCase(c2);\n    }\n\n    /**\n     * Builds the bad symbol table required to run the algorithm. The method\n     * starts from the second to last character of the pattern and moves to the\n     * left. When it meets a new character, it is by definition its rightmost\n     * occurrence and therefore puts the distance from the current index to the\n     * index of the last character into the table. If the character is already\n     * in the table, then it is not a rightmost occurrence, so it continues.\n     *\n     * @param pattern basis for the bad symbol table\n     * @return the bad symbol table\n     */\n    private static HashMap<Character, Integer> calcShiftValues(String pattern) {\n        patternLength = pattern.length();\n        HashMap<Character, Integer> table = new HashMap<>();\n\n        for (int i = pattern.length() - 2; i >= 0; i--) { // length - 2 is the index of the second to last character\n            char c = pattern.charAt(i);\n            int finalI = i;\n            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);\n        }\n\n        return table;\n    }\n\n    /**\n     * Helper function that uses the bad symbol shift table to return the\n     * appropriate shift value for a given character\n     *\n     * @param c character\n     * @return shift value that corresponds to the character argument\n     */\n    private static Integer getShiftValue(char c) {\n        if (shiftValues.get(c) != null) {\n            return shiftValues.get(c);\n        } else {\n            return patternLength;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HorspoolSearchTest {\n\n    @Test\n    void testFindFirstMatch() {\n        int index = HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstNotMatch() {\n        int index = HorspoolSearch.findFirst(\"hell\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternLongerText() {\n        int index = HorspoolSearch.findFirst(\"Hello World!!!\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"Hello\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternAndTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstSpecialCharacter() {\n        int index = HorspoolSearch.findFirst(\"$3**\", \"Hello $3**$ World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"hello\", \"Hello World\");\n        assertEquals(0, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveNotMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"helo\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testGetLastComparisons() {\n        HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(7, lastSearchNumber);\n    }\n\n    @Test\n    void testGetLastComparisonsNotMatch() {\n        HorspoolSearch.findFirst(\"Word\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(3, lastSearchNumber);\n    }\n\n    @Test\n    void testFindFirstPatternNull() {\n        assertThrows(\n            NullPointerException.class, () -> HorspoolSearch.findFirst(null, \"Hello World\"));\n    }\n\n    @Test\n    void testFindFirstTextNull() {\n        assertThrows(NullPointerException.class, () -> HorspoolSearch.findFirst(\"Hello\", null));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HorspoolSearchTest {\n\n    @Test\n    void testFindFirstMatch() {\n        int index = HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstNotMatch() {\n        int index = HorspoolSearch.findFirst(\"hell\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternLongerText() {\n        int index = HorspoolSearch.findFirst(\"Hello World!!!\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"Hello\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternAndTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstSpecialCharacter() {\n        int index = HorspoolSearch.findFirst(\"$3**\", \"Hello $3**$ World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"hello\", \"Hello World\");\n        assertEquals(0, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveNotMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"helo\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testGetLastComparisons() {\n        HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(7, lastSearchNumber);\n    }\n\n    @Test\n    void testGetLastComparisonsNotMatch() {\n        HorspoolSearch.findFirst(\"Word\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(3, lastSearchNumber);\n    }\n\n    @Test\n    void testFindFirstPatternNull() {\n        assertThrows(NullPointerException.class, () -> HorspoolSearch.findFirst(null, \"Hello World\"));\n    }\n\n    @Test\n    void testFindFirstTextNull() {\n        assertThrows(NullPointerException.class, () -> HorspoolSearch.findFirst(\"Hello\", null));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Palindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PalindromeTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Check if a string is palindrome string or not using String Builder\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return (\n            (s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString()));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindromeRecursion(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using two pointer technique\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeTwoPointer(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Check if a string is palindrome string or not using String Builder\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return ((s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString()));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindromeRecursion(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using two pointer technique\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeTwoPointer(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n\n    @Test\n    public void palindrome() {\n\n        String[] palindromes = {null, \"\", \"aba\", \"123321\", \"kayak\"};\n        for (String s : palindromes) {\n            Assertions.assertTrue(Palindrome.isPalindrome(s) && Palindrome.isPalindromeRecursion(s)\n                && Palindrome.isPalindromeTwoPointer(s));\n        }\n\n        String[] notPalindromes = {\"abb\", \"abc\", \"abc123\", \"kayaks\"};\n        for (String s : notPalindromes) {\n            Assertions.assertFalse(Palindrome.isPalindrome(s) || Palindrome.isPalindromeRecursion(s)\n                || Palindrome.isPalindromeTwoPointer(s));\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n\n    @Test\n    public void palindrome() {\n\n        String[] palindromes = {null, \"\", \"aba\", \"123321\", \"kayak\"};\n        for (String s : palindromes) {\n            Assertions.assertTrue(Palindrome.isPalindrome(s) && Palindrome.isPalindromeRecursion(s) && Palindrome.isPalindromeTwoPointer(s));\n        }\n\n        String[] notPalindromes = {\"abb\", \"abc\", \"abc123\", \"kayaks\"};\n        for (String s : notPalindromes) {\n            Assertions.assertFalse(Palindrome.isPalindrome(s) || Palindrome.isPalindromeRecursion(s) || Palindrome.isPalindromeTwoPointer(s));\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/AllPathsFromSourceToTarget.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java",
        "product_old_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm=new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices)\n    {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList()\n    {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v)\n    {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n\n    public void storeAllPaths(int s, int d)\n    {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path \n    private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList)\n    {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n        \n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int[][] a, int source, int destination)\n    {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for(int i=0 ; i<a.length ; i++)\n        {\n            g.addEdge(a[i][0], a[i][1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "product_new_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm = new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices) {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList() {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v) {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n    public void storeAllPaths(int s, int d) {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path\n    private void storeAllPathsUtil(\n        Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList) {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n\n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(\n        int vertices, int[][] a, int source, int destination) {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for (int i = 0; i < a.length; i++) {\n            g.addEdge(a[i][0], a[i][1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int[][] a = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3),List.of(2, 0, 3),List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int[][] a = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3},{1,4},{3,4},{2,4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4),List.of(0, 1, 4),List.of(0, 2, 1, 3, 4),List.of(0, 2, 1, 4),List.of(0, 2, 4),List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int[][] a = {{1,0},{2,3},{0,4},{1,5},{4,3},{0,2},{0,3},{1,2},{0,5},{3,4},{2,5},{2,4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5),List.of(1, 0, 5),List.of(1, 5),List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int[][] a = {{0,1},{0,2},{1,2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2),List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2\n            = List.of(List.of(2, 0, 1, 3), List.of(2, 0, 3), List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int[][] a = {{0, 1}, {0, 2}, {0, 3}, {2, 0}, {2, 1}, {1, 3}, {1, 4}, {3, 4}, {2, 4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4), List.of(0, 1, 4),\n            List.of(0, 2, 1, 3, 4), List.of(0, 2, 1, 4), List.of(0, 2, 4), List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int[][] a = {{1, 0}, {2, 3}, {0, 4}, {1, 5}, {4, 3}, {0, 2}, {0, 3}, {1, 2}, {0, 5}, {3, 4},\n            {2, 5}, {2, 4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2\n            = List.of(List.of(1, 0, 2, 5), List.of(1, 0, 5), List.of(1, 5), List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int[][] a = {{0, 1}, {0, 2}, {1, 2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2), List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(\n            vertices, a, source, destination);\n        list2 = list1;\n        assertIterableEquals(list1, list2);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/Combination.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/CombinationTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\nimport java.util.*;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Combination {\n\n    private static int length;\n\n    /**\n     * Find all combinations of given array using backtracking\n     * @param arr the array.\n     * @param n length of combination\n     * @param <T> the type of elements in the array.\n     * @return a list of all combinations of length n. If n == 0, return null.\n     */\n    public static <T> List<TreeSet<T>> combination(T[] arr, int n) {\n        if (n == 0) {\n            return null;\n        }\n        length = n;\n        T[] array = arr.clone();\n        Arrays.sort(array);\n        List<TreeSet<T>> result = new LinkedList<>();\n        backtracking(array, 0, new TreeSet<T>(), result);\n        return result;\n    }\n\n    /**\n     * Backtrack all possible combinations of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param currSet set that tracks current combination\n     * @param result the list contains all combination.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(\n        T[] arr,\n        int index,\n        TreeSet<T> currSet,\n        List<TreeSet<T>> result\n    ) {\n        if (index + length - currSet.size() > arr.length) return;\n        if (length - 1 == currSet.size()) {\n            for (int i = index; i < arr.length; i++) {\n                currSet.add(arr[i]);\n                result.add((TreeSet<T>) currSet.clone());\n                currSet.remove(arr[i]);\n            }\n        }\n        for (int i = index; i < arr.length; i++) {\n            currSet.add(arr[i]);\n            backtracking(arr, i + 1, currSet, result);\n            currSet.remove(arr[i]);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.*;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Combination {\n\n    private static int length;\n\n    /**\n     * Find all combinations of given array using backtracking\n     * @param arr the array.\n     * @param n length of combination\n     * @param <T> the type of elements in the array.\n     * @return a list of all combinations of length n. If n == 0, return null.\n     */\n    public static <T> List<TreeSet<T>> combination(T[] arr, int n) {\n        if (n == 0) {\n            return null;\n        }\n        length = n;\n        T[] array = arr.clone();\n        Arrays.sort(array);\n        List<TreeSet<T>> result = new LinkedList<>();\n        backtracking(array, 0, new TreeSet<T>(), result);\n        return result;\n    }\n\n    /**\n     * Backtrack all possible combinations of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param currSet set that tracks current combination\n     * @param result the list contains all combination.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(\n        T[] arr, int index, TreeSet<T> currSet, List<TreeSet<T>> result) {\n        if (index + length - currSet.size() > arr.length) return;\n        if (length - 1 == currSet.size()) {\n            for (int i = index; i < arr.length; i++) {\n                currSet.add(arr[i]);\n                result.add((TreeSet<T>) currSet.clone());\n                currSet.remove(arr[i]);\n            }\n        }\n        for (int i = index; i < arr.length; i++) {\n            currSet.add(arr[i]);\n            backtracking(arr, i + 1, currSet, result);\n            currSet.remove(arr[i]);\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\n\npublic class CombinationTest {\n\n    @Test\n    void testNoElement() {\n        List<TreeSet<Integer>> result = Combination.combination(\n            new Integer[] { 1, 2 },\n            0\n        );\n        assertTrue(result == null);\n    }\n\n    @Test\n    void testLengthOne() {\n        List<TreeSet<Integer>> result = Combination.combination(\n            new Integer[] { 1, 2 },\n            1\n        );\n        assertTrue(result.get(0).iterator().next() == 1);\n        assertTrue(result.get(1).iterator().next() == 2);\n    }\n\n    @Test\n    void testLengthTwo() {\n        List<TreeSet<Integer>> result = Combination.combination(\n            new Integer[] { 1, 2 },\n            2\n        );\n        Integer[] arr = result.get(0).toArray(new Integer[2]);\n        assertTrue(arr[0] == 1);\n        assertTrue(arr[1] == 2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\n\npublic class CombinationTest {\n\n    @Test\n    void testNoElement() {\n        List<TreeSet<Integer>> result = Combination.combination(new Integer[] {1, 2}, 0);\n        assertTrue(result == null);\n    }\n\n    @Test\n    void testLengthOne() {\n        List<TreeSet<Integer>> result = Combination.combination(new Integer[] {1, 2}, 1);\n        assertTrue(result.get(0).iterator().next() == 1);\n        assertTrue(result.get(1).iterator().next() == 2);\n    }\n\n    @Test\n    void testLengthTwo() {\n        List<TreeSet<Integer>> result = Combination.combination(new Integer[] {1, 2}, 2);\n        Integer[] arr = result.get(0).toArray(new Integer[2]);\n        assertTrue(arr[0] == 1);\n        assertTrue(arr[1] == 2);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/FloodFill.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/FloodFillTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */\n    public static void floodFill(\n        int[][] image,\n        int x,\n        int y,\n        int newColor,\n        int oldColor\n    ) {\n        if (x < 0 || x >= image.length) return;\n        if (y < 0 || y >= image[x].length) return;\n        if (getPixel(image, x, y) != oldColor) return;\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */\n    public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {\n        if (x < 0 || x >= image.length) return;\n        if (y < 0 || y >= image[x].length) return;\n        if (getPixel(image, x, y) != oldColor) return;\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage() {\n        int[][] image = {};\n        int[][] expected = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSingleElementImage() {\n        int[][] image = { { 1 } };\n        int[][] expected = { { 3 } };\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageOne() {\n        int[][] image = {\n            { 0, 0, 0, 0, 0, 0, 0 },\n            { 0, 3, 3, 3, 3, 0, 0 },\n            { 0, 3, 1, 1, 5, 0, 0 },\n            { 0, 3, 1, 1, 5, 5, 3 },\n            { 0, 3, 5, 5, 1, 1, 3 },\n            { 0, 0, 0, 5, 1, 1, 3 },\n            { 0, 0, 0, 3, 3, 3, 3 },\n        };\n\n        int[][] expected = {\n            { 0, 0, 0, 0, 0, 0, 0 },\n            { 0, 3, 3, 3, 3, 0, 0 },\n            { 0, 3, 2, 2, 5, 0, 0 },\n            { 0, 3, 2, 2, 5, 5, 3 },\n            { 0, 3, 5, 5, 2, 2, 3 },\n            { 0, 0, 0, 5, 2, 2, 3 },\n            { 0, 0, 0, 3, 3, 3, 3 },\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageTwo() {\n        int[][] image = {\n            { 0, 0, 1, 1, 0, 0, 0 },\n            { 1, 1, 3, 3, 3, 0, 0 },\n            { 1, 3, 1, 1, 5, 0, 0 },\n            { 0, 3, 1, 1, 5, 5, 3 },\n            { 0, 3, 5, 5, 1, 1, 3 },\n            { 0, 0, 0, 5, 1, 1, 3 },\n            { 0, 0, 0, 1, 3, 1, 3 },\n        };\n\n        int[][] expected = {\n            { 0, 0, 2, 2, 0, 0, 0 },\n            { 2, 2, 3, 3, 3, 0, 0 },\n            { 2, 3, 2, 2, 5, 0, 0 },\n            { 0, 3, 2, 2, 5, 5, 3 },\n            { 0, 3, 5, 5, 2, 2, 3 },\n            { 0, 0, 0, 5, 2, 2, 3 },\n            { 0, 0, 0, 2, 3, 2, 3 },\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageThree() {\n        int[][] image = {\n            { 1, 1, 2, 3, 1, 1, 1 },\n            { 1, 0, 0, 1, 0, 0, 1 },\n            { 1, 1, 1, 0, 3, 1, 2 },\n        };\n\n        int[][] expected = {\n            { 4, 4, 2, 3, 4, 4, 4 },\n            { 4, 0, 0, 4, 0, 0, 4 },\n            { 4, 4, 4, 0, 3, 4, 2 },\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage() {\n        int[][] image = {};\n        int[][] expected = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSingleElementImage() {\n        int[][] image = {{1}};\n        int[][] expected = {{3}};\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageOne() {\n        int[][] image = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 3, 3, 3, 3, 0, 0},\n            {0, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 3, 3, 3, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageTwo() {\n        int[][] image = {\n            {0, 0, 1, 1, 0, 0, 0},\n            {1, 1, 3, 3, 3, 0, 0},\n            {1, 3, 1, 1, 5, 0, 0},\n            {0, 3, 1, 1, 5, 5, 3},\n            {0, 3, 5, 5, 1, 1, 3},\n            {0, 0, 0, 5, 1, 1, 3},\n            {0, 0, 0, 1, 3, 1, 3},\n        };\n\n        int[][] expected = {\n            {0, 0, 2, 2, 0, 0, 0},\n            {2, 2, 3, 3, 3, 0, 0},\n            {2, 3, 2, 2, 5, 0, 0},\n            {0, 3, 2, 2, 5, 5, 3},\n            {0, 3, 5, 5, 2, 2, 3},\n            {0, 0, 0, 5, 2, 2, 3},\n            {0, 0, 0, 2, 3, 2, 3},\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageThree() {\n        int[][] image = {\n            {1, 1, 2, 3, 1, 1, 1},\n            {1, 0, 0, 1, 0, 0, 1},\n            {1, 1, 1, 0, 3, 1, 2},\n        };\n\n        int[][] expected = {\n            {4, 4, 2, 3, 4, 4, 4},\n            {4, 0, 0, 4, 0, 0, 4},\n            {4, 4, 4, 0, 3, 4, 2},\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/MazeRecursionTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n\n    public static void mazeRecursion() {\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Print the current map\n        System.out.println(\"The condition of the map\uff1a \");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // clone another map for setWay2 method\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                map2[i][j] = map[i][j];\n            }\n        }\n\n        // By using recursive backtracking to let your ball(target) find its way in the\n        // maze\n        // The first parameter is the map\n        // Second parameter is x coordinate of your target\n        // Thrid parameter is the y coordinate of your target\n        setWay(map, 1, 1);\n        setWay2(map2, 1, 1);\n\n        // Print out the new map1, with the ball footprint\n        System.out.println(\n            \"After the ball goes through the map1\uff0cshow the current map1 condition\"\n        );\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // Print out the new map2, with the ball footprint\n        System.out.println(\n            \"After the ball goes through the map2\uff0cshow the current map2 condition\"\n        );\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map2[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    /**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     * \n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */\n    public static boolean setWay(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : down -> right -> up -> left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n            if (setWay(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtraking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone though before,\n            // and cannot head to deadend.\n            return false;\n        }\n    }\n\n    // Here is another move strategy for the ball: up->right->down->left\n    public static boolean setWay2(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : up->right->down->left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n            if (setWay2(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay2(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay2(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay2(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtraking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone though before,\n            // and cannot head to deadend.\n            return false;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n\n    public static void mazeRecursion() {\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Print the current map\n        System.out.println(\"The condition of the map\uff1a \");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // clone another map for setWay2 method\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                map2[i][j] = map[i][j];\n            }\n        }\n\n        // By using recursive backtracking to let your ball(target) find its way in the\n        // maze\n        // The first parameter is the map\n        // Second parameter is x coordinate of your target\n        // Thrid parameter is the y coordinate of your target\n        setWay(map, 1, 1);\n        setWay2(map2, 1, 1);\n\n        // Print out the new map1, with the ball footprint\n        System.out.println(\"After the ball goes through the map1\uff0cshow the current map1 condition\");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // Print out the new map2, with the ball footprint\n        System.out.println(\"After the ball goes through the map2\uff0cshow the current map2 condition\");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map2[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    /**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */\n    public static boolean setWay(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : down -> right -> up -> left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                           // first\u3002\n            if (setWay(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtraking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone though before,\n            // and cannot head to deadend.\n            return false;\n        }\n    }\n\n    // Here is another move strategy for the ball: up->right->down->left\n    public static boolean setWay2(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : up->right->down->left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                           // first\u3002\n            if (setWay2(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay2(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay2(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay2(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtraking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone though before,\n            // and cannot head to deadend.\n            return false;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author onglipwei\n * @create 2022-08-03 5:17 AM\n */\npublic class MazeRecursionTest {\n\n    @Test\n    public void testMaze() {\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        //clone another map for setWay2 method\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                map2[i][j] = map[i][j];\n            }\n        }\n\n        MazeRecursion.setWay(map, 1, 1);\n        MazeRecursion.setWay2(map2, 1, 1);\n\n        int[][] expectedMap = new int[][] {\n            { 1, 1, 1, 1, 1, 1, 1 },\n            { 1, 2, 0, 0, 0, 0, 1 },\n            { 1, 2, 2, 2, 0, 0, 1 },\n            { 1, 1, 1, 2, 0, 0, 1 },\n            { 1, 0, 0, 2, 0, 0, 1 },\n            { 1, 0, 0, 2, 0, 0, 1 },\n            { 1, 0, 0, 2, 2, 2, 1 },\n            { 1, 1, 1, 1, 1, 1, 1 },\n        };\n\n        int[][] expectedMap2 = new int[][] {\n            { 1, 1, 1, 1, 1, 1, 1 },\n            { 1, 2, 2, 2, 2, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 1, 1, 0, 0, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 1, 1, 1, 1, 1, 1 },\n        };\n\n        assertArrayEquals(map, expectedMap);\n        assertArrayEquals(map2, expectedMap2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author onglipwei\n * @create 2022-08-03 5:17 AM\n */\npublic class MazeRecursionTest {\n\n    @Test\n    public void testMaze() {\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // clone another map for setWay2 method\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                map2[i][j] = map[i][j];\n            }\n        }\n\n        MazeRecursion.setWay(map, 1, 1);\n        MazeRecursion.setWay2(map2, 1, 1);\n\n        int[][] expectedMap = new int[][] {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 0, 0, 0, 0, 1},\n            {1, 2, 2, 2, 0, 0, 1},\n            {1, 1, 1, 2, 0, 0, 1},\n            {1, 0, 0, 2, 0, 0, 1},\n            {1, 0, 0, 2, 0, 0, 1},\n            {1, 0, 0, 2, 2, 2, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n        };\n\n        int[][] expectedMap2 = new int[][] {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 2, 2, 2, 2, 1},\n            {1, 0, 0, 0, 0, 2, 1},\n            {1, 1, 1, 0, 0, 2, 1},\n            {1, 0, 0, 0, 0, 2, 1},\n            {1, 0, 0, 0, 0, 2, 1},\n            {1, 0, 0, 0, 0, 2, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n        };\n\n        assertArrayEquals(map, expectedMap);\n        assertArrayEquals(map2, expectedMap2);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/PowerSum.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/PowerSumTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\n\n/*\n * Problem Statement :\n * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers of unique, natural numbers.\n * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3.\n * Therefore output will be 1.\n */\npublic class PowerSum {\n\n    private int count = 0, sum = 0;\n\n    public int powSum(int N, int X) {\n        Sum(N, X, 1);\n        return count;\n    }\n\n    //here i is the natural number which will be raised by X and added in sum.\n    public void Sum(int N, int X, int i) {\n        //if sum is equal to N that is one of our answer and count is increased.\n        if (sum == N) {\n            count++;\n            return;\n        } //we will be adding next natural number raised to X only if on adding it in sum the result is less than N.\n        else if (sum + power(i, X) <= N) {\n            sum += power(i, X);\n            Sum(N, X, i + 1);\n            //backtracking and removing the number added last since no possible combination is there with it.\n            sum -= power(i, X);\n        }\n        if (power(i, X) < N) {\n            //calling the sum function with next natural number after backtracking if when it is raised to X is still less than X.\n            Sum(N, X, i + 1);\n        }\n    }\n\n    //creating a separate power function so that it can be used again and again when required.\n    private int power(int a, int b) {\n        return (int) Math.pow(a, b);\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\n/*\n * Problem Statement :\n * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers\n * of unique, natural numbers. For example, if N=100 and X=3, we have to find all combinations of\n * unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3. Therefore output will be 1.\n */\npublic class PowerSum {\n\n    private int count = 0, sum = 0;\n\n    public int powSum(int N, int X) {\n        Sum(N, X, 1);\n        return count;\n    }\n\n    // here i is the natural number which will be raised by X and added in sum.\n    public void Sum(int N, int X, int i) {\n        // if sum is equal to N that is one of our answer and count is increased.\n        if (sum == N) {\n            count++;\n            return;\n        } // we will be adding next natural number raised to X only if on adding it in sum the\n          // result is less than N.\n        else if (sum + power(i, X) <= N) {\n            sum += power(i, X);\n            Sum(N, X, i + 1);\n            // backtracking and removing the number added last since no possible combination is\n            // there with it.\n            sum -= power(i, X);\n        }\n        if (power(i, X) < N) {\n            // calling the sum function with next natural number after backtracking if when it is\n            // raised to X is still less than X.\n            Sum(N, X, i + 1);\n        }\n    }\n\n    // creating a separate power function so that it can be used again and again when required.\n    private int power(int a, int b) {\n        return (int) Math.pow(a, b);\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class PowerSumTest {\n\n    @Test\n    void testNumberZeroAndPowerZero() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(0, 0);\n        assertEquals(1, result);\n    }\n\n    @Test\n    void testNumberHundredAndPowerTwo() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 2);\n        assertEquals(3, result);\n    }\n  \n    @Test\n    void testNumberHundredAndPowerThree() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 3);\n        assertEquals(1, result);\n    }\n    \n}",
        "test_new_content": "package com.thealgorithms.backtracking;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PowerSumTest {\n\n    @Test\n    void testNumberZeroAndPowerZero() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(0, 0);\n        assertEquals(1, result);\n    }\n\n    @Test\n    void testNumberHundredAndPowerTwo() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 2);\n        assertEquals(3, result);\n    }\n\n    @Test\n    void testNumberHundredAndPowerThree() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 3);\n        assertEquals(1, result);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/WordSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/WordSearchTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\n\n/*\nWord Search Problem (https://en.wikipedia.org/wiki/Word_search)\n\nGiven an m x n grid of characters board and a string word, return true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or\nvertically neighboring. The same letter cell may not be used more than once.\n\nFor example,\nGiven board =\n\n[\n ['A','B','C','E'],\n ['S','F','C','S'],\n ['A','D','E','E']\n]\nword = \"ABCCED\", -> returns true,\nword = \"SEE\", -> returns true,\nword = \"ABCB\", -> returns false.\n*/\n\n/*\n   Solution\n   Depth First Search in matrix (as multiple sources possible) with backtracking\n   like finding cycle in a directed graph. Maintain a record of path\n\n   Tx = O(m * n * 3^L): for each cell, we look at 3 options (not 4 as that one will be visited), we do it L times\n   Sx = O(L) : stack size is max L\n*/\n\npublic class WordSearch {\n    private final int[] dx = {0, 0, 1, -1};\n    private final int[] dy = {1, -1, 0, 0};\n    private boolean[][] visited;\n    private char[][] board;\n    private String word;\n\n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < board.length && y >= 0 && y < board[0].length;\n    }\n\n    private boolean doDFS(int x, int y, int nextIdx) {\n        visited[x][y] = true;\n        if (nextIdx == word.length()) {\n            return true;\n        }\n        for (int i = 0; i < 4; ++i) {\n            int xi = x + dx[i];\n            int yi = y + dy[i];\n            if (isValid(xi, yi) && board[xi][yi] == word.charAt(nextIdx) && !visited[xi][yi]) {\n                boolean exists = doDFS(xi, yi, nextIdx + 1);\n                if (exists)\n                    return true;\n            }\n        }\n        visited[x][y] = false;\n        return false;\n    }\n\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        this.word = word;\n        for (int i = 0; i < board.length; ++i) {\n            for (int j = 0; j < board[0].length; ++j) {\n                if (board[i][j] == word.charAt(0)) {\n                    visited = new boolean[board.length][board[0].length];\n                    boolean exists = doDFS(i, j, 1);\n                    if (exists)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\n/*\nWord Search Problem (https://en.wikipedia.org/wiki/Word_search)\n\nGiven an m x n grid of characters board and a string word, return true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are\nthose horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nFor example,\nGiven board =\n\n[\n ['A','B','C','E'],\n ['S','F','C','S'],\n ['A','D','E','E']\n]\nword = \"ABCCED\", -> returns true,\nword = \"SEE\", -> returns true,\nword = \"ABCB\", -> returns false.\n*/\n\n/*\n   Solution\n   Depth First Search in matrix (as multiple sources possible) with backtracking\n   like finding cycle in a directed graph. Maintain a record of path\n\n   Tx = O(m * n * 3^L): for each cell, we look at 3 options (not 4 as that one will be visited), we\n   do it L times Sx = O(L) : stack size is max L\n*/\n\npublic class WordSearch {\n    private final int[] dx = {0, 0, 1, -1};\n    private final int[] dy = {1, -1, 0, 0};\n    private boolean[][] visited;\n    private char[][] board;\n    private String word;\n\n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < board.length && y >= 0 && y < board[0].length;\n    }\n\n    private boolean doDFS(int x, int y, int nextIdx) {\n        visited[x][y] = true;\n        if (nextIdx == word.length()) {\n            return true;\n        }\n        for (int i = 0; i < 4; ++i) {\n            int xi = x + dx[i];\n            int yi = y + dy[i];\n            if (isValid(xi, yi) && board[xi][yi] == word.charAt(nextIdx) && !visited[xi][yi]) {\n                boolean exists = doDFS(xi, yi, nextIdx + 1);\n                if (exists) return true;\n            }\n        }\n        visited[x][y] = false;\n        return false;\n    }\n\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        this.word = word;\n        for (int i = 0; i < board.length; ++i) {\n            for (int j = 0; j < board[0].length; ++j) {\n                if (board[i][j] == word.charAt(0)) {\n                    visited = new boolean[board.length][board[0].length];\n                    boolean exists = doDFS(i, j, 1);\n                    if (exists) return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class WordSearchTest {\n    @Test\n    void test1() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word = \"ABCCED\";\n        assertTrue(ws.exist(board, word));\n    }\n\n    @Test\n    void test2() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word = \"SEE\";\n        assertTrue(ws.exist(board, word));\n    }\n\n    @Test\n    void test3() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word = \"ABCB\";\n        Assertions.assertFalse(ws.exist(board, word));\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class WordSearchTest {\n    @Test\n    void test1() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'}};\n        String word = \"ABCCED\";\n        assertTrue(ws.exist(board, word));\n    }\n\n    @Test\n    void test2() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'}};\n        String word = \"SEE\";\n        assertTrue(ws.exist(board, word));\n    }\n\n    @Test\n    void test3() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'S'}, {'A', 'D', 'E', 'E'}};\n        String word = \"ABCB\";\n        Assertions.assertFalse(ws.exist(board, word));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Blowfish.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/BlowfishTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/*\n * Java program for Blowfish Algorithm\n * Wikipedia: https://en.wikipedia.org/wiki/Blowfish_(cipher)\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class Blowfish {\n\n    //Initializing substitution boxes\n    String[][] S = {\n        {\n            \"d1310ba6\",\n            \"98dfb5ac\",\n            \"2ffd72db\",\n            \"d01adfb7\",\n            \"b8e1afed\",\n            \"6a267e96\",\n            \"ba7c9045\",\n            \"f12c7f99\",\n            \"24a19947\",\n            \"b3916cf7\",\n            \"0801f2e2\",\n            \"858efc16\",\n            \"636920d8\",\n            \"71574e69\",\n            \"a458fea3\",\n            \"f4933d7e\",\n            \"0d95748f\",\n            \"728eb658\",\n            \"718bcd58\",\n            \"82154aee\",\n            \"7b54a41d\",\n            \"c25a59b5\",\n            \"9c30d539\",\n            \"2af26013\",\n            \"c5d1b023\",\n            \"286085f0\",\n            \"ca417918\",\n            \"b8db38ef\",\n            \"8e79dcb0\",\n            \"603a180e\",\n            \"6c9e0e8b\",\n            \"b01e8a3e\",\n            \"d71577c1\",\n            \"bd314b27\",\n            \"78af2fda\",\n            \"55605c60\",\n            \"e65525f3\",\n            \"aa55ab94\",\n            \"57489862\",\n            \"63e81440\",\n            \"55ca396a\",\n            \"2aab10b6\",\n            \"b4cc5c34\",\n            \"1141e8ce\",\n            \"a15486af\",\n            \"7c72e993\",\n            \"b3ee1411\",\n            \"636fbc2a\",\n            \"2ba9c55d\",\n            \"741831f6\",\n            \"ce5c3e16\",\n            \"9b87931e\",\n            \"afd6ba33\",\n            \"6c24cf5c\",\n            \"7a325381\",\n            \"28958677\",\n            \"3b8f4898\",\n            \"6b4bb9af\",\n            \"c4bfe81b\",\n            \"66282193\",\n            \"61d809cc\",\n            \"fb21a991\",\n            \"487cac60\",\n            \"5dec8032\",\n            \"ef845d5d\",\n            \"e98575b1\",\n            \"dc262302\",\n            \"eb651b88\",\n            \"23893e81\",\n            \"d396acc5\",\n            \"0f6d6ff3\",\n            \"83f44239\",\n            \"2e0b4482\",\n            \"a4842004\",\n            \"69c8f04a\",\n            \"9e1f9b5e\",\n            \"21c66842\",\n            \"f6e96c9a\",\n            \"670c9c61\",\n            \"abd388f0\",\n            \"6a51a0d2\",\n            \"d8542f68\",\n            \"960fa728\",\n            \"ab5133a3\",\n            \"6eef0b6c\",\n            \"137a3be4\",\n            \"ba3bf050\",\n            \"7efb2a98\",\n            \"a1f1651d\",\n            \"39af0176\",\n            \"66ca593e\",\n            \"82430e88\",\n            \"8cee8619\",\n            \"456f9fb4\",\n            \"7d84a5c3\",\n            \"3b8b5ebe\",\n            \"e06f75d8\",\n            \"85c12073\",\n            \"401a449f\",\n            \"56c16aa6\",\n            \"4ed3aa62\",\n            \"363f7706\",\n            \"1bfedf72\",\n            \"429b023d\",\n            \"37d0d724\",\n            \"d00a1248\",\n            \"db0fead3\",\n            \"49f1c09b\",\n            \"075372c9\",\n            \"80991b7b\",\n            \"25d479d8\",\n            \"f6e8def7\",\n            \"e3fe501a\",\n            \"b6794c3b\",\n            \"976ce0bd\",\n            \"04c006ba\",\n            \"c1a94fb6\",\n            \"409f60c4\",\n            \"5e5c9ec2\",\n            \"196a2463\",\n            \"68fb6faf\",\n            \"3e6c53b5\",\n            \"1339b2eb\",\n            \"3b52ec6f\",\n            \"6dfc511f\",\n            \"9b30952c\",\n            \"cc814544\",\n            \"af5ebd09\",\n            \"bee3d004\",\n            \"de334afd\",\n            \"660f2807\",\n            \"192e4bb3\",\n            \"c0cba857\",\n            \"45c8740f\",\n            \"d20b5f39\",\n            \"b9d3fbdb\",\n            \"5579c0bd\",\n            \"1a60320a\",\n            \"d6a100c6\",\n            \"402c7279\",\n            \"679f25fe\",\n            \"fb1fa3cc\",\n            \"8ea5e9f8\",\n            \"db3222f8\",\n            \"3c7516df\",\n            \"fd616b15\",\n            \"2f501ec8\",\n            \"ad0552ab\",\n            \"323db5fa\",\n            \"fd238760\",\n            \"53317b48\",\n            \"3e00df82\",\n            \"9e5c57bb\",\n            \"ca6f8ca0\",\n            \"1a87562e\",\n            \"df1769db\",\n            \"d542a8f6\",\n            \"287effc3\",\n            \"ac6732c6\",\n            \"8c4f5573\",\n            \"695b27b0\",\n            \"bbca58c8\",\n            \"e1ffa35d\",\n            \"b8f011a0\",\n            \"10fa3d98\",\n            \"fd2183b8\",\n            \"4afcb56c\",\n            \"2dd1d35b\",\n            \"9a53e479\",\n            \"b6f84565\",\n            \"d28e49bc\",\n            \"4bfb9790\",\n            \"e1ddf2da\",\n            \"a4cb7e33\",\n            \"62fb1341\",\n            \"cee4c6e8\",\n            \"ef20cada\",\n            \"36774c01\",\n            \"d07e9efe\",\n            \"2bf11fb4\",\n            \"95dbda4d\",\n            \"ae909198\",\n            \"eaad8e71\",\n            \"6b93d5a0\",\n            \"d08ed1d0\",\n            \"afc725e0\",\n            \"8e3c5b2f\",\n            \"8e7594b7\",\n            \"8ff6e2fb\",\n            \"f2122b64\",\n            \"8888b812\",\n            \"900df01c\",\n            \"4fad5ea0\",\n            \"688fc31c\",\n            \"d1cff191\",\n            \"b3a8c1ad\",\n            \"2f2f2218\",\n            \"be0e1777\",\n            \"ea752dfe\",\n            \"8b021fa1\",\n            \"e5a0cc0f\",\n            \"b56f74e8\",\n            \"18acf3d6\",\n            \"ce89e299\",\n            \"b4a84fe0\",\n            \"fd13e0b7\",\n            \"7cc43b81\",\n            \"d2ada8d9\",\n            \"165fa266\",\n            \"80957705\",\n            \"93cc7314\",\n            \"211a1477\",\n            \"e6ad2065\",\n            \"77b5fa86\",\n            \"c75442f5\",\n            \"fb9d35cf\",\n            \"ebcdaf0c\",\n            \"7b3e89a0\",\n            \"d6411bd3\",\n            \"ae1e7e49\",\n            \"00250e2d\",\n            \"2071b35e\",\n            \"226800bb\",\n            \"57b8e0af\",\n            \"2464369b\",\n            \"f009b91e\",\n            \"5563911d\",\n            \"59dfa6aa\",\n            \"78c14389\",\n            \"d95a537f\",\n            \"207d5ba2\",\n            \"02e5b9c5\",\n            \"83260376\",\n            \"6295cfa9\",\n            \"11c81968\",\n            \"4e734a41\",\n            \"b3472dca\",\n            \"7b14a94a\",\n            \"1b510052\",\n            \"9a532915\",\n            \"d60f573f\",\n            \"bc9bc6e4\",\n            \"2b60a476\",\n            \"81e67400\",\n            \"08ba6fb5\",\n            \"571be91f\",\n            \"f296ec6b\",\n            \"2a0dd915\",\n            \"b6636521\",\n            \"e7b9f9b6\",\n            \"ff34052e\",\n            \"c5855664\",\n            \"53b02d5d\",\n            \"a99f8fa1\",\n            \"08ba4799\",\n            \"6e85076a\",\n        },\n        {\n            \"4b7a70e9\",\n            \"b5b32944\",\n            \"db75092e\",\n            \"c4192623\",\n            \"ad6ea6b0\",\n            \"49a7df7d\",\n            \"9cee60b8\",\n            \"8fedb266\",\n            \"ecaa8c71\",\n            \"699a17ff\",\n            \"5664526c\",\n            \"c2b19ee1\",\n            \"193602a5\",\n            \"75094c29\",\n            \"a0591340\",\n            \"e4183a3e\",\n            \"3f54989a\",\n            \"5b429d65\",\n            \"6b8fe4d6\",\n            \"99f73fd6\",\n            \"a1d29c07\",\n            \"efe830f5\",\n            \"4d2d38e6\",\n            \"f0255dc1\",\n            \"4cdd2086\",\n            \"8470eb26\",\n            \"6382e9c6\",\n            \"021ecc5e\",\n            \"09686b3f\",\n            \"3ebaefc9\",\n            \"3c971814\",\n            \"6b6a70a1\",\n            \"687f3584\",\n            \"52a0e286\",\n            \"b79c5305\",\n            \"aa500737\",\n            \"3e07841c\",\n            \"7fdeae5c\",\n            \"8e7d44ec\",\n            \"5716f2b8\",\n            \"b03ada37\",\n            \"f0500c0d\",\n            \"f01c1f04\",\n            \"0200b3ff\",\n            \"ae0cf51a\",\n            \"3cb574b2\",\n            \"25837a58\",\n            \"dc0921bd\",\n            \"d19113f9\",\n            \"7ca92ff6\",\n            \"94324773\",\n            \"22f54701\",\n            \"3ae5e581\",\n            \"37c2dadc\",\n            \"c8b57634\",\n            \"9af3dda7\",\n            \"a9446146\",\n            \"0fd0030e\",\n            \"ecc8c73e\",\n            \"a4751e41\",\n            \"e238cd99\",\n            \"3bea0e2f\",\n            \"3280bba1\",\n            \"183eb331\",\n            \"4e548b38\",\n            \"4f6db908\",\n            \"6f420d03\",\n            \"f60a04bf\",\n            \"2cb81290\",\n            \"24977c79\",\n            \"5679b072\",\n            \"bcaf89af\",\n            \"de9a771f\",\n            \"d9930810\",\n            \"b38bae12\",\n            \"dccf3f2e\",\n            \"5512721f\",\n            \"2e6b7124\",\n            \"501adde6\",\n            \"9f84cd87\",\n            \"7a584718\",\n            \"7408da17\",\n            \"bc9f9abc\",\n            \"e94b7d8c\",\n            \"ec7aec3a\",\n            \"db851dfa\",\n            \"63094366\",\n            \"c464c3d2\",\n            \"ef1c1847\",\n            \"3215d908\",\n            \"dd433b37\",\n            \"24c2ba16\",\n            \"12a14d43\",\n            \"2a65c451\",\n            \"50940002\",\n            \"133ae4dd\",\n            \"71dff89e\",\n            \"10314e55\",\n            \"81ac77d6\",\n            \"5f11199b\",\n            \"043556f1\",\n            \"d7a3c76b\",\n            \"3c11183b\",\n            \"5924a509\",\n            \"f28fe6ed\",\n            \"97f1fbfa\",\n            \"9ebabf2c\",\n            \"1e153c6e\",\n            \"86e34570\",\n            \"eae96fb1\",\n            \"860e5e0a\",\n            \"5a3e2ab3\",\n            \"771fe71c\",\n            \"4e3d06fa\",\n            \"2965dcb9\",\n            \"99e71d0f\",\n            \"803e89d6\",\n            \"5266c825\",\n            \"2e4cc978\",\n            \"9c10b36a\",\n            \"c6150eba\",\n            \"94e2ea78\",\n            \"a5fc3c53\",\n            \"1e0a2df4\",\n            \"f2f74ea7\",\n            \"361d2b3d\",\n            \"1939260f\",\n            \"19c27960\",\n            \"5223a708\",\n            \"f71312b6\",\n            \"ebadfe6e\",\n            \"eac31f66\",\n            \"e3bc4595\",\n            \"a67bc883\",\n            \"b17f37d1\",\n            \"018cff28\",\n            \"c332ddef\",\n            \"be6c5aa5\",\n            \"65582185\",\n            \"68ab9802\",\n            \"eecea50f\",\n            \"db2f953b\",\n            \"2aef7dad\",\n            \"5b6e2f84\",\n            \"1521b628\",\n            \"29076170\",\n            \"ecdd4775\",\n            \"619f1510\",\n            \"13cca830\",\n            \"eb61bd96\",\n            \"0334fe1e\",\n            \"aa0363cf\",\n            \"b5735c90\",\n            \"4c70a239\",\n            \"d59e9e0b\",\n            \"cbaade14\",\n            \"eecc86bc\",\n            \"60622ca7\",\n            \"9cab5cab\",\n            \"b2f3846e\",\n            \"648b1eaf\",\n            \"19bdf0ca\",\n            \"a02369b9\",\n            \"655abb50\",\n            \"40685a32\",\n            \"3c2ab4b3\",\n            \"319ee9d5\",\n            \"c021b8f7\",\n            \"9b540b19\",\n            \"875fa099\",\n            \"95f7997e\",\n            \"623d7da8\",\n            \"f837889a\",\n            \"97e32d77\",\n            \"11ed935f\",\n            \"16681281\",\n            \"0e358829\",\n            \"c7e61fd6\",\n            \"96dedfa1\",\n            \"7858ba99\",\n            \"57f584a5\",\n            \"1b227263\",\n            \"9b83c3ff\",\n            \"1ac24696\",\n            \"cdb30aeb\",\n            \"532e3054\",\n            \"8fd948e4\",\n            \"6dbc3128\",\n            \"58ebf2ef\",\n            \"34c6ffea\",\n            \"fe28ed61\",\n            \"ee7c3c73\",\n            \"5d4a14d9\",\n            \"e864b7e3\",\n            \"42105d14\",\n            \"203e13e0\",\n            \"45eee2b6\",\n            \"a3aaabea\",\n            \"db6c4f15\",\n            \"facb4fd0\",\n            \"c742f442\",\n            \"ef6abbb5\",\n            \"654f3b1d\",\n            \"41cd2105\",\n            \"d81e799e\",\n            \"86854dc7\",\n            \"e44b476a\",\n            \"3d816250\",\n            \"cf62a1f2\",\n            \"5b8d2646\",\n            \"fc8883a0\",\n            \"c1c7b6a3\",\n            \"7f1524c3\",\n            \"69cb7492\",\n            \"47848a0b\",\n            \"5692b285\",\n            \"095bbf00\",\n            \"ad19489d\",\n            \"1462b174\",\n            \"23820e00\",\n            \"58428d2a\",\n            \"0c55f5ea\",\n            \"1dadf43e\",\n            \"233f7061\",\n            \"3372f092\",\n            \"8d937e41\",\n            \"d65fecf1\",\n            \"6c223bdb\",\n            \"7cde3759\",\n            \"cbee7460\",\n            \"4085f2a7\",\n            \"ce77326e\",\n            \"a6078084\",\n            \"19f8509e\",\n            \"e8efd855\",\n            \"61d99735\",\n            \"a969a7aa\",\n            \"c50c06c2\",\n            \"5a04abfc\",\n            \"800bcadc\",\n            \"9e447a2e\",\n            \"c3453484\",\n            \"fdd56705\",\n            \"0e1e9ec9\",\n            \"db73dbd3\",\n            \"105588cd\",\n            \"675fda79\",\n            \"e3674340\",\n            \"c5c43465\",\n            \"713e38d8\",\n            \"3d28f89e\",\n            \"f16dff20\",\n            \"153e21e7\",\n            \"8fb03d4a\",\n            \"e6e39f2b\",\n            \"db83adf7\",\n        },\n        {\n            \"e93d5a68\",\n            \"948140f7\",\n            \"f64c261c\",\n            \"94692934\",\n            \"411520f7\",\n            \"7602d4f7\",\n            \"bcf46b2e\",\n            \"d4a20068\",\n            \"d4082471\",\n            \"3320f46a\",\n            \"43b7d4b7\",\n            \"500061af\",\n            \"1e39f62e\",\n            \"97244546\",\n            \"14214f74\",\n            \"bf8b8840\",\n            \"4d95fc1d\",\n            \"96b591af\",\n            \"70f4ddd3\",\n            \"66a02f45\",\n            \"bfbc09ec\",\n            \"03bd9785\",\n            \"7fac6dd0\",\n            \"31cb8504\",\n            \"96eb27b3\",\n            \"55fd3941\",\n            \"da2547e6\",\n            \"abca0a9a\",\n            \"28507825\",\n            \"530429f4\",\n            \"0a2c86da\",\n            \"e9b66dfb\",\n            \"68dc1462\",\n            \"d7486900\",\n            \"680ec0a4\",\n            \"27a18dee\",\n            \"4f3ffea2\",\n            \"e887ad8c\",\n            \"b58ce006\",\n            \"7af4d6b6\",\n            \"aace1e7c\",\n            \"d3375fec\",\n            \"ce78a399\",\n            \"406b2a42\",\n            \"20fe9e35\",\n            \"d9f385b9\",\n            \"ee39d7ab\",\n            \"3b124e8b\",\n            \"1dc9faf7\",\n            \"4b6d1856\",\n            \"26a36631\",\n            \"eae397b2\",\n            \"3a6efa74\",\n            \"dd5b4332\",\n            \"6841e7f7\",\n            \"ca7820fb\",\n            \"fb0af54e\",\n            \"d8feb397\",\n            \"454056ac\",\n            \"ba489527\",\n            \"55533a3a\",\n            \"20838d87\",\n            \"fe6ba9b7\",\n            \"d096954b\",\n            \"55a867bc\",\n            \"a1159a58\",\n            \"cca92963\",\n            \"99e1db33\",\n            \"a62a4a56\",\n            \"3f3125f9\",\n            \"5ef47e1c\",\n            \"9029317c\",\n            \"fdf8e802\",\n            \"04272f70\",\n            \"80bb155c\",\n            \"05282ce3\",\n            \"95c11548\",\n            \"e4c66d22\",\n            \"48c1133f\",\n            \"c70f86dc\",\n            \"07f9c9ee\",\n            \"41041f0f\",\n            \"404779a4\",\n            \"5d886e17\",\n            \"325f51eb\",\n            \"d59bc0d1\",\n            \"f2bcc18f\",\n            \"41113564\",\n            \"257b7834\",\n            \"602a9c60\",\n            \"dff8e8a3\",\n            \"1f636c1b\",\n            \"0e12b4c2\",\n            \"02e1329e\",\n            \"af664fd1\",\n            \"cad18115\",\n            \"6b2395e0\",\n            \"333e92e1\",\n            \"3b240b62\",\n            \"eebeb922\",\n            \"85b2a20e\",\n            \"e6ba0d99\",\n            \"de720c8c\",\n            \"2da2f728\",\n            \"d0127845\",\n            \"95b794fd\",\n            \"647d0862\",\n            \"e7ccf5f0\",\n            \"5449a36f\",\n            \"877d48fa\",\n            \"c39dfd27\",\n            \"f33e8d1e\",\n            \"0a476341\",\n            \"992eff74\",\n            \"3a6f6eab\",\n            \"f4f8fd37\",\n            \"a812dc60\",\n            \"a1ebddf8\",\n            \"991be14c\",\n            \"db6e6b0d\",\n            \"c67b5510\",\n            \"6d672c37\",\n            \"2765d43b\",\n            \"dcd0e804\",\n            \"f1290dc7\",\n            \"cc00ffa3\",\n            \"b5390f92\",\n            \"690fed0b\",\n            \"667b9ffb\",\n            \"cedb7d9c\",\n            \"a091cf0b\",\n            \"d9155ea3\",\n            \"bb132f88\",\n            \"515bad24\",\n            \"7b9479bf\",\n            \"763bd6eb\",\n            \"37392eb3\",\n            \"cc115979\",\n            \"8026e297\",\n            \"f42e312d\",\n            \"6842ada7\",\n            \"c66a2b3b\",\n            \"12754ccc\",\n            \"782ef11c\",\n            \"6a124237\",\n            \"b79251e7\",\n            \"06a1bbe6\",\n            \"4bfb6350\",\n            \"1a6b1018\",\n            \"11caedfa\",\n            \"3d25bdd8\",\n            \"e2e1c3c9\",\n            \"44421659\",\n            \"0a121386\",\n            \"d90cec6e\",\n            \"d5abea2a\",\n            \"64af674e\",\n            \"da86a85f\",\n            \"bebfe988\",\n            \"64e4c3fe\",\n            \"9dbc8057\",\n            \"f0f7c086\",\n            \"60787bf8\",\n            \"6003604d\",\n            \"d1fd8346\",\n            \"f6381fb0\",\n            \"7745ae04\",\n            \"d736fccc\",\n            \"83426b33\",\n            \"f01eab71\",\n            \"b0804187\",\n            \"3c005e5f\",\n            \"77a057be\",\n            \"bde8ae24\",\n            \"55464299\",\n            \"bf582e61\",\n            \"4e58f48f\",\n            \"f2ddfda2\",\n            \"f474ef38\",\n            \"8789bdc2\",\n            \"5366f9c3\",\n            \"c8b38e74\",\n            \"b475f255\",\n            \"46fcd9b9\",\n            \"7aeb2661\",\n            \"8b1ddf84\",\n            \"846a0e79\",\n            \"915f95e2\",\n            \"466e598e\",\n            \"20b45770\",\n            \"8cd55591\",\n            \"c902de4c\",\n            \"b90bace1\",\n            \"bb8205d0\",\n            \"11a86248\",\n            \"7574a99e\",\n            \"b77f19b6\",\n            \"e0a9dc09\",\n            \"662d09a1\",\n            \"c4324633\",\n            \"e85a1f02\",\n            \"09f0be8c\",\n            \"4a99a025\",\n            \"1d6efe10\",\n            \"1ab93d1d\",\n            \"0ba5a4df\",\n            \"a186f20f\",\n            \"2868f169\",\n            \"dcb7da83\",\n            \"573906fe\",\n            \"a1e2ce9b\",\n            \"4fcd7f52\",\n            \"50115e01\",\n            \"a70683fa\",\n            \"a002b5c4\",\n            \"0de6d027\",\n            \"9af88c27\",\n            \"773f8641\",\n            \"c3604c06\",\n            \"61a806b5\",\n            \"f0177a28\",\n            \"c0f586e0\",\n            \"006058aa\",\n            \"30dc7d62\",\n            \"11e69ed7\",\n            \"2338ea63\",\n            \"53c2dd94\",\n            \"c2c21634\",\n            \"bbcbee56\",\n            \"90bcb6de\",\n            \"ebfc7da1\",\n            \"ce591d76\",\n            \"6f05e409\",\n            \"4b7c0188\",\n            \"39720a3d\",\n            \"7c927c24\",\n            \"86e3725f\",\n            \"724d9db9\",\n            \"1ac15bb4\",\n            \"d39eb8fc\",\n            \"ed545578\",\n            \"08fca5b5\",\n            \"d83d7cd3\",\n            \"4dad0fc4\",\n            \"1e50ef5e\",\n            \"b161e6f8\",\n            \"a28514d9\",\n            \"6c51133c\",\n            \"6fd5c7e7\",\n            \"56e14ec4\",\n            \"362abfce\",\n            \"ddc6c837\",\n            \"d79a3234\",\n            \"92638212\",\n            \"670efa8e\",\n            \"406000e0\",\n        },\n        {\n            \"3a39ce37\",\n            \"d3faf5cf\",\n            \"abc27737\",\n            \"5ac52d1b\",\n            \"5cb0679e\",\n            \"4fa33742\",\n            \"d3822740\",\n            \"99bc9bbe\",\n            \"d5118e9d\",\n            \"bf0f7315\",\n            \"d62d1c7e\",\n            \"c700c47b\",\n            \"b78c1b6b\",\n            \"21a19045\",\n            \"b26eb1be\",\n            \"6a366eb4\",\n            \"5748ab2f\",\n            \"bc946e79\",\n            \"c6a376d2\",\n            \"6549c2c8\",\n            \"530ff8ee\",\n            \"468dde7d\",\n            \"d5730a1d\",\n            \"4cd04dc6\",\n            \"2939bbdb\",\n            \"a9ba4650\",\n            \"ac9526e8\",\n            \"be5ee304\",\n            \"a1fad5f0\",\n            \"6a2d519a\",\n            \"63ef8ce2\",\n            \"9a86ee22\",\n            \"c089c2b8\",\n            \"43242ef6\",\n            \"a51e03aa\",\n            \"9cf2d0a4\",\n            \"83c061ba\",\n            \"9be96a4d\",\n            \"8fe51550\",\n            \"ba645bd6\",\n            \"2826a2f9\",\n            \"a73a3ae1\",\n            \"4ba99586\",\n            \"ef5562e9\",\n            \"c72fefd3\",\n            \"f752f7da\",\n            \"3f046f69\",\n            \"77fa0a59\",\n            \"80e4a915\",\n            \"87b08601\",\n            \"9b09e6ad\",\n            \"3b3ee593\",\n            \"e990fd5a\",\n            \"9e34d797\",\n            \"2cf0b7d9\",\n            \"022b8b51\",\n            \"96d5ac3a\",\n            \"017da67d\",\n            \"d1cf3ed6\",\n            \"7c7d2d28\",\n            \"1f9f25cf\",\n            \"adf2b89b\",\n            \"5ad6b472\",\n            \"5a88f54c\",\n            \"e029ac71\",\n            \"e019a5e6\",\n            \"47b0acfd\",\n            \"ed93fa9b\",\n            \"e8d3c48d\",\n            \"283b57cc\",\n            \"f8d56629\",\n            \"79132e28\",\n            \"785f0191\",\n            \"ed756055\",\n            \"f7960e44\",\n            \"e3d35e8c\",\n            \"15056dd4\",\n            \"88f46dba\",\n            \"03a16125\",\n            \"0564f0bd\",\n            \"c3eb9e15\",\n            \"3c9057a2\",\n            \"97271aec\",\n            \"a93a072a\",\n            \"1b3f6d9b\",\n            \"1e6321f5\",\n            \"f59c66fb\",\n            \"26dcf319\",\n            \"7533d928\",\n            \"b155fdf5\",\n            \"03563482\",\n            \"8aba3cbb\",\n            \"28517711\",\n            \"c20ad9f8\",\n            \"abcc5167\",\n            \"ccad925f\",\n            \"4de81751\",\n            \"3830dc8e\",\n            \"379d5862\",\n            \"9320f991\",\n            \"ea7a90c2\",\n            \"fb3e7bce\",\n            \"5121ce64\",\n            \"774fbe32\",\n            \"a8b6e37e\",\n            \"c3293d46\",\n            \"48de5369\",\n            \"6413e680\",\n            \"a2ae0810\",\n            \"dd6db224\",\n            \"69852dfd\",\n            \"09072166\",\n            \"b39a460a\",\n            \"6445c0dd\",\n            \"586cdecf\",\n            \"1c20c8ae\",\n            \"5bbef7dd\",\n            \"1b588d40\",\n            \"ccd2017f\",\n            \"6bb4e3bb\",\n            \"dda26a7e\",\n            \"3a59ff45\",\n            \"3e350a44\",\n            \"bcb4cdd5\",\n            \"72eacea8\",\n            \"fa6484bb\",\n            \"8d6612ae\",\n            \"bf3c6f47\",\n            \"d29be463\",\n            \"542f5d9e\",\n            \"aec2771b\",\n            \"f64e6370\",\n            \"740e0d8d\",\n            \"e75b1357\",\n            \"f8721671\",\n            \"af537d5d\",\n            \"4040cb08\",\n            \"4eb4e2cc\",\n            \"34d2466a\",\n            \"0115af84\",\n            \"e1b00428\",\n            \"95983a1d\",\n            \"06b89fb4\",\n            \"ce6ea048\",\n            \"6f3f3b82\",\n            \"3520ab82\",\n            \"011a1d4b\",\n            \"277227f8\",\n            \"611560b1\",\n            \"e7933fdc\",\n            \"bb3a792b\",\n            \"344525bd\",\n            \"a08839e1\",\n            \"51ce794b\",\n            \"2f32c9b7\",\n            \"a01fbac9\",\n            \"e01cc87e\",\n            \"bcc7d1f6\",\n            \"cf0111c3\",\n            \"a1e8aac7\",\n            \"1a908749\",\n            \"d44fbd9a\",\n            \"d0dadecb\",\n            \"d50ada38\",\n            \"0339c32a\",\n            \"c6913667\",\n            \"8df9317c\",\n            \"e0b12b4f\",\n            \"f79e59b7\",\n            \"43f5bb3a\",\n            \"f2d519ff\",\n            \"27d9459c\",\n            \"bf97222c\",\n            \"15e6fc2a\",\n            \"0f91fc71\",\n            \"9b941525\",\n            \"fae59361\",\n            \"ceb69ceb\",\n            \"c2a86459\",\n            \"12baa8d1\",\n            \"b6c1075e\",\n            \"e3056a0c\",\n            \"10d25065\",\n            \"cb03a442\",\n            \"e0ec6e0e\",\n            \"1698db3b\",\n            \"4c98a0be\",\n            \"3278e964\",\n            \"9f1f9532\",\n            \"e0d392df\",\n            \"d3a0342b\",\n            \"8971f21e\",\n            \"1b0a7441\",\n            \"4ba3348c\",\n            \"c5be7120\",\n            \"c37632d8\",\n            \"df359f8d\",\n            \"9b992f2e\",\n            \"e60b6f47\",\n            \"0fe3f11d\",\n            \"e54cda54\",\n            \"1edad891\",\n            \"ce6279cf\",\n            \"cd3e7e6f\",\n            \"1618b166\",\n            \"fd2c1d05\",\n            \"848fd2c5\",\n            \"f6fb2299\",\n            \"f523f357\",\n            \"a6327623\",\n            \"93a83531\",\n            \"56cccd02\",\n            \"acf08162\",\n            \"5a75ebb5\",\n            \"6e163697\",\n            \"88d273cc\",\n            \"de966292\",\n            \"81b949d0\",\n            \"4c50901b\",\n            \"71c65614\",\n            \"e6c6c7bd\",\n            \"327a140a\",\n            \"45e1d006\",\n            \"c3f27b9a\",\n            \"c9aa53fd\",\n            \"62a80f00\",\n            \"bb25bfe2\",\n            \"35bdd2f6\",\n            \"71126905\",\n            \"b2040222\",\n            \"b6cbcf7c\",\n            \"cd769c2b\",\n            \"53113ec0\",\n            \"1640e3d3\",\n            \"38abbd60\",\n            \"2547adf0\",\n            \"ba38209c\",\n            \"f746ce76\",\n            \"77afa1c5\",\n            \"20756060\",\n            \"85cbfe4e\",\n            \"8ae88dd8\",\n            \"7aaaf9b0\",\n            \"4cf9aa7e\",\n            \"1948c25c\",\n            \"02fb8a8c\",\n            \"01c36ae4\",\n            \"d6ebe1f9\",\n            \"90d4f869\",\n            \"a65cdea0\",\n            \"3f09252d\",\n            \"c208e69f\",\n            \"b74e6132\",\n            \"ce77e25b\",\n            \"578fdfe3\",\n            \"3ac372e6\",\n        },\n    };\n\n    //Initializing subkeys with digits of pi\n    String[] P = {\n        \"243f6a88\",\n        \"85a308d3\",\n        \"13198a2e\",\n        \"03707344\",\n        \"a4093822\",\n        \"299f31d0\",\n        \"082efa98\",\n        \"ec4e6c89\",\n        \"452821e6\",\n        \"38d01377\",\n        \"be5466cf\",\n        \"34e90c6c\",\n        \"c0ac29b7\",\n        \"c97c50dd\",\n        \"3f84d5b5\",\n        \"b5470917\",\n        \"9216d5d9\",\n        \"8979fb1b\",\n    };\n\n    //Initializing modVal to 2^32\n    long modVal = 4294967296L;\n\n    /**\n     * This method returns binary representation of the hexadecimal number passed as parameter\n     *\n     * @param hex Number for which binary representation is required\n     * @return String object which is a binary representation of the hex number passed as parameter\n     */\n    private String hexToBin(String hex) {\n        String binary = \"\";\n        long num;\n        String binary4B;\n        int n = hex.length();\n        for (int i = 0; i < n; i++) {\n            num = Long.parseUnsignedLong(hex.charAt(i) + \"\", 16);\n            binary4B = Long.toBinaryString(num);\n\n            binary4B = \"0000\" + binary4B;\n\n            binary4B = binary4B.substring(binary4B.length() - 4);\n            binary += binary4B;\n        }\n        return binary;\n    }\n\n    /**\n     * This method returns hexadecimal representation of the binary number passed as parameter\n     *\n     * @param binary Number for which hexadecimal representation is required\n     * @return String object which is a hexadecimal representation of the binary number passed as parameter\n     */\n    private String binToHex(String binary) {\n        long num = Long.parseUnsignedLong(binary, 2);\n        String hex = Long.toHexString(num);\n        while (hex.length() < (binary.length() / 4)) hex = \"0\" + hex;\n\n        return hex;\n    }\n\n    /**\n     * This method returns a string obtained by XOR-ing two strings of same length passed a method parameters\n     *\n     * @param String a and b are string objects which will be XORed and are to be of same length\n     * @return String object obtained by XOR operation on String a and String b\n     * */\n    private String xor(String a, String b) {\n        a = hexToBin(a);\n        b = hexToBin(b);\n        String ans = \"\";\n        for (int i = 0; i < a.length(); i++) ans +=\n            (char) (((a.charAt(i) - '0') ^ (b.charAt(i) - '0')) + '0');\n        ans = binToHex(ans);\n        return ans;\n    }\n\n    /**\n     * This method returns addition of two hexadecimal numbers passed as parameters and moded with 2^32\n     *\n     * @param String a and b are hexadecimal numbers\n     * @return String object which is a is addition that is then moded with 2^32 of hex numbers passed as parameters\n     */\n    private String addBin(String a, String b) {\n        String ans = \"\";\n        long n1 = Long.parseUnsignedLong(a, 16);\n        long n2 = Long.parseUnsignedLong(b, 16);\n        n1 = (n1 + n2) % modVal;\n        ans = Long.toHexString(n1);\n        ans = \"00000000\" + ans;\n        return ans.substring(ans.length() - 8);\n    }\n\n    /*F-function splits the 32-bit input into four 8-bit quarters \n\t and uses the quarters as input to the S-boxes. \n\t The S-boxes accept 8-bit input and produce 32-bit output. \n\t The outputs are added modulo 232 and XORed to produce the final 32-bit output \n\t*/\n    private String f(String plainText) {\n        String[] a = new String[4];\n        String ans = \"\";\n        for (int i = 0; i < 8; i += 2) {\n            //column number for S-box is a 8-bit value\n            long col = Long.parseUnsignedLong(\n                hexToBin(plainText.substring(i, i + 2)),\n                2\n            );\n            a[i / 2] = S[i / 2][(int) col];\n        }\n        ans = addBin(a[0], a[1]);\n        ans = xor(ans, a[2]);\n        ans = addBin(ans, a[3]);\n        return ans;\n    }\n\n    //generate subkeys\n    private void keyGenerate(String key) {\n        int j = 0;\n        for (int i = 0; i < P.length; i++) {\n            //XOR-ing 32-bit parts of the key with initial subkeys\n            P[i] = xor(P[i], key.substring(j, j + 8));\n\n            j = (j + 8) % key.length();\n        }\n    }\n\n    //round function\n    private String round(int time, String plainText) {\n        String left, right;\n        left = plainText.substring(0, 8);\n        right = plainText.substring(8, 16);\n        left = xor(left, P[time]);\n\n        //output from F function\n        String fOut = f(left);\n\n        right = xor(fOut, right);\n\n        //swap left and right\n        return right + left;\n    }\n\n    /**\n     * This method returns cipher text for the plaintext passed as the first parameter generated\n     * using the key passed as the second parameter\n     *\n     * @param String plainText is the text which is to be encrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String cipherText is the encrypted value\n     */\n    String encrypt(String plainText, String key) {\n        //generating key\n        keyGenerate(key);\n\n        for (int i = 0; i < 16; i++) plainText = round(i, plainText);\n\n        //postprocessing\n        String right = plainText.substring(0, 8);\n        String left = plainText.substring(8, 16);\n        right = xor(right, P[16]);\n        left = xor(left, P[17]);\n        return left + right;\n    }\n\n    /**\n     * This method returns plaintext for the ciphertext passed as the first parameter decoded\n     * using the key passed as the second parameter\n     *\n     * @param String ciphertext is the text which is to be decrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String plainText is the decrypted text\n     */\n    String decrypt(String cipherText, String key) {\n        //generating key\n        keyGenerate(key);\n\n        for (int i = 17; i > 1; i--) cipherText = round(i, cipherText);\n\n        //postprocessing\n        String right = cipherText.substring(0, 8);\n        String left = cipherText.substring(8, 16);\n        right = xor(right, P[1]);\n        left = xor(left, P[0]);\n        return left + right;\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/*\n * Java program for Blowfish Algorithm\n * Wikipedia: https://en.wikipedia.org/wiki/Blowfish_(cipher)\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class Blowfish {\n\n    // Initializing substitution boxes\n    String[][] S = {\n        {\n            \"d1310ba6\",\n            \"98dfb5ac\",\n            \"2ffd72db\",\n            \"d01adfb7\",\n            \"b8e1afed\",\n            \"6a267e96\",\n            \"ba7c9045\",\n            \"f12c7f99\",\n            \"24a19947\",\n            \"b3916cf7\",\n            \"0801f2e2\",\n            \"858efc16\",\n            \"636920d8\",\n            \"71574e69\",\n            \"a458fea3\",\n            \"f4933d7e\",\n            \"0d95748f\",\n            \"728eb658\",\n            \"718bcd58\",\n            \"82154aee\",\n            \"7b54a41d\",\n            \"c25a59b5\",\n            \"9c30d539\",\n            \"2af26013\",\n            \"c5d1b023\",\n            \"286085f0\",\n            \"ca417918\",\n            \"b8db38ef\",\n            \"8e79dcb0\",\n            \"603a180e\",\n            \"6c9e0e8b\",\n            \"b01e8a3e\",\n            \"d71577c1\",\n            \"bd314b27\",\n            \"78af2fda\",\n            \"55605c60\",\n            \"e65525f3\",\n            \"aa55ab94\",\n            \"57489862\",\n            \"63e81440\",\n            \"55ca396a\",\n            \"2aab10b6\",\n            \"b4cc5c34\",\n            \"1141e8ce\",\n            \"a15486af\",\n            \"7c72e993\",\n            \"b3ee1411\",\n            \"636fbc2a\",\n            \"2ba9c55d\",\n            \"741831f6\",\n            \"ce5c3e16\",\n            \"9b87931e\",\n            \"afd6ba33\",\n            \"6c24cf5c\",\n            \"7a325381\",\n            \"28958677\",\n            \"3b8f4898\",\n            \"6b4bb9af\",\n            \"c4bfe81b\",\n            \"66282193\",\n            \"61d809cc\",\n            \"fb21a991\",\n            \"487cac60\",\n            \"5dec8032\",\n            \"ef845d5d\",\n            \"e98575b1\",\n            \"dc262302\",\n            \"eb651b88\",\n            \"23893e81\",\n            \"d396acc5\",\n            \"0f6d6ff3\",\n            \"83f44239\",\n            \"2e0b4482\",\n            \"a4842004\",\n            \"69c8f04a\",\n            \"9e1f9b5e\",\n            \"21c66842\",\n            \"f6e96c9a\",\n            \"670c9c61\",\n            \"abd388f0\",\n            \"6a51a0d2\",\n            \"d8542f68\",\n            \"960fa728\",\n            \"ab5133a3\",\n            \"6eef0b6c\",\n            \"137a3be4\",\n            \"ba3bf050\",\n            \"7efb2a98\",\n            \"a1f1651d\",\n            \"39af0176\",\n            \"66ca593e\",\n            \"82430e88\",\n            \"8cee8619\",\n            \"456f9fb4\",\n            \"7d84a5c3\",\n            \"3b8b5ebe\",\n            \"e06f75d8\",\n            \"85c12073\",\n            \"401a449f\",\n            \"56c16aa6\",\n            \"4ed3aa62\",\n            \"363f7706\",\n            \"1bfedf72\",\n            \"429b023d\",\n            \"37d0d724\",\n            \"d00a1248\",\n            \"db0fead3\",\n            \"49f1c09b\",\n            \"075372c9\",\n            \"80991b7b\",\n            \"25d479d8\",\n            \"f6e8def7\",\n            \"e3fe501a\",\n            \"b6794c3b\",\n            \"976ce0bd\",\n            \"04c006ba\",\n            \"c1a94fb6\",\n            \"409f60c4\",\n            \"5e5c9ec2\",\n            \"196a2463\",\n            \"68fb6faf\",\n            \"3e6c53b5\",\n            \"1339b2eb\",\n            \"3b52ec6f\",\n            \"6dfc511f\",\n            \"9b30952c\",\n            \"cc814544\",\n            \"af5ebd09\",\n            \"bee3d004\",\n            \"de334afd\",\n            \"660f2807\",\n            \"192e4bb3\",\n            \"c0cba857\",\n            \"45c8740f\",\n            \"d20b5f39\",\n            \"b9d3fbdb\",\n            \"5579c0bd\",\n            \"1a60320a\",\n            \"d6a100c6\",\n            \"402c7279\",\n            \"679f25fe\",\n            \"fb1fa3cc\",\n            \"8ea5e9f8\",\n            \"db3222f8\",\n            \"3c7516df\",\n            \"fd616b15\",\n            \"2f501ec8\",\n            \"ad0552ab\",\n            \"323db5fa\",\n            \"fd238760\",\n            \"53317b48\",\n            \"3e00df82\",\n            \"9e5c57bb\",\n            \"ca6f8ca0\",\n            \"1a87562e\",\n            \"df1769db\",\n            \"d542a8f6\",\n            \"287effc3\",\n            \"ac6732c6\",\n            \"8c4f5573\",\n            \"695b27b0\",\n            \"bbca58c8\",\n            \"e1ffa35d\",\n            \"b8f011a0\",\n            \"10fa3d98\",\n            \"fd2183b8\",\n            \"4afcb56c\",\n            \"2dd1d35b\",\n            \"9a53e479\",\n            \"b6f84565\",\n            \"d28e49bc\",\n            \"4bfb9790\",\n            \"e1ddf2da\",\n            \"a4cb7e33\",\n            \"62fb1341\",\n            \"cee4c6e8\",\n            \"ef20cada\",\n            \"36774c01\",\n            \"d07e9efe\",\n            \"2bf11fb4\",\n            \"95dbda4d\",\n            \"ae909198\",\n            \"eaad8e71\",\n            \"6b93d5a0\",\n            \"d08ed1d0\",\n            \"afc725e0\",\n            \"8e3c5b2f\",\n            \"8e7594b7\",\n            \"8ff6e2fb\",\n            \"f2122b64\",\n            \"8888b812\",\n            \"900df01c\",\n            \"4fad5ea0\",\n            \"688fc31c\",\n            \"d1cff191\",\n            \"b3a8c1ad\",\n            \"2f2f2218\",\n            \"be0e1777\",\n            \"ea752dfe\",\n            \"8b021fa1\",\n            \"e5a0cc0f\",\n            \"b56f74e8\",\n            \"18acf3d6\",\n            \"ce89e299\",\n            \"b4a84fe0\",\n            \"fd13e0b7\",\n            \"7cc43b81\",\n            \"d2ada8d9\",\n            \"165fa266\",\n            \"80957705\",\n            \"93cc7314\",\n            \"211a1477\",\n            \"e6ad2065\",\n            \"77b5fa86\",\n            \"c75442f5\",\n            \"fb9d35cf\",\n            \"ebcdaf0c\",\n            \"7b3e89a0\",\n            \"d6411bd3\",\n            \"ae1e7e49\",\n            \"00250e2d\",\n            \"2071b35e\",\n            \"226800bb\",\n            \"57b8e0af\",\n            \"2464369b\",\n            \"f009b91e\",\n            \"5563911d\",\n            \"59dfa6aa\",\n            \"78c14389\",\n            \"d95a537f\",\n            \"207d5ba2\",\n            \"02e5b9c5\",\n            \"83260376\",\n            \"6295cfa9\",\n            \"11c81968\",\n            \"4e734a41\",\n            \"b3472dca\",\n            \"7b14a94a\",\n            \"1b510052\",\n            \"9a532915\",\n            \"d60f573f\",\n            \"bc9bc6e4\",\n            \"2b60a476\",\n            \"81e67400\",\n            \"08ba6fb5\",\n            \"571be91f\",\n            \"f296ec6b\",\n            \"2a0dd915\",\n            \"b6636521\",\n            \"e7b9f9b6\",\n            \"ff34052e\",\n            \"c5855664\",\n            \"53b02d5d\",\n            \"a99f8fa1\",\n            \"08ba4799\",\n            \"6e85076a\",\n        },\n        {\n            \"4b7a70e9\",\n            \"b5b32944\",\n            \"db75092e\",\n            \"c4192623\",\n            \"ad6ea6b0\",\n            \"49a7df7d\",\n            \"9cee60b8\",\n            \"8fedb266\",\n            \"ecaa8c71\",\n            \"699a17ff\",\n            \"5664526c\",\n            \"c2b19ee1\",\n            \"193602a5\",\n            \"75094c29\",\n            \"a0591340\",\n            \"e4183a3e\",\n            \"3f54989a\",\n            \"5b429d65\",\n            \"6b8fe4d6\",\n            \"99f73fd6\",\n            \"a1d29c07\",\n            \"efe830f5\",\n            \"4d2d38e6\",\n            \"f0255dc1\",\n            \"4cdd2086\",\n            \"8470eb26\",\n            \"6382e9c6\",\n            \"021ecc5e\",\n            \"09686b3f\",\n            \"3ebaefc9\",\n            \"3c971814\",\n            \"6b6a70a1\",\n            \"687f3584\",\n            \"52a0e286\",\n            \"b79c5305\",\n            \"aa500737\",\n            \"3e07841c\",\n            \"7fdeae5c\",\n            \"8e7d44ec\",\n            \"5716f2b8\",\n            \"b03ada37\",\n            \"f0500c0d\",\n            \"f01c1f04\",\n            \"0200b3ff\",\n            \"ae0cf51a\",\n            \"3cb574b2\",\n            \"25837a58\",\n            \"dc0921bd\",\n            \"d19113f9\",\n            \"7ca92ff6\",\n            \"94324773\",\n            \"22f54701\",\n            \"3ae5e581\",\n            \"37c2dadc\",\n            \"c8b57634\",\n            \"9af3dda7\",\n            \"a9446146\",\n            \"0fd0030e\",\n            \"ecc8c73e\",\n            \"a4751e41\",\n            \"e238cd99\",\n            \"3bea0e2f\",\n            \"3280bba1\",\n            \"183eb331\",\n            \"4e548b38\",\n            \"4f6db908\",\n            \"6f420d03\",\n            \"f60a04bf\",\n            \"2cb81290\",\n            \"24977c79\",\n            \"5679b072\",\n            \"bcaf89af\",\n            \"de9a771f\",\n            \"d9930810\",\n            \"b38bae12\",\n            \"dccf3f2e\",\n            \"5512721f\",\n            \"2e6b7124\",\n            \"501adde6\",\n            \"9f84cd87\",\n            \"7a584718\",\n            \"7408da17\",\n            \"bc9f9abc\",\n            \"e94b7d8c\",\n            \"ec7aec3a\",\n            \"db851dfa\",\n            \"63094366\",\n            \"c464c3d2\",\n            \"ef1c1847\",\n            \"3215d908\",\n            \"dd433b37\",\n            \"24c2ba16\",\n            \"12a14d43\",\n            \"2a65c451\",\n            \"50940002\",\n            \"133ae4dd\",\n            \"71dff89e\",\n            \"10314e55\",\n            \"81ac77d6\",\n            \"5f11199b\",\n            \"043556f1\",\n            \"d7a3c76b\",\n            \"3c11183b\",\n            \"5924a509\",\n            \"f28fe6ed\",\n            \"97f1fbfa\",\n            \"9ebabf2c\",\n            \"1e153c6e\",\n            \"86e34570\",\n            \"eae96fb1\",\n            \"860e5e0a\",\n            \"5a3e2ab3\",\n            \"771fe71c\",\n            \"4e3d06fa\",\n            \"2965dcb9\",\n            \"99e71d0f\",\n            \"803e89d6\",\n            \"5266c825\",\n            \"2e4cc978\",\n            \"9c10b36a\",\n            \"c6150eba\",\n            \"94e2ea78\",\n            \"a5fc3c53\",\n            \"1e0a2df4\",\n            \"f2f74ea7\",\n            \"361d2b3d\",\n            \"1939260f\",\n            \"19c27960\",\n            \"5223a708\",\n            \"f71312b6\",\n            \"ebadfe6e\",\n            \"eac31f66\",\n            \"e3bc4595\",\n            \"a67bc883\",\n            \"b17f37d1\",\n            \"018cff28\",\n            \"c332ddef\",\n            \"be6c5aa5\",\n            \"65582185\",\n            \"68ab9802\",\n            \"eecea50f\",\n            \"db2f953b\",\n            \"2aef7dad\",\n            \"5b6e2f84\",\n            \"1521b628\",\n            \"29076170\",\n            \"ecdd4775\",\n            \"619f1510\",\n            \"13cca830\",\n            \"eb61bd96\",\n            \"0334fe1e\",\n            \"aa0363cf\",\n            \"b5735c90\",\n            \"4c70a239\",\n            \"d59e9e0b\",\n            \"cbaade14\",\n            \"eecc86bc\",\n            \"60622ca7\",\n            \"9cab5cab\",\n            \"b2f3846e\",\n            \"648b1eaf\",\n            \"19bdf0ca\",\n            \"a02369b9\",\n            \"655abb50\",\n            \"40685a32\",\n            \"3c2ab4b3\",\n            \"319ee9d5\",\n            \"c021b8f7\",\n            \"9b540b19\",\n            \"875fa099\",\n            \"95f7997e\",\n            \"623d7da8\",\n            \"f837889a\",\n            \"97e32d77\",\n            \"11ed935f\",\n            \"16681281\",\n            \"0e358829\",\n            \"c7e61fd6\",\n            \"96dedfa1\",\n            \"7858ba99\",\n            \"57f584a5\",\n            \"1b227263\",\n            \"9b83c3ff\",\n            \"1ac24696\",\n            \"cdb30aeb\",\n            \"532e3054\",\n            \"8fd948e4\",\n            \"6dbc3128\",\n            \"58ebf2ef\",\n            \"34c6ffea\",\n            \"fe28ed61\",\n            \"ee7c3c73\",\n            \"5d4a14d9\",\n            \"e864b7e3\",\n            \"42105d14\",\n            \"203e13e0\",\n            \"45eee2b6\",\n            \"a3aaabea\",\n            \"db6c4f15\",\n            \"facb4fd0\",\n            \"c742f442\",\n            \"ef6abbb5\",\n            \"654f3b1d\",\n            \"41cd2105\",\n            \"d81e799e\",\n            \"86854dc7\",\n            \"e44b476a\",\n            \"3d816250\",\n            \"cf62a1f2\",\n            \"5b8d2646\",\n            \"fc8883a0\",\n            \"c1c7b6a3\",\n            \"7f1524c3\",\n            \"69cb7492\",\n            \"47848a0b\",\n            \"5692b285\",\n            \"095bbf00\",\n            \"ad19489d\",\n            \"1462b174\",\n            \"23820e00\",\n            \"58428d2a\",\n            \"0c55f5ea\",\n            \"1dadf43e\",\n            \"233f7061\",\n            \"3372f092\",\n            \"8d937e41\",\n            \"d65fecf1\",\n            \"6c223bdb\",\n            \"7cde3759\",\n            \"cbee7460\",\n            \"4085f2a7\",\n            \"ce77326e\",\n            \"a6078084\",\n            \"19f8509e\",\n            \"e8efd855\",\n            \"61d99735\",\n            \"a969a7aa\",\n            \"c50c06c2\",\n            \"5a04abfc\",\n            \"800bcadc\",\n            \"9e447a2e\",\n            \"c3453484\",\n            \"fdd56705\",\n            \"0e1e9ec9\",\n            \"db73dbd3\",\n            \"105588cd\",\n            \"675fda79\",\n            \"e3674340\",\n            \"c5c43465\",\n            \"713e38d8\",\n            \"3d28f89e\",\n            \"f16dff20\",\n            \"153e21e7\",\n            \"8fb03d4a\",\n            \"e6e39f2b\",\n            \"db83adf7\",\n        },\n        {\n            \"e93d5a68\",\n            \"948140f7\",\n            \"f64c261c\",\n            \"94692934\",\n            \"411520f7\",\n            \"7602d4f7\",\n            \"bcf46b2e\",\n            \"d4a20068\",\n            \"d4082471\",\n            \"3320f46a\",\n            \"43b7d4b7\",\n            \"500061af\",\n            \"1e39f62e\",\n            \"97244546\",\n            \"14214f74\",\n            \"bf8b8840\",\n            \"4d95fc1d\",\n            \"96b591af\",\n            \"70f4ddd3\",\n            \"66a02f45\",\n            \"bfbc09ec\",\n            \"03bd9785\",\n            \"7fac6dd0\",\n            \"31cb8504\",\n            \"96eb27b3\",\n            \"55fd3941\",\n            \"da2547e6\",\n            \"abca0a9a\",\n            \"28507825\",\n            \"530429f4\",\n            \"0a2c86da\",\n            \"e9b66dfb\",\n            \"68dc1462\",\n            \"d7486900\",\n            \"680ec0a4\",\n            \"27a18dee\",\n            \"4f3ffea2\",\n            \"e887ad8c\",\n            \"b58ce006\",\n            \"7af4d6b6\",\n            \"aace1e7c\",\n            \"d3375fec\",\n            \"ce78a399\",\n            \"406b2a42\",\n            \"20fe9e35\",\n            \"d9f385b9\",\n            \"ee39d7ab\",\n            \"3b124e8b\",\n            \"1dc9faf7\",\n            \"4b6d1856\",\n            \"26a36631\",\n            \"eae397b2\",\n            \"3a6efa74\",\n            \"dd5b4332\",\n            \"6841e7f7\",\n            \"ca7820fb\",\n            \"fb0af54e\",\n            \"d8feb397\",\n            \"454056ac\",\n            \"ba489527\",\n            \"55533a3a\",\n            \"20838d87\",\n            \"fe6ba9b7\",\n            \"d096954b\",\n            \"55a867bc\",\n            \"a1159a58\",\n            \"cca92963\",\n            \"99e1db33\",\n            \"a62a4a56\",\n            \"3f3125f9\",\n            \"5ef47e1c\",\n            \"9029317c\",\n            \"fdf8e802\",\n            \"04272f70\",\n            \"80bb155c\",\n            \"05282ce3\",\n            \"95c11548\",\n            \"e4c66d22\",\n            \"48c1133f\",\n            \"c70f86dc\",\n            \"07f9c9ee\",\n            \"41041f0f\",\n            \"404779a4\",\n            \"5d886e17\",\n            \"325f51eb\",\n            \"d59bc0d1\",\n            \"f2bcc18f\",\n            \"41113564\",\n            \"257b7834\",\n            \"602a9c60\",\n            \"dff8e8a3\",\n            \"1f636c1b\",\n            \"0e12b4c2\",\n            \"02e1329e\",\n            \"af664fd1\",\n            \"cad18115\",\n            \"6b2395e0\",\n            \"333e92e1\",\n            \"3b240b62\",\n            \"eebeb922\",\n            \"85b2a20e\",\n            \"e6ba0d99\",\n            \"de720c8c\",\n            \"2da2f728\",\n            \"d0127845\",\n            \"95b794fd\",\n            \"647d0862\",\n            \"e7ccf5f0\",\n            \"5449a36f\",\n            \"877d48fa\",\n            \"c39dfd27\",\n            \"f33e8d1e\",\n            \"0a476341\",\n            \"992eff74\",\n            \"3a6f6eab\",\n            \"f4f8fd37\",\n            \"a812dc60\",\n            \"a1ebddf8\",\n            \"991be14c\",\n            \"db6e6b0d\",\n            \"c67b5510\",\n            \"6d672c37\",\n            \"2765d43b\",\n            \"dcd0e804\",\n            \"f1290dc7\",\n            \"cc00ffa3\",\n            \"b5390f92\",\n            \"690fed0b\",\n            \"667b9ffb\",\n            \"cedb7d9c\",\n            \"a091cf0b\",\n            \"d9155ea3\",\n            \"bb132f88\",\n            \"515bad24\",\n            \"7b9479bf\",\n            \"763bd6eb\",\n            \"37392eb3\",\n            \"cc115979\",\n            \"8026e297\",\n            \"f42e312d\",\n            \"6842ada7\",\n            \"c66a2b3b\",\n            \"12754ccc\",\n            \"782ef11c\",\n            \"6a124237\",\n            \"b79251e7\",\n            \"06a1bbe6\",\n            \"4bfb6350\",\n            \"1a6b1018\",\n            \"11caedfa\",\n            \"3d25bdd8\",\n            \"e2e1c3c9\",\n            \"44421659\",\n            \"0a121386\",\n            \"d90cec6e\",\n            \"d5abea2a\",\n            \"64af674e\",\n            \"da86a85f\",\n            \"bebfe988\",\n            \"64e4c3fe\",\n            \"9dbc8057\",\n            \"f0f7c086\",\n            \"60787bf8\",\n            \"6003604d\",\n            \"d1fd8346\",\n            \"f6381fb0\",\n            \"7745ae04\",\n            \"d736fccc\",\n            \"83426b33\",\n            \"f01eab71\",\n            \"b0804187\",\n            \"3c005e5f\",\n            \"77a057be\",\n            \"bde8ae24\",\n            \"55464299\",\n            \"bf582e61\",\n            \"4e58f48f\",\n            \"f2ddfda2\",\n            \"f474ef38\",\n            \"8789bdc2\",\n            \"5366f9c3\",\n            \"c8b38e74\",\n            \"b475f255\",\n            \"46fcd9b9\",\n            \"7aeb2661\",\n            \"8b1ddf84\",\n            \"846a0e79\",\n            \"915f95e2\",\n            \"466e598e\",\n            \"20b45770\",\n            \"8cd55591\",\n            \"c902de4c\",\n            \"b90bace1\",\n            \"bb8205d0\",\n            \"11a86248\",\n            \"7574a99e\",\n            \"b77f19b6\",\n            \"e0a9dc09\",\n            \"662d09a1\",\n            \"c4324633\",\n            \"e85a1f02\",\n            \"09f0be8c\",\n            \"4a99a025\",\n            \"1d6efe10\",\n            \"1ab93d1d\",\n            \"0ba5a4df\",\n            \"a186f20f\",\n            \"2868f169\",\n            \"dcb7da83\",\n            \"573906fe\",\n            \"a1e2ce9b\",\n            \"4fcd7f52\",\n            \"50115e01\",\n            \"a70683fa\",\n            \"a002b5c4\",\n            \"0de6d027\",\n            \"9af88c27\",\n            \"773f8641\",\n            \"c3604c06\",\n            \"61a806b5\",\n            \"f0177a28\",\n            \"c0f586e0\",\n            \"006058aa\",\n            \"30dc7d62\",\n            \"11e69ed7\",\n            \"2338ea63\",\n            \"53c2dd94\",\n            \"c2c21634\",\n            \"bbcbee56\",\n            \"90bcb6de\",\n            \"ebfc7da1\",\n            \"ce591d76\",\n            \"6f05e409\",\n            \"4b7c0188\",\n            \"39720a3d\",\n            \"7c927c24\",\n            \"86e3725f\",\n            \"724d9db9\",\n            \"1ac15bb4\",\n            \"d39eb8fc\",\n            \"ed545578\",\n            \"08fca5b5\",\n            \"d83d7cd3\",\n            \"4dad0fc4\",\n            \"1e50ef5e\",\n            \"b161e6f8\",\n            \"a28514d9\",\n            \"6c51133c\",\n            \"6fd5c7e7\",\n            \"56e14ec4\",\n            \"362abfce\",\n            \"ddc6c837\",\n            \"d79a3234\",\n            \"92638212\",\n            \"670efa8e\",\n            \"406000e0\",\n        },\n        {\n            \"3a39ce37\",\n            \"d3faf5cf\",\n            \"abc27737\",\n            \"5ac52d1b\",\n            \"5cb0679e\",\n            \"4fa33742\",\n            \"d3822740\",\n            \"99bc9bbe\",\n            \"d5118e9d\",\n            \"bf0f7315\",\n            \"d62d1c7e\",\n            \"c700c47b\",\n            \"b78c1b6b\",\n            \"21a19045\",\n            \"b26eb1be\",\n            \"6a366eb4\",\n            \"5748ab2f\",\n            \"bc946e79\",\n            \"c6a376d2\",\n            \"6549c2c8\",\n            \"530ff8ee\",\n            \"468dde7d\",\n            \"d5730a1d\",\n            \"4cd04dc6\",\n            \"2939bbdb\",\n            \"a9ba4650\",\n            \"ac9526e8\",\n            \"be5ee304\",\n            \"a1fad5f0\",\n            \"6a2d519a\",\n            \"63ef8ce2\",\n            \"9a86ee22\",\n            \"c089c2b8\",\n            \"43242ef6\",\n            \"a51e03aa\",\n            \"9cf2d0a4\",\n            \"83c061ba\",\n            \"9be96a4d\",\n            \"8fe51550\",\n            \"ba645bd6\",\n            \"2826a2f9\",\n            \"a73a3ae1\",\n            \"4ba99586\",\n            \"ef5562e9\",\n            \"c72fefd3\",\n            \"f752f7da\",\n            \"3f046f69\",\n            \"77fa0a59\",\n            \"80e4a915\",\n            \"87b08601\",\n            \"9b09e6ad\",\n            \"3b3ee593\",\n            \"e990fd5a\",\n            \"9e34d797\",\n            \"2cf0b7d9\",\n            \"022b8b51\",\n            \"96d5ac3a\",\n            \"017da67d\",\n            \"d1cf3ed6\",\n            \"7c7d2d28\",\n            \"1f9f25cf\",\n            \"adf2b89b\",\n            \"5ad6b472\",\n            \"5a88f54c\",\n            \"e029ac71\",\n            \"e019a5e6\",\n            \"47b0acfd\",\n            \"ed93fa9b\",\n            \"e8d3c48d\",\n            \"283b57cc\",\n            \"f8d56629\",\n            \"79132e28\",\n            \"785f0191\",\n            \"ed756055\",\n            \"f7960e44\",\n            \"e3d35e8c\",\n            \"15056dd4\",\n            \"88f46dba\",\n            \"03a16125\",\n            \"0564f0bd\",\n            \"c3eb9e15\",\n            \"3c9057a2\",\n            \"97271aec\",\n            \"a93a072a\",\n            \"1b3f6d9b\",\n            \"1e6321f5\",\n            \"f59c66fb\",\n            \"26dcf319\",\n            \"7533d928\",\n            \"b155fdf5\",\n            \"03563482\",\n            \"8aba3cbb\",\n            \"28517711\",\n            \"c20ad9f8\",\n            \"abcc5167\",\n            \"ccad925f\",\n            \"4de81751\",\n            \"3830dc8e\",\n            \"379d5862\",\n            \"9320f991\",\n            \"ea7a90c2\",\n            \"fb3e7bce\",\n            \"5121ce64\",\n            \"774fbe32\",\n            \"a8b6e37e\",\n            \"c3293d46\",\n            \"48de5369\",\n            \"6413e680\",\n            \"a2ae0810\",\n            \"dd6db224\",\n            \"69852dfd\",\n            \"09072166\",\n            \"b39a460a\",\n            \"6445c0dd\",\n            \"586cdecf\",\n            \"1c20c8ae\",\n            \"5bbef7dd\",\n            \"1b588d40\",\n            \"ccd2017f\",\n            \"6bb4e3bb\",\n            \"dda26a7e\",\n            \"3a59ff45\",\n            \"3e350a44\",\n            \"bcb4cdd5\",\n            \"72eacea8\",\n            \"fa6484bb\",\n            \"8d6612ae\",\n            \"bf3c6f47\",\n            \"d29be463\",\n            \"542f5d9e\",\n            \"aec2771b\",\n            \"f64e6370\",\n            \"740e0d8d\",\n            \"e75b1357\",\n            \"f8721671\",\n            \"af537d5d\",\n            \"4040cb08\",\n            \"4eb4e2cc\",\n            \"34d2466a\",\n            \"0115af84\",\n            \"e1b00428\",\n            \"95983a1d\",\n            \"06b89fb4\",\n            \"ce6ea048\",\n            \"6f3f3b82\",\n            \"3520ab82\",\n            \"011a1d4b\",\n            \"277227f8\",\n            \"611560b1\",\n            \"e7933fdc\",\n            \"bb3a792b\",\n            \"344525bd\",\n            \"a08839e1\",\n            \"51ce794b\",\n            \"2f32c9b7\",\n            \"a01fbac9\",\n            \"e01cc87e\",\n            \"bcc7d1f6\",\n            \"cf0111c3\",\n            \"a1e8aac7\",\n            \"1a908749\",\n            \"d44fbd9a\",\n            \"d0dadecb\",\n            \"d50ada38\",\n            \"0339c32a\",\n            \"c6913667\",\n            \"8df9317c\",\n            \"e0b12b4f\",\n            \"f79e59b7\",\n            \"43f5bb3a\",\n            \"f2d519ff\",\n            \"27d9459c\",\n            \"bf97222c\",\n            \"15e6fc2a\",\n            \"0f91fc71\",\n            \"9b941525\",\n            \"fae59361\",\n            \"ceb69ceb\",\n            \"c2a86459\",\n            \"12baa8d1\",\n            \"b6c1075e\",\n            \"e3056a0c\",\n            \"10d25065\",\n            \"cb03a442\",\n            \"e0ec6e0e\",\n            \"1698db3b\",\n            \"4c98a0be\",\n            \"3278e964\",\n            \"9f1f9532\",\n            \"e0d392df\",\n            \"d3a0342b\",\n            \"8971f21e\",\n            \"1b0a7441\",\n            \"4ba3348c\",\n            \"c5be7120\",\n            \"c37632d8\",\n            \"df359f8d\",\n            \"9b992f2e\",\n            \"e60b6f47\",\n            \"0fe3f11d\",\n            \"e54cda54\",\n            \"1edad891\",\n            \"ce6279cf\",\n            \"cd3e7e6f\",\n            \"1618b166\",\n            \"fd2c1d05\",\n            \"848fd2c5\",\n            \"f6fb2299\",\n            \"f523f357\",\n            \"a6327623\",\n            \"93a83531\",\n            \"56cccd02\",\n            \"acf08162\",\n            \"5a75ebb5\",\n            \"6e163697\",\n            \"88d273cc\",\n            \"de966292\",\n            \"81b949d0\",\n            \"4c50901b\",\n            \"71c65614\",\n            \"e6c6c7bd\",\n            \"327a140a\",\n            \"45e1d006\",\n            \"c3f27b9a\",\n            \"c9aa53fd\",\n            \"62a80f00\",\n            \"bb25bfe2\",\n            \"35bdd2f6\",\n            \"71126905\",\n            \"b2040222\",\n            \"b6cbcf7c\",\n            \"cd769c2b\",\n            \"53113ec0\",\n            \"1640e3d3\",\n            \"38abbd60\",\n            \"2547adf0\",\n            \"ba38209c\",\n            \"f746ce76\",\n            \"77afa1c5\",\n            \"20756060\",\n            \"85cbfe4e\",\n            \"8ae88dd8\",\n            \"7aaaf9b0\",\n            \"4cf9aa7e\",\n            \"1948c25c\",\n            \"02fb8a8c\",\n            \"01c36ae4\",\n            \"d6ebe1f9\",\n            \"90d4f869\",\n            \"a65cdea0\",\n            \"3f09252d\",\n            \"c208e69f\",\n            \"b74e6132\",\n            \"ce77e25b\",\n            \"578fdfe3\",\n            \"3ac372e6\",\n        },\n    };\n\n    // Initializing subkeys with digits of pi\n    String[] P = {\n        \"243f6a88\",\n        \"85a308d3\",\n        \"13198a2e\",\n        \"03707344\",\n        \"a4093822\",\n        \"299f31d0\",\n        \"082efa98\",\n        \"ec4e6c89\",\n        \"452821e6\",\n        \"38d01377\",\n        \"be5466cf\",\n        \"34e90c6c\",\n        \"c0ac29b7\",\n        \"c97c50dd\",\n        \"3f84d5b5\",\n        \"b5470917\",\n        \"9216d5d9\",\n        \"8979fb1b\",\n    };\n\n    // Initializing modVal to 2^32\n    long modVal = 4294967296L;\n\n    /**\n     * This method returns binary representation of the hexadecimal number passed as parameter\n     *\n     * @param hex Number for which binary representation is required\n     * @return String object which is a binary representation of the hex number passed as parameter\n     */\n    private String hexToBin(String hex) {\n        String binary = \"\";\n        long num;\n        String binary4B;\n        int n = hex.length();\n        for (int i = 0; i < n; i++) {\n            num = Long.parseUnsignedLong(hex.charAt(i) + \"\", 16);\n            binary4B = Long.toBinaryString(num);\n\n            binary4B = \"0000\" + binary4B;\n\n            binary4B = binary4B.substring(binary4B.length() - 4);\n            binary += binary4B;\n        }\n        return binary;\n    }\n\n    /**\n     * This method returns hexadecimal representation of the binary number passed as parameter\n     *\n     * @param binary Number for which hexadecimal representation is required\n     * @return String object which is a hexadecimal representation of the binary number passed as\n     *     parameter\n     */\n    private String binToHex(String binary) {\n        long num = Long.parseUnsignedLong(binary, 2);\n        String hex = Long.toHexString(num);\n        while (hex.length() < (binary.length() / 4)) hex = \"0\" + hex;\n\n        return hex;\n    }\n\n    /**\n     * This method returns a string obtained by XOR-ing two strings of same length passed a method\n     * parameters\n     *\n     * @param String a and b are string objects which will be XORed and are to be of same length\n     * @return String object obtained by XOR operation on String a and String b\n     * */\n    private String xor(String a, String b) {\n        a = hexToBin(a);\n        b = hexToBin(b);\n        String ans = \"\";\n        for (int i = 0; i < a.length(); i++)\n            ans += (char) (((a.charAt(i) - '0') ^ (b.charAt(i) - '0')) + '0');\n        ans = binToHex(ans);\n        return ans;\n    }\n\n    /**\n     * This method returns addition of two hexadecimal numbers passed as parameters and moded with\n     * 2^32\n     *\n     * @param String a and b are hexadecimal numbers\n     * @return String object which is a is addition that is then moded with 2^32 of hex numbers\n     *     passed as parameters\n     */\n    private String addBin(String a, String b) {\n        String ans = \"\";\n        long n1 = Long.parseUnsignedLong(a, 16);\n        long n2 = Long.parseUnsignedLong(b, 16);\n        n1 = (n1 + n2) % modVal;\n        ans = Long.toHexString(n1);\n        ans = \"00000000\" + ans;\n        return ans.substring(ans.length() - 8);\n    }\n\n    /*F-function splits the 32-bit input into four 8-bit quarters\n         and uses the quarters as input to the S-boxes.\n         The S-boxes accept 8-bit input and produce 32-bit output.\n         The outputs are added modulo 232 and XORed to produce the final 32-bit output\n        */\n    private String f(String plainText) {\n        String[] a = new String[4];\n        String ans = \"\";\n        for (int i = 0; i < 8; i += 2) {\n            // column number for S-box is a 8-bit value\n            long col = Long.parseUnsignedLong(hexToBin(plainText.substring(i, i + 2)), 2);\n            a[i / 2] = S[i / 2][(int) col];\n        }\n        ans = addBin(a[0], a[1]);\n        ans = xor(ans, a[2]);\n        ans = addBin(ans, a[3]);\n        return ans;\n    }\n\n    // generate subkeys\n    private void keyGenerate(String key) {\n        int j = 0;\n        for (int i = 0; i < P.length; i++) {\n            // XOR-ing 32-bit parts of the key with initial subkeys\n            P[i] = xor(P[i], key.substring(j, j + 8));\n\n            j = (j + 8) % key.length();\n        }\n    }\n\n    // round function\n    private String round(int time, String plainText) {\n        String left, right;\n        left = plainText.substring(0, 8);\n        right = plainText.substring(8, 16);\n        left = xor(left, P[time]);\n\n        // output from F function\n        String fOut = f(left);\n\n        right = xor(fOut, right);\n\n        // swap left and right\n        return right + left;\n    }\n\n    /**\n     * This method returns cipher text for the plaintext passed as the first parameter generated\n     * using the key passed as the second parameter\n     *\n     * @param String plainText is the text which is to be encrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String cipherText is the encrypted value\n     */\n    String encrypt(String plainText, String key) {\n        // generating key\n        keyGenerate(key);\n\n        for (int i = 0; i < 16; i++) plainText = round(i, plainText);\n\n        // postprocessing\n        String right = plainText.substring(0, 8);\n        String left = plainText.substring(8, 16);\n        right = xor(right, P[16]);\n        left = xor(left, P[17]);\n        return left + right;\n    }\n\n    /**\n     * This method returns plaintext for the ciphertext passed as the first parameter decoded\n     * using the key passed as the second parameter\n     *\n     * @param String ciphertext is the text which is to be decrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String plainText is the decrypted text\n     */\n    String decrypt(String cipherText, String key) {\n        // generating key\n        keyGenerate(key);\n\n        for (int i = 17; i > 1; i--) cipherText = round(i, cipherText);\n\n        // postprocessing\n        String right = cipherText.substring(0, 8);\n        String left = cipherText.substring(8, 16);\n        right = xor(right, P[1]);\n        left = xor(left, P[0]);\n        return left + right;\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass BlowfishTest {\n\n    Blowfish blowfish = new Blowfish();\n\n    @Test\n    void testEncrypt() {\n        //given\n        String plainText = \"123456abcd132536\";\n        String key = \"aabb09182736ccdd\";\n        String expectedOutput = \"d748ec383d3405f7\";\n\n        //when\n        String cipherText = blowfish.encrypt(plainText, key);\n\n        //then\n        assertEquals(expectedOutput, cipherText);\n    }\n\n    @Test\n    void testDecrypt() {\n        //given\n        String cipherText = \"d748ec383d3405f7\";\n        String key = \"aabb09182736ccdd\";\n        String expectedOutput = \"123456abcd132536\";\n\n        //when\n        String plainText = blowfish.decrypt(cipherText, key);\n\n        //then\n        assertEquals(expectedOutput, plainText);\n    }\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass BlowfishTest {\n\n    Blowfish blowfish = new Blowfish();\n\n    @Test\n    void testEncrypt() {\n        // given\n        String plainText = \"123456abcd132536\";\n        String key = \"aabb09182736ccdd\";\n        String expectedOutput = \"d748ec383d3405f7\";\n\n        // when\n        String cipherText = blowfish.encrypt(plainText, key);\n\n        // then\n        assertEquals(expectedOutput, cipherText);\n    }\n\n    @Test\n    void testDecrypt() {\n        // given\n        String cipherText = \"d748ec383d3405f7\";\n        String key = \"aabb09182736ccdd\";\n        String expectedOutput = \"123456abcd132536\";\n\n        // when\n        String plainText = blowfish.decrypt(cipherText, key);\n\n        // then\n        assertEquals(expectedOutput, plainText);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Caesar.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/CaesarTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Caesar Cipher. /It is a type of substitution cipher\n * in which each letter in the plaintext is replaced by a letter some fixed\n * number of positions down the alphabet. /\n *\n * @author FAHRI YARDIMCI\n * @author khalil2535\n */\npublic class Caesar {\n\n    /**\n     * Encrypt text by shifting every Latin char by add number shift for ASCII\n     * Example : A + 1 -> B\n     *\n     * @return Encrypted message\n     */\n    public String encode(String message, int shift) {\n        StringBuilder encoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = message.length();\n        for (int i = 0; i < length; i++) {\n            //            int current = message.charAt(i); //using char to shift characters because ascii\n            // is in-order latin alphabet\n            char current = message.charAt(i); // Java law : char + int = char\n\n            if (isCapitalLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters\n            } else {\n                encoded.append(current);\n            }\n        }\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by shifting back every Latin char to previous the ASCII\n     * Example : B - 1 -> A\n     *\n     * @return message\n     */\n    public String decode(String encryptedMessage, int shift) {\n        StringBuilder decoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = encryptedMessage.length();\n        for (int i = 0; i < length; i++) {\n            char current = encryptedMessage.charAt(i);\n            if (isCapitalLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n            } else {\n                decoded.append(current);\n            }\n        }\n        return decoded.toString();\n    }\n\n    /**\n     * @return true if character is capital Latin letter or false for others\n     */\n    private static boolean isCapitalLatinLetter(char c) {\n        return c >= 'A' && c <= 'Z';\n    }\n\n    /**\n     * @return true if character is small Latin letter or false for others\n     */\n    private static boolean isSmallLatinLetter(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    /**\n     *  @return string array which contains all the possible decoded combination.\n     */\n    public String[] bruteforce(String encryptedMessage) {\n        String[] listOfAllTheAnswers = new String[27];\n        for (int i = 0; i <= 26; i++) {\n            listOfAllTheAnswers[i] = decode(encryptedMessage, i);\n        }\n\n        return listOfAllTheAnswers;\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Caesar Cipher. /It is a type of substitution cipher\n * in which each letter in the plaintext is replaced by a letter some fixed\n * number of positions down the alphabet. /\n *\n * @author FAHRI YARDIMCI\n * @author khalil2535\n */\npublic class Caesar {\n\n    /**\n     * Encrypt text by shifting every Latin char by add number shift for ASCII\n     * Example : A + 1 -> B\n     *\n     * @return Encrypted message\n     */\n    public String encode(String message, int shift) {\n        StringBuilder encoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = message.length();\n        for (int i = 0; i < length; i++) {\n            //            int current = message.charAt(i); //using char to shift characters because\n            //            ascii\n            // is in-order latin alphabet\n            char current = message.charAt(i); // Java law : char + int = char\n\n            if (isCapitalLatinLetter(current)) {\n                current += shift;\n                encoded.append((\n                    char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current += shift;\n                encoded.append((\n                    char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters\n            } else {\n                encoded.append(current);\n            }\n        }\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by shifting back every Latin char to previous the ASCII\n     * Example : B - 1 -> A\n     *\n     * @return message\n     */\n    public String decode(String encryptedMessage, int shift) {\n        StringBuilder decoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = encryptedMessage.length();\n        for (int i = 0; i < length; i++) {\n            char current = encryptedMessage.charAt(i);\n            if (isCapitalLatinLetter(current)) {\n                current -= shift;\n                decoded.append((\n                    char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current -= shift;\n                decoded.append((\n                    char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n            } else {\n                decoded.append(current);\n            }\n        }\n        return decoded.toString();\n    }\n\n    /**\n     * @return true if character is capital Latin letter or false for others\n     */\n    private static boolean isCapitalLatinLetter(char c) {\n        return c >= 'A' && c <= 'Z';\n    }\n\n    /**\n     * @return true if character is small Latin letter or false for others\n     */\n    private static boolean isSmallLatinLetter(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    /**\n     *  @return string array which contains all the possible decoded combination.\n     */\n    public String[] bruteforce(String encryptedMessage) {\n        String[] listOfAllTheAnswers = new String[27];\n        for (int i = 0; i <= 26; i++) {\n            listOfAllTheAnswers[i] = decode(encryptedMessage, i);\n        }\n\n        return listOfAllTheAnswers;\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CaesarTest {\n\n    Caesar caesar = new Caesar();\n\n    @Test\n    void caesarEncryptTest() {\n        // given\n        String textToEncrypt = \"Encrypt this text\";\n\n        // when\n        String cipherText = caesar.encode(textToEncrypt, 5);\n\n        // then\n        assertEquals(\"Jshwduy ymnx yjcy\", cipherText);\n    }\n\n    @Test\n    void caesarDecryptTest() {\n        // given\n        String encryptedText = \"Jshwduy ymnx yjcy\";\n\n        // when\n        String cipherText = caesar.decode(encryptedText, 5);\n\n        // then\n        assertEquals(\"Encrypt this text\", cipherText);\n    }\n\n    @Test\n    void caesarBruteForce() {\n        // given\n        String encryptedText = \"Jshwduy ymnx yjcy\";\n\n        // when\n        String[] allPossibleAnswers = caesar.bruteforce(encryptedText);\n\n        assertEquals(27, allPossibleAnswers.length);\n        assertEquals(\"Encrypt this text\", allPossibleAnswers[5]);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass CaesarTest {\n\n    Caesar caesar = new Caesar();\n\n    @Test\n    void caesarEncryptTest() {\n        // given\n        String textToEncrypt = \"Encrypt this text\";\n\n        // when\n        String cipherText = caesar.encode(textToEncrypt, 5);\n\n        // then\n        assertEquals(\"Jshwduy ymnx yjcy\", cipherText);\n    }\n\n    @Test\n    void caesarDecryptTest() {\n        // given\n        String encryptedText = \"Jshwduy ymnx yjcy\";\n\n        // when\n        String cipherText = caesar.decode(encryptedText, 5);\n\n        // then\n        assertEquals(\"Encrypt this text\", cipherText);\n    }\n\n    @Test\n    void caesarBruteForce() {\n        // given\n        String encryptedText = \"Jshwduy ymnx yjcy\";\n\n        // when\n        String[] allPossibleAnswers = caesar.bruteforce(encryptedText);\n\n        assertEquals(27, allPossibleAnswers.length);\n        assertEquals(\"Encrypt this text\", allPossibleAnswers[5]);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/DES.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/DESTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/**\n * This class is build to demonstrate the application of the DES-algorithm (https://en.wikipedia.org/wiki/Data_Encryption_Standard) on a\n * plain English message. The supplied key must be in form of a 64 bit binary String.\n */\npublic class DES {\n\n    private String key;\n    private String subKeys[];\n\n    private void sanitize(String key) {\n        int length = key.length();\n        if (length != 64) {\n            throw new IllegalArgumentException(\"DES key must be supplied as a 64 character binary string\");\n        }\n    }\n\n    DES(String key) {\n        sanitize(key);\n        this.key = key;\n        subKeys = getSubkeys(key);\n    }\n\n    public String getKey() {\n        return this.key;\n    }\n\n    public void setKey(String key) {\n        sanitize(key);\n        this.key = key;\n    }\n\t\n    //Permutation table to convert initial 64 bit key to 56 bit key\n\tprivate static int[] PC1 = \n\t{  \n\t\t57, 49, 41, 33, 25, 17,  9,\n        1, 58, 50, 42, 34, 26, 18,\n        10,  2, 59, 51, 43, 35, 27,\n        19, 11,  3, 60, 52, 44, 36,\n        63, 55, 47, 39, 31, 23, 15,\n        7, 62, 54, 46, 38, 30, 22,\n        14,  6, 61, 53, 45, 37, 29,\n        21, 13,  5, 28, 20, 12,  4\n\t};\n\n    //Lookup table used to shift the initial key, in order to generate the subkeys\n    private static int[] KEY_SHIFTS = \n\t{\n\t\t1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1\n\t};\n\n    //Table to convert the 56 bit subkeys to 48 bit subkeys\n    private static int[] PC2 = \n\t{\n\t\t14, 17, 11, 24,  1,  5,\n        3, 28, 15,  6, 21, 10,\n        23, 19, 12,  4, 26,  8,\n        16,  7, 27, 20, 13,  2,\n        41, 52, 31, 37, 47, 55,\n        30, 40, 51, 45, 33, 48,\n        44, 49, 39, 56, 34, 53,\n        46, 42, 50, 36, 29, 32\n\t};\n\n    //Initial permutatation of each 64 but message block\n    private static int[] IP = \n\t{\n\t\t 58, 50, 42, 34, 26, 18, 10 , 2,\n         60, 52, 44, 36, 28, 20, 12, 4,\n         62, 54, 46, 38, 30, 22, 14, 6,\n         64, 56, 48, 40, 32, 24, 16, 8,\n         57, 49, 41, 33, 25, 17, 9, 1,\n         59, 51, 43, 35, 27, 19, 11, 3,\n         61, 53, 45, 37, 29, 21, 13, 5,\n         63, 55, 47, 39, 31, 23, 15, 7\n\t};\n\n    //Expansion table to convert right half of message blocks from 32 bits to 48 bits\n    private static int[] expansion = \n\t{\n\t\t32,  1,  2,  3,  4,  5,\n\t\t4,  5,  6,  7,  8,  9, \n\t\t8,  9, 10, 11, 12, 13, \n\t\t12, 13, 14, 15, 16, 17,\n\t\t16, 17, 18, 19, 20, 21, \n\t\t20, 21, 22, 23, 24, 25, \n\t\t24, 25, 26, 27, 28, 29, \n\t\t28, 29, 30, 31, 32,  1\n\t};\n \n    //The eight substitution boxes are defined below\n    private static int[][] s1 = {\n\t\t{14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},\n\t\t{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11,  9,  5,  3,  8},\n\t\t{4, 1, 14,  8, 13,  6, 2, 11, 15, 12,  9,  7,  3, 10,  5,  0},\n\t\t{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}\n\t };\n\n\tprivate static int[][] s2 = {\n\t\t\t{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},\n\t\t\t{3, 13,  4, 7, 15,  2,  8, 14, 12,  0, 1, 10,  6,  9, 11,  5},\n\t\t\t{0, 14, 7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},\n\t\t\t{13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14,  9}\n\t\t };\n\t\n\tprivate static int[][] s3 = {\n\t\t\t{10, 0, 9, 14, 6, 3, 15, 5,  1, 13, 12, 7, 11, 4, 2,  8},\n\t\t\t{13, 7, 0, 9, 3,  4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},\n\t\t\t{13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14,  7},\n\t\t\t{1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}\n\t\t };\n\t\n\tprivate static int[][] s4 = {\n\t\t\t{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},\n\t\t\t{13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,  9},\n\t\t\t{10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},\n\t\t\t{3, 15, 0, 6, 10, 1, 13, 8, 9,  4, 5, 11, 12, 7, 2, 14}\n\t\t };\n\t\n\tprivate static int[][] s5 = {\n\t\t\t{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},\n\t\t\t{14, 11, 2, 12,  4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},\n\t\t\t{4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},\n\t\t\t{11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}\n\t\t  };\n\t\n\tprivate static int[][] s6 = {\n\t\t\t{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},\n\t\t\t{10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},\n\t\t\t{9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},\n\t\t\t{4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}\n\t\t  };\n\t\n\tprivate static int[][] s7 = {\n\t\t\t{4, 11, 2, 14, 15,  0, 8, 13 , 3, 12, 9 , 7,  5, 10, 6, 1},\n\t\t\t{13 , 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},\n\t\t\t{1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},\n\t\t\t{6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}\n\t\t  };\n\t\n\tprivate static int[][] s8 = {\n\t\t\t{13, 2, 8,  4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},\n\t\t\t{1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6 ,11, 0, 14, 9, 2},\n\t\t\t{7, 11, 4, 1, 9, 12, 14, 2,  0, 6, 10 ,13, 15, 3, 5, 8},\n\t\t\t{2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6 ,11}\n\t\t};\n\t\n\tprivate static int[][][] s = {s1, s2, s3, s4, s5, s6, s7, s8};\n\n    //Permutation table, used in the feistel function post s-box usage\n    static int[] permutation = \n\t{\n\t\t16,  7, 20, 21, \n\t\t29, 12, 28, 17, \n\t\t 1, 15, 23, 26, \n\t\t 5, 18, 31, 10, \n\t\t 2,  8, 24, 14, \n\t\t32, 27,  3,  9, \n\t\t19, 13, 30,  6, \n\t\t22, 11,  4, 25\n\t};\n\n    //Table used for final inversion of the message box after 16 rounds of Feistel Function\n    static int[] IPinverse = \n\t{\n\t\t40, 8, 48, 16, 56, 24, 64, 32,\n\t    39, 7, 47, 15, 55, 23, 63, 31,\n\t    38, 6, 46, 14, 54, 22, 62, 30,\n\t    37, 5, 45, 13, 53, 21, 61, 29,\n\t    36, 4, 44, 12, 52, 20, 60, 28,\n\t    35, 3, 43 ,11, 51, 19, 59, 27,\n\t    34, 2, 42, 10, 50, 18, 58, 26,\n\t    33, 1, 41, 9, 49, 17, 57, 25\n\t};\n\n    private String[] getSubkeys(String originalKey) {\n        StringBuilder permutedKey = new StringBuilder(); //Initial permutation of keys via PC1\n        int i, j;\n        for (i = 0; i < 56; i++) {\n            permutedKey.append(originalKey.charAt(PC1[i] - 1)); \n        }\n        String subKeys[] = new String[16];\n        String initialPermutedKey = permutedKey.toString();\n        String C0 = initialPermutedKey.substring(0, 28), D0 = initialPermutedKey.substring(28);\n        \n        //We will now operate on the left and right halves of the permutedKey\n        for (i = 0; i < 16; i++) {\n            String Cn = C0.substring(KEY_SHIFTS[i]) + C0.substring(0, KEY_SHIFTS[i]);\n            String Dn = D0.substring(KEY_SHIFTS[i]) + D0.substring(0, KEY_SHIFTS[i]);\n            subKeys[i] = Cn + Dn;\n            C0 = Cn; //Re-assign the values to create running permutation\n            D0 = Dn;\n        }\n\n        //Let us shrink the keys to 48 bits (well, characters here) using PC2\n        for (i = 0; i < 16; i++) {\n            String key = subKeys[i];\n            permutedKey.setLength(0);\n            for (j = 0; j < 48; j++) {\n                permutedKey.append(key.charAt(PC2[j] - 1));\n            }\n            subKeys[i] = permutedKey.toString();\n        }\n\n        return subKeys;\n    }\n\n    private String XOR(String a, String b) {\n        int i, l = a.length();\n        StringBuilder xor = new StringBuilder();\n        for (i = 0; i < l; i++) {\n            int firstBit = a.charAt(i) - 48; // 48 is '0' in ascii\n            int secondBit = b.charAt(i) - 48;\n            xor.append((firstBit ^ secondBit));\n        }\n        return xor.toString();\n    }\n\n    private String createPaddedString(String s, int desiredLength, char pad) {\n        int i, l = s.length();\n        StringBuilder paddedString = new StringBuilder();\n        int diff = desiredLength - l;\n        for (i = 0; i < diff; i++) {\n            paddedString.append(pad);\n        }\n        return paddedString.toString();\n    }\n\n    private String pad(String s, int desiredLength) {\n        return createPaddedString(s, desiredLength, '0') + s;\n    }\n\n    private String padLast(String s, int desiredLength) {\n        return s + createPaddedString(s, desiredLength, '\\u0000');\n    }\n\n    private String feistel(String messageBlock, String key) {\n        int i;\n        StringBuilder expandedKey = new StringBuilder();\n        for (i = 0; i < 48; i++) {\n            expandedKey.append(messageBlock.charAt(expansion[i] - 1));\n        }\n        String mixedKey = XOR(expandedKey.toString(), key);\n        StringBuilder substitutedString = new StringBuilder();\n\n        //Let us now use the s-boxes to transform each 6 bit (length here) block to 4 bits\n        for (i = 0; i < 48; i += 6) {\n            String block = mixedKey.substring(i, i + 6);\n            int row = (block.charAt(0) - 48) * 2 + (block.charAt(5) - 48);\n            int col = (block.charAt(1) - 48) * 8 + (block.charAt(2) - 48) * 4 + (block.charAt(3) - 48) * 2 + (block.charAt(4) - 48);\n            String substitutedBlock = pad(Integer.toBinaryString(s[i / 6][row][col]), 4);\n            substitutedString.append(substitutedBlock);\n        }\n\n        StringBuilder permutedString = new StringBuilder(); \n        for (i = 0; i < 32; i++) {\n            permutedString.append(substitutedString.charAt(permutation[i] - 1));\n        }\n\n        return permutedString.toString();\n    }\n\n    private String encryptBlock(String message, String keys[]) {\n        StringBuilder permutedMessage = new StringBuilder();\n        int i;\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(message.charAt(IP[i] - 1));\n        }\n        String L0 = permutedMessage.substring(0, 32), R0 = permutedMessage.substring(32);\n\n        //Iterate 16 times\n        for (i = 0; i < 16; i++) {\n            String Ln = R0; // Previous Right block\n            String Rn = XOR(L0, feistel(R0, keys[i]));\n            L0 = Ln;\n            R0 = Rn;\n        }\n\n        String combinedBlock = R0 + L0; //Reverse the 16th block\n        permutedMessage.setLength(0);\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(combinedBlock.charAt(IPinverse[i] - 1));\n        }\n        return permutedMessage.toString();\n    }\n\n    //To decode, we follow the same process as encoding, but with reversed keys\n    private String decryptBlock(String message, String keys[]) {\n        String reversedKeys[] = new String[keys.length];\n        for (int i = 0; i < keys.length; i++) {\n            reversedKeys[i] = keys[keys.length - i - 1];\n        }\n        return encryptBlock(message, reversedKeys);\n    }\n\n    /**\n     * @param message Message to be encrypted\n     * @return The encrypted message, as a binary string\n     */\n    public String encrypt(String message) {\n        StringBuilder encryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 8 != 0) {\n            int desiredLength = (l / 8 + 1) * 8;\n            l = desiredLength;\n            message = padLast(message, desiredLength);\n        }\n\n        for (i = 0; i < l; i+= 8) {\n            String block = message.substring(i, i + 8);\n            StringBuilder bitBlock = new StringBuilder();\n            byte[] bytes = block.getBytes();\n            for (j = 0; j < 8; j++) {\n                bitBlock.append(pad(Integer.toBinaryString(bytes[j]), 8));\n            }\n            encryptedMessage.append(encryptBlock(bitBlock.toString(), subKeys));\n        }\n        return encryptedMessage.toString();\n    }\n\n    /**\n     * @param message The encrypted string. Expects it to be a multiple of 64 bits, in binary format\n     * @return The decrypted String, in plain English\n     */\n    public String decrypt(String message) {\n        StringBuilder decryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 64 != 0) {\n            throw new IllegalArgumentException(\"Encrypted message should be a multiple of 64 characters in length\");\n        }\n        for (i = 0; i < l; i+= 64) {\n            String block = message.substring(i, i + 64);\n            String result = decryptBlock(block.toString(), subKeys);\n            byte res[] = new byte[8];\n            for (j = 0; j < 64; j+=8) {\n                res[j / 8] = (byte)Integer.parseInt(result.substring(j, j + 8), 2);\n            }\n            decryptedMessage.append(new String(res));\n        }\n        return decryptedMessage.toString().replace(\"\\0\", \"\"); // Get rid of the null bytes used for padding\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * This class is build to demonstrate the application of the DES-algorithm\n * (https://en.wikipedia.org/wiki/Data_Encryption_Standard) on a plain English message. The supplied\n * key must be in form of a 64 bit binary String.\n */\npublic class DES {\n\n    private String key;\n    private String subKeys[];\n\n    private void sanitize(String key) {\n        int length = key.length();\n        if (length != 64) {\n            throw new IllegalArgumentException(\n                \"DES key must be supplied as a 64 character binary string\");\n        }\n    }\n\n    DES(String key) {\n        sanitize(key);\n        this.key = key;\n        subKeys = getSubkeys(key);\n    }\n\n    public String getKey() {\n        return this.key;\n    }\n\n    public void setKey(String key) {\n        sanitize(key);\n        this.key = key;\n    }\n\n    // Permutation table to convert initial 64 bit key to 56 bit key\n    private static int[] PC1 = {57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51,\n        43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30,\n        22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4};\n\n    // Lookup table used to shift the initial key, in order to generate the subkeys\n    private static int[] KEY_SHIFTS = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};\n\n    // Table to convert the 56 bit subkeys to 48 bit subkeys\n    private static int[] PC2 = {14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8,\n        16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34,\n        53, 46, 42, 50, 36, 29, 32};\n\n    // Initial permutatation of each 64 but message block\n    private static int[] IP = {58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54,\n        46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51,\n        43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7};\n\n    // Expansion table to convert right half of message blocks from 32 bits to 48 bits\n    private static int[] expansion = {32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12,\n        13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29,\n        28, 29, 30, 31, 32, 1};\n\n    // The eight substitution boxes are defined below\n    private static int[][] s1 = {{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},\n        {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},\n        {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},\n        {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}};\n\n    private static int[][] s2 = {{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},\n        {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},\n        {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},\n        {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}};\n\n    private static int[][] s3 = {{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},\n        {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},\n        {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},\n        {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}};\n\n    private static int[][] s4 = {{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},\n        {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},\n        {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},\n        {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}};\n\n    private static int[][] s5 = {{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},\n        {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},\n        {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},\n        {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}};\n\n    private static int[][] s6 = {{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},\n        {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},\n        {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},\n        {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}};\n\n    private static int[][] s7 = {{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},\n        {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},\n        {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},\n        {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}};\n\n    private static int[][] s8 = {{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},\n        {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},\n        {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},\n        {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}};\n\n    private static int[][][] s = {s1, s2, s3, s4, s5, s6, s7, s8};\n\n    // Permutation table, used in the feistel function post s-box usage\n    static int[] permutation = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8,\n        24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25};\n\n    // Table used for final inversion of the message box after 16 rounds of Feistel Function\n    static int[] IPinverse = {40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6,\n        46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3,\n        43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25};\n\n    private String[] getSubkeys(String originalKey) {\n        StringBuilder permutedKey = new StringBuilder(); // Initial permutation of keys via PC1\n        int i, j;\n        for (i = 0; i < 56; i++) {\n            permutedKey.append(originalKey.charAt(PC1[i] - 1));\n        }\n        String subKeys[] = new String[16];\n        String initialPermutedKey = permutedKey.toString();\n        String C0 = initialPermutedKey.substring(0, 28), D0 = initialPermutedKey.substring(28);\n\n        // We will now operate on the left and right halves of the permutedKey\n        for (i = 0; i < 16; i++) {\n            String Cn = C0.substring(KEY_SHIFTS[i]) + C0.substring(0, KEY_SHIFTS[i]);\n            String Dn = D0.substring(KEY_SHIFTS[i]) + D0.substring(0, KEY_SHIFTS[i]);\n            subKeys[i] = Cn + Dn;\n            C0 = Cn; // Re-assign the values to create running permutation\n            D0 = Dn;\n        }\n\n        // Let us shrink the keys to 48 bits (well, characters here) using PC2\n        for (i = 0; i < 16; i++) {\n            String key = subKeys[i];\n            permutedKey.setLength(0);\n            for (j = 0; j < 48; j++) {\n                permutedKey.append(key.charAt(PC2[j] - 1));\n            }\n            subKeys[i] = permutedKey.toString();\n        }\n\n        return subKeys;\n    }\n\n    private String XOR(String a, String b) {\n        int i, l = a.length();\n        StringBuilder xor = new StringBuilder();\n        for (i = 0; i < l; i++) {\n            int firstBit = a.charAt(i) - 48; // 48 is '0' in ascii\n            int secondBit = b.charAt(i) - 48;\n            xor.append((firstBit ^ secondBit));\n        }\n        return xor.toString();\n    }\n\n    private String createPaddedString(String s, int desiredLength, char pad) {\n        int i, l = s.length();\n        StringBuilder paddedString = new StringBuilder();\n        int diff = desiredLength - l;\n        for (i = 0; i < diff; i++) {\n            paddedString.append(pad);\n        }\n        return paddedString.toString();\n    }\n\n    private String pad(String s, int desiredLength) {\n        return createPaddedString(s, desiredLength, '0') + s;\n    }\n\n    private String padLast(String s, int desiredLength) {\n        return s + createPaddedString(s, desiredLength, '\\u0000');\n    }\n\n    private String feistel(String messageBlock, String key) {\n        int i;\n        StringBuilder expandedKey = new StringBuilder();\n        for (i = 0; i < 48; i++) {\n            expandedKey.append(messageBlock.charAt(expansion[i] - 1));\n        }\n        String mixedKey = XOR(expandedKey.toString(), key);\n        StringBuilder substitutedString = new StringBuilder();\n\n        // Let us now use the s-boxes to transform each 6 bit (length here) block to 4 bits\n        for (i = 0; i < 48; i += 6) {\n            String block = mixedKey.substring(i, i + 6);\n            int row = (block.charAt(0) - 48) * 2 + (block.charAt(5) - 48);\n            int col = (block.charAt(1) - 48) * 8 + (block.charAt(2) - 48) * 4\n                + (block.charAt(3) - 48) * 2 + (block.charAt(4) - 48);\n            String substitutedBlock = pad(Integer.toBinaryString(s[i / 6][row][col]), 4);\n            substitutedString.append(substitutedBlock);\n        }\n\n        StringBuilder permutedString = new StringBuilder();\n        for (i = 0; i < 32; i++) {\n            permutedString.append(substitutedString.charAt(permutation[i] - 1));\n        }\n\n        return permutedString.toString();\n    }\n\n    private String encryptBlock(String message, String keys[]) {\n        StringBuilder permutedMessage = new StringBuilder();\n        int i;\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(message.charAt(IP[i] - 1));\n        }\n        String L0 = permutedMessage.substring(0, 32), R0 = permutedMessage.substring(32);\n\n        // Iterate 16 times\n        for (i = 0; i < 16; i++) {\n            String Ln = R0; // Previous Right block\n            String Rn = XOR(L0, feistel(R0, keys[i]));\n            L0 = Ln;\n            R0 = Rn;\n        }\n\n        String combinedBlock = R0 + L0; // Reverse the 16th block\n        permutedMessage.setLength(0);\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(combinedBlock.charAt(IPinverse[i] - 1));\n        }\n        return permutedMessage.toString();\n    }\n\n    // To decode, we follow the same process as encoding, but with reversed keys\n    private String decryptBlock(String message, String keys[]) {\n        String reversedKeys[] = new String[keys.length];\n        for (int i = 0; i < keys.length; i++) {\n            reversedKeys[i] = keys[keys.length - i - 1];\n        }\n        return encryptBlock(message, reversedKeys);\n    }\n\n    /**\n     * @param message Message to be encrypted\n     * @return The encrypted message, as a binary string\n     */\n    public String encrypt(String message) {\n        StringBuilder encryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 8 != 0) {\n            int desiredLength = (l / 8 + 1) * 8;\n            l = desiredLength;\n            message = padLast(message, desiredLength);\n        }\n\n        for (i = 0; i < l; i += 8) {\n            String block = message.substring(i, i + 8);\n            StringBuilder bitBlock = new StringBuilder();\n            byte[] bytes = block.getBytes();\n            for (j = 0; j < 8; j++) {\n                bitBlock.append(pad(Integer.toBinaryString(bytes[j]), 8));\n            }\n            encryptedMessage.append(encryptBlock(bitBlock.toString(), subKeys));\n        }\n        return encryptedMessage.toString();\n    }\n\n    /**\n     * @param message The encrypted string. Expects it to be a multiple of 64 bits, in binary format\n     * @return The decrypted String, in plain English\n     */\n    public String decrypt(String message) {\n        StringBuilder decryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 64 != 0) {\n            throw new IllegalArgumentException(\n                \"Encrypted message should be a multiple of 64 characters in length\");\n        }\n        for (i = 0; i < l; i += 64) {\n            String block = message.substring(i, i + 64);\n            String result = decryptBlock(block.toString(), subKeys);\n            byte res[] = new byte[8];\n            for (j = 0; j < 64; j += 8) {\n                res[j / 8] = (byte) Integer.parseInt(result.substring(j, j + 8), 2);\n            }\n            decryptedMessage.append(new String(res));\n        }\n        return decryptedMessage.toString().replace(\n            \"\\0\", \"\"); // Get rid of the null bytes used for padding\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n//Test example taken from https://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm\npublic class DESTest {\n\n    DES des;\n\n    @BeforeEach\n    public void setUp() {\n        des = new DES(\"0000111000110010100100100011001011101010011011010000110101110011\");\n    }\n\n    @Test\n    void testEncrypt() {\n        //given\n        String plainText = \"Your lips are smoother than vaseline\\r\\n\";\n        //This is equal to c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in hexadecimal\n        String expectedOutput = \"11000000100110011001111111011101111000110111100011010111111\" +\n        \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\" +\n        \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\" +\n        \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n\n        //when\n        String cipherText = des.encrypt(plainText);\n\n        //then\n        assertEquals(expectedOutput, cipherText);\n    }\n\n    @Test\n    void testDecrypt() {\n        //given\n       //This is equal to c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in hexadecimal\n       String cipherText = \"11000000100110011001111111011101111000110111100011010111111\" +\n       \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\" +\n       \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\" +\n       \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n        String expectedOutput = \"Your lips are smoother than vaseline\\r\\n\";;\n\n        //when\n        String plainText = des.decrypt(cipherText);\n\n        //then\n        assertEquals(expectedOutput, plainText);\n    }\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n// Test example taken from https://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm\npublic class DESTest {\n\n    DES des;\n\n    @BeforeEach\n    public void setUp() {\n        des = new DES(\"0000111000110010100100100011001011101010011011010000110101110011\");\n    }\n\n    @Test\n    void testEncrypt() {\n        // given\n        String plainText = \"Your lips are smoother than vaseline\\r\\n\";\n        // This is equal to\n        // c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in\n        // hexadecimal\n        String expectedOutput = \"11000000100110011001111111011101111000110111100011010111111\"\n            + \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\"\n            + \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\"\n            + \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n\n        // when\n        String cipherText = des.encrypt(plainText);\n\n        // then\n        assertEquals(expectedOutput, cipherText);\n    }\n\n    @Test\n    void testDecrypt() {\n        // given\n        // This is equal to\n        // c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in\n        // hexadecimal\n        String cipherText = \"11000000100110011001111111011101111000110111100011010111111\"\n            + \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\"\n            + \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\"\n            + \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n        String expectedOutput = \"Your lips are smoother than vaseline\\r\\n\";\n        ;\n\n        // when\n        String plainText = des.decrypt(cipherText);\n\n        // then\n        assertEquals(expectedOutput, plainText);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/RSA.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/RSATest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\n/**\n * @author Nguyen Duy Tiep on 23-Oct-17.\n */\npublic class RSA {\n\n    private BigInteger modulus;\n    private BigInteger privateKey;\n    private BigInteger publicKey;\n\n    public RSA(int bits) {\n        generateKeys(bits);\n    }\n\n    /**\n     * @return encrypted message\n     */\n    public synchronized String encrypt(String message) {\n        return (new BigInteger(message.getBytes())).modPow(publicKey, modulus)\n            .toString();\n    }\n\n    /**\n     * @return encrypted message as big integer\n     */\n    public synchronized BigInteger encrypt(BigInteger message) {\n        return message.modPow(publicKey, modulus);\n    }\n\n    /**\n     * @return plain message\n     */\n    public synchronized String decrypt(String encryptedMessage) {\n        return new String(\n            (new BigInteger(encryptedMessage)).modPow(privateKey, modulus)\n                .toByteArray()\n        );\n    }\n\n    /**\n     * @return plain message as big integer\n     */\n    public synchronized BigInteger decrypt(BigInteger encryptedMessage) {\n        return encryptedMessage.modPow(privateKey, modulus);\n    }\n\n    /**\n     * Generate a new public and private key set.\n     */\n    public synchronized void generateKeys(int bits) {\n        SecureRandom r = new SecureRandom();\n        BigInteger p = new BigInteger(bits / 2, 100, r);\n        BigInteger q = new BigInteger(bits / 2, 100, r);\n        modulus = p.multiply(q);\n\n        BigInteger m =\n            (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\n\n        publicKey = BigInteger.valueOf(3L);\n\n        while (m.gcd(publicKey).intValue() > 1) {\n            publicKey = publicKey.add(BigInteger.TWO);\n        }\n\n        privateKey = publicKey.modInverse(m);\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\n/**\n * @author Nguyen Duy Tiep on 23-Oct-17.\n */\npublic class RSA {\n\n    private BigInteger modulus;\n    private BigInteger privateKey;\n    private BigInteger publicKey;\n\n    public RSA(int bits) {\n        generateKeys(bits);\n    }\n\n    /**\n     * @return encrypted message\n     */\n    public synchronized String encrypt(String message) {\n        return (new BigInteger(message.getBytes())).modPow(publicKey, modulus).toString();\n    }\n\n    /**\n     * @return encrypted message as big integer\n     */\n    public synchronized BigInteger encrypt(BigInteger message) {\n        return message.modPow(publicKey, modulus);\n    }\n\n    /**\n     * @return plain message\n     */\n    public synchronized String decrypt(String encryptedMessage) {\n        return new String(\n            (new BigInteger(encryptedMessage)).modPow(privateKey, modulus).toByteArray());\n    }\n\n    /**\n     * @return plain message as big integer\n     */\n    public synchronized BigInteger decrypt(BigInteger encryptedMessage) {\n        return encryptedMessage.modPow(privateKey, modulus);\n    }\n\n    /**\n     * Generate a new public and private key set.\n     */\n    public synchronized void generateKeys(int bits) {\n        SecureRandom r = new SecureRandom();\n        BigInteger p = new BigInteger(bits / 2, 100, r);\n        BigInteger q = new BigInteger(bits / 2, 100, r);\n        modulus = p.multiply(q);\n\n        BigInteger m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\n\n        publicKey = BigInteger.valueOf(3L);\n\n        while (m.gcd(publicKey).intValue() > 1) {\n            publicKey = publicKey.add(BigInteger.TWO);\n        }\n\n        privateKey = publicKey.modInverse(m);\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass RSATest {\n\n    RSA rsa = new RSA(1024);\n\n    @Test\n    void testRSA() {\n        // given\n        String textToEncrypt = \"Such secure\";\n\n        // when\n        String cipherText = rsa.encrypt(textToEncrypt);\n        String decryptedText = rsa.decrypt(cipherText);\n\n        // then\n        assertEquals(\"Such secure\", decryptedText);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass RSATest {\n\n    RSA rsa = new RSA(1024);\n\n    @Test\n    void testRSA() {\n        // given\n        String textToEncrypt = \"Such secure\";\n\n        // when\n        String cipherText = rsa.encrypt(textToEncrypt);\n        String decryptedText = rsa.decrypt(cipherText);\n\n        // then\n        assertEquals(\"Such secure\", decryptedText);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/SimpleSubCipher.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/SimpleSubCipherTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n */\npublic class SimpleSubCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @param message\n     * @param cipherSmall\n     * @return Encrypted message\n     */\n    public String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @param encryptedMessage\n     * @param cipherSmall\n     * @return message\n     */\n    public String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n */\npublic class SimpleSubCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @param message\n     * @param cipherSmall\n     * @return Encrypted message\n     */\n    public String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @param encryptedMessage\n     * @param cipherSmall\n     * @return message\n     */\n    public String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SimpleSubCipherTest {\n\n    SimpleSubCipher simpleSubCipher = new SimpleSubCipher();\n\n    @Test\n    void simpleSubCipherEncryptTest() {\n        // given\n        String text = \"defend the east wall of the castle\";\n        String cipherSmall = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // when\n        String cipherText = simpleSubCipher.encode(text, cipherSmall);\n\n        // then\n        assertEquals(\"giuifg cei iprc tpnn du cei qprcni\", cipherText);\n    }\n\n    @Test\n    void simpleSubCipherDecryptTest() {\n        // given\n        String encryptedText = \"giuifg cei iprc tpnn du cei qprcni\";\n        String cipherSmall = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // when\n        String decryptedText = simpleSubCipher.decode(encryptedText, cipherSmall);\n\n        // then\n        assertEquals(\"defend the east wall of the castle\", decryptedText);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass SimpleSubCipherTest {\n\n    SimpleSubCipher simpleSubCipher = new SimpleSubCipher();\n\n    @Test\n    void simpleSubCipherEncryptTest() {\n        // given\n        String text = \"defend the east wall of the castle\";\n        String cipherSmall = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // when\n        String cipherText = simpleSubCipher.encode(text, cipherSmall);\n\n        // then\n        assertEquals(\"giuifg cei iprc tpnn du cei qprcni\", cipherText);\n    }\n\n    @Test\n    void simpleSubCipherDecryptTest() {\n        // given\n        String encryptedText = \"giuifg cei iprc tpnn du cei qprcni\";\n        String cipherSmall = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // when\n        String decryptedText = simpleSubCipher.decode(encryptedText, cipherSmall);\n\n        // then\n        assertEquals(\"defend the east wall of the castle\", decryptedText);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Vigenere.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/VigenereTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Vigenere Cipher.\n *\n * @author straiffix\n * @author beingmartinbmc\n */\npublic class Vigenere {\n\n    public String encrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        int j = 0;\n        for (int i = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append(\n                        (char) (\n                            (c + key.toUpperCase().charAt(j) - 2 * 'A') %\n                            26 +\n                            'A'\n                        )\n                    );\n                } else {\n                    result.append(\n                        (char) (\n                            (c + key.toLowerCase().charAt(j) - 2 * 'a') %\n                            26 +\n                            'a'\n                        )\n                    );\n                }\n            } else {\n                result.append(c);\n            }\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n\n    public String decrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        int j = 0;\n        for (int i = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append(\n                        (char) (\n                            'Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26\n                        )\n                    );\n                } else {\n                    result.append(\n                        (char) (\n                            'z' - (25 - (c - key.toLowerCase().charAt(j))) % 26\n                        )\n                    );\n                }\n            } else {\n                result.append(c);\n            }\n\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Vigenere Cipher.\n *\n * @author straiffix\n * @author beingmartinbmc\n */\npublic class Vigenere {\n\n    public String encrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        int j = 0;\n        for (int i = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append((char) ((c + key.toUpperCase().charAt(j) - 2 * 'A') % 26 + 'A'));\n                } else {\n                    result.append((char) ((c + key.toLowerCase().charAt(j) - 2 * 'a') % 26 + 'a'));\n                }\n            } else {\n                result.append(c);\n            }\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n\n    public String decrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        int j = 0;\n        for (int i = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append((char) ('Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26));\n                } else {\n                    result.append((char) ('z' - (25 - (c - key.toLowerCase().charAt(j))) % 26));\n                }\n            } else {\n                result.append(c);\n            }\n\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass VigenereTest {\n\n    Vigenere vigenere = new Vigenere();\n\n    @Test\n    void vigenereEncryptTest() {\n        // given\n        String text = \"Hello World!\";\n        String key = \"suchsecret\";\n\n        // when\n        String cipherText = vigenere.encrypt(text, key);\n\n        // then\n        assertEquals(\"Zynsg Yfvev!\", cipherText);\n    }\n\n    @Test\n    void vigenereDecryptTest() {\n        // given\n        String encryptedText = \"Zynsg Yfvev!\";\n        String key = \"suchsecret\";\n\n        // when\n        String decryptedText = vigenere.decrypt(encryptedText, key);\n\n        // then\n        assertEquals(\"Hello World!\", decryptedText);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass VigenereTest {\n\n    Vigenere vigenere = new Vigenere();\n\n    @Test\n    void vigenereEncryptTest() {\n        // given\n        String text = \"Hello World!\";\n        String key = \"suchsecret\";\n\n        // when\n        String cipherText = vigenere.encrypt(text, key);\n\n        // then\n        assertEquals(\"Zynsg Yfvev!\", cipherText);\n    }\n\n    @Test\n    void vigenereDecryptTest() {\n        // given\n        String encryptedText = \"Zynsg Yfvev!\";\n        String key = \"suchsecret\";\n\n        // when\n        String decryptedText = vigenere.decrypt(encryptedText, key);\n\n        // then\n        assertEquals(\"Hello World!\", decryptedText);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/conversions/DecimalToBinary.java",
        "test_file_path": "src/test/java/com/thealgorithms/conversions/HexaDecimalToBinaryTest.java",
        "product_old_content": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\n/**\n * This class converts a Decimal number to a Binary number\n */\nclass DecimalToBinary {\n\n    /**\n     * Main Method\n     *\n     * @param args Command Line Arguments\n     */\n    public static void main(String[] args) {\n        conventionalConversion();\n        bitwiseConversion();\n    }\n\n    /**\n     * This method converts a decimal number to a binary number using a\n     * conventional algorithm.\n     */\n    public static void conventionalConversion() {\n        int n, b = 0, c = 0, d;\n        Scanner input = new Scanner(System.in);\n        System.out.printf(\n            \"Conventional conversion.%n Enter the decimal number: \"\n        );\n        n = input.nextInt();\n        while (n != 0) {\n            d = n % 2;\n            b = b + d * (int) Math.pow(10, c++);\n            n /= 2;\n        } // converting decimal to binary\n        System.out.println(\"\\tBinary number: \" + b);\n        input.close();\n    }\n\n    /**\n     * This method converts a decimal number to a binary number using a bitwise\n     * algorithm\n     */\n    public static void bitwiseConversion() {\n        int n, b = 0, c = 0, d;\n        Scanner input = new Scanner(System.in);\n        System.out.printf(\"Bitwise conversion.%n Enter the decimal number: \");\n        n = input.nextInt();\n        while (n != 0) {\n            d = (n & 1);\n            b += d * (int) Math.pow(10, c++);\n            n >>= 1;\n        }\n        System.out.println(\"\\tBinary number: \" + b);\n        input.close();\n    }\n}",
        "product_new_content": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\n/**\n * This class converts a Decimal number to a Binary number\n */\nclass DecimalToBinary {\n\n    /**\n     * Main Method\n     *\n     * @param args Command Line Arguments\n     */\n    public static void main(String[] args) {\n        conventionalConversion();\n        bitwiseConversion();\n    }\n\n    /**\n     * This method converts a decimal number to a binary number using a\n     * conventional algorithm.\n     */\n    public static void conventionalConversion() {\n        int n, b = 0, c = 0, d;\n        Scanner input = new Scanner(System.in);\n        System.out.printf(\"Conventional conversion.%n Enter the decimal number: \");\n        n = input.nextInt();\n        while (n != 0) {\n            d = n % 2;\n            b = b + d * (int) Math.pow(10, c++);\n            n /= 2;\n        } // converting decimal to binary\n        System.out.println(\"\\tBinary number: \" + b);\n        input.close();\n    }\n\n    /**\n     * This method converts a decimal number to a binary number using a bitwise\n     * algorithm\n     */\n    public static void bitwiseConversion() {\n        int n, b = 0, c = 0, d;\n        Scanner input = new Scanner(System.in);\n        System.out.printf(\"Bitwise conversion.%n Enter the decimal number: \");\n        n = input.nextInt();\n        while (n != 0) {\n            d = (n & 1);\n            b += d * (int) Math.pow(10, c++);\n            n >>= 1;\n        }\n        System.out.println(\"\\tBinary number: \" + b);\n        input.close();\n    }\n}",
        "test_old_content": "package com.thealgorithms.conversions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HexaDecimalToBinaryTest {\n\n    @Test\n    public void testHexaDecimalToBinary(){\n        HexaDecimalToBinary hexaDecimalToBinary = new HexaDecimalToBinary();\n        assertEquals(\"1111111111111111111111111111111\", hexaDecimalToBinary.convert(\"7fffffff\"));\n        assertEquals(\"101010111100110111101111\", hexaDecimalToBinary.convert(\"abcdef\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.conversions;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HexaDecimalToBinaryTest {\n\n    @Test\n    public void testHexaDecimalToBinary() {\n        HexaDecimalToBinary hexaDecimalToBinary = new HexaDecimalToBinary();\n        assertEquals(\"1111111111111111111111111111111\", hexaDecimalToBinary.convert(\"7fffffff\"));\n        assertEquals(\"101010111100110111101111\", hexaDecimalToBinary.convert(\"abcdef\"));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/buffers/CircularBuffer.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/buffers/CircularBufferTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.buffers;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CircularBuffer<Item> {\n    private final Item[] buffer;\n    private final CircularPointer putPointer;\n    private final CircularPointer getPointer;\n    private final AtomicInteger size = new AtomicInteger(0);\n\n    public CircularBuffer(int size) {\n        //noinspection unchecked\n        this.buffer = (Item[]) new Object[size];\n        this.putPointer = new CircularPointer(0, size);\n        this.getPointer = new CircularPointer(0, size);\n    }\n\n    public boolean isEmpty() {\n        return size.get() == 0;\n    }\n\n    public boolean isFull() {\n        return size.get() == buffer.length;\n    }\n\n    public Item get() {\n        if (isEmpty())\n            return null;\n\n        Item item = buffer[getPointer.getAndIncrement()];\n        size.decrementAndGet();\n        return item;\n    }\n\n    public boolean put(Item item) {\n        if (isFull())\n            return false;\n\n        buffer[putPointer.getAndIncrement()] = item;\n        size.incrementAndGet();\n        return true;\n    }\n\n    private static class CircularPointer {\n        private int pointer;\n        private final int max;\n\n        public CircularPointer(int pointer, int max) {\n            this.pointer = pointer;\n            this.max = max;\n        }\n\n        public int getAndIncrement() {\n            if (pointer == max)\n                pointer = 0;\n            int tmp = pointer;\n            pointer++;\n            return tmp;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.buffers;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CircularBuffer<Item> {\n    private final Item[] buffer;\n    private final CircularPointer putPointer;\n    private final CircularPointer getPointer;\n    private final AtomicInteger size = new AtomicInteger(0);\n\n    public CircularBuffer(int size) {\n        // noinspection unchecked\n        this.buffer = (Item[]) new Object[size];\n        this.putPointer = new CircularPointer(0, size);\n        this.getPointer = new CircularPointer(0, size);\n    }\n\n    public boolean isEmpty() {\n        return size.get() == 0;\n    }\n\n    public boolean isFull() {\n        return size.get() == buffer.length;\n    }\n\n    public Item get() {\n        if (isEmpty()) return null;\n\n        Item item = buffer[getPointer.getAndIncrement()];\n        size.decrementAndGet();\n        return item;\n    }\n\n    public boolean put(Item item) {\n        if (isFull()) return false;\n\n        buffer[putPointer.getAndIncrement()] = item;\n        size.incrementAndGet();\n        return true;\n    }\n\n    private static class CircularPointer {\n        private int pointer;\n        private final int max;\n\n        public CircularPointer(int pointer, int max) {\n            this.pointer = pointer;\n            this.max = max;\n        }\n\n        public int getAndIncrement() {\n            if (pointer == max) pointer = 0;\n            int tmp = pointer;\n            pointer++;\n            return tmp;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.buffers;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CircularBufferTest {\n    private static final int BUFFER_SIZE = 10;\n    private CircularBuffer<Integer> buffer;\n\n    @BeforeEach\n    void setUp() {\n        buffer = new CircularBuffer<>(BUFFER_SIZE);\n    }\n\n    @Test\n    void isEmpty() {\n        assertTrue(buffer.isEmpty());\n        buffer.put(generateInt());\n        assertFalse(buffer.isEmpty());\n    }\n\n    @Test\n    void isFull() {\n        assertFalse(buffer.isFull());\n        buffer.put(generateInt());\n        assertFalse(buffer.isFull());\n\n        for (int i = 1; i < BUFFER_SIZE; i++)\n            buffer.put(generateInt());\n        assertTrue(buffer.isFull());\n    }\n\n    @Test\n    void get() {\n        assertNull(buffer.get());\n        for (int i = 0; i < 100; i++)\n            buffer.put(i);\n        for (int i = 0; i < BUFFER_SIZE; i++)\n            assertEquals(i, buffer.get());\n        assertNull(buffer.get());\n    }\n\n    @Test\n    void put() {\n        for (int i = 0; i < BUFFER_SIZE; i++)\n            assertTrue(buffer.put(generateInt()));\n        assertFalse(buffer.put(generateInt()));\n    }\n\n    @RepeatedTest(1000)\n    void concurrentTest() throws InterruptedException {\n        final int numberOfThreadsForProducers = 3;\n        final int numberOfThreadsForConsumers = 2;\n        final int numberOfItems = 300;\n        final CountDownLatch producerCountDownLatch = new CountDownLatch(numberOfItems);\n        final CountDownLatch consumerCountDownLatch = new CountDownLatch(numberOfItems);\n        final AtomicIntegerArray resultAtomicArray = new AtomicIntegerArray(numberOfItems);\n\n        // We are running 2 ExecutorService simultaneously 1 - producer, 2 - consumer\n        // Run producer threads to populate buffer.\n        ExecutorService putExecutors = Executors.newFixedThreadPool(numberOfThreadsForProducers);\n        putExecutors.execute(() -> {\n            while (producerCountDownLatch.getCount() > 0) {\n                int count = (int) producerCountDownLatch.getCount();\n                boolean put = buffer.put(count);\n                while (!put) put = buffer.put(count);\n                producerCountDownLatch.countDown();\n            }\n        });\n\n        // Run consumer threads to retrieve the data from buffer.\n        ExecutorService getExecutors = Executors.newFixedThreadPool(numberOfThreadsForConsumers);\n        getExecutors.execute(() -> {\n            while (consumerCountDownLatch.getCount() > 0) {\n                int count = (int) consumerCountDownLatch.getCount();\n                Integer item = buffer.get();\n                while (item == null) item = buffer.get();\n                resultAtomicArray.set(count - 1, item);\n                consumerCountDownLatch.countDown();\n            }\n        });\n\n        producerCountDownLatch.await();\n        consumerCountDownLatch.await();\n        putExecutors.shutdown();\n        getExecutors.shutdown();\n        shutDownExecutorSafely(putExecutors);\n        shutDownExecutorSafely(getExecutors);\n\n        List<Integer> resultArray = getSortedListFrom(resultAtomicArray);\n        for (int i = 0; i < numberOfItems; i++) {\n            int expectedItem = i + 1;\n            assertEquals(expectedItem, resultArray.get(i));\n        }\n    }\n\n    private int generateInt() {\n        return ThreadLocalRandom.current().nextInt(0, 100);\n    }\n\n    private void shutDownExecutorSafely(ExecutorService executorService) {\n        try {\n            if (!executorService.awaitTermination(1_000, TimeUnit.MILLISECONDS))\n                executorService.shutdownNow();\n        } catch (InterruptedException e) {\n            executorService.shutdownNow();\n        }\n    }\n\n    public List<Integer> getSortedListFrom(AtomicIntegerArray atomicArray) {\n        int length = atomicArray.length();\n        ArrayList<Integer> result = new ArrayList<>(length);\n        for (int i = 0; i < length; i++)\n            result.add(atomicArray.get(i));\n        result.sort(Comparator.comparingInt(o -> o));\n        return result;\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.buffers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\n\nclass CircularBufferTest {\n    private static final int BUFFER_SIZE = 10;\n    private CircularBuffer<Integer> buffer;\n\n    @BeforeEach\n    void setUp() {\n        buffer = new CircularBuffer<>(BUFFER_SIZE);\n    }\n\n    @Test\n    void isEmpty() {\n        assertTrue(buffer.isEmpty());\n        buffer.put(generateInt());\n        assertFalse(buffer.isEmpty());\n    }\n\n    @Test\n    void isFull() {\n        assertFalse(buffer.isFull());\n        buffer.put(generateInt());\n        assertFalse(buffer.isFull());\n\n        for (int i = 1; i < BUFFER_SIZE; i++) buffer.put(generateInt());\n        assertTrue(buffer.isFull());\n    }\n\n    @Test\n    void get() {\n        assertNull(buffer.get());\n        for (int i = 0; i < 100; i++) buffer.put(i);\n        for (int i = 0; i < BUFFER_SIZE; i++) assertEquals(i, buffer.get());\n        assertNull(buffer.get());\n    }\n\n    @Test\n    void put() {\n        for (int i = 0; i < BUFFER_SIZE; i++) assertTrue(buffer.put(generateInt()));\n        assertFalse(buffer.put(generateInt()));\n    }\n\n    @RepeatedTest(1000)\n    void concurrentTest() throws InterruptedException {\n        final int numberOfThreadsForProducers = 3;\n        final int numberOfThreadsForConsumers = 2;\n        final int numberOfItems = 300;\n        final CountDownLatch producerCountDownLatch = new CountDownLatch(numberOfItems);\n        final CountDownLatch consumerCountDownLatch = new CountDownLatch(numberOfItems);\n        final AtomicIntegerArray resultAtomicArray = new AtomicIntegerArray(numberOfItems);\n\n        // We are running 2 ExecutorService simultaneously 1 - producer, 2 - consumer\n        // Run producer threads to populate buffer.\n        ExecutorService putExecutors = Executors.newFixedThreadPool(numberOfThreadsForProducers);\n        putExecutors.execute(() -> {\n            while (producerCountDownLatch.getCount() > 0) {\n                int count = (int) producerCountDownLatch.getCount();\n                boolean put = buffer.put(count);\n                while (!put) put = buffer.put(count);\n                producerCountDownLatch.countDown();\n            }\n        });\n\n        // Run consumer threads to retrieve the data from buffer.\n        ExecutorService getExecutors = Executors.newFixedThreadPool(numberOfThreadsForConsumers);\n        getExecutors.execute(() -> {\n            while (consumerCountDownLatch.getCount() > 0) {\n                int count = (int) consumerCountDownLatch.getCount();\n                Integer item = buffer.get();\n                while (item == null) item = buffer.get();\n                resultAtomicArray.set(count - 1, item);\n                consumerCountDownLatch.countDown();\n            }\n        });\n\n        producerCountDownLatch.await();\n        consumerCountDownLatch.await();\n        putExecutors.shutdown();\n        getExecutors.shutdown();\n        shutDownExecutorSafely(putExecutors);\n        shutDownExecutorSafely(getExecutors);\n\n        List<Integer> resultArray = getSortedListFrom(resultAtomicArray);\n        for (int i = 0; i < numberOfItems; i++) {\n            int expectedItem = i + 1;\n            assertEquals(expectedItem, resultArray.get(i));\n        }\n    }\n\n    private int generateInt() {\n        return ThreadLocalRandom.current().nextInt(0, 100);\n    }\n\n    private void shutDownExecutorSafely(ExecutorService executorService) {\n        try {\n            if (!executorService.awaitTermination(1_000, TimeUnit.MILLISECONDS))\n                executorService.shutdownNow();\n        } catch (InterruptedException e) {\n            executorService.shutdownNow();\n        }\n    }\n\n    public List<Integer> getSortedListFrom(AtomicIntegerArray atomicArray) {\n        int length = atomicArray.length();\n        ArrayList<Integer> result = new ArrayList<>(length);\n        for (int i = 0; i < length; i++) result.add(atomicArray.get(i));\n        result.sort(Comparator.comparingInt(o -> o));\n        return result;\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/LFUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/LFUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Java program for LFU Cache (https://en.wikipedia.org/wiki/Least_frequently_used)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class LFUCache<K, V> {\n\n    private class Node {\n\n        private K key;\n        private V value;\n        private int frequency;\n        private Node previous;\n        private Node next;\n\n        public Node(K key, V value, int frequency) {\n            this.key = key;\n            this.value = value;\n            this.frequency = frequency;\n        }\n    }\n\n    private Node head;\n    private Node tail;\n    private Map<K, Node> map = null;\n    private Integer capacity;\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public LFUCache() {\n        this.capacity = DEFAULT_CAPACITY;\n    }\n\n    public LFUCache(Integer capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>();\n    }\n\n    /**\n     * This method returns value present in the cache corresponding to the key passed as parameter\n     *\n     * @param <K> key for which value is to be retrieved\n     * @returns <V> object corresponding to the key passed as parameter, returns null if <K> key is not present in the cache\n     */\n    public V get(K key) {\n        if (this.map.get(key) == null) {\n            return null;\n        }\n\n        Node node = map.get(key);\n        removeNode(node);\n        node.frequency += 1;\n        addNodeWithUpdatedFrequency(node);\n\n        return node.value;\n    }\n\n    /**\n     * This method stores <K> key and <V> value in the cache\n     *\n     * @param <K> key which is to be stored in the cache\n     * @param <V> value which is to be stored in the cache\n     */\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            node.frequency += 1;\n            removeNode(node);\n            addNodeWithUpdatedFrequency(node);\n        } else {\n            if (map.size() >= capacity) {\n                map.remove(this.head.key);\n                removeNode(head);\n            }\n            Node node = new Node(key, value, 1);\n            addNodeWithUpdatedFrequency(node);\n            map.put(key, node);\n        }\n    }\n\n    /**\n     * This method stores the node in the cache with updated frequency\n     *\n     * @param Node node which is to be updated in the cache\n     */\n    private void addNodeWithUpdatedFrequency(Node node) {\n        if (tail != null && head != null) {\n            Node temp = this.head;\n            while (temp != null) {\n                if (temp.frequency > node.frequency) {\n                    if (temp == head) {\n                        node.next = temp;\n                        temp.previous = node;\n                        this.head = node;\n                        break;\n                    } else {\n                        node.next = temp;\n                        node.previous = temp.previous;\n                        temp.previous.next = node;\n                        temp.previous = node;\n                        break;\n                    }\n                } else {\n                    temp = temp.next;\n                    if (temp == null) {\n                        tail.next = node;\n                        node.previous = tail;\n                        node.next = null;\n                        tail = node;\n                        break;\n                    }\n                }\n            }\n        } else {\n            tail = node;\n            head = tail;\n        }\n    }\n\n    /**\n     * This method removes node from the cache\n     *\n     * @param Node node which is to be removed in the cache\n     */\n    private void removeNode(Node node) {\n        if (node.previous != null) {\n            node.previous.next = node.next;\n        } else {\n            this.head = node.next;\n        }\n\n        if (node.next != null) {\n            node.next.previous = node.previous;\n        } else {\n            this.tail = node.previous;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Java program for LFU Cache (https://en.wikipedia.org/wiki/Least_frequently_used)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class LFUCache<K, V> {\n\n    private class Node {\n\n        private K key;\n        private V value;\n        private int frequency;\n        private Node previous;\n        private Node next;\n\n        public Node(K key, V value, int frequency) {\n            this.key = key;\n            this.value = value;\n            this.frequency = frequency;\n        }\n    }\n\n    private Node head;\n    private Node tail;\n    private Map<K, Node> map = null;\n    private Integer capacity;\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public LFUCache() {\n        this.capacity = DEFAULT_CAPACITY;\n    }\n\n    public LFUCache(Integer capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>();\n    }\n\n    /**\n     * This method returns value present in the cache corresponding to the key passed as parameter\n     *\n     * @param <K> key for which value is to be retrieved\n     * @returns <V> object corresponding to the key passed as parameter, returns null if <K> key is\n     *     not present in the cache\n     */\n    public V get(K key) {\n        if (this.map.get(key) == null) {\n            return null;\n        }\n\n        Node node = map.get(key);\n        removeNode(node);\n        node.frequency += 1;\n        addNodeWithUpdatedFrequency(node);\n\n        return node.value;\n    }\n\n    /**\n     * This method stores <K> key and <V> value in the cache\n     *\n     * @param <K> key which is to be stored in the cache\n     * @param <V> value which is to be stored in the cache\n     */\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            node.frequency += 1;\n            removeNode(node);\n            addNodeWithUpdatedFrequency(node);\n        } else {\n            if (map.size() >= capacity) {\n                map.remove(this.head.key);\n                removeNode(head);\n            }\n            Node node = new Node(key, value, 1);\n            addNodeWithUpdatedFrequency(node);\n            map.put(key, node);\n        }\n    }\n\n    /**\n     * This method stores the node in the cache with updated frequency\n     *\n     * @param Node node which is to be updated in the cache\n     */\n    private void addNodeWithUpdatedFrequency(Node node) {\n        if (tail != null && head != null) {\n            Node temp = this.head;\n            while (temp != null) {\n                if (temp.frequency > node.frequency) {\n                    if (temp == head) {\n                        node.next = temp;\n                        temp.previous = node;\n                        this.head = node;\n                        break;\n                    } else {\n                        node.next = temp;\n                        node.previous = temp.previous;\n                        temp.previous.next = node;\n                        temp.previous = node;\n                        break;\n                    }\n                } else {\n                    temp = temp.next;\n                    if (temp == null) {\n                        tail.next = node;\n                        node.previous = tail;\n                        node.next = null;\n                        tail = node;\n                        break;\n                    }\n                }\n            }\n        } else {\n            tail = node;\n            head = tail;\n        }\n    }\n\n    /**\n     * This method removes node from the cache\n     *\n     * @param Node node which is to be removed in the cache\n     */\n    private void removeNode(Node node) {\n        if (node.previous != null) {\n            node.previous.next = node.next;\n        } else {\n            this.head = node.next;\n        }\n\n        if (node.next != null) {\n            node.next.previous = node.previous;\n        } else {\n            this.tail = node.previous;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LFUCacheTest {\n\n    @Test\n    void testLFUCacheWithIntegerValueShouldPass() {\n        LFUCache<Integer, Integer> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, 10);\n        lfuCache.put(2, 20);\n        lfuCache.put(3, 30);\n        lfuCache.put(4, 40);\n        lfuCache.put(5, 50);\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(10, lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, 60);\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return 60\n        assertEquals(60, lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, 70);\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(70, lfuCache.get(7));\n    }\n\n    @Test\n    void testLFUCacheWithStringValueShouldPass() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, \"Alpha\");\n        lfuCache.put(2, \"Beta\");\n        lfuCache.put(3, \"Gamma\");\n        lfuCache.put(4, \"Delta\");\n        lfuCache.put(5, \"Eplison\");\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(\"Alpha\", lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, \"Digamma\");\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return string Digamma\n        assertEquals(\"Digamma\", lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, \"Zeta\");\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(\"Zeta\", lfuCache.get(7));\n    }\n\n    /**\n     * test addNodeWithUpdatedFrequency method\n     * @author yuluo\n     */\n    @Test\n    void testAddNodeWithUpdatedFrequency() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(3);\n        lfuCache.put(1, \"beijing\");\n        lfuCache.put(2, \"shanghai\");\n        lfuCache.put(3, \"gansu\");\n\n        assertEquals(\"beijing\", lfuCache.get(1));\n\n        lfuCache.put(1, \"shanxi\");\n\n        assertEquals(\"shanxi\", lfuCache.get(1));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LFUCacheTest {\n\n    @Test\n    void testLFUCacheWithIntegerValueShouldPass() {\n        LFUCache<Integer, Integer> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, 10);\n        lfuCache.put(2, 20);\n        lfuCache.put(3, 30);\n        lfuCache.put(4, 40);\n        lfuCache.put(5, 50);\n\n        // get method call will increase frequency of key 1 by 1\n        assertEquals(10, lfuCache.get(1));\n\n        // this operation will remove value with key as 2\n        lfuCache.put(6, 60);\n\n        // will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        // should return 60\n        assertEquals(60, lfuCache.get(6));\n\n        // this operation will remove value with key as 3\n        lfuCache.put(7, 70);\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(70, lfuCache.get(7));\n    }\n\n    @Test\n    void testLFUCacheWithStringValueShouldPass() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, \"Alpha\");\n        lfuCache.put(2, \"Beta\");\n        lfuCache.put(3, \"Gamma\");\n        lfuCache.put(4, \"Delta\");\n        lfuCache.put(5, \"Eplison\");\n\n        // get method call will increase frequency of key 1 by 1\n        assertEquals(\"Alpha\", lfuCache.get(1));\n\n        // this operation will remove value with key as 2\n        lfuCache.put(6, \"Digamma\");\n\n        // will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        // should return string Digamma\n        assertEquals(\"Digamma\", lfuCache.get(6));\n\n        // this operation will remove value with key as 3\n        lfuCache.put(7, \"Zeta\");\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(\"Zeta\", lfuCache.get(7));\n    }\n\n    /**\n     * test addNodeWithUpdatedFrequency method\n     * @author yuluo\n     */\n    @Test\n    void testAddNodeWithUpdatedFrequency() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(3);\n        lfuCache.put(1, \"beijing\");\n        lfuCache.put(2, \"shanghai\");\n        lfuCache.put(3, \"gansu\");\n\n        assertEquals(\"beijing\", lfuCache.get(1));\n\n        lfuCache.put(1, \"shanxi\");\n\n        assertEquals(\"shanxi\", lfuCache.get(1));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/HamiltonianCycle.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/HamiltonianCycleTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.graphs;\n\n/**\n * Java program for Hamiltonian Cycle (https://en.wikipedia.org/wiki/Hamiltonian_path)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class HamiltonianCycle {\n\n    private int V, pathCount;\n    private int[] cycle;\n    private int[][] graph;\n\n    /**\n     * Find hamiltonian cycle for given graph G(V,E)\n     * @param graph Adjacency matrix of a graph G(V, E)\n     * for which hamiltonian path is to be found\n     * @return Array containing hamiltonian cycle\n     * else returns 1D array with value -1.\n     */\n    public int[] findHamiltonianCycle(int[][] graph) {\n        this.V = graph.length;\n        this.cycle = new int[this.V + 1];\n\n        //Initialize path array with -1 value\n        for (int i = 0; i < this.cycle.length; i++) {\n            this.cycle[i] = -1;\n        }\n\n        this.graph = graph;\n\n        this.cycle[0] = 0;\n        this.pathCount = 1;\n        if (!isPathFound(0)) {\n            for (int i = 0; i < this.cycle.length; i++) {\n                this.cycle[i] = -1;\n            }\n        } else {\n            this.cycle[this.cycle.length - 1] = this.cycle[0];\n        }\n\n        return cycle;\n    }\n\n    /** function to find paths recursively\n     * Find paths recursively from given vertex\n     * @param vertex Vertex from which path is to be found\n     * @returns true if path is found false otherwise\n     */\n    public boolean isPathFound(int vertex) {\n        boolean isLastVertexConnectedToStart = this.graph[vertex][0] == 1 && this.pathCount == this.V;\n        if (isLastVertexConnectedToStart) {\n            return true;\n        }\n\n        /** all vertices selected but last vertex not linked to 0 **/\n        if (this.pathCount == this.V) {\n            return false;\n        }\n\n        for (int v = 0; v < this.V; v++) {\n            /** if connected **/\n            if (this.graph[vertex][v] == 1) {\n                /** add to path **/\n                this.cycle[this.pathCount++] = v;\n\n                /** remove connection **/\n                this.graph[vertex][v] = 0;\n                this.graph[v][vertex] = 0;\n\n                /** if vertex not already selected  solve recursively **/\n                if (!isPresent(v)) {\n                    return isPathFound(v);\n                }\n\n                /** restore connection **/\n                this.graph[vertex][v] = 1;\n                this.graph[v][vertex] = 1;\n\n                /** remove path **/\n                this.cycle[--this.pathCount] = -1;\n            }\n        }\n        return false;\n    }\n\n    /** function to check if path is already selected\n     * Check if path is already selected\n     * @param vertex Starting vertex\n     */\n    public boolean isPresent(int vertex) {\n        for (int i = 0; i < pathCount - 1; i++) {\n            if (cycle[i] == vertex) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\n/**\n * Java program for Hamiltonian Cycle (https://en.wikipedia.org/wiki/Hamiltonian_path)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class HamiltonianCycle {\n\n    private int V, pathCount;\n    private int[] cycle;\n    private int[][] graph;\n\n    /**\n     * Find hamiltonian cycle for given graph G(V,E)\n     * @param graph Adjacency matrix of a graph G(V, E)\n     * for which hamiltonian path is to be found\n     * @return Array containing hamiltonian cycle\n     * else returns 1D array with value -1.\n     */\n    public int[] findHamiltonianCycle(int[][] graph) {\n        this.V = graph.length;\n        this.cycle = new int[this.V + 1];\n\n        // Initialize path array with -1 value\n        for (int i = 0; i < this.cycle.length; i++) {\n            this.cycle[i] = -1;\n        }\n\n        this.graph = graph;\n\n        this.cycle[0] = 0;\n        this.pathCount = 1;\n        if (!isPathFound(0)) {\n            for (int i = 0; i < this.cycle.length; i++) {\n                this.cycle[i] = -1;\n            }\n        } else {\n            this.cycle[this.cycle.length - 1] = this.cycle[0];\n        }\n\n        return cycle;\n    }\n\n    /**\n     * function to find paths recursively\n     * Find paths recursively from given vertex\n     * @param vertex Vertex from which path is to be found\n     * @returns true if path is found false otherwise\n     */\n    public boolean isPathFound(int vertex) {\n        boolean isLastVertexConnectedToStart\n            = this.graph[vertex][0] == 1 && this.pathCount == this.V;\n        if (isLastVertexConnectedToStart) {\n            return true;\n        }\n\n        /** all vertices selected but last vertex not linked to 0 **/\n        if (this.pathCount == this.V) {\n            return false;\n        }\n\n        for (int v = 0; v < this.V; v++) {\n            /** if connected **/\n            if (this.graph[vertex][v] == 1) {\n                /** add to path **/\n                this.cycle[this.pathCount++] = v;\n\n                /** remove connection **/\n                this.graph[vertex][v] = 0;\n                this.graph[v][vertex] = 0;\n\n                /** if vertex not already selected  solve recursively **/\n                if (!isPresent(v)) {\n                    return isPathFound(v);\n                }\n\n                /** restore connection **/\n                this.graph[vertex][v] = 1;\n                this.graph[v][vertex] = 1;\n\n                /** remove path **/\n                this.cycle[--this.pathCount] = -1;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * function to check if path is already selected\n     * Check if path is already selected\n     * @param vertex Starting vertex\n     */\n    public boolean isPresent(int vertex) {\n        for (int i = 0; i < pathCount - 1; i++) {\n            if (cycle[i] == vertex) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HamiltonianCycleTest {\n\n    private HamiltonianCycle hamiltonianCycle = new HamiltonianCycle();\n\n    @Test\n    void testFindHamiltonianCycleShouldReturnHamiltonianCycle() {\n        int[] expectedArray = { 0, 1, 2, 4, 3, 0 };\n        int[][] inputArray = {\n            { 0, 1, 0, 1, 0 },\n            { 1, 0, 1, 1, 1 },\n            { 0, 1, 0, 0, 1 },\n            { 1, 1, 0, 0, 1 },\n            { 0, 1, 1, 1, 0 },\n        };\n\n        assertArrayEquals(\n            expectedArray,\n            hamiltonianCycle.findHamiltonianCycle(inputArray)\n        );\n    }\n\n    @Test\n    void testFindHamiltonianCycleShouldReturnInfinityArray() {\n        int[] expectedArray = { -1, -1, -1, -1, -1, -1 };\n\n        int[][] inputArray = {\n            { 0, 1, 0, 1, 0 },\n            { 1, 0, 1, 1, 1 },\n            { 0, 1, 0, 0, 1 },\n            { 1, 1, 0, 0, 0 },\n            { 0, 1, 1, 0, 0 },\n        };\n\n        assertArrayEquals(\n            expectedArray,\n            hamiltonianCycle.findHamiltonianCycle(inputArray)\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HamiltonianCycleTest {\n\n    private HamiltonianCycle hamiltonianCycle = new HamiltonianCycle();\n\n    @Test\n    void testFindHamiltonianCycleShouldReturnHamiltonianCycle() {\n        int[] expectedArray = {0, 1, 2, 4, 3, 0};\n        int[][] inputArray = {\n            {0, 1, 0, 1, 0},\n            {1, 0, 1, 1, 1},\n            {0, 1, 0, 0, 1},\n            {1, 1, 0, 0, 1},\n            {0, 1, 1, 1, 0},\n        };\n\n        assertArrayEquals(expectedArray, hamiltonianCycle.findHamiltonianCycle(inputArray));\n    }\n\n    @Test\n    void testFindHamiltonianCycleShouldReturnInfinityArray() {\n        int[] expectedArray = {-1, -1, -1, -1, -1, -1};\n\n        int[][] inputArray = {\n            {0, 1, 0, 1, 0},\n            {1, 0, 1, 1, 1},\n            {0, 1, 0, 0, 1},\n            {1, 1, 0, 0, 0},\n            {0, 1, 1, 0, 0},\n        };\n\n        assertArrayEquals(expectedArray, hamiltonianCycle.findHamiltonianCycle(inputArray));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/Kosaraju.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/KosarajuTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * Java program that implements Kosaraju Algorithm.\n * @author Shivanagouda S A (https://github.com/shivu2002a)\n * \n */\n\n/**\n * Kosaraju algorithm is a linear time algorithm to find the strongly connected components of a \n   directed graph, which, from here onwards will be referred by SCC. It leverages the fact that the transpose\n   graph (same graph with all the edges reversed) has exactly the same SCCs as the original graph.\n    \n * A graph is said to be strongly connected if every vertex is reachable from every other vertex. \n   The SCCs of a directed graph form a partition into subgraphs that are themselves strongly connected.\n   Single node is always a SCC.\n\n * Example:\n\n    0 <--- 2 -------> 3 -------- > 4 ---- > 7\n    |     ^                      | ^       ^\n    |    /                       |  \\     /\n    |   /                        |   \\   /\n    v  /                         v    \\ /\n    1                            5 --> 6 \n\n    For the above graph, the SCC list goes as follows:\n    0, 1, 2 \n    3\n    4, 5, 6\n    7\n    \n    We can also see that order of the nodes in an SCC doesn't matter since they are in cycle.\n\n {@summary}\n * Kosaraju Algorithm: \n    1. Perform DFS traversal of the graph. Push node to stack before returning. This gives edges sorted by lowest finish time.\n    2. Find the transpose graph by reversing the edges.\n    3. Pop nodes one by one from the stack and again to DFS on the modified graph.\n\n    The transpose graph of the above graph:\n     0 ---> 2 <------- 3 <------- 4 <------ 7\n    ^     /                      ^ \\       /\n    |    /                       |  \\     /\n    |   /                        |   \\   /\n    |  v                         |    v v\n    1                            5 <--- 6 \n\n    We can observe that this graph has the same SCC as that of original graph.\n\n */\n\npublic class Kosaraju {\n\n    // Sort edges according to lowest finish time\n    Stack<Integer> stack = new Stack<Integer>();\n\n    //Store each component\n    private List<Integer> scc = new ArrayList<>();\n\n    //All the strongly connected components\n    private List<List<Integer>> sccsList = new ArrayList<>();\n\n    /**\n     * \n     * @param v Node count\n     * @param list Adjacency list of graph\n     * @return List of SCCs\n     */\n    public List<List<Integer>> kosaraju(int v, List<List<Integer>> list){\n        \n        sortEdgesByLowestFinishTime(v, list);\n        \n        List<List<Integer>> transposeGraph = createTransposeMatrix(v, list);\n\n        findStronglyConnectedComponents(v, transposeGraph);\n        \n        return sccsList;\n    }\n\n    private void sortEdgesByLowestFinishTime(int v, List<List<Integer>> list){\n        int[] vis = new int[v];\n        for (int i = 0; i < v; i++) {\n            if(vis[i] == 0){\n                dfs(i, vis, list);\n            }\n        }\n    }\n\n    private List<List<Integer>> createTransposeMatrix(int v, List<List<Integer>> list) {\n        var transposeGraph = new ArrayList<List<Integer>>(v);\n        for (int i = 0; i < v; i++) {\n            transposeGraph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < v; i++) {\n            for (Integer neigh : list.get(i)) {\n                transposeGraph.get(neigh).add(i);\n            }\n        }\n        return transposeGraph;\n    }\n\n    /**\n     * \n     * @param v Node count\n     * @param transposeGraph Transpose of the given adjacency list\n     */\n    public void findStronglyConnectedComponents(int v, List<List<Integer>> transposeGraph){\n        int[] vis = new int[v];\n        while (!stack.isEmpty()) {\n            var node = stack.pop();\n            if(vis[node] == 0){\n                dfs2(node, vis, transposeGraph);\n                sccsList.add(scc);\n                scc = new ArrayList<>();\n            }\n        }\n    }\n\n    //Dfs to store the nodes in order of lowest finish time\n    private void dfs(int node, int[] vis, List<List<Integer>> list){\n        vis[node] = 1;\n        for(Integer neighbour : list.get(node)){\n            if(vis[neighbour] == 0)\n                dfs(neighbour, vis, list);\n        }\n        stack.push(node);\n    }\n\n    //Dfs to find all the nodes of each strongly connected component\n    private void dfs2(int node, int[] vis, List<List<Integer>> list){\n        vis[node] = 1;\n        for(Integer neighbour : list.get(node)){\n            if(vis[neighbour] == 0)\n                dfs2(neighbour, vis, list);\n        }\n        scc.add(node);\n    }\n    \n}",
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * Java program that implements Kosaraju Algorithm.\n * @author Shivanagouda S A (https://github.com/shivu2002a)\n *\n */\n\n/**\n * Kosaraju algorithm is a linear time algorithm to find the strongly connected components of a\n   directed graph, which, from here onwards will be referred by SCC. It leverages the fact that the\n transpose graph (same graph with all the edges reversed) has exactly the same SCCs as the original\n graph.\n\n * A graph is said to be strongly connected if every vertex is reachable from every other vertex.\n   The SCCs of a directed graph form a partition into subgraphs that are themselves strongly\n connected. Single node is always a SCC.\n\n * Example:\n\n    0 <--- 2 -------> 3 -------- > 4 ---- > 7\n    |     ^                      | ^       ^\n    |    /                       |  \\     /\n    |   /                        |   \\   /\n    v  /                         v    \\ /\n    1                            5 --> 6\n\n    For the above graph, the SCC list goes as follows:\n    0, 1, 2\n    3\n    4, 5, 6\n    7\n\n    We can also see that order of the nodes in an SCC doesn't matter since they are in cycle.\n\n {@summary}\n * Kosaraju Algorithm:\n    1. Perform DFS traversal of the graph. Push node to stack before returning. This gives edges\n sorted by lowest finish time.\n    2. Find the transpose graph by reversing the edges.\n    3. Pop nodes one by one from the stack and again to DFS on the modified graph.\n\n    The transpose graph of the above graph:\n     0 ---> 2 <------- 3 <------- 4 <------ 7\n    ^     /                      ^ \\       /\n    |    /                       |  \\     /\n    |   /                        |   \\   /\n    |  v                         |    v v\n    1                            5 <--- 6\n\n    We can observe that this graph has the same SCC as that of original graph.\n\n */\n\npublic class Kosaraju {\n\n    // Sort edges according to lowest finish time\n    Stack<Integer> stack = new Stack<Integer>();\n\n    // Store each component\n    private List<Integer> scc = new ArrayList<>();\n\n    // All the strongly connected components\n    private List<List<Integer>> sccsList = new ArrayList<>();\n\n    /**\n     *\n     * @param v Node count\n     * @param list Adjacency list of graph\n     * @return List of SCCs\n     */\n    public List<List<Integer>> kosaraju(int v, List<List<Integer>> list) {\n\n        sortEdgesByLowestFinishTime(v, list);\n\n        List<List<Integer>> transposeGraph = createTransposeMatrix(v, list);\n\n        findStronglyConnectedComponents(v, transposeGraph);\n\n        return sccsList;\n    }\n\n    private void sortEdgesByLowestFinishTime(int v, List<List<Integer>> list) {\n        int[] vis = new int[v];\n        for (int i = 0; i < v; i++) {\n            if (vis[i] == 0) {\n                dfs(i, vis, list);\n            }\n        }\n    }\n\n    private List<List<Integer>> createTransposeMatrix(int v, List<List<Integer>> list) {\n        var transposeGraph = new ArrayList<List<Integer>>(v);\n        for (int i = 0; i < v; i++) {\n            transposeGraph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < v; i++) {\n            for (Integer neigh : list.get(i)) {\n                transposeGraph.get(neigh).add(i);\n            }\n        }\n        return transposeGraph;\n    }\n\n    /**\n     *\n     * @param v Node count\n     * @param transposeGraph Transpose of the given adjacency list\n     */\n    public void findStronglyConnectedComponents(int v, List<List<Integer>> transposeGraph) {\n        int[] vis = new int[v];\n        while (!stack.isEmpty()) {\n            var node = stack.pop();\n            if (vis[node] == 0) {\n                dfs2(node, vis, transposeGraph);\n                sccsList.add(scc);\n                scc = new ArrayList<>();\n            }\n        }\n    }\n\n    // Dfs to store the nodes in order of lowest finish time\n    private void dfs(int node, int[] vis, List<List<Integer>> list) {\n        vis[node] = 1;\n        for (Integer neighbour : list.get(node)) {\n            if (vis[neighbour] == 0) dfs(neighbour, vis, list);\n        }\n        stack.push(node);\n    }\n\n    // Dfs to find all the nodes of each strongly connected component\n    private void dfs2(int node, int[] vis, List<List<Integer>> list) {\n        vis[node] = 1;\n        for (Integer neighbour : list.get(node)) {\n            if (vis[neighbour] == 0) dfs2(neighbour, vis, list);\n        }\n        scc.add(node);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KosarajuTest {\n\n    private Kosaraju kosaraju = new Kosaraju();\n\n    @Test\n    public void findStronglyConnectedComps() {\n        //Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(0);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(4).add(7);\n        adjList.get(5).add(6);\n        adjList.get(6).add(4);\n        adjList.get(6).add(7);\n\n        List<List<Integer>> actualResult = kosaraju.kosaraju(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result: \n            0, 1, 2\n            3\n            5, 4, 6 \n            7\n        */\n        expectedResult.add(Arrays.asList(1, 2, 0));\n        expectedResult.add(Arrays.asList(3));\n        expectedResult.add(Arrays.asList(5, 6, 4));\n        expectedResult.add(Arrays.asList(7));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n    @Test\n    public void findStronglyConnectedCompsShouldGetSingleNodes() {\n        //Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(5).add(6);\n        adjList.get(6).add(7);\n        adjList.get(7).add(0);\n\n        List<List<Integer>> actualResult = kosaraju.kosaraju(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result: \n            0, 1, 2, 3, 4, 5, 6, 7\n        */\n        expectedResult.add(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class KosarajuTest {\n\n    private Kosaraju kosaraju = new Kosaraju();\n\n    @Test\n    public void findStronglyConnectedComps() {\n        // Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(0);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(4).add(7);\n        adjList.get(5).add(6);\n        adjList.get(6).add(4);\n        adjList.get(6).add(7);\n\n        List<List<Integer>> actualResult = kosaraju.kosaraju(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result:\n            0, 1, 2\n            3\n            5, 4, 6\n            7\n        */\n        expectedResult.add(Arrays.asList(1, 2, 0));\n        expectedResult.add(Arrays.asList(3));\n        expectedResult.add(Arrays.asList(5, 6, 4));\n        expectedResult.add(Arrays.asList(7));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n    @Test\n    public void findStronglyConnectedCompsShouldGetSingleNodes() {\n        // Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(5).add(6);\n        adjList.get(6).add(7);\n        adjList.get(7).add(0);\n\n        List<List<Integer>> actualResult = kosaraju.kosaraju(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result:\n            0, 1, 2, 3, 4, 5, 6, 7\n        */\n        expectedResult.add(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithm.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithmTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * Java program that implements Tarjan's Algorithm.\n * @author Shivanagouda S A (https://github.com/shivu2002a)\n * \n */\n\n/**\n * Tarjan's algorithm is a linear time algorithm to find the strongly connected components of a \n   directed graph, which, from here onwards will be referred as SCC. \n    \n * A graph is said to be strongly connected if every vertex is reachable from every other vertex. \n   The SCCs of a directed graph form a partition into subgraphs that are themselves strongly connected.\n   Single node is always a SCC.\n\n * Example:\n    0 --------> 1 -------> 3 --------> 4\n    ^          /\n    |         /\n    |        /\n    |       /\n    |      /\n    |     /\n    |    /\n    |   /\n    |  /\n    | /\n    |V\n    2\n\n    For the above graph, the SCC list goes as follows:\n    1, 2, 0\n    3\n    4\n    \n    We can also see that order of the nodes in an SCC doesn't matter since they are in cycle.\n\n {@summary}\n    Tarjan's Algorithm: \n    * DFS search produces a DFS tree \n    * Strongly Connected Components form subtrees of the DFS tree. \n    * If we can find the head of these subtrees, we can get all the nodes in that subtree (including the head)\n      and that will be one SCC. \n    * There is no back edge from one SCC to another (here can be cross edges, but they will not be used).\n\n    * Kosaraju Algorithm aims at doing the same but uses two DFS traversalse whereas Tarjan\u2019s algorithm does \n      the same in a single DFS, which leads to much lower constant factors in the latter.\n\n */\npublic class TarjansAlgorithm {\n\n    //Timer for tracking lowtime and insertion time\n    private int Time;\n\n    private List<List<Integer>> SCClist = new ArrayList<List<Integer>>();\n\n    public List<List<Integer>> stronglyConnectedComponents(int V, List<List<Integer>> graph) {\n\n        // Initially all vertices as unvisited, insertion and low time are undefined\n\n        // insertionTime:Time when a node is visited 1st time while DFS traversal\n\n        // lowTime: indicates the earliest visited vertex (the vertex with minimum insertion time) that can \n        // be reached from a subtree rooted with a particular node.\n        int[] lowTime = new int[V];\n        int[] insertionTime = new int[V];\n        for (int i = 0; i < V; i++) {\n            insertionTime[i] = -1;\n            lowTime[i] = -1;\n        }\n        \n        // To check if element is present in stack\n        boolean[] isInStack = new boolean[V];\n\n        // Store nodes during DFS\n        Stack<Integer> st = new Stack<Integer>();\n\n        for (int i = 0; i < V; i++) {\n            if (insertionTime[i] == -1)\n                stronglyConnCompsUtil(i, lowTime, insertionTime, isInStack, st, graph);\n        }\n\n        return SCClist;\n    }\n\n    private void stronglyConnCompsUtil(int u, int[] lowTime, int[] insertionTime,\n                                       boolean[] isInStack, Stack<Integer> st, List<List<Integer>> graph) {\n\n        // Initialize insertion time and lowTime value of current node\n        insertionTime[u] = Time;\n        lowTime[u] = Time;\n        Time += 1;\n\n        //Push current node into stack\n        isInStack[u] = true;\n        st.push(u);\n\n        // Go through all vertices adjacent to this\n        for (Integer vertex : graph.get(u)) {\n            //If the adjacent node is unvisited, do DFS\n            if (insertionTime[vertex] == -1) {\n                stronglyConnCompsUtil(vertex, lowTime, insertionTime, isInStack, st, graph);\n                //update lowTime for the current node comparing lowtime of adj node\n                lowTime[u] = Math.min(lowTime[u], lowTime[vertex]);\n            } else if (isInStack[vertex]) {\n                //If adj node is in stack, update low \n                lowTime[u] = Math.min(lowTime[u], insertionTime[vertex]);\n            }\n        }\n        //If lowtime and insertion time are same, current node is the head of an SCC\n        // head node found, get all the nodes in this SCC\n        if (lowTime[u] == insertionTime[u]) {\n            int w = -1;\n            var scc = new ArrayList<Integer>();\n\n            //Stack has all the nodes of the current SCC\n            while (w != u) {\n                w = st.pop();\n                scc.add(w);\n                isInStack[w] = false;\n            }\n            SCClist.add(scc);\n        }\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * Java program that implements Tarjan's Algorithm.\n * @author Shivanagouda S A (https://github.com/shivu2002a)\n *\n */\n\n/**\n * Tarjan's algorithm is a linear time algorithm to find the strongly connected components of a\n   directed graph, which, from here onwards will be referred as SCC.\n\n * A graph is said to be strongly connected if every vertex is reachable from every other vertex.\n   The SCCs of a directed graph form a partition into subgraphs that are themselves strongly\n connected. Single node is always a SCC.\n\n * Example:\n    0 --------> 1 -------> 3 --------> 4\n    ^          /\n    |         /\n    |        /\n    |       /\n    |      /\n    |     /\n    |    /\n    |   /\n    |  /\n    | /\n    |V\n    2\n\n    For the above graph, the SCC list goes as follows:\n    1, 2, 0\n    3\n    4\n\n    We can also see that order of the nodes in an SCC doesn't matter since they are in cycle.\n\n {@summary}\n    Tarjan's Algorithm:\n    * DFS search produces a DFS tree\n    * Strongly Connected Components form subtrees of the DFS tree.\n    * If we can find the head of these subtrees, we can get all the nodes in that subtree (including\n the head) and that will be one SCC.\n    * There is no back edge from one SCC to another (here can be cross edges, but they will not be\n used).\n\n    * Kosaraju Algorithm aims at doing the same but uses two DFS traversalse whereas Tarjan\u2019s\n algorithm does the same in a single DFS, which leads to much lower constant factors in the latter.\n\n */\npublic class TarjansAlgorithm {\n\n    // Timer for tracking lowtime and insertion time\n    private int Time;\n\n    private List<List<Integer>> SCClist = new ArrayList<List<Integer>>();\n\n    public List<List<Integer>> stronglyConnectedComponents(int V, List<List<Integer>> graph) {\n\n        // Initially all vertices as unvisited, insertion and low time are undefined\n\n        // insertionTime:Time when a node is visited 1st time while DFS traversal\n\n        // lowTime: indicates the earliest visited vertex (the vertex with minimum insertion time)\n        // that can be reached from a subtree rooted with a particular node.\n        int[] lowTime = new int[V];\n        int[] insertionTime = new int[V];\n        for (int i = 0; i < V; i++) {\n            insertionTime[i] = -1;\n            lowTime[i] = -1;\n        }\n\n        // To check if element is present in stack\n        boolean[] isInStack = new boolean[V];\n\n        // Store nodes during DFS\n        Stack<Integer> st = new Stack<Integer>();\n\n        for (int i = 0; i < V; i++) {\n            if (insertionTime[i] == -1)\n                stronglyConnCompsUtil(i, lowTime, insertionTime, isInStack, st, graph);\n        }\n\n        return SCClist;\n    }\n\n    private void stronglyConnCompsUtil(int u, int[] lowTime, int[] insertionTime,\n        boolean[] isInStack, Stack<Integer> st, List<List<Integer>> graph) {\n\n        // Initialize insertion time and lowTime value of current node\n        insertionTime[u] = Time;\n        lowTime[u] = Time;\n        Time += 1;\n\n        // Push current node into stack\n        isInStack[u] = true;\n        st.push(u);\n\n        // Go through all vertices adjacent to this\n        for (Integer vertex : graph.get(u)) {\n            // If the adjacent node is unvisited, do DFS\n            if (insertionTime[vertex] == -1) {\n                stronglyConnCompsUtil(vertex, lowTime, insertionTime, isInStack, st, graph);\n                // update lowTime for the current node comparing lowtime of adj node\n                lowTime[u] = Math.min(lowTime[u], lowTime[vertex]);\n            } else if (isInStack[vertex]) {\n                // If adj node is in stack, update low\n                lowTime[u] = Math.min(lowTime[u], insertionTime[vertex]);\n            }\n        }\n        // If lowtime and insertion time are same, current node is the head of an SCC\n        //  head node found, get all the nodes in this SCC\n        if (lowTime[u] == insertionTime[u]) {\n            int w = -1;\n            var scc = new ArrayList<Integer>();\n\n            // Stack has all the nodes of the current SCC\n            while (w != u) {\n                w = st.pop();\n                scc.add(w);\n                isInStack[w] = false;\n            }\n            SCClist.add(scc);\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class TarjansAlgorithmTest {\n    \n    TarjansAlgorithm tarjansAlgo = new TarjansAlgorithm();\n\n    @Test\n    public void findStronglyConnectedComps(){\n        var v = 5;\n        var graph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < v; i++) {\n            graph.add(new ArrayList<>());\n        }\n        graph.get(0).add(1);\n        graph.get(1).add(2);\n        graph.get(2).add(0);\n        graph.get(1).add(3);\n        graph.get(3).add(4);\n\n        var actualResult = tarjansAlgo.stronglyConnectedComponents(v, graph);\n        /*\n            Expected result: \n            0, 1, 2\n            3\n            4 \n        */\n        List<List<Integer>> expectedResult = new ArrayList<>();\n\n        expectedResult.add(Arrays.asList(4));\n        expectedResult.add(Arrays.asList(3));\n        expectedResult.add(Arrays.asList(2, 1, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n    @Test\n    public void findStronglyConnectedCompsShouldGetSingleNodes() {\n        //Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(5).add(6);\n        adjList.get(6).add(7);\n        adjList.get(7).add(0);\n\n        List<List<Integer>> actualResult = tarjansAlgo.stronglyConnectedComponents(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result: \n            7, 6, 5, 4, 3, 2, 1, 0\n        */\n        expectedResult.add(Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n    \n}",
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class TarjansAlgorithmTest {\n\n    TarjansAlgorithm tarjansAlgo = new TarjansAlgorithm();\n\n    @Test\n    public void findStronglyConnectedComps() {\n        var v = 5;\n        var graph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < v; i++) {\n            graph.add(new ArrayList<>());\n        }\n        graph.get(0).add(1);\n        graph.get(1).add(2);\n        graph.get(2).add(0);\n        graph.get(1).add(3);\n        graph.get(3).add(4);\n\n        var actualResult = tarjansAlgo.stronglyConnectedComponents(v, graph);\n        /*\n            Expected result:\n            0, 1, 2\n            3\n            4\n        */\n        List<List<Integer>> expectedResult = new ArrayList<>();\n\n        expectedResult.add(Arrays.asList(4));\n        expectedResult.add(Arrays.asList(3));\n        expectedResult.add(Arrays.asList(2, 1, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n    @Test\n    public void findStronglyConnectedCompsShouldGetSingleNodes() {\n        // Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(5).add(6);\n        adjList.get(6).add(7);\n        adjList.get(7).add(0);\n\n        List<List<Integer>> actualResult = tarjansAlgo.stronglyConnectedComponents(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result:\n            7, 6, 5, 4, 3, 2, 1, 0\n        */\n        expectedResult.add(Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElementTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\n/*\nThis class finds the majority element(s) in an array of integers.\nA majority element is an element that appears more than or equal to n/2 times, where n is the length of the array.\n*/\npublic class MajorityElement {\n      /*\n     This method returns the majority element(s) in the given array of integers.\n     @param nums: an array of integers\n     @return a list of majority elements\n     */\n    public static List<Integer> majority(int[] nums){\n        HashMap<Integer,Integer> numToCount  = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (numToCount.containsKey(nums[i])){\n                numToCount.put(nums[i],numToCount.get(nums[i])+1);\n            } else {\n                numToCount.put(nums[i],1);\n            }\n        }\n        List<Integer> majorityElements = new ArrayList<>();\n        for (int key: numToCount.keySet()) {\n            if (numToCount.get(key) >= n/2){\n                majorityElements.add(key);\n            }\n        }\n        return majorityElements;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n/*\nThis class finds the majority element(s) in an array of integers.\nA majority element is an element that appears more than or equal to n/2 times, where n is the length\nof the array.\n*/\npublic class MajorityElement {\n    /*\n   This method returns the majority element(s) in the given array of integers.\n   @param nums: an array of integers\n   @return a list of majority elements\n   */\n    public static List<Integer> majority(int[] nums) {\n        HashMap<Integer, Integer> numToCount = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (numToCount.containsKey(nums[i])) {\n                numToCount.put(nums[i], numToCount.get(nums[i]) + 1);\n            } else {\n                numToCount.put(nums[i], 1);\n            }\n        }\n        List<Integer> majorityElements = new ArrayList<>();\n        for (int key : numToCount.keySet()) {\n            if (numToCount.get(key) >= n / 2) {\n                majorityElements.add(key);\n            }\n        }\n        return majorityElements;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport com.thealgorithms.datastructures.hashmap.hashing.MajorityElement;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport java.util.ArrayList;\n\npublic class MajorityElementTest{\n    @Test\n    void testMajorityWithSingleMajorityElement() {\n        int[] nums = {1, 2, 3, 9, 9, 6, 7, 8, 9, 9, 9, 9};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(9);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithMultipleMajorityElements() {\n        int[] nums = {1, 2, 3, 3, 4, 4, 4, 4};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(4);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithNoMajorityElement() {\n        int[] nums = {1, 2, 4, 4, 5, 4};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(4);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithEmptyArray() {\n        int[] nums = {};\n        List<Integer> expected = Collections.emptyList(); \n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.datastructures.hashmap.hashing.MajorityElement;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class MajorityElementTest {\n    @Test\n    void testMajorityWithSingleMajorityElement() {\n        int[] nums = {1, 2, 3, 9, 9, 6, 7, 8, 9, 9, 9, 9};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(9);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithMultipleMajorityElements() {\n        int[] nums = {1, 2, 3, 3, 4, 4, 4, 4};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(4);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithNoMajorityElement() {\n        int[] nums = {1, 2, 4, 4, 5, 4};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(4);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithEmptyArray() {\n        int[] nums = {};\n        List<Integer> expected = Collections.emptyList();\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/hashmap/hashing/Map.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/hashmap/hashing/MapTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\npublic abstract class Map<Key, Value> {\n\n    abstract boolean put(Key key, Value value);\n\n    abstract Value get(Key key);\n\n    abstract boolean delete(Key key);\n\n    abstract Iterable<Key> keys();\n\n    abstract int size();\n\n    public boolean contains(Key key) {\n        return get(key) != null;\n    }\n\n    protected int hash(Key key, int size) {\n        return (key.hashCode() & Integer.MAX_VALUE) % size;\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\npublic abstract class Map<Key, Value> {\n\n    abstract boolean put(Key key, Value value);\n\n    abstract Value get(Key key);\n\n    abstract boolean delete(Key key);\n\n    abstract Iterable<Key> keys();\n\n    abstract int size();\n\n    public boolean contains(Key key) {\n        return get(key) != null;\n    }\n\n    protected int hash(Key key, int size) {\n        return (key.hashCode() & Integer.MAX_VALUE) % size;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Random;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nabstract class MapTest {\n    abstract <Key extends Comparable<Key>, Value> Map<Key, Value> getMap();\n\n    @Test\n    void putTest() {\n        Map<Integer, String> map = getMap();\n\n        assertFalse(map.put(null, \"-25\"));\n        assertFalse(map.put(null, null));\n        assertTrue(map.put(-25, \"-25\"));\n        assertTrue(map.put(33, \"33\"));\n        assertTrue(map.put(100, \"100\"));\n        assertTrue(map.put(100, \"+100\"));\n        assertTrue(map.put(100, null));\n    }\n\n    @Test\n    void getTest() {\n        Map<Integer, String> map = getMap();\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        for (int i = -100; i < 100; i++) {\n            assertEquals(map.get(i), String.valueOf(i));\n        }\n\n        for (int i = 100; i < 200; i++) {\n            assertNull(map.get(i));\n        }\n\n        assertNull(map.get(null));\n    }\n\n    @Test\n    void deleteTest() {\n        Map<Integer, String> map = getMap();\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        for (int i = 0; i < 100; i++) {\n            assertTrue(map.delete(i));\n        }\n\n        for (int i = 100; i < 200; i++) {\n            assertFalse(map.delete(i));\n        }\n\n        assertFalse(map.delete(null));\n    }\n\n    @Test\n    void containsTest() {\n        Map<Integer, String> map = getMap();\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        for (int i = -50; i < 50; i++) {\n            assertTrue(map.contains(i));\n        }\n\n        for (int i = 100; i < 200; i++) {\n            assertFalse(map.contains(i));\n        }\n\n        assertFalse(map.contains(null));\n    }\n\n    @Test\n    void sizeTest() {\n        Map<Integer, String> map = getMap();\n        assertEquals(map.size(), 0);\n\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        assertEquals(map.size(), 200);\n\n        for (int i = -50; i < 50; i++) {\n            map.delete(i);\n        }\n\n        assertEquals(map.size(), 100);\n    }\n\n    @Test\n    void keysTest() {\n        Map<Integer, String> map = getMap();\n        Iterable<Integer> keys = map.keys();\n        assertFalse(keys.iterator().hasNext());\n\n        for (int i = 100; i > -100; i--) {\n            map.put(i, String.valueOf(i));\n        }\n\n        keys = map.keys();\n        int i = -100;\n        for (Integer key : keys) {\n            assertEquals(key, ++i);\n        }\n    }\n\n    @Test\n    void hashTest() {\n        Map<Integer, String> map = getMap();\n        int testSize = 100;\n        Random random = new Random();\n        for (int i = 0; i < 1000; i++) {\n            int randomInt = random.nextInt();\n            int hashIndex = map.hash(randomInt, testSize);\n            int negateHashIndex = map.hash(-randomInt, testSize);\n            assertTrue(hashIndex >= 0);\n            assertTrue(hashIndex < testSize);\n            assertTrue(negateHashIndex >= 0);\n            assertTrue(negateHashIndex < testSize);\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Random;\nimport org.junit.jupiter.api.Test;\n\nabstract class MapTest {\n    abstract <Key extends Comparable<Key>, Value> Map<Key, Value> getMap();\n\n    @Test\n    void putTest() {\n        Map<Integer, String> map = getMap();\n\n        assertFalse(map.put(null, \"-25\"));\n        assertFalse(map.put(null, null));\n        assertTrue(map.put(-25, \"-25\"));\n        assertTrue(map.put(33, \"33\"));\n        assertTrue(map.put(100, \"100\"));\n        assertTrue(map.put(100, \"+100\"));\n        assertTrue(map.put(100, null));\n    }\n\n    @Test\n    void getTest() {\n        Map<Integer, String> map = getMap();\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        for (int i = -100; i < 100; i++) {\n            assertEquals(map.get(i), String.valueOf(i));\n        }\n\n        for (int i = 100; i < 200; i++) {\n            assertNull(map.get(i));\n        }\n\n        assertNull(map.get(null));\n    }\n\n    @Test\n    void deleteTest() {\n        Map<Integer, String> map = getMap();\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        for (int i = 0; i < 100; i++) {\n            assertTrue(map.delete(i));\n        }\n\n        for (int i = 100; i < 200; i++) {\n            assertFalse(map.delete(i));\n        }\n\n        assertFalse(map.delete(null));\n    }\n\n    @Test\n    void containsTest() {\n        Map<Integer, String> map = getMap();\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        for (int i = -50; i < 50; i++) {\n            assertTrue(map.contains(i));\n        }\n\n        for (int i = 100; i < 200; i++) {\n            assertFalse(map.contains(i));\n        }\n\n        assertFalse(map.contains(null));\n    }\n\n    @Test\n    void sizeTest() {\n        Map<Integer, String> map = getMap();\n        assertEquals(map.size(), 0);\n\n        for (int i = -100; i < 100; i++) {\n            map.put(i, String.valueOf(i));\n        }\n\n        assertEquals(map.size(), 200);\n\n        for (int i = -50; i < 50; i++) {\n            map.delete(i);\n        }\n\n        assertEquals(map.size(), 100);\n    }\n\n    @Test\n    void keysTest() {\n        Map<Integer, String> map = getMap();\n        Iterable<Integer> keys = map.keys();\n        assertFalse(keys.iterator().hasNext());\n\n        for (int i = 100; i > -100; i--) {\n            map.put(i, String.valueOf(i));\n        }\n\n        keys = map.keys();\n        int i = -100;\n        for (Integer key : keys) {\n            assertEquals(key, ++i);\n        }\n    }\n\n    @Test\n    void hashTest() {\n        Map<Integer, String> map = getMap();\n        int testSize = 100;\n        Random random = new Random();\n        for (int i = 0; i < 1000; i++) {\n            int randomInt = random.nextInt();\n            int hashIndex = map.hash(randomInt, testSize);\n            int negateHashIndex = map.hash(-randomInt, testSize);\n            assertTrue(hashIndex >= 0);\n            assertTrue(hashIndex < testSize);\n            assertTrue(negateHashIndex >= 0);\n            assertTrue(negateHashIndex < testSize);\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.heaps;\n\nimport java.util.ArrayList;\n\n/* \n * This is a leftist heap that follows the same operations as a\n * binary min heap, but may be unbalanced at times and follows a\n * leftist property, in which the left side is more heavy on the\n * right based on the null-path length (npl) values.\n * \n * Source: https://iq.opengenus.org/leftist-heap/\n * \n */\n\npublic class LeftistHeap {\n\tprivate class Node {\n\t\tprivate int element, npl;\n\t\tprivate Node left, right;\n\n\t\t// Node constructor setting the data element and left/right pointers to null\n\t\tprivate Node(int element) {\n\t\t\tthis.element = element;\n\t\t\tleft = right = null;\n\t\t\tnpl = 0;\n\t\t}\n\t}\n\n\tprivate Node root;\n\n\t// Constructor\n\tpublic LeftistHeap() {\n\t\troot = null;\n\t}\n\n\t// Checks if heap is empty\n\tpublic boolean isEmpty() {\n\t\treturn root == null;\n\t}\n\n\t// Resets structure to initial state\n\tpublic void clear() {\n\t\t// We will put head is null\n\t\troot = null;\n\t}\n\n\t// Merge function that merges the contents of another leftist heap with the\n\t// current one\n\tpublic void merge(LeftistHeap h1) {\n\t\t// If the present function is rhs then we ignore the merge\n\t\troot = merge(root, h1.root);\n\t\th1.root = null;\n\t}\n\n\t// Function merge with two Nodes a and b\n\tpublic Node merge(Node a, Node b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\n\t\tif (b == null)\n\t\t\treturn a;\n\n\t\t// Violates leftist property, so must do a swap\n\t\tif (a.element > b.element) {\n\t\t\tNode temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\n\t\t// Now we call the function merge to merge a and b\n\t\ta.right = merge(a.right, b);\n\n\t\t// Violates leftist property so must swap here\n\t\tif (a.left == null) {\n\t\t\ta.left = a.right;\n\t\t\ta.right = null;\n\t\t} else {\n\t\t\tif (a.left.npl < a.right.npl) {\n\t\t\t\tNode temp = a.left;\n\t\t\t\ta.left = a.right;\n\t\t\t\ta.right = temp;\n\t\t\t}\n\t\t\ta.npl = a.right.npl + 1;\n\t\t}\n\t\treturn a;\n\t}\n\n\t// Function insert. Uses the merge function to add the data\n\tpublic void insert(int a) {\n\t\troot = merge(new Node(a), root);\n\t}\n\n\t// Returns and removes the minimum element in the heap\n\tpublic int extract_min() {\n\t\t// If is empty return -1\n\t\tif (isEmpty())\n\t\t\treturn -1;\n\n\t\tint min = root.element;\n\t\troot = merge(root.left, root.right);\n\t\treturn min;\n\t}\n\n\t// Function returning a list of an in order traversal of the data structure\n\tpublic ArrayList<Integer> in_order() {\n\t\tArrayList<Integer> lst = new ArrayList<>();\n\t\tin_order_aux(root, lst);\n\t\treturn new ArrayList<>(lst);\n\t}\n\n\t// Auxiliary function for in_order\n\tprivate void in_order_aux(Node n, ArrayList<Integer> lst) {\n\t\tif (n == null)\n\t\t\treturn;\n\t\tin_order_aux(n.left, lst);\n\t\tlst.add(n.element);\n\t\tin_order_aux(n.right, lst);\n\t}\n}",
        "product_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport java.util.ArrayList;\n\n/*\n * This is a leftist heap that follows the same operations as a\n * binary min heap, but may be unbalanced at times and follows a\n * leftist property, in which the left side is more heavy on the\n * right based on the null-path length (npl) values.\n *\n * Source: https://iq.opengenus.org/leftist-heap/\n *\n */\n\npublic class LeftistHeap {\n    private class Node {\n        private int element, npl;\n        private Node left, right;\n\n        // Node constructor setting the data element and left/right pointers to null\n        private Node(int element) {\n            this.element = element;\n            left = right = null;\n            npl = 0;\n        }\n    }\n\n    private Node root;\n\n    // Constructor\n    public LeftistHeap() {\n        root = null;\n    }\n\n    // Checks if heap is empty\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    // Resets structure to initial state\n    public void clear() {\n        // We will put head is null\n        root = null;\n    }\n\n    // Merge function that merges the contents of another leftist heap with the\n    // current one\n    public void merge(LeftistHeap h1) {\n        // If the present function is rhs then we ignore the merge\n        root = merge(root, h1.root);\n        h1.root = null;\n    }\n\n    // Function merge with two Nodes a and b\n    public Node merge(Node a, Node b) {\n        if (a == null) return b;\n\n        if (b == null) return a;\n\n        // Violates leftist property, so must do a swap\n        if (a.element > b.element) {\n            Node temp = a;\n            a = b;\n            b = temp;\n        }\n\n        // Now we call the function merge to merge a and b\n        a.right = merge(a.right, b);\n\n        // Violates leftist property so must swap here\n        if (a.left == null) {\n            a.left = a.right;\n            a.right = null;\n        } else {\n            if (a.left.npl < a.right.npl) {\n                Node temp = a.left;\n                a.left = a.right;\n                a.right = temp;\n            }\n            a.npl = a.right.npl + 1;\n        }\n        return a;\n    }\n\n    // Function insert. Uses the merge function to add the data\n    public void insert(int a) {\n        root = merge(new Node(a), root);\n    }\n\n    // Returns and removes the minimum element in the heap\n    public int extract_min() {\n        // If is empty return -1\n        if (isEmpty()) return -1;\n\n        int min = root.element;\n        root = merge(root.left, root.right);\n        return min;\n    }\n\n    // Function returning a list of an in order traversal of the data structure\n    public ArrayList<Integer> in_order() {\n        ArrayList<Integer> lst = new ArrayList<>();\n        in_order_aux(root, lst);\n        return new ArrayList<>(lst);\n    }\n\n    // Auxiliary function for in_order\n    private void in_order_aux(Node n, ArrayList<Integer> lst) {\n        if (n == null) return;\n        in_order_aux(n.left, lst);\n        lst.add(n.element);\n        in_order_aux(n.right, lst);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeftistHeapTest {\n\t\n\t@Test\n\tvoid testLeftistHeap() {\n\t\tLeftistHeap heap = new LeftistHeap();\n\t\tAssertions.assertTrue(heap.isEmpty());\n\t\theap.insert(6);\n\t\tAssertions.assertTrue(!heap.isEmpty());\n\t\theap.insert(2);\n\t\theap.insert(3);\n\t\theap.insert(1);\n\t\theap.in_order();\n\t\tAssertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3, 1]\"));\n\t\tAssertions.assertTrue(heap.extract_min() == 1);\n\t\tAssertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3]\"));\n\t\theap.insert(8);\n\t\theap.insert(12);\n\t\theap.insert(4);\n\t\tAssertions.assertTrue(heap.in_order().toString().equals(\"[8, 3, 12, 2, 6, 4]\"));\n\t\theap.clear();\n\t\tAssertions.assertTrue(heap.isEmpty());\n\t}\n}",
        "test_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeftistHeapTest {\n\n    @Test\n    void testLeftistHeap() {\n        LeftistHeap heap = new LeftistHeap();\n        Assertions.assertTrue(heap.isEmpty());\n        heap.insert(6);\n        Assertions.assertTrue(!heap.isEmpty());\n        heap.insert(2);\n        heap.insert(3);\n        heap.insert(1);\n        heap.in_order();\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3, 1]\"));\n        Assertions.assertTrue(heap.extract_min() == 1);\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3]\"));\n        heap.insert(8);\n        heap.insert(12);\n        heap.insert(4);\n        Assertions.assertTrue(heap.in_order().toString().equals(\"[8, 3, 12, 2, 6, 4]\"));\n        heap.clear();\n        Assertions.assertTrue(heap.isEmpty());\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    public Node reverseList(Node node) {\n        Node prev = null;\n        Node curr = node;\n        \n        while (curr != null && curr.next != null) {\n            Node next=curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        //when curr.next==null, the current element is left without pointing it to its prev,so \n        if(curr != null){\n            curr.next = prev;\n            prev=curr;\n        }\n        //prev will be pointing to the last element in the Linkedlist, it will be the new head of the reversed linkedlist\n        return prev;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (\n                    newHead.next != null && newHead.value == newHead.next.value\n                ) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) &&\n        list.search(5) &&\n        list.search(1) &&\n        !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 &&\n        list.getNth(2) == 5 &&\n        list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(\n            0,\n            new Node(2, new Node(3, new Node(3, new Node(4))))\n        );\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {}\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    public Node reverseList(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i+1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        //List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode/2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode/2, list.middle().value);\n\n        //return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        //return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1,5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); //Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    //Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList(){\n\n        //Creating a new LinkedList of size:4\n        //The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n          \n        //Reversing the LinkedList using reverseList() method and storing the head of the reversed linkedlist in a head node\n        //The reversed linkedlist will be 4->3->2->1->null\n        Node head=list.reverseList(list.getHead());\n\n        //Recording the Nodes after reversing the LinkedList\n        Node firstNode = head;              //4\n        Node secondNode = firstNode.next;   //3\n        Node thirdNode = secondNode.next;   //2\n        Node fourthNode = thirdNode.next;   //1\n        \n        //Checking whether the LinkedList is reversed or not by comparing the original list and reversed list nodes\n        assertEquals(1,fourthNode.value);\n        assertEquals(2,thirdNode.value);\n        assertEquals(3,secondNode.value);\n        assertEquals(4,firstNode.value);\n    }\n    \n    //Test to check whether implemented reverseList() method handles NullPointer Exception for TestCase where head==null\n    @Test\n    void reverseListNullPointer(){\n        //Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list=new SinglyLinkedList();\n        Node first=list.getHead();\n        \n        //Reversing the linkedlist\n        Node head=list.reverseList(first);\n\n        //checking whether the method works fine if the input is null\n        assertEquals(head,first);\n    }\n\n    //Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest(){\n        //Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        //Reversing the LinkedList using reverseList() method and storing the head of the reversed linkedlist in a head node\n        Node head=list.reverseList(list.getHead());\n        \n        //Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp=head;\n\n        int i=20; //This is for the comparison of values of nodes of the reversed linkedlist\n        //Checking whether the reverseList() method performed its task\n        while(temp!=null && i>0){\n             assertEquals(i,temp.value);\n             temp=temp.next;\n             i--;\n        }\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseList(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseList(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseList(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SkipList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SkipListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            if (current.next(i) != null) {\n                current.next(i).setPrevious(i, current.previous(i));\n            }\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers\n            .stream()\n            .map(layer -> {\n                StringBuilder acc = new StringBuilder();\n                for (boolean b : layer) {\n                    if (b) {\n                        acc.append(\"[ ]\");\n                    } else {\n                        acc.append(\"---\");\n                    }\n                    acc.append(\" \");\n                }\n                return acc.toString();\n            })\n            .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream\n            .range(0, sizeWithHeader - 1)\n            .mapToObj(i -> String.format(\"%3d\", i))\n            .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\n                    \"Probability should be from 0 to 1. But was: \" + probability\n                );\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(\n                Math.log10(expectedSize) / Math.log10(1 / probability)\n            );\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            if (current.next(i) != null) {\n                current.next(i).setPrevious(i, current.previous(i));\n            }\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                            .map(layer -> {\n                                StringBuilder acc = new StringBuilder();\n                                for (boolean b : layer) {\n                                    if (b) {\n                                        acc.append(\"[ ]\");\n                                    } else {\n                                        acc.append(\"---\");\n                                    }\n                                    acc.append(\" \");\n                                }\n                                return acc.toString();\n                            })\n                            .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1)\n                               .mapToObj(i -> String.format(\"%3d\", i))\n                               .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\n                    \"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\nimport org.junit.jupiter.api.Test;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = { \"d\", \"b\", \"a\", \"c\" };\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream\n            .range(0, values.length)\n            .mapToObj(skipList::get)\n            .toArray(String[]::new);\n\n        assertArrayEquals(new String[] { \"a\", \"b\", \"c\", \"d\" }, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n            \"f\",\n            \"g\",\n            \"h\",\n            \"i\",\n            \"j\",\n            \"k\",\n        };\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\nimport org.junit.jupiter.api.Test;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder\n            = IntStream.range(0, values.length).mapToObj(skipList::get).toArray(String[] ::new);\n\n        assertArrayEquals(new String[] {\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n            \"f\",\n            \"g\",\n            \"h\",\n            \"i\",\n            \"j\",\n            \"k\",\n        };\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/queues/LinkedQueue.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/queues/LinkedQueueTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.queues;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.StringJoiner;\n\npublic class LinkedQueue<T> implements Iterable<T> {\n\n    static class Node<T> {\n\n        T data;\n        Node<T> next;\n\n        public Node() {\n            this(null);\n        }\n\n        public Node(T data) {\n            this(data, null);\n        }\n\n        public Node(T data, Node<T> next) {\n            this.data = data;\n            this.next = next;\n        }\n    }\n\n    /**\n     * Front of Queue\n     */\n    private Node<T> front;\n\n    /**\n     * Rear of Queue\n     */\n    private Node<T> rear;\n\n    /**\n     * Size of Queue\n     */\n    private int size;\n\n    /**\n     * Init LinkedQueue\n     */\n    public LinkedQueue() {\n        front = rear = new Node<>();\n    }\n\n    /**\n     * Check if queue is empty\n     *\n     * @return true if queue is empty, otherwise false\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Add element to rear of queue\n     *\n     * @param data insert value\n     */\n    public void enqueue(T data) {\n        Node<T> newNode = new Node<>(data);\n\n        rear.next = newNode;\n        rear = newNode;\n        /* make rear point at last node */\n        size++;\n    }\n\n    /**\n     * Remove element at the front of queue\n     *\n     * @return element at the front of queue\n     */\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        Node<T> destroy = front.next;\n        T retValue = destroy.data;\n        front.next = front.next.next;\n        /* clear let GC do it's work */\n        size--;\n\n        if (isEmpty()) {\n            front = rear;\n        }\n\n        return retValue;\n    }\n\n    /**\n     * Peek element at the front of queue without removing\n     *\n     * @return element at the front\n     */\n    public T peekFront() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return front.next.data;\n    }\n\n    /**\n     * Peek element at the rear of queue without removing\n     *\n     * @return element at the front\n     */\n    public T peekRear() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return rear.data;\n    }\n\n    /**\n     * Peeks the element at the index and\n     *          returns the value\n     * @param pos at which to peek\n     */\n\n    public T peek(int pos) {\n        if (pos > size)\n            throw new IndexOutOfBoundsException(\n                    \"Position %s out of range!\".formatted(pos));\n        Node<T> node = front;\n        while (pos-- > 0)\n            node = node.next;\n        return node.data;\n    }\n\n    /**\n     * Node iterator, allows to travel through\n     * the nodes using for() loop or forEach(Consumer)\n     */\n\n    @Override\n    public Iterator<T> iterator() {\n        return new Iterator<>() {\n\n            Node<T> node = front;\n\n            @Override\n            public boolean hasNext() {\n                return node.next != null;\n            }\n\n            @Override\n            public T next() {\n                return (node = node.next).data;\n            }\n        };\n    }\n\n    /**\n     * Return size of queue\n     *\n     * @return size of queue\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Clear all nodes in queue\n     */\n    public void clear() {\n        while (size > 0)\n            dequeue();\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner join = new StringJoiner(\", \"); // separator of ', '\n        Node<T> travel = front;\n        while ((travel = travel.next) != null)\n            join.add(String.valueOf(travel.data));\n        return '[' + join.toString() + ']';\n    }\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        LinkedQueue<Integer> queue = new LinkedQueue<>();\n        assert queue.isEmpty();\n\n        queue.enqueue(1);\n        /* 1 */\n        queue.enqueue(2);\n        /* 1 2 */\n        queue.enqueue(3);\n        /* 1 2 3 */\n        System.out.println(queue);\n        /* [1, 2, 3] */\n\n        assert queue.size() == 3;\n        assert queue.dequeue() == 1;\n        assert queue.peekFront() == 2;\n        assert queue.peekRear() == 3;\n\n        queue.clear();\n        assert queue.isEmpty();\n\n        System.out.println(queue);\n        /* [] */\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.queues;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.StringJoiner;\n\npublic class LinkedQueue<T> implements Iterable<T> {\n\n    static class Node<T> {\n\n        T data;\n        Node<T> next;\n\n        public Node() {\n            this(null);\n        }\n\n        public Node(T data) {\n            this(data, null);\n        }\n\n        public Node(T data, Node<T> next) {\n            this.data = data;\n            this.next = next;\n        }\n    }\n\n    /**\n     * Front of Queue\n     */\n    private Node<T> front;\n\n    /**\n     * Rear of Queue\n     */\n    private Node<T> rear;\n\n    /**\n     * Size of Queue\n     */\n    private int size;\n\n    /**\n     * Init LinkedQueue\n     */\n    public LinkedQueue() {\n        front = rear = new Node<>();\n    }\n\n    /**\n     * Check if queue is empty\n     *\n     * @return true if queue is empty, otherwise false\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Add element to rear of queue\n     *\n     * @param data insert value\n     */\n    public void enqueue(T data) {\n        Node<T> newNode = new Node<>(data);\n\n        rear.next = newNode;\n        rear = newNode;\n        /* make rear point at last node */\n        size++;\n    }\n\n    /**\n     * Remove element at the front of queue\n     *\n     * @return element at the front of queue\n     */\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        Node<T> destroy = front.next;\n        T retValue = destroy.data;\n        front.next = front.next.next;\n        /* clear let GC do it's work */\n        size--;\n\n        if (isEmpty()) {\n            front = rear;\n        }\n\n        return retValue;\n    }\n\n    /**\n     * Peek element at the front of queue without removing\n     *\n     * @return element at the front\n     */\n    public T peekFront() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return front.next.data;\n    }\n\n    /**\n     * Peek element at the rear of queue without removing\n     *\n     * @return element at the front\n     */\n    public T peekRear() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return rear.data;\n    }\n\n    /**\n     * Peeks the element at the index and\n     *          returns the value\n     * @param pos at which to peek\n     */\n\n    public T peek(int pos) {\n        if (pos > size)\n            throw new IndexOutOfBoundsException(\"Position %s out of range!\".formatted(pos));\n        Node<T> node = front;\n        while (pos-- > 0) node = node.next;\n        return node.data;\n    }\n\n    /**\n     * Node iterator, allows to travel through\n     * the nodes using for() loop or forEach(Consumer)\n     */\n\n    @Override\n    public Iterator<T> iterator() {\n        return new Iterator<>() {\n            Node<T> node = front;\n\n            @Override\n            public boolean hasNext() {\n                return node.next != null;\n            }\n\n            @Override\n            public T next() {\n                return (node = node.next).data;\n            }\n        };\n    }\n\n    /**\n     * Return size of queue\n     *\n     * @return size of queue\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Clear all nodes in queue\n     */\n    public void clear() {\n        while (size > 0) dequeue();\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner join = new StringJoiner(\", \"); // separator of ', '\n        Node<T> travel = front;\n        while ((travel = travel.next) != null) join.add(String.valueOf(travel.data));\n        return '[' + join.toString() + ']';\n    }\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        LinkedQueue<Integer> queue = new LinkedQueue<>();\n        assert queue.isEmpty();\n\n        queue.enqueue(1);\n        /* 1 */\n        queue.enqueue(2);\n        /* 1 2 */\n        queue.enqueue(3);\n        /* 1 2 3 */\n        System.out.println(queue);\n        /* [1, 2, 3] */\n\n        assert queue.size() == 3;\n        assert queue.dequeue() == 1;\n        assert queue.peekFront() == 2;\n        assert queue.peekRear() == 3;\n\n        queue.clear();\n        assert queue.isEmpty();\n\n        System.out.println(queue);\n        /* [] */\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.queues;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\nclass LinkedQueueTest {\n  @Test\n  public void testQue() {\n    LinkedQueue<Integer> queue = new LinkedQueue<>();\n    for (int i = 1; i < 5; i++)\n      queue.enqueue(i);\n\n    assertEquals(queue.peekRear(), 4);\n    assertEquals(queue.peek(2), 2);\n\n    assertEquals(queue.peek(4), 4);\n\n    final int[] element = { 1 };\n\n    // iterates over all the elements present\n    // as in the form of nodes\n    queue.forEach(integer -> {\n      if (element[0]++ != integer)\n        throw new AssertionError();\n    });\n  }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.queues;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LinkedQueueTest {\n    @Test\n    public void testQue() {\n        LinkedQueue<Integer> queue = new LinkedQueue<>();\n        for (int i = 1; i < 5; i++) queue.enqueue(i);\n\n        assertEquals(queue.peekRear(), 4);\n        assertEquals(queue.peek(2), 2);\n\n        assertEquals(queue.peek(4), 4);\n\n        final int[] element = {1};\n\n        // iterates over all the elements present\n        // as in the form of nodes\n        queue.forEach(integer -> {\n            if (element[0]++ != integer) throw new AssertionError();\n        });\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/queues/PriorityQueues.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/queues/PriorityQueuesTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.queues;\n\n\n\n\n/**\n * This class implements a PriorityQueue.\n *\n * <p>\n * A priority queue adds elements into positions based on their priority. So the\n * most important elements are placed at the front/on the top. In this example I\n * give numbers that are bigger, a higher priority. Queues in theory have no\n * fixed size but when using an array implementation it does.\n * <p>\n * Additional contibutions made by: PuneetTri(https://github.com/PuneetTri)\n */\nclass PriorityQueue {\n\n    /**\n     * The max size of the queue\n     */\n    private int maxSize;\n    /**\n     * The array for the queue\n     */\n    private int[] queueArray;\n    /**\n     * How many items are in the queue\n     */\n    private int nItems;\n\n    /**\n     * Default Constructor\n     */\n\n    public PriorityQueue() {\n        /* If capacity is not defined, default size of 11 would be used\n         *  capacity=max+1 because we cant access 0th element of PQ, and to\n         *  accomodate (max)th elements we need capacity to be max+1.\n         *  Parent is at position k, child at position (k*2,k*2+1), if we\n         *  use position 0 in our queue, its child would be at:\n         *  (0*2, 0*2+1) -> (0,0). This is why we start at position 1\n         */\n        int size = 11; // Default value of 11\n        maxSize = size + 1;\n        queueArray = new int[maxSize];\n        nItems = 0;\n    }\n\n    /**\n     * Parameterized Constructor\n     *\n     * @param size Size of the queue\n     */\n\n    public PriorityQueue(int size) {\n        maxSize = size + 1;\n        queueArray = new int[maxSize];\n        nItems = 0;\n    }\n\n    /**\n     * Helper function for the max-heap implementation of PQ\n     * Function would help demote parent node to their correct\n     * position\n     *\n     * @param pos Position of newly added element at bottom\n     */\n    private void swim(int pos) {\n        // Check if parent is smaller than child node\n        while (pos > 1 && (queueArray[pos / 2] < queueArray[pos])) {\n            // In such case swap value of child with parent\n            int temp = queueArray[pos];\n            queueArray[pos] = queueArray[pos / 2];\n            queueArray[pos / 2] = temp;\n            pos = pos / 2; // Jump to position of parent node\n        }\n        // Promotion of child node will go on until it becomes smaller than the parent\n    }\n\n    /**\n     * Helper function for the max-heap implementation of PQ\n     * Function would help demote parent node to their correct\n     * position\n     *\n     * @param pos Position of element at top\n     */\n    private void sink(int pos) {\n        // Check if node's position is that of parent node\n        while (2 * pos <= nItems) {\n            int current = 2 * pos; // Jump to the positon of child node\n            // Compare both the children for the greater one\n            if (current < nItems && queueArray[current] < queueArray[current + 1]) current++;\n            // If the parent node is greater, sink operation is complete. Break the loop\n            if (queueArray[pos] >= queueArray[current]) break;\n\n            // If not exchange the value of parent with child\n            int temp = queueArray[pos];\n            queueArray[pos] = queueArray[current];\n            queueArray[current] = temp;\n            pos = current; // Exchange parent position to child position in the array\n        }\n    }\n\n    /**\n     * Inserts an element in it's appropriate place\n     *\n     * @param value Value to be inserted\n     */\n    public void insert(int value) {\n        // Print overflow message if the capacity is full\n        if (isFull()) {\n            throw new RuntimeException(\"Queue is full\");\n        } else {\n            queueArray[++nItems] = value;\n            swim(nItems); // Swim up the element to its correct position\n        }\n    }\n\n    /**\n     * Dequeue the element with the max priority from PQ\n     *\n     * @return The element removed\n     */\n    public int remove() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Queue is Empty\");\n        } else {\n            int max = queueArray[1]; // By defintion of our max-heap, value at queueArray[1] pos is the greatest\n\n            // Swap max and last element\n            int temp = queueArray[1];\n            queueArray[1] = queueArray[nItems];\n            queueArray[nItems] = temp;\n            queueArray[nItems--] = 0; // Nullify the last element from the priority queue\n            sink(1); // Sink the element in order\n\n            return max;\n        }\n    }\n\n    /**\n     * Checks what's at the front of the queue\n     *\n     * @return element at the front of the queue\n     */\n    public int peek() {\n        return queueArray[1];\n    }\n\n    /**\n     * Returns true if the queue is empty\n     *\n     * @return true if the queue is empty\n     */\n    public boolean isEmpty() {\n        return (nItems == 0);\n    }\n\n    /**\n     * Returns true if the queue is full\n     *\n     * @return true if the queue is full\n     */\n    public boolean isFull() {\n        return (nItems == maxSize - 1);\n    }\n\n    /**\n     * Returns the number of elements in the queue\n     *\n     * @return number of elements in the queue\n     */\n    public int getSize() {\n        return nItems;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.queues;\n\n/**\n * This class implements a PriorityQueue.\n *\n * <p>\n * A priority queue adds elements into positions based on their priority. So the\n * most important elements are placed at the front/on the top. In this example I\n * give numbers that are bigger, a higher priority. Queues in theory have no\n * fixed size but when using an array implementation it does.\n * <p>\n * Additional contibutions made by: PuneetTri(https://github.com/PuneetTri)\n */\nclass PriorityQueue {\n\n    /**\n     * The max size of the queue\n     */\n    private int maxSize;\n    /**\n     * The array for the queue\n     */\n    private int[] queueArray;\n    /**\n     * How many items are in the queue\n     */\n    private int nItems;\n\n    /**\n     * Default Constructor\n     */\n\n    public PriorityQueue() {\n        /* If capacity is not defined, default size of 11 would be used\n         *  capacity=max+1 because we cant access 0th element of PQ, and to\n         *  accomodate (max)th elements we need capacity to be max+1.\n         *  Parent is at position k, child at position (k*2,k*2+1), if we\n         *  use position 0 in our queue, its child would be at:\n         *  (0*2, 0*2+1) -> (0,0). This is why we start at position 1\n         */\n        int size = 11; // Default value of 11\n        maxSize = size + 1;\n        queueArray = new int[maxSize];\n        nItems = 0;\n    }\n\n    /**\n     * Parameterized Constructor\n     *\n     * @param size Size of the queue\n     */\n\n    public PriorityQueue(int size) {\n        maxSize = size + 1;\n        queueArray = new int[maxSize];\n        nItems = 0;\n    }\n\n    /**\n     * Helper function for the max-heap implementation of PQ\n     * Function would help demote parent node to their correct\n     * position\n     *\n     * @param pos Position of newly added element at bottom\n     */\n    private void swim(int pos) {\n        // Check if parent is smaller than child node\n        while (pos > 1 && (queueArray[pos / 2] < queueArray[pos])) {\n            // In such case swap value of child with parent\n            int temp = queueArray[pos];\n            queueArray[pos] = queueArray[pos / 2];\n            queueArray[pos / 2] = temp;\n            pos = pos / 2; // Jump to position of parent node\n        }\n        // Promotion of child node will go on until it becomes smaller than the parent\n    }\n\n    /**\n     * Helper function for the max-heap implementation of PQ\n     * Function would help demote parent node to their correct\n     * position\n     *\n     * @param pos Position of element at top\n     */\n    private void sink(int pos) {\n        // Check if node's position is that of parent node\n        while (2 * pos <= nItems) {\n            int current = 2 * pos; // Jump to the positon of child node\n            // Compare both the children for the greater one\n            if (current < nItems && queueArray[current] < queueArray[current + 1]) current++;\n            // If the parent node is greater, sink operation is complete. Break the loop\n            if (queueArray[pos] >= queueArray[current]) break;\n\n            // If not exchange the value of parent with child\n            int temp = queueArray[pos];\n            queueArray[pos] = queueArray[current];\n            queueArray[current] = temp;\n            pos = current; // Exchange parent position to child position in the array\n        }\n    }\n\n    /**\n     * Inserts an element in it's appropriate place\n     *\n     * @param value Value to be inserted\n     */\n    public void insert(int value) {\n        // Print overflow message if the capacity is full\n        if (isFull()) {\n            throw new RuntimeException(\"Queue is full\");\n        } else {\n            queueArray[++nItems] = value;\n            swim(nItems); // Swim up the element to its correct position\n        }\n    }\n\n    /**\n     * Dequeue the element with the max priority from PQ\n     *\n     * @return The element removed\n     */\n    public int remove() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Queue is Empty\");\n        } else {\n            int max = queueArray[1]; // By defintion of our max-heap, value at queueArray[1] pos is\n                                     // the greatest\n\n            // Swap max and last element\n            int temp = queueArray[1];\n            queueArray[1] = queueArray[nItems];\n            queueArray[nItems] = temp;\n            queueArray[nItems--] = 0; // Nullify the last element from the priority queue\n            sink(1); // Sink the element in order\n\n            return max;\n        }\n    }\n\n    /**\n     * Checks what's at the front of the queue\n     *\n     * @return element at the front of the queue\n     */\n    public int peek() {\n        return queueArray[1];\n    }\n\n    /**\n     * Returns true if the queue is empty\n     *\n     * @return true if the queue is empty\n     */\n    public boolean isEmpty() {\n        return (nItems == 0);\n    }\n\n    /**\n     * Returns true if the queue is full\n     *\n     * @return true if the queue is full\n     */\n    public boolean isFull() {\n        return (nItems == maxSize - 1);\n    }\n\n    /**\n     * Returns the number of elements in the queue\n     *\n     * @return number of elements in the queue\n     */\n    public int getSize() {\n        return nItems;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.queues;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nclass PriorityQueuesTest {\n\n    @Test\n    void testPQInsertion() {\n        PriorityQueue myQueue = new PriorityQueue(4);\n        myQueue.insert(2);\n        Assertions.assertEquals(myQueue.peek(), 2);\n\n        myQueue.insert(5);\n        myQueue.insert(3);\n        Assertions.assertEquals(myQueue.peek(), 5);\n\n        myQueue.insert(10);\n        Assertions.assertEquals(myQueue.peek(), 10);\n    }\n\n    @Test\n    void testPQDeletion() {\n        PriorityQueue myQueue = new PriorityQueue(4);\n        myQueue.insert(2);\n        myQueue.insert(5);\n        myQueue.insert(3);\n        myQueue.insert(10);\n        \n        myQueue.remove();\n        Assertions.assertEquals(myQueue.peek(), 5);\n        myQueue.remove();\n        myQueue.remove();\n        Assertions.assertEquals(myQueue.peek(), 2);\n    }\n\n    @Test\n    void testPQExtra() {\n        PriorityQueue myQueue = new PriorityQueue(4);\n        Assertions.assertEquals(myQueue.isEmpty(), true);\n        Assertions.assertEquals(myQueue.isFull(), false);\n        myQueue.insert(2);\n        myQueue.insert(5);\n        Assertions.assertEquals(myQueue.isFull(), false);\n        myQueue.insert(3);\n        myQueue.insert(10);\n        Assertions.assertEquals(myQueue.isEmpty(), false);\n        Assertions.assertEquals(myQueue.isFull(), true);\n        \n        myQueue.remove();\n        Assertions.assertEquals(myQueue.getSize(), 3);\n        Assertions.assertEquals(myQueue.peek(), 5);\n        myQueue.remove();\n        myQueue.remove();\n        Assertions.assertEquals(myQueue.peek(), 2);\n        Assertions.assertEquals(myQueue.getSize(), 1);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.queues;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nclass PriorityQueuesTest {\n\n    @Test\n    void testPQInsertion() {\n        PriorityQueue myQueue = new PriorityQueue(4);\n        myQueue.insert(2);\n        Assertions.assertEquals(myQueue.peek(), 2);\n\n        myQueue.insert(5);\n        myQueue.insert(3);\n        Assertions.assertEquals(myQueue.peek(), 5);\n\n        myQueue.insert(10);\n        Assertions.assertEquals(myQueue.peek(), 10);\n    }\n\n    @Test\n    void testPQDeletion() {\n        PriorityQueue myQueue = new PriorityQueue(4);\n        myQueue.insert(2);\n        myQueue.insert(5);\n        myQueue.insert(3);\n        myQueue.insert(10);\n\n        myQueue.remove();\n        Assertions.assertEquals(myQueue.peek(), 5);\n        myQueue.remove();\n        myQueue.remove();\n        Assertions.assertEquals(myQueue.peek(), 2);\n    }\n\n    @Test\n    void testPQExtra() {\n        PriorityQueue myQueue = new PriorityQueue(4);\n        Assertions.assertEquals(myQueue.isEmpty(), true);\n        Assertions.assertEquals(myQueue.isFull(), false);\n        myQueue.insert(2);\n        myQueue.insert(5);\n        Assertions.assertEquals(myQueue.isFull(), false);\n        myQueue.insert(3);\n        myQueue.insert(10);\n        Assertions.assertEquals(myQueue.isEmpty(), false);\n        Assertions.assertEquals(myQueue.isFull(), true);\n\n        myQueue.remove();\n        Assertions.assertEquals(myQueue.getSize(), 3);\n        Assertions.assertEquals(myQueue.peek(), 5);\n        myQueue.remove();\n        myQueue.remove();\n        Assertions.assertEquals(myQueue.peek(), 2);\n        Assertions.assertEquals(myQueue.getSize(), 1);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CheckBinaryTreeIsValidBST.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckBinaryTreeIsValidBSTTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n * This code recursively validates whether given Binary Search Tree (BST) is balanced or not.\n * Trees with only distinct values are supported.\n * Key points:\n * 1. According to the definition of a BST, each node in a tree must be in range [min, max],\n *    where 'min' and 'max' values represent the child nodes (left, right).\n * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE.\n */\npublic class CheckBinaryTreeIsValidBST {\n    public static boolean isBST(BinaryTree.Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) {\n        // empty tree is a BST\n        if (node == null) {\n            return true;\n        }\n\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        return (\n            isBSTUtil(node.left, min, node.data - 1) &&\n            isBSTUtil(node.right, node.data + 1, max)\n        );\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n * This code recursively validates whether given Binary Search Tree (BST) is balanced or not.\n * Trees with only distinct values are supported.\n * Key points:\n * 1. According to the definition of a BST, each node in a tree must be in range [min, max],\n *    where 'min' and 'max' values represent the child nodes (left, right).\n * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE.\n */\npublic class CheckBinaryTreeIsValidBST {\n    public static boolean isBST(BinaryTree.Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) {\n        // empty tree is a BST\n        if (node == null) {\n            return true;\n        }\n\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        return (\n            isBSTUtil(node.left, min, node.data - 1) && isBSTUtil(node.right, node.data + 1, max));\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class CheckBinaryTreeIsValidBSTTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{Integer.MIN_VALUE});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 13});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 12});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class CheckBinaryTreeIsValidBSTTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {Integer.MIN_VALUE});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root\n            = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root\n            = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 13});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root\n            = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 12});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CheckTreeIsSymmetric.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckTreeIsSymmetricTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\n/**\n * Check if a binary tree is symmetric or not.\n * A binary tree is a symmetric tree if the left and right subtree of root are mirror image.\n * Below is a symmetric tree\n *                               1\n *                   /                         \\\n *                2                           2\n *         /                \\             /             \\\n *      3                    4         4                3\n *\n * Below is not symmetric because values is different in last level\n *                               1\n *                   /                         \\\n *                 2                           2\n *         /                \\             /             \\\n *      3                    5         4                3\n * <p>\n * Approach:\n * Recursively check for left and right subtree of root\n * 1. left subtrees root's values should be equal right subtree's root value\n * 2. recursively check with left subtrees' left child VS right subtree's right child AND\n * left subtree's right child VS right subtree left child\n * Complexity\n * 1. Time: O(n)\n * 2. Space: O(lg(n)) for height of tree\n *\n * @author kumanoit on 10/10/22 IST 12:52 AM\n */\npublic class CheckTreeIsSymmetric {\n\n    public static boolean isSymmetric(Node root) {\n        if (root == null) {\n            return true;\n        }\n        return isSymmetric(root.left, root.right);\n    }\n\n    private static boolean isSymmetric(Node leftSubtreeRoot, Node rightSubtreRoot) {\n        if (leftSubtreeRoot == null && rightSubtreRoot == null) {\n            return true;\n        }\n\n        if (isInvalidSubtree(leftSubtreeRoot, rightSubtreRoot)) {\n            return false;\n        }\n\n        return isSymmetric(leftSubtreeRoot.right, rightSubtreRoot.left) && isSymmetric(leftSubtreeRoot.left, rightSubtreRoot.right);\n    }\n\n    private static boolean isInvalidSubtree(Node leftSubtreeRoot, Node rightSubtreeRoot) {\n        return leftSubtreeRoot == null || rightSubtreeRoot == null || leftSubtreeRoot.data != rightSubtreeRoot.data;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\n/**\n * Check if a binary tree is symmetric or not.\n * A binary tree is a symmetric tree if the left and right subtree of root are mirror image.\n * Below is a symmetric tree\n *                               1\n *                   /                         \\\n *                2                           2\n *         /                \\             /             \\\n *      3                    4         4                3\n *\n * Below is not symmetric because values is different in last level\n *                               1\n *                   /                         \\\n *                 2                           2\n *         /                \\             /             \\\n *      3                    5         4                3\n * <p>\n * Approach:\n * Recursively check for left and right subtree of root\n * 1. left subtrees root's values should be equal right subtree's root value\n * 2. recursively check with left subtrees' left child VS right subtree's right child AND\n * left subtree's right child VS right subtree left child\n * Complexity\n * 1. Time: O(n)\n * 2. Space: O(lg(n)) for height of tree\n *\n * @author kumanoit on 10/10/22 IST 12:52 AM\n */\npublic class CheckTreeIsSymmetric {\n\n    public static boolean isSymmetric(Node root) {\n        if (root == null) {\n            return true;\n        }\n        return isSymmetric(root.left, root.right);\n    }\n\n    private static boolean isSymmetric(Node leftSubtreeRoot, Node rightSubtreRoot) {\n        if (leftSubtreeRoot == null && rightSubtreRoot == null) {\n            return true;\n        }\n\n        if (isInvalidSubtree(leftSubtreeRoot, rightSubtreRoot)) {\n            return false;\n        }\n\n        return isSymmetric(leftSubtreeRoot.right, rightSubtreRoot.left)\n            && isSymmetric(leftSubtreeRoot.left, rightSubtreRoot.right);\n    }\n\n    private static boolean isInvalidSubtree(Node leftSubtreeRoot, Node rightSubtreeRoot) {\n        return leftSubtreeRoot == null || rightSubtreeRoot == null\n            || leftSubtreeRoot.data != rightSubtreeRoot.data;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author kumanoit on 10/10/22 IST 1:02 AM\n */\npublic class CheckTreeIsSymmetricTest {\n\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{100});\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n    @Test\n    public void testSymmetricTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1,2,2,3,4,4,3});\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n    @Test\n    public void testNonSymmetricTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1,2,2,3,5,4,3});\n        assertFalse(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author kumanoit on 10/10/22 IST 1:02 AM\n */\npublic class CheckTreeIsSymmetricTest {\n\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {100});\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n    @Test\n    public void testSymmetricTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {1, 2, 2, 3, 4, 4, 3});\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n    @Test\n    public void testNonSymmetricTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {1, 2, 2, 3, 5, 4, 3});\n        assertFalse(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CreateBinaryTreeFromInorderPreorder.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CreateBinaryTreeFromInorderPreorderTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Approach: Naive Solution: Create root node from first value present in\n * preorder traversal. Look for the index of root node's value in inorder\n * traversal. That will tell total nodes present in left subtree and right\n * subtree. Based on that index create left and right subtree. Complexity: Time:\n * O(n^2) for each node there is iteration to find index in inorder array Space:\n * Stack size = O(height) = O(lg(n))\n * <p>\n * Optimized Solution: Instead of iterating over inorder array to find index of\n * root value, create a hashmap and find out the index of root value.\n * Complexity: Time: O(n) hashmap reduced iteration to find index in inorder\n * array Space: O(n) space taken by hashmap\n */\npublic class CreateBinaryTreeFromInorderPreorder {\n    public static Node createTree(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        return createTree(preorder, inorder, 0, 0, inorder.length);\n    }\n\n    public static Node createTreeOptimized(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        return createTreeOptimized(preorder, inorderMap, 0, 0, inorder.length);\n    }\n\n    private static Node createTree(\n            final Integer[] preorder,\n            final Integer[] inorder,\n            final int preStart,\n            final int inStart,\n            final int size\n    ) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inStart;\n        while (!preorder[preStart].equals(inorder[i])) {\n            i++;\n        }\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left =\n                createTree(\n                        preorder,\n                        inorder,\n                        preStart + 1,\n                        inStart,\n                        leftNodesCount\n                );\n        root.right =\n                createTree(\n                        preorder,\n                        inorder,\n                        preStart + leftNodesCount + 1,\n                        i + 1,\n                        rightNodesCount\n                );\n        return root;\n    }\n\n    private static Node createTreeOptimized(\n            final Integer[] preorder,\n            final Map<Integer, Integer> inorderMap,\n            final int preStart,\n            final int inStart,\n            final int size\n    ) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inorderMap.get(preorder[preStart]);\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left =\n                createTreeOptimized(\n                        preorder,\n                        inorderMap,\n                        preStart + 1,\n                        inStart,\n                        leftNodesCount\n                );\n        root.right =\n                createTreeOptimized(\n                        preorder,\n                        inorderMap,\n                        preStart + leftNodesCount + 1,\n                        i + 1,\n                        rightNodesCount\n                );\n        return root;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Approach: Naive Solution: Create root node from first value present in\n * preorder traversal. Look for the index of root node's value in inorder\n * traversal. That will tell total nodes present in left subtree and right\n * subtree. Based on that index create left and right subtree. Complexity: Time:\n * O(n^2) for each node there is iteration to find index in inorder array Space:\n * Stack size = O(height) = O(lg(n))\n * <p>\n * Optimized Solution: Instead of iterating over inorder array to find index of\n * root value, create a hashmap and find out the index of root value.\n * Complexity: Time: O(n) hashmap reduced iteration to find index in inorder\n * array Space: O(n) space taken by hashmap\n */\npublic class CreateBinaryTreeFromInorderPreorder {\n    public static Node createTree(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        return createTree(preorder, inorder, 0, 0, inorder.length);\n    }\n\n    public static Node createTreeOptimized(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        return createTreeOptimized(preorder, inorderMap, 0, 0, inorder.length);\n    }\n\n    private static Node createTree(final Integer[] preorder, final Integer[] inorder,\n        final int preStart, final int inStart, final int size) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inStart;\n        while (!preorder[preStart].equals(inorder[i])) {\n            i++;\n        }\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left = createTree(preorder, inorder, preStart + 1, inStart, leftNodesCount);\n        root.right\n            = createTree(preorder, inorder, preStart + leftNodesCount + 1, i + 1, rightNodesCount);\n        return root;\n    }\n\n    private static Node createTreeOptimized(final Integer[] preorder,\n        final Map<Integer, Integer> inorderMap, final int preStart, final int inStart,\n        final int size) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inorderMap.get(preorder[preStart]);\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left\n            = createTreeOptimized(preorder, inorderMap, preStart + 1, inStart, leftNodesCount);\n        root.right = createTreeOptimized(\n            preorder, inorderMap, preStart + leftNodesCount + 1, i + 1, rightNodesCount);\n        return root;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\n\n/**\n * @author Albina Gimaletdinova on 14/05/2023\n */\npublic class CreateBinaryTreeFromInorderPreorderTest {\n    @Test\n    public void testOnNullArraysShouldReturnNullTree() {\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(null, null);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(null, null);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnEmptyArraysShouldCreateNullTree() {\n        // given\n        Integer[] preorder = {};\n        Integer[] inorder = {};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnSingleNodeTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1};\n        Integer[] inorder = {1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnRightSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {1, 2, 3, 4};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnLeftSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {4, 3, 2, 1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnNormalTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {3, 9, 20, 15, 7};\n        Integer[] inorder = {9, 3, 15, 20, 7};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    private static void checkTree(Integer[] preorder, Integer[] inorder, BinaryTree.Node root) {\n        Assertions.assertNotNull(root);\n        Assertions.assertEquals(PreOrderTraversal.iterativePreOrder(root), Arrays.asList(preorder));\n        Assertions.assertEquals(InorderTraversal.iterativeInorder(root), Arrays.asList(inorder));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 14/05/2023\n */\npublic class CreateBinaryTreeFromInorderPreorderTest {\n    @Test\n    public void testOnNullArraysShouldReturnNullTree() {\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(null, null);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(null, null);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnEmptyArraysShouldCreateNullTree() {\n        // given\n        Integer[] preorder = {};\n        Integer[] inorder = {};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnSingleNodeTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1};\n        Integer[] inorder = {1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnRightSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {1, 2, 3, 4};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnLeftSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {4, 3, 2, 1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnNormalTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {3, 9, 20, 15, 7};\n        Integer[] inorder = {9, 3, 15, 20, 7};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt\n            = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    private static void checkTree(Integer[] preorder, Integer[] inorder, BinaryTree.Node root) {\n        Assertions.assertNotNull(root);\n        Assertions.assertEquals(PreOrderTraversal.iterativePreOrder(root), Arrays.asList(preorder));\n        Assertions.assertEquals(InorderTraversal.iterativeInorder(root), Arrays.asList(inorder));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/KDTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/KDTreeTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/*\n * K-D Tree Implementation\n * Wikipedia: https://en.wikipedia.org/wiki/K-d_tree\n *\n * Author: Amir Hosseini (https://github.com/itsamirhn)\n *\n * */\n\npublic class KDTree {\n\n    private Node root;\n\n    private final int k; // Dimensions of the points\n\n    /**\n     * Constructor for empty KDTree\n     *\n     * @param k Number of dimensions\n     */\n    KDTree(int k) {\n        this.k = k;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     */\n    KDTree(Point[] points) {\n        if (points.length == 0) throw new IllegalArgumentException(\n            \"Points array cannot be empty\"\n        );\n        this.k = points[0].getDimension();\n        for (Point point : points) if (\n            point.getDimension() != k\n        ) throw new IllegalArgumentException(\n            \"Points must have the same dimension\"\n        );\n        this.root = build(points, 0);\n    }\n\n    /**\n     * Builds the KDTree from the specified coordinates of the points\n     *\n     * @param pointsCoordinates Array of initial points coordinates\n     *\n     */\n    KDTree(int[][] pointsCoordinates) {\n        if (pointsCoordinates.length == 0) throw new IllegalArgumentException(\n            \"Points array cannot be empty\"\n        );\n        this.k = pointsCoordinates[0].length;\n        Point[] points = Arrays\n            .stream(pointsCoordinates)\n            .map(Point::new)\n            .toArray(Point[]::new);\n        for (Point point : points) if (\n            point.getDimension() != k\n        ) throw new IllegalArgumentException(\n            \"Points must have the same dimension\"\n        );\n        this.root = build(points, 0);\n    }\n\n    static class Point {\n\n        int[] coordinates;\n\n        public int getCoordinate(int i) {\n            return coordinates[i];\n        }\n\n        public int getDimension() {\n            return coordinates.length;\n        }\n\n        public Point(int[] coordinates) {\n            this.coordinates = coordinates;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Point other) {\n                if (other.getDimension() != this.getDimension()) return false;\n                return Arrays.equals(other.coordinates, this.coordinates);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(coordinates);\n        }\n\n        /**\n         * Find the comparable distance between two points (without SQRT)\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         *\n         * @return The comparable distance between the two points\n         */\n        public static int comparableDistance(Point p1, Point p2) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n\n        /**\n         * Find the comparable distance between two points with ignoring specified axis\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         * @param axis The axis to ignore\n         *\n         * @return The distance between the two points\n         */\n        public static int comparableDistanceExceptAxis(\n            Point p1,\n            Point p2,\n            int axis\n        ) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                if (i == axis) continue;\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n    }\n\n    static class Node {\n\n        private Point point;\n        private int axis; // 0 for x, 1 for y, 2 for z, etc.\n\n        private Node left = null; // Left child\n        private Node right = null; // Right child\n\n        Node(Point point, int axis) {\n            this.point = point;\n            this.axis = axis;\n        }\n\n        public Point getPoint() {\n            return point;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n\n        public int getAxis() {\n            return axis;\n        }\n\n        /**\n         * Get the nearest child according to the specified point\n         *\n         * @param point The point to find the nearest child to\n         *\n         * @return The nearest child Node\n         */\n        public Node getNearChild(Point point) {\n            if (\n                point.getCoordinate(axis) < this.point.getCoordinate(axis)\n            ) return left; else return right;\n        }\n\n        /**\n         * Get the farthest child according to the specified point\n         *\n         * @param point The point to find the farthest child to\n         *\n         * @return The farthest child Node\n         */\n        public Node getFarChild(Point point) {\n            if (\n                point.getCoordinate(axis) < this.point.getCoordinate(axis)\n            ) return right; else return left;\n        }\n\n        /**\n         * Get the node axis coordinate of point\n         *\n         * @return The axis coordinate of the point\n         */\n        public int getAxisCoordinate() {\n            return point.getCoordinate(axis);\n        }\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node build(Point[] points, int depth) {\n        if (points.length == 0) return null;\n        int axis = depth % k;\n        if (points.length == 1) return new Node(points[0], axis);\n        Arrays.sort(\n            points,\n            Comparator.comparingInt(o -> o.getCoordinate(axis))\n        );\n        int median = points.length >> 1;\n        Node node = new Node(points[median], axis);\n        node.left = build(Arrays.copyOfRange(points, 0, median), depth + 1);\n        node.right =\n            build(\n                Arrays.copyOfRange(points, median + 1, points.length),\n                depth + 1\n            );\n        return node;\n    }\n\n    /**\n     * Insert a point into the KDTree\n     *\n     * @param point The point to insert\n     *\n     */\n    public void insert(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\n            \"Point has wrong dimension\"\n        );\n        root = insert(root, point, 0);\n    }\n\n    /**\n     * Insert a point into a subtree\n     *\n     * @param root The root of the subtree\n     * @param point The point to insert\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node insert(Node root, Point point, int depth) {\n        int axis = depth % k;\n        if (root == null) return new Node(point, axis);\n        if (point.getCoordinate(axis) < root.getAxisCoordinate()) root.left =\n            insert(root.left, point, depth + 1); else root.right =\n            insert(root.right, point, depth + 1);\n\n        return root;\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in the KDTree\n     *\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\n            \"Point has wrong dimension\"\n        );\n        return search(root, point);\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Node root, Point point) {\n        if (root == null) return Optional.empty();\n        if (root.point.equals(point)) return Optional.of(root);\n        return search(root.getNearChild(point), point);\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The point with minimum value in the specified axis\n     */\n    public Point findMin(int axis) {\n        return findMin(root, axis).point;\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The Node with minimum value in the specified axis of the point\n     */\n    public Node findMin(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.left == null) return root;\n            return findMin(root.left, axis);\n        } else {\n            Node left = findMin(root.left, axis);\n            Node right = findMin(root.right, axis);\n            Node[] candidates = { left, root, right };\n            return Arrays\n                .stream(candidates)\n                .filter(Objects::nonNull)\n                .min(Comparator.comparingInt(a -> a.point.getCoordinate(axis)))\n                .orElse(null);\n        }\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The point with maximum value in the specified axis\n     */\n    public Point findMax(int axis) {\n        return findMax(root, axis).point;\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The Node with maximum value in the specified axis of the point\n     */\n    public Node findMax(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.right == null) return root;\n            return findMax(root.right, axis);\n        } else {\n            Node left = findMax(root.left, axis);\n            Node right = findMax(root.right, axis);\n            Node[] candidates = { left, root, right };\n            return Arrays\n                .stream(candidates)\n                .filter(Objects::nonNull)\n                .max(Comparator.comparingInt(a -> a.point.getCoordinate(axis)))\n                .orElse(null);\n        }\n    }\n\n    /**\n     * Delete the node with the given point.\n     *\n     * @param point the point to delete\n     * */\n    public void delete(Point point) {\n        Node node = search(point)\n            .orElseThrow(() -> new IllegalArgumentException(\"Point not found\"));\n        root = delete(root, node);\n    }\n\n    /**\n     * Delete the specified node from a subtree.\n     *\n     * @param root The root of the subtree to delete from\n     * @param node The node to delete\n     *\n     * @return The new root of the subtree\n     */\n    private Node delete(Node root, Node node) {\n        if (root == null) return null;\n        if (root.equals(node)) {\n            if (root.right != null) {\n                Node min = findMin(root.right, root.getAxis());\n                root.point = min.point;\n                root.right = delete(root.right, min);\n            } else if (root.left != null) {\n                Node min = findMin(root.left, root.getAxis());\n                root.point = min.point;\n                root.left = delete(root.left, min);\n            } else return null;\n        }\n        if (\n            root.getAxisCoordinate() < node.point.getCoordinate(root.getAxis())\n        ) root.left = delete(root.left, node); else root.right =\n            delete(root.right, node);\n        return root;\n    }\n\n    /**\n     * Finds the nearest point in the tree to the given point.\n     *\n     * @param point The point to find the nearest neighbor to.\n     * */\n    public Point findNearest(Point point) {\n        return findNearest(root, point, root).point;\n    }\n\n    /**\n     * Finds the nearest point in a subtree to the given point.\n     *\n     * @param root The root of the subtree to search in.\n     * @param point The point to find the nearest neighbor to.\n     * @param nearest The nearest neighbor found so far.\n     * */\n    private Node findNearest(Node root, Point point, Node nearest) {\n        if (root == null) return nearest;\n        if (root.point.equals(point)) return root;\n        int distance = Point.comparableDistance(root.point, point);\n        int distanceExceptAxis = Point.comparableDistanceExceptAxis(\n            root.point,\n            point,\n            root.getAxis()\n        );\n        if (distance < Point.comparableDistance(nearest.point, point)) nearest =\n            root;\n        nearest = findNearest(root.getNearChild(point), point, nearest);\n        if (\n            distanceExceptAxis < Point.comparableDistance(nearest.point, point)\n        ) nearest = findNearest(root.getFarChild(point), point, nearest);\n        return nearest;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/*\n * K-D Tree Implementation\n * Wikipedia: https://en.wikipedia.org/wiki/K-d_tree\n *\n * Author: Amir Hosseini (https://github.com/itsamirhn)\n *\n * */\n\npublic class KDTree {\n\n    private Node root;\n\n    private final int k; // Dimensions of the points\n\n    /**\n     * Constructor for empty KDTree\n     *\n     * @param k Number of dimensions\n     */\n    KDTree(int k) {\n        this.k = k;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     */\n    KDTree(Point[] points) {\n        if (points.length == 0) throw new IllegalArgumentException(\"Points array cannot be empty\");\n        this.k = points[0].getDimension();\n        for (Point point : points)\n            if (point.getDimension() != k)\n                throw new IllegalArgumentException(\"Points must have the same dimension\");\n        this.root = build(points, 0);\n    }\n\n    /**\n     * Builds the KDTree from the specified coordinates of the points\n     *\n     * @param pointsCoordinates Array of initial points coordinates\n     *\n     */\n    KDTree(int[][] pointsCoordinates) {\n        if (pointsCoordinates.length == 0)\n            throw new IllegalArgumentException(\"Points array cannot be empty\");\n        this.k = pointsCoordinates[0].length;\n        Point[] points = Arrays.stream(pointsCoordinates).map(Point::new).toArray(Point[] ::new);\n        for (Point point : points)\n            if (point.getDimension() != k)\n                throw new IllegalArgumentException(\"Points must have the same dimension\");\n        this.root = build(points, 0);\n    }\n\n    static class Point {\n\n        int[] coordinates;\n\n        public int getCoordinate(int i) {\n            return coordinates[i];\n        }\n\n        public int getDimension() {\n            return coordinates.length;\n        }\n\n        public Point(int[] coordinates) {\n            this.coordinates = coordinates;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Point other) {\n                if (other.getDimension() != this.getDimension()) return false;\n                return Arrays.equals(other.coordinates, this.coordinates);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(coordinates);\n        }\n\n        /**\n         * Find the comparable distance between two points (without SQRT)\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         *\n         * @return The comparable distance between the two points\n         */\n        public static int comparableDistance(Point p1, Point p2) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n\n        /**\n         * Find the comparable distance between two points with ignoring specified axis\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         * @param axis The axis to ignore\n         *\n         * @return The distance between the two points\n         */\n        public static int comparableDistanceExceptAxis(Point p1, Point p2, int axis) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                if (i == axis) continue;\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n    }\n\n    static class Node {\n\n        private Point point;\n        private int axis; // 0 for x, 1 for y, 2 for z, etc.\n\n        private Node left = null; // Left child\n        private Node right = null; // Right child\n\n        Node(Point point, int axis) {\n            this.point = point;\n            this.axis = axis;\n        }\n\n        public Point getPoint() {\n            return point;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n\n        public int getAxis() {\n            return axis;\n        }\n\n        /**\n         * Get the nearest child according to the specified point\n         *\n         * @param point The point to find the nearest child to\n         *\n         * @return The nearest child Node\n         */\n        public Node getNearChild(Point point) {\n            if (point.getCoordinate(axis) < this.point.getCoordinate(axis))\n                return left;\n            else\n                return right;\n        }\n\n        /**\n         * Get the farthest child according to the specified point\n         *\n         * @param point The point to find the farthest child to\n         *\n         * @return The farthest child Node\n         */\n        public Node getFarChild(Point point) {\n            if (point.getCoordinate(axis) < this.point.getCoordinate(axis))\n                return right;\n            else\n                return left;\n        }\n\n        /**\n         * Get the node axis coordinate of point\n         *\n         * @return The axis coordinate of the point\n         */\n        public int getAxisCoordinate() {\n            return point.getCoordinate(axis);\n        }\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node build(Point[] points, int depth) {\n        if (points.length == 0) return null;\n        int axis = depth % k;\n        if (points.length == 1) return new Node(points[0], axis);\n        Arrays.sort(points, Comparator.comparingInt(o -> o.getCoordinate(axis)));\n        int median = points.length >> 1;\n        Node node = new Node(points[median], axis);\n        node.left = build(Arrays.copyOfRange(points, 0, median), depth + 1);\n        node.right = build(Arrays.copyOfRange(points, median + 1, points.length), depth + 1);\n        return node;\n    }\n\n    /**\n     * Insert a point into the KDTree\n     *\n     * @param point The point to insert\n     *\n     */\n    public void insert(Point point) {\n        if (point.getDimension() != k)\n            throw new IllegalArgumentException(\"Point has wrong dimension\");\n        root = insert(root, point, 0);\n    }\n\n    /**\n     * Insert a point into a subtree\n     *\n     * @param root The root of the subtree\n     * @param point The point to insert\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node insert(Node root, Point point, int depth) {\n        int axis = depth % k;\n        if (root == null) return new Node(point, axis);\n        if (point.getCoordinate(axis) < root.getAxisCoordinate())\n            root.left = insert(root.left, point, depth + 1);\n        else\n            root.right = insert(root.right, point, depth + 1);\n\n        return root;\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in the KDTree\n     *\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Point point) {\n        if (point.getDimension() != k)\n            throw new IllegalArgumentException(\"Point has wrong dimension\");\n        return search(root, point);\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Node root, Point point) {\n        if (root == null) return Optional.empty();\n        if (root.point.equals(point)) return Optional.of(root);\n        return search(root.getNearChild(point), point);\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The point with minimum value in the specified axis\n     */\n    public Point findMin(int axis) {\n        return findMin(root, axis).point;\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The Node with minimum value in the specified axis of the point\n     */\n    public Node findMin(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.left == null) return root;\n            return findMin(root.left, axis);\n        } else {\n            Node left = findMin(root.left, axis);\n            Node right = findMin(root.right, axis);\n            Node[] candidates = {left, root, right};\n            return Arrays.stream(candidates)\n                .filter(Objects::nonNull)\n                .min(Comparator.comparingInt(a -> a.point.getCoordinate(axis)))\n                .orElse(null);\n        }\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The point with maximum value in the specified axis\n     */\n    public Point findMax(int axis) {\n        return findMax(root, axis).point;\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The Node with maximum value in the specified axis of the point\n     */\n    public Node findMax(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.right == null) return root;\n            return findMax(root.right, axis);\n        } else {\n            Node left = findMax(root.left, axis);\n            Node right = findMax(root.right, axis);\n            Node[] candidates = {left, root, right};\n            return Arrays.stream(candidates)\n                .filter(Objects::nonNull)\n                .max(Comparator.comparingInt(a -> a.point.getCoordinate(axis)))\n                .orElse(null);\n        }\n    }\n\n    /**\n     * Delete the node with the given point.\n     *\n     * @param point the point to delete\n     * */\n    public void delete(Point point) {\n        Node node\n            = search(point).orElseThrow(() -> new IllegalArgumentException(\"Point not found\"));\n        root = delete(root, node);\n    }\n\n    /**\n     * Delete the specified node from a subtree.\n     *\n     * @param root The root of the subtree to delete from\n     * @param node The node to delete\n     *\n     * @return The new root of the subtree\n     */\n    private Node delete(Node root, Node node) {\n        if (root == null) return null;\n        if (root.equals(node)) {\n            if (root.right != null) {\n                Node min = findMin(root.right, root.getAxis());\n                root.point = min.point;\n                root.right = delete(root.right, min);\n            } else if (root.left != null) {\n                Node min = findMin(root.left, root.getAxis());\n                root.point = min.point;\n                root.left = delete(root.left, min);\n            } else\n                return null;\n        }\n        if (root.getAxisCoordinate() < node.point.getCoordinate(root.getAxis()))\n            root.left = delete(root.left, node);\n        else\n            root.right = delete(root.right, node);\n        return root;\n    }\n\n    /**\n     * Finds the nearest point in the tree to the given point.\n     *\n     * @param point The point to find the nearest neighbor to.\n     * */\n    public Point findNearest(Point point) {\n        return findNearest(root, point, root).point;\n    }\n\n    /**\n     * Finds the nearest point in a subtree to the given point.\n     *\n     * @param root The root of the subtree to search in.\n     * @param point The point to find the nearest neighbor to.\n     * @param nearest The nearest neighbor found so far.\n     * */\n    private Node findNearest(Node root, Point point, Node nearest) {\n        if (root == null) return nearest;\n        if (root.point.equals(point)) return root;\n        int distance = Point.comparableDistance(root.point, point);\n        int distanceExceptAxis\n            = Point.comparableDistanceExceptAxis(root.point, point, root.getAxis());\n        if (distance < Point.comparableDistance(nearest.point, point)) nearest = root;\n        nearest = findNearest(root.getNearChild(point), point, nearest);\n        if (distanceExceptAxis < Point.comparableDistance(nearest.point, point))\n            nearest = findNearest(root.getFarChild(point), point, nearest);\n        return nearest;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KDTreeTest {\n\n    KDTree.Point pointOf(int x, int y) {\n        return new KDTree.Point(new int[] { x, y });\n    }\n\n    @Test\n    void findMin() {\n        int[][] coordinates = {\n            { 30, 40 },\n            { 5, 25 },\n            { 70, 70 },\n            { 10, 12 },\n            { 50, 30 },\n            { 35, 45 },\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(5, kdTree.findMin(0).getCoordinate(0));\n        assertEquals(12, kdTree.findMin(1).getCoordinate(1));\n    }\n\n    @Test\n    void delete() {\n        int[][] coordinates = {\n            { 30, 40 },\n            { 5, 25 },\n            { 70, 70 },\n            { 10, 12 },\n            { 50, 30 },\n            { 35, 45 },\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        kdTree.delete(pointOf(30, 40));\n        assertEquals(35, kdTree.getRoot().getPoint().getCoordinate(0));\n        assertEquals(45, kdTree.getRoot().getPoint().getCoordinate(1));\n    }\n\n    @Test\n    void findNearest() {\n        int[][] coordinates = {\n            { 2, 3 },\n            { 5, 4 },\n            { 9, 6 },\n            { 4, 7 },\n            { 8, 1 },\n            { 7, 2 },\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(pointOf(7, 2), kdTree.findNearest(pointOf(7, 2)));\n        assertEquals(pointOf(8, 1), kdTree.findNearest(pointOf(8, 1)));\n        assertEquals(pointOf(2, 3), kdTree.findNearest(pointOf(1, 1)));\n        assertEquals(pointOf(5, 4), kdTree.findNearest(pointOf(5, 5)));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KDTreeTest {\n\n    KDTree.Point pointOf(int x, int y) {\n        return new KDTree.Point(new int[] {x, y});\n    }\n\n    @Test\n    void findMin() {\n        int[][] coordinates = {\n            {30, 40},\n            {5, 25},\n            {70, 70},\n            {10, 12},\n            {50, 30},\n            {35, 45},\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(5, kdTree.findMin(0).getCoordinate(0));\n        assertEquals(12, kdTree.findMin(1).getCoordinate(1));\n    }\n\n    @Test\n    void delete() {\n        int[][] coordinates = {\n            {30, 40},\n            {5, 25},\n            {70, 70},\n            {10, 12},\n            {50, 30},\n            {35, 45},\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        kdTree.delete(pointOf(30, 40));\n        assertEquals(35, kdTree.getRoot().getPoint().getCoordinate(0));\n        assertEquals(45, kdTree.getRoot().getPoint().getCoordinate(1));\n    }\n\n    @Test\n    void findNearest() {\n        int[][] coordinates = {\n            {2, 3},\n            {5, 4},\n            {9, 6},\n            {4, 7},\n            {8, 1},\n            {7, 2},\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(pointOf(7, 2), kdTree.findNearest(pointOf(7, 2)));\n        assertEquals(pointOf(8, 1), kdTree.findNearest(pointOf(8, 1)));\n        assertEquals(pointOf(2, 3), kdTree.findNearest(pointOf(1, 1)));\n        assertEquals(pointOf(5, 4), kdTree.findNearest(pointOf(5, 5)));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/LazySegmentTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/LazySegmentTreeTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\npublic class LazySegmentTree {\n\n    /**\n     * Lazy Segment Tree\n     *\n     * @see\n     *\t<a href=\"https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/\">\n     */\n    static class Node {\n\n        private final int start, end; // start and end of the segment represented by this node\n        private int value; // value is the sum of all elements in the range [start, end)\n        private int lazy; // lazied value that should be added to children nodes\n        Node left, right; // left and right children\n\n        public Node(int start, int end, int value) {\n            this.start = start;\n            this.end = end;\n            this.value = value;\n            this.lazy = 0;\n            this.left = null;\n            this.right = null;\n        }\n\n        /** Update the value of this node with the given value diff.\n         *\n         * @param diff The value to add to every index of this node range.\n         */\n        public void applyUpdate(int diff) {\n            this.lazy += diff;\n            this.value += (this.end - this.start) * diff;\n        }\n\n        /** Shift the lazy value of this node to its children.\n         */\n        public void shift() {\n            if (lazy == 0) return;\n            if (this.left == null && this.right == null) return;\n            this.value += this.lazy;\n            if (this.left != null) this.left.applyUpdate(this.lazy);\n            if (this.right != null) this.right.applyUpdate(this.lazy);\n            this.lazy = 0;\n        }\n\n        /** Create a new node that is the sum of this node and the given node.\n         *\n         * @param left The left Node of merging\n         * @param right The right Node of merging\n         * @return The new Node.\n         */\n        static Node merge(Node left, Node right) {\n            if (left == null) return right;\n            if (right == null) return left;\n            Node result = new Node(\n                left.start,\n                right.end,\n                left.value + right.value\n            );\n            result.left = left;\n            result.right = right;\n            return result;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n    }\n\n    private final Node root;\n\n    /** Create a new LazySegmentTree with the given array.\n     *\n     * @param array The array to create the LazySegmentTree from.\n     */\n    public LazySegmentTree(int[] array) {\n        this.root = buildTree(array, 0, array.length);\n    }\n\n    /** Build a new LazySegmentTree from the given array in O(n) time.\n     *\n     * @param array The array to build the LazySegmentTree from.\n     * @param start The start index of the current node.\n     * @param end The end index of the current node.\n     * @return The root of the new LazySegmentTree.\n     */\n    private Node buildTree(int[] array, int start, int end) {\n        if (end - start < 2) return new Node(start, end, array[start]);\n        int mid = (start + end) >> 1;\n        Node left = buildTree(array, start, mid);\n        Node right = buildTree(array, mid, end);\n        return Node.merge(left, right);\n    }\n\n    /** Update the value of given range with the given value diff in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @param diff The value to add to every index of the range.\n     * @param curr The current node.\n     */\n    private void updateRange(int left, int right, int diff, Node curr) {\n        if (left <= curr.start && curr.end <= right) {\n            curr.applyUpdate(diff);\n            return;\n        }\n        if (left >= curr.end || right <= curr.start) return;\n        curr.shift();\n        updateRange(left, right, diff, curr.left);\n        updateRange(left, right, diff, curr.right);\n        Node merge = Node.merge(curr.left, curr.right);\n        curr.value = merge.value;\n    }\n\n    /** Get Node of given range in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @return The Node representing the sum of the given range.\n     */\n    private Node getRange(int left, int right, Node curr) {\n        if (left <= curr.start && curr.end <= right) return curr;\n        if (left >= curr.end || right <= curr.start) return null;\n        curr.shift();\n        return Node.merge(\n            getRange(left, right, curr.left),\n            getRange(left, right, curr.right)\n        );\n    }\n\n    public int getRange(int left, int right) {\n        Node result = getRange(left, right, root);\n        return result == null ? 0 : result.getValue();\n    }\n\n    public void updateRange(int left, int right, int diff) {\n        updateRange(left, right, diff, root);\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\npublic class LazySegmentTree {\n\n    /**\n     * Lazy Segment Tree\n     *\n     * @see\n     *\t<a href=\"https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/\">\n     */\n    static class Node {\n\n        private final int start, end; // start and end of the segment represented by this node\n        private int value; // value is the sum of all elements in the range [start, end)\n        private int lazy; // lazied value that should be added to children nodes\n        Node left, right; // left and right children\n\n        public Node(int start, int end, int value) {\n            this.start = start;\n            this.end = end;\n            this.value = value;\n            this.lazy = 0;\n            this.left = null;\n            this.right = null;\n        }\n\n        /**\n         * Update the value of this node with the given value diff.\n         *\n         * @param diff The value to add to every index of this node range.\n         */\n        public void applyUpdate(int diff) {\n            this.lazy += diff;\n            this.value += (this.end - this.start) * diff;\n        }\n\n        /**\n         * Shift the lazy value of this node to its children.\n         */\n        public void shift() {\n            if (lazy == 0) return;\n            if (this.left == null && this.right == null) return;\n            this.value += this.lazy;\n            if (this.left != null) this.left.applyUpdate(this.lazy);\n            if (this.right != null) this.right.applyUpdate(this.lazy);\n            this.lazy = 0;\n        }\n\n        /**\n         * Create a new node that is the sum of this node and the given node.\n         *\n         * @param left The left Node of merging\n         * @param right The right Node of merging\n         * @return The new Node.\n         */\n        static Node merge(Node left, Node right) {\n            if (left == null) return right;\n            if (right == null) return left;\n            Node result = new Node(left.start, right.end, left.value + right.value);\n            result.left = left;\n            result.right = right;\n            return result;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n    }\n\n    private final Node root;\n\n    /**\n     * Create a new LazySegmentTree with the given array.\n     *\n     * @param array The array to create the LazySegmentTree from.\n     */\n    public LazySegmentTree(int[] array) {\n        this.root = buildTree(array, 0, array.length);\n    }\n\n    /**\n     * Build a new LazySegmentTree from the given array in O(n) time.\n     *\n     * @param array The array to build the LazySegmentTree from.\n     * @param start The start index of the current node.\n     * @param end The end index of the current node.\n     * @return The root of the new LazySegmentTree.\n     */\n    private Node buildTree(int[] array, int start, int end) {\n        if (end - start < 2) return new Node(start, end, array[start]);\n        int mid = (start + end) >> 1;\n        Node left = buildTree(array, start, mid);\n        Node right = buildTree(array, mid, end);\n        return Node.merge(left, right);\n    }\n\n    /**\n     * Update the value of given range with the given value diff in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @param diff The value to add to every index of the range.\n     * @param curr The current node.\n     */\n    private void updateRange(int left, int right, int diff, Node curr) {\n        if (left <= curr.start && curr.end <= right) {\n            curr.applyUpdate(diff);\n            return;\n        }\n        if (left >= curr.end || right <= curr.start) return;\n        curr.shift();\n        updateRange(left, right, diff, curr.left);\n        updateRange(left, right, diff, curr.right);\n        Node merge = Node.merge(curr.left, curr.right);\n        curr.value = merge.value;\n    }\n\n    /**\n     * Get Node of given range in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @return The Node representing the sum of the given range.\n     */\n    private Node getRange(int left, int right, Node curr) {\n        if (left <= curr.start && curr.end <= right) return curr;\n        if (left >= curr.end || right <= curr.start) return null;\n        curr.shift();\n        return Node.merge(getRange(left, right, curr.left), getRange(left, right, curr.right));\n    }\n\n    public int getRange(int left, int right) {\n        Node result = getRange(left, right, root);\n        return result == null ? 0 : result.getValue();\n    }\n\n    public void updateRange(int left, int right, int diff) {\n        updateRange(left, right, diff, root);\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++) for (int j = i + 1; j < 10; j++) {\n            lazySegmentTree.updateRange(i, j, 1);\n            assertEquals(j - i, lazySegmentTree.getRange(i, j));\n            lazySegmentTree.updateRange(i, j, -1);\n            assertEquals(0, lazySegmentTree.getRange(i, j));\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++)\n            for (int j = i + 1; j < 10; j++) {\n                lazySegmentTree.updateRange(i, j, 1);\n                assertEquals(j - i, lazySegmentTree.getRange(i, j));\n                lazySegmentTree.updateRange(i, j, -1);\n                assertEquals(0, lazySegmentTree.getRange(i, j));\n            }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/SameTreesCheck.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/SameTreesCheckTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * Given 2 binary trees.\n * This code checks whether they are the same (structurally identical and have the same values) or not.\n * <p>\n * Example:\n * 1. Binary trees:\n *      1                 1\n *     / \\               / \\\n *    2   3             2   3\n *   /\\   /\\           /\\   /\\\n *  4  5 6  7         4  5 6  7\n * These trees are the same, so the code returns 'true'.\n * <p>\n * 2. Binary trees:\n *      1   1\n *     /     \\\n *    2       2\n * These trees are NOT the same (the structure differs), so the code returns 'false'.\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm.\n * For each tree we create a queue and iterate the trees using these queues.\n * On each step we check the nodes for equality, and if the nodes are not the same, return false.\n * Otherwise, add children nodes to the queues and continue traversing the trees.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree,\n * O(N) - space, where N is the number of nodes in a binary tree.\n *\n * @author Albina Gimaletdinova on 13/01/2023\n */\npublic class SameTreesCheck {\n    public static boolean check(BinaryTree.Node p, BinaryTree.Node q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n\n        Deque<BinaryTree.Node> q1 = new ArrayDeque<>();\n        Deque<BinaryTree.Node> q2 = new ArrayDeque<>();\n        q1.add(p);\n        q2.add(q);\n        while (!q1.isEmpty() && !q2.isEmpty()) {\n            BinaryTree.Node first = q1.poll();\n            BinaryTree.Node second = q2.poll();\n            // check that some node can be null\n            // if the check is true: both nodes are null or both nodes are not null\n            if (!equalNodes(first, second)) return false;\n\n            if (first != null) {\n                if (!equalNodes(first.left, second.left)) return false;\n                if (first.left != null) {\n                    q1.add(first.left);\n                    q2.add(second.left);\n                }\n\n                if (!equalNodes(first.right, second.right)) return false;\n                if (first.right != null) {\n                    q1.add(first.right);\n                    q2.add(second.right);\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean equalNodes(BinaryTree.Node p, BinaryTree.Node q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.data == q.data;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * Given 2 binary trees.\n * This code checks whether they are the same (structurally identical and have the same values) or\n * not. <p> Example:\n * 1. Binary trees:\n *      1                 1\n *     / \\               / \\\n *    2   3             2   3\n *   /\\   /\\           /\\   /\\\n *  4  5 6  7         4  5 6  7\n * These trees are the same, so the code returns 'true'.\n * <p>\n * 2. Binary trees:\n *      1   1\n *     /     \\\n *    2       2\n * These trees are NOT the same (the structure differs), so the code returns 'false'.\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm.\n * For each tree we create a queue and iterate the trees using these queues.\n * On each step we check the nodes for equality, and if the nodes are not the same, return false.\n * Otherwise, add children nodes to the queues and continue traversing the trees.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree,\n * O(N) - space, where N is the number of nodes in a binary tree.\n *\n * @author Albina Gimaletdinova on 13/01/2023\n */\npublic class SameTreesCheck {\n    public static boolean check(BinaryTree.Node p, BinaryTree.Node q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n\n        Deque<BinaryTree.Node> q1 = new ArrayDeque<>();\n        Deque<BinaryTree.Node> q2 = new ArrayDeque<>();\n        q1.add(p);\n        q2.add(q);\n        while (!q1.isEmpty() && !q2.isEmpty()) {\n            BinaryTree.Node first = q1.poll();\n            BinaryTree.Node second = q2.poll();\n            // check that some node can be null\n            // if the check is true: both nodes are null or both nodes are not null\n            if (!equalNodes(first, second)) return false;\n\n            if (first != null) {\n                if (!equalNodes(first.left, second.left)) return false;\n                if (first.left != null) {\n                    q1.add(first.left);\n                    q2.add(second.left);\n                }\n\n                if (!equalNodes(first.right, second.right)) return false;\n                if (first.right != null) {\n                    q1.add(first.right);\n                    q2.add(second.right);\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean equalNodes(BinaryTree.Node p, BinaryTree.Node q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.data == q.data;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author Albina Gimaletdinova on 12/01/2023\n */\npublic class SameTreesCheckTest {\n    @Test\n    public void testBothRootsAreNull() {\n        assertTrue(SameTreesCheck.check(null, null));\n    }\n\n    @Test\n    public void testOneRootIsNull() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{100});\n        assertFalse(SameTreesCheck.check(root, null));\n    }\n\n    @Test\n    public void testSingleNodeTreesAreSame() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{100});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{100});\n        assertTrue(SameTreesCheck.check(p, q));\n    }\n\n    /*\n         1                 1\n        / \\               / \\\n       2   3             2   3\n      /\\   /\\           /\\   /\\\n     4  5 6  7         4  5 6  7\n     */\n    @Test\n    public void testSameTreesIsSuccessful() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertTrue(SameTreesCheck.check(p, q));\n    }\n\n\n    /*\n         1                 1\n        / \\               / \\\n       2   3             2   3\n      /\\   /\\           /\\   /\n     4  5 6  7         4  5 6\n     */\n    @Test\n    public void testSameTreesFails() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6});\n        assertFalse(SameTreesCheck.check(p, q));\n    }\n\n    /*\n       1    1\n      /      \\\n     2        2\n     */\n    @Test\n    public void testTreesWithDifferentStructure() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{1, 2});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{1, null, 2});\n        assertFalse(SameTreesCheck.check(p, q));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 12/01/2023\n */\npublic class SameTreesCheckTest {\n    @Test\n    public void testBothRootsAreNull() {\n        assertTrue(SameTreesCheck.check(null, null));\n    }\n\n    @Test\n    public void testOneRootIsNull() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {100});\n        assertFalse(SameTreesCheck.check(root, null));\n    }\n\n    @Test\n    public void testSingleNodeTreesAreSame() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[] {100});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[] {100});\n        assertTrue(SameTreesCheck.check(p, q));\n    }\n\n    /*\n         1                 1\n        / \\               / \\\n       2   3             2   3\n      /\\   /\\           /\\   /\\\n     4  5 6  7         4  5 6  7\n     */\n    @Test\n    public void testSameTreesIsSuccessful() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[] {1, 2, 3, 4, 5, 6, 7});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[] {1, 2, 3, 4, 5, 6, 7});\n        assertTrue(SameTreesCheck.check(p, q));\n    }\n\n    /*\n         1                 1\n        / \\               / \\\n       2   3             2   3\n      /\\   /\\           /\\   /\n     4  5 6  7         4  5 6\n     */\n    @Test\n    public void testSameTreesFails() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[] {1, 2, 3, 4, 5, 6, 7});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[] {1, 2, 3, 4, 5, 6});\n        assertFalse(SameTreesCheck.check(p, q));\n    }\n\n    /*\n       1    1\n      /      \\\n     2        2\n     */\n    @Test\n    public void testTreesWithDifferentStructure() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[] {1, 2});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[] {1, null, 2});\n        assertFalse(SameTreesCheck.check(p, q));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/SegmentTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/LazySegmentTreeTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\npublic class SegmentTree {\n\n    private int[] seg_t;\n    private int n;\n    private int[] arr;\n\n    /* Constructor which takes the size of the array and the array as a parameter*/\n    public SegmentTree(int n, int[] arr) {\n        this.n = n;\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n        int seg_size = 2 * (int) Math.pow(2, x) - 1;\n\n        this.seg_t = new int[seg_size];\n        this.arr = arr;\n        this.n = n;\n        constructTree(arr, 0, n - 1, 0);\n    }\n\n    /* A function which will create the segment tree*/\n    public int constructTree(int[] arr, int start, int end, int index) {\n        if (start == end) {\n            this.seg_t[index] = arr[start];\n            return arr[start];\n        }\n\n        int mid = start + (end - start) / 2;\n        this.seg_t[index] =\n            constructTree(arr, start, mid, index * 2 + 1) +\n            constructTree(arr, mid + 1, end, index * 2 + 2);\n        return this.seg_t[index];\n    }\n\n    /* A function which will update the value at a index i. This will be called by the\n    update function internally*/\n    private void updateTree(\n        int start,\n        int end,\n        int index,\n        int diff,\n        int seg_index\n    ) {\n        if (index < start || index > end) {\n            return;\n        }\n\n        this.seg_t[seg_index] += diff;\n        if (start != end) {\n            int mid = start + (end - start) / 2;\n            updateTree(start, mid, index, diff, seg_index * 2 + 1);\n            updateTree(mid + 1, end, index, diff, seg_index * 2 + 2);\n        }\n    }\n\n    /* A function to update the value at a particular index*/\n    public void update(int index, int value) {\n        if (index < 0 || index > n) {\n            return;\n        }\n\n        int diff = value - arr[index];\n        arr[index] = value;\n        updateTree(0, n - 1, index, diff, 0);\n    }\n\n    /* A function to get the sum of the elements from index l to index r. This will be called internally*/\n    private int getSumTree(\n        int start,\n        int end,\n        int q_start,\n        int q_end,\n        int seg_index\n    ) {\n        if (q_start <= start && q_end >= end) {\n            return this.seg_t[seg_index];\n        }\n\n        if (q_start > end || q_end < start) {\n            return 0;\n        }\n\n        int mid = start + (end - start) / 2;\n        return (\n            getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) +\n            getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2)\n        );\n    }\n\n    /* A function to query the sum of the subarray [start...end]*/\n    public int getSum(int start, int end) {\n        if (start < 0 || end > n || start > end) {\n            return 0;\n        }\n        return getSumTree(0, n - 1, start, end, 0);\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\npublic class SegmentTree {\n\n    private int[] seg_t;\n    private int n;\n    private int[] arr;\n\n    /* Constructor which takes the size of the array and the array as a parameter*/\n    public SegmentTree(int n, int[] arr) {\n        this.n = n;\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n        int seg_size = 2 * (int) Math.pow(2, x) - 1;\n\n        this.seg_t = new int[seg_size];\n        this.arr = arr;\n        this.n = n;\n        constructTree(arr, 0, n - 1, 0);\n    }\n\n    /* A function which will create the segment tree*/\n    public int constructTree(int[] arr, int start, int end, int index) {\n        if (start == end) {\n            this.seg_t[index] = arr[start];\n            return arr[start];\n        }\n\n        int mid = start + (end - start) / 2;\n        this.seg_t[index] = constructTree(arr, start, mid, index * 2 + 1)\n            + constructTree(arr, mid + 1, end, index * 2 + 2);\n        return this.seg_t[index];\n    }\n\n    /* A function which will update the value at a index i. This will be called by the\n    update function internally*/\n    private void updateTree(int start, int end, int index, int diff, int seg_index) {\n        if (index < start || index > end) {\n            return;\n        }\n\n        this.seg_t[seg_index] += diff;\n        if (start != end) {\n            int mid = start + (end - start) / 2;\n            updateTree(start, mid, index, diff, seg_index * 2 + 1);\n            updateTree(mid + 1, end, index, diff, seg_index * 2 + 2);\n        }\n    }\n\n    /* A function to update the value at a particular index*/\n    public void update(int index, int value) {\n        if (index < 0 || index > n) {\n            return;\n        }\n\n        int diff = value - arr[index];\n        arr[index] = value;\n        updateTree(0, n - 1, index, diff, 0);\n    }\n\n    /* A function to get the sum of the elements from index l to index r. This will be called\n     * internally*/\n    private int getSumTree(int start, int end, int q_start, int q_end, int seg_index) {\n        if (q_start <= start && q_end >= end) {\n            return this.seg_t[seg_index];\n        }\n\n        if (q_start > end || q_end < start) {\n            return 0;\n        }\n\n        int mid = start + (end - start) / 2;\n        return (getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1)\n            + getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2));\n    }\n\n    /* A function to query the sum of the subarray [start...end]*/\n    public int getSum(int start, int end) {\n        if (start < 0 || end > n || start > end) {\n            return 0;\n        }\n        return getSumTree(0, n - 1, start, end, 0);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++) for (int j = i + 1; j < 10; j++) {\n            lazySegmentTree.updateRange(i, j, 1);\n            assertEquals(j - i, lazySegmentTree.getRange(i, j));\n            lazySegmentTree.updateRange(i, j, -1);\n            assertEquals(0, lazySegmentTree.getRange(i, j));\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++)\n            for (int j = i + 1; j < 10; j++) {\n                lazySegmentTree.updateRange(i, j, 1);\n                assertEquals(j - i, lazySegmentTree.getRange(i, j));\n                lazySegmentTree.updateRange(i, j, -1);\n                assertEquals(0, lazySegmentTree.getRange(i, j));\n            }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/VerticalOrderTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/VerticalOrderTraversalTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\n\n/* The following class implements a vertical order traversal\nin a tree from top to bottom and left to right, so for a tree :\n           1\n          / \\\n         2   3\n        / \\   \\\n       4   5   6\n        \\     / \\\n         7   8   10\n          \\\n           9\n the sequence will be :\n 4 2 7 1 5 9 3 8 6 10\n */\npublic class VerticalOrderTraversal {\n\n    /*Function that receives a root Node and prints the tree\n\tin Vertical Order.*/\n    public static ArrayList<Integer> verticalTraversal(BinaryTree.Node root) {\n        if (root == null) {\n            return new ArrayList<>();\n        }\n\n        /*Queue to store the Nodes.*/\n        Queue<BinaryTree.Node> queue = new LinkedList<>();\n\n        /*Queue to store the index of particular vertical \n\t\t column of a tree , with root at 0, Nodes on left \n\t\t with negative index and Nodes on right with positive\n\t\t index. */\n        Queue<Integer> index = new LinkedList<>();\n\n        /*Map of Integer and ArrayList to store all the \n\t\t elements in a particular index in a single arrayList\n\t\t that will have a key equal to the index itself. */\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\n\n        /* min and max stores leftmost and right most index to\n\t\t later print the tree in vertical fashion.*/\n        int max = 0, min = 0;\n        queue.offer(root);\n        index.offer(0);\n\n        while (!queue.isEmpty()) {\n            if (queue.peek().left != null) {\n                /*Adding the left Node if it is not null\n\t\t\t\tand its index by subtracting 1 from it's \n\t\t\t\tparent's index*/\n                queue.offer(queue.peek().left);\n                index.offer(index.peek() - 1);\n            }\n            if (queue.peek().right != null) {\n                /*Adding the right Node if it is not null\n\t\t\t\tand its index by adding 1 from it's \n\t\t\t\tparent's index*/\n                queue.offer(queue.peek().right);\n                index.offer(index.peek() + 1);\n            }\n            /*If the map does not contains the index a new\n\t\t\t ArrayList is created with the index as key.*/\n            if (!map.containsKey(index.peek())) {\n                ArrayList<Integer> a = new ArrayList<>();\n                map.put(index.peek(), a);\n            }\n            /*For a index, corresponding Node data is added\n\t\t\t to the respective ArrayList present at that\n\t\t\t index. */\n            map.get(index.peek()).add(queue.peek().data);\n            max = Math.max(max, index.peek());\n            min = Math.min(min, index.peek());\n            /*The Node and its index are removed\n\t\t\t from their respective queues.*/\n            index.poll();\n            queue.poll();\n        }\n        /*Finally map data is printed here which has keys\n\t\tfrom min to max. Each ArrayList represents a\n\t\tvertical column that is added in ans ArrayList.*/\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) {\n            ans.addAll(map.get(i));\n        }\n        return ans;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\n\n/* The following class implements a vertical order traversal\nin a tree from top to bottom and left to right, so for a tree :\n           1\n          / \\\n         2   3\n        / \\   \\\n       4   5   6\n        \\     / \\\n         7   8   10\n          \\\n           9\n the sequence will be :\n 4 2 7 1 5 9 3 8 6 10\n */\npublic class VerticalOrderTraversal {\n\n    /*Function that receives a root Node and prints the tree\n        in Vertical Order.*/\n    public static ArrayList<Integer> verticalTraversal(BinaryTree.Node root) {\n        if (root == null) {\n            return new ArrayList<>();\n        }\n\n        /*Queue to store the Nodes.*/\n        Queue<BinaryTree.Node> queue = new LinkedList<>();\n\n        /*Queue to store the index of particular vertical\n                 column of a tree , with root at 0, Nodes on left\n                 with negative index and Nodes on right with positive\n                 index. */\n        Queue<Integer> index = new LinkedList<>();\n\n        /*Map of Integer and ArrayList to store all the\n                 elements in a particular index in a single arrayList\n                 that will have a key equal to the index itself. */\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\n\n        /* min and max stores leftmost and right most index to\n                 later print the tree in vertical fashion.*/\n        int max = 0, min = 0;\n        queue.offer(root);\n        index.offer(0);\n\n        while (!queue.isEmpty()) {\n            if (queue.peek().left != null) {\n                /*Adding the left Node if it is not null\n                                and its index by subtracting 1 from it's\n                                parent's index*/\n                queue.offer(queue.peek().left);\n                index.offer(index.peek() - 1);\n            }\n            if (queue.peek().right != null) {\n                /*Adding the right Node if it is not null\n                                and its index by adding 1 from it's\n                                parent's index*/\n                queue.offer(queue.peek().right);\n                index.offer(index.peek() + 1);\n            }\n            /*If the map does not contains the index a new\n                         ArrayList is created with the index as key.*/\n            if (!map.containsKey(index.peek())) {\n                ArrayList<Integer> a = new ArrayList<>();\n                map.put(index.peek(), a);\n            }\n            /*For a index, corresponding Node data is added\n                         to the respective ArrayList present at that\n                         index. */\n            map.get(index.peek()).add(queue.peek().data);\n            max = Math.max(max, index.peek());\n            min = Math.min(min, index.peek());\n            /*The Node and its index are removed\n                         from their respective queues.*/\n            index.poll();\n            queue.poll();\n        }\n        /*Finally map data is printed here which has keys\n                from min to max. Each ArrayList represents a\n                vertical column that is added in ans ArrayList.*/\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) {\n            ans.addAll(map.get(i));\n        }\n        return ans;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 13/01/2023\n */\npublic class VerticalOrderTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), VerticalOrderTraversal.verticalTraversal(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{50});\n        assertEquals(List.of(50), VerticalOrderTraversal.verticalTraversal(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testVerticalTraversalCompleteTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(4, 2, 1, 5, 6, 3, 7), VerticalOrderTraversal.verticalTraversal(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n        /  \\\n       8    9\n    */\n    @Test\n    public void testVerticalTraversalDifferentHeight() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(\n                new Integer[]{1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9});\n        assertEquals(List.of(4, 2, 8, 1, 5, 6, 3, 9, 7), VerticalOrderTraversal.verticalTraversal(root));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 13/01/2023\n */\npublic class VerticalOrderTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), VerticalOrderTraversal.verticalTraversal(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {50});\n        assertEquals(List.of(50), VerticalOrderTraversal.verticalTraversal(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testVerticalTraversalCompleteTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(4, 2, 1, 5, 6, 3, 7), VerticalOrderTraversal.verticalTraversal(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n        /  \\\n       8    9\n    */\n    @Test\n    public void testVerticalTraversalDifferentHeight() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(\n            new Integer[] {1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9});\n        assertEquals(\n            List.of(4, 2, 8, 1, 5, 6, 3, 9, 7), VerticalOrderTraversal.verticalTraversal(root));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/ZigzagTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/ZigzagTraversalTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.*;\n\n/**\n * Given a binary tree.\n * This code returns the zigzag level order traversal of its nodes' values.\n * Binary tree:\n *                               7\n *                   /                         \\\n *                6                           3\n *         /                \\             /             \\\n *      2                    4         10                19\n * Zigzag traversal:\n * [[7], [3, 6], [2, 4, 10, 19]]\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm using a queue.\n * 1. The algorithm starts with a root node. This node is added to a queue.\n * 2. While the queue is not empty:\n *  - each time we enter the while-loop we get queue size. Queue size refers to the number of nodes at the current level.\n *  - we traverse all the level nodes in 2 ways: from left to right OR from right to left\n *    (this state is stored on `prevLevelFromLeftToRight` variable)\n *  - if the current node has children we add them to a queue\n *  - add level with nodes to a result.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree\n * O(N) - space, where N is the number of nodes in a binary tree\n *\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversal {\n    public static List<List<Integer>> traverse(BinaryTree.Node root) {\n        if (root == null) {\n            return List.of();\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        // create a queue\n        Deque<BinaryTree.Node> q = new ArrayDeque<>();\n        q.offer(root);\n        // start with writing nodes from left to right\n        boolean prevLevelFromLeftToRight = false;\n\n        while (!q.isEmpty()) {\n            int nodesOnLevel = q.size();\n            List<Integer> level = new LinkedList<>();\n            // traverse all the level nodes\n            for (int i = 0; i < nodesOnLevel; i++) {\n                BinaryTree.Node node = q.poll();\n                if (prevLevelFromLeftToRight) {\n                    level.add(0, node.data);\n                } else {\n                    level.add(node.data);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            // the next level node traversal will be from the other side\n            prevLevelFromLeftToRight = !prevLevelFromLeftToRight;\n            result.add(level);\n        }\n        return result;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.*;\n\n/**\n * Given a binary tree.\n * This code returns the zigzag level order traversal of its nodes' values.\n * Binary tree:\n *                               7\n *                   /                         \\\n *                6                           3\n *         /                \\             /             \\\n *      2                    4         10                19\n * Zigzag traversal:\n * [[7], [3, 6], [2, 4, 10, 19]]\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm using a queue.\n * 1. The algorithm starts with a root node. This node is added to a queue.\n * 2. While the queue is not empty:\n *  - each time we enter the while-loop we get queue size. Queue size refers to the number of nodes\n * at the current level.\n *  - we traverse all the level nodes in 2 ways: from left to right OR from right to left\n *    (this state is stored on `prevLevelFromLeftToRight` variable)\n *  - if the current node has children we add them to a queue\n *  - add level with nodes to a result.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree\n * O(N) - space, where N is the number of nodes in a binary tree\n *\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversal {\n    public static List<List<Integer>> traverse(BinaryTree.Node root) {\n        if (root == null) {\n            return List.of();\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        // create a queue\n        Deque<BinaryTree.Node> q = new ArrayDeque<>();\n        q.offer(root);\n        // start with writing nodes from left to right\n        boolean prevLevelFromLeftToRight = false;\n\n        while (!q.isEmpty()) {\n            int nodesOnLevel = q.size();\n            List<Integer> level = new LinkedList<>();\n            // traverse all the level nodes\n            for (int i = 0; i < nodesOnLevel; i++) {\n                BinaryTree.Node node = q.poll();\n                if (prevLevelFromLeftToRight) {\n                    level.add(0, node.data);\n                } else {\n                    level.add(node.data);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            // the next level node traversal will be from the other side\n            prevLevelFromLeftToRight = !prevLevelFromLeftToRight;\n            result.add(level);\n        }\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), ZigzagTraversal.traverse(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{50});\n        assertEquals(List.of(List.of(50)), ZigzagTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testZigzagTraversalCompleteTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7)), ZigzagTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n        /  \\\n       8    9\n    */\n    @Test\n    public void testZigzagTraversalDifferentHeight() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(\n                new Integer[]{1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9});\n        assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7), List.of(9, 8)),\n                ZigzagTraversal.traverse(root));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.Collections;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), ZigzagTraversal.traverse(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {50});\n        assertEquals(List.of(List.of(50)), ZigzagTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testZigzagTraversalCompleteTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7)),\n            ZigzagTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n        /  \\\n       8    9\n    */\n    @Test\n    public void testZigzagTraversalDifferentHeight() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(\n            new Integer[] {1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9});\n        assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7), List.of(9, 8)),\n            ZigzagTraversal.traverse(root));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/divideandconquer/BinaryExponentiation.java",
        "test_file_path": "src/test/java/com/thealgorithms/divideandconquer/BinaryExponentiationTest.java",
        "product_old_content": "package com.thealgorithms.divideandconquer;\n\n// Java Program to Implement Binary Exponentiation (power in log n)\n\n/*\n * Binary Exponentiation is a method to calculate a to the power of b.\n * It is used to calculate a^n in O(log n) time.\n * \n * Reference:\n * https://iq.opengenus.org/binary-exponentiation/\n */\n\npublic class BinaryExponentiation {\n\n    // recursive function to calculate a to the power of b\n    public static long calculatePower(long x, long y) {\n        if (y == 0) {\n            return 1;\n        }\n        long val = calculatePower(x, y / 2);\n        if (y % 2 == 0) {\n            return val * val;\n        }\n        return val * val * x;\n    }\n\n    // iterative function to calculate a to the power of b\n    long power(long N, long M) {\n        long power = N, sum = 1;\n        while (M > 0) {\n            if ((M & 1) == 1) {\n                sum *= power;\n            }\n            power = power * power;\n            M = M >> 1;\n        }\n        return sum;\n    }\n}",
        "product_new_content": "package com.thealgorithms.divideandconquer;\n\n// Java Program to Implement Binary Exponentiation (power in log n)\n\n/*\n * Binary Exponentiation is a method to calculate a to the power of b.\n * It is used to calculate a^n in O(log n) time.\n *\n * Reference:\n * https://iq.opengenus.org/binary-exponentiation/\n */\n\npublic class BinaryExponentiation {\n\n    // recursive function to calculate a to the power of b\n    public static long calculatePower(long x, long y) {\n        if (y == 0) {\n            return 1;\n        }\n        long val = calculatePower(x, y / 2);\n        if (y % 2 == 0) {\n            return val * val;\n        }\n        return val * val * x;\n    }\n\n    // iterative function to calculate a to the power of b\n    long power(long N, long M) {\n        long power = N, sum = 1;\n        while (M > 0) {\n            if ((M & 1) == 1) {\n                sum *= power;\n            }\n            power = power * power;\n            M = M >> 1;\n        }\n        return sum;\n    }\n}",
        "test_old_content": "package com.thealgorithms.divideandconquer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BinaryExponentiationTest {\n\n    @Test\n    public void testCalculatePower() {\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000000000L));\n    }\n\n    @Test\n    public void testPower() {\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000000000L));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.divideandconquer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BinaryExponentiationTest {\n\n    @Test\n    public void testCalculatePower() {\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000000000L));\n    }\n\n    @Test\n    public void testPower() {\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000000000L));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/divideandconquer/StrassenMatrixMultiplication.java",
        "test_file_path": "src/test/java/com/thealgorithms/divideandconquer/StrassenMatrixMultiplicationTest.java",
        "product_old_content": "package com.thealgorithms.divideandconquer;\n\n// Java Program to Implement Strassen Algorithm for Matrix Multiplication\n\n/*\n * Uses the divide and conquer approach to multiply two matrices.\n * Time Complexity: O(n^2.8074) better than the O(n^3) of the standard matrix multiplication algorithm.\n * Space Complexity: O(n^2)\n * \n * This Matrix multiplication can be performed only on square matrices \n * where n is a power of 2. Order of both of the matrices are n \u00d7 n.\n * \n * Reference:\n * https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_strassens_matrix_multiplication.htm#:~:text=Strassen's%20Matrix%20multiplication%20can%20be,matrices%20are%20n%20%C3%97%20n.\n * https://www.geeksforgeeks.org/strassens-matrix-multiplication/\n */\n\npublic class StrassenMatrixMultiplication {\n\n    // Function to multiply matrices\n    public int[][] multiply(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] R = new int[n][n];\n\n        if (n == 1) {\n            R[0][0] = A[0][0] * B[0][0];\n        } else {\n            // Dividing Matrix into parts\n            // by storing sub-parts to variables\n            int[][] A11 = new int[n / 2][n / 2];\n            int[][] A12 = new int[n / 2][n / 2];\n            int[][] A21 = new int[n / 2][n / 2];\n            int[][] A22 = new int[n / 2][n / 2];\n            int[][] B11 = new int[n / 2][n / 2];\n            int[][] B12 = new int[n / 2][n / 2];\n            int[][] B21 = new int[n / 2][n / 2];\n            int[][] B22 = new int[n / 2][n / 2];\n\n            // Dividing matrix A into 4 parts\n            split(A, A11, 0, 0);\n            split(A, A12, 0, n / 2);\n            split(A, A21, n / 2, 0);\n            split(A, A22, n / 2, n / 2);\n\n            // Dividing matrix B into 4 parts\n            split(B, B11, 0, 0);\n            split(B, B12, 0, n / 2);\n            split(B, B21, n / 2, 0);\n            split(B, B22, n / 2, n / 2);\n\n            // Using Formulas as described in algorithm\n            // M1:=(A1+A3)\u00d7(B1+B2)\n            int[][] M1 = multiply(add(A11, A22), add(B11, B22));\n\n            // M2:=(A2+A4)\u00d7(B3+B4)\n            int[][] M2 = multiply(add(A21, A22), B11);\n\n            // M3:=(A1\u2212A4)\u00d7(B1+A4)\n            int[][] M3 = multiply(A11, sub(B12, B22));\n\n            // M4:=A1\u00d7(B2\u2212B4)\n            int[][] M4 = multiply(A22, sub(B21, B11));\n\n            // M5:=(A3+A4)\u00d7(B1)\n            int[][] M5 = multiply(add(A11, A12), B22);\n\n            // M6:=(A1+A2)\u00d7(B4)\n            int[][] M6 = multiply(sub(A21, A11), add(B11, B12));\n\n            // M7:=A4\u00d7(B3\u2212B1)\n            int[][] M7 = multiply(sub(A12, A22), add(B21, B22));\n\n            // P:=M2+M3\u2212M6\u2212M7\n            int[][] C11 = add(sub(add(M1, M4), M5), M7);\n\n            // Q:=M4+M6\n            int[][] C12 = add(M3, M5);\n\n            // R:=M5+M7\n            int[][] C21 = add(M2, M4);\n\n            // S:=M1\u2212M3\u2212M4\u2212M5\n            int[][] C22 = add(sub(add(M1, M3), M2), M6);\n\n            join(C11, R, 0, 0);\n            join(C12, R, 0, n / 2);\n            join(C21, R, n / 2, 0);\n            join(C22, R, n / 2, n / 2);\n        }\n\n        return R;\n    }\n\n    // Function to subtract two matrices\n    public int[][] sub(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] - B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Function to add two matrices\n    public int[][] add(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] + B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Function to split parent matrix into child matrices\n    public void split(int[][] P, int[][] C, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                C[i1][j1] = P[i2][j2];\n            }\n        }\n    }\n\n    // Function to join child matrices into (to) parent matrix\n    public void join(int[][] C, int[][] P, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                P[i2][j2] = C[i1][j1];\n            }\n        }\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.divideandconquer;\n\n// Java Program to Implement Strassen Algorithm for Matrix Multiplication\n\n/*\n * Uses the divide and conquer approach to multiply two matrices.\n * Time Complexity: O(n^2.8074) better than the O(n^3) of the standard matrix multiplication\n * algorithm. Space Complexity: O(n^2)\n *\n * This Matrix multiplication can be performed only on square matrices\n * where n is a power of 2. Order of both of the matrices are n \u00d7 n.\n *\n * Reference:\n * https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_strassens_matrix_multiplication.htm#:~:text=Strassen's%20Matrix%20multiplication%20can%20be,matrices%20are%20n%20%C3%97%20n.\n * https://www.geeksforgeeks.org/strassens-matrix-multiplication/\n */\n\npublic class StrassenMatrixMultiplication {\n\n    // Function to multiply matrices\n    public int[][] multiply(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] R = new int[n][n];\n\n        if (n == 1) {\n            R[0][0] = A[0][0] * B[0][0];\n        } else {\n            // Dividing Matrix into parts\n            // by storing sub-parts to variables\n            int[][] A11 = new int[n / 2][n / 2];\n            int[][] A12 = new int[n / 2][n / 2];\n            int[][] A21 = new int[n / 2][n / 2];\n            int[][] A22 = new int[n / 2][n / 2];\n            int[][] B11 = new int[n / 2][n / 2];\n            int[][] B12 = new int[n / 2][n / 2];\n            int[][] B21 = new int[n / 2][n / 2];\n            int[][] B22 = new int[n / 2][n / 2];\n\n            // Dividing matrix A into 4 parts\n            split(A, A11, 0, 0);\n            split(A, A12, 0, n / 2);\n            split(A, A21, n / 2, 0);\n            split(A, A22, n / 2, n / 2);\n\n            // Dividing matrix B into 4 parts\n            split(B, B11, 0, 0);\n            split(B, B12, 0, n / 2);\n            split(B, B21, n / 2, 0);\n            split(B, B22, n / 2, n / 2);\n\n            // Using Formulas as described in algorithm\n            // M1:=(A1+A3)\u00d7(B1+B2)\n            int[][] M1 = multiply(add(A11, A22), add(B11, B22));\n\n            // M2:=(A2+A4)\u00d7(B3+B4)\n            int[][] M2 = multiply(add(A21, A22), B11);\n\n            // M3:=(A1\u2212A4)\u00d7(B1+A4)\n            int[][] M3 = multiply(A11, sub(B12, B22));\n\n            // M4:=A1\u00d7(B2\u2212B4)\n            int[][] M4 = multiply(A22, sub(B21, B11));\n\n            // M5:=(A3+A4)\u00d7(B1)\n            int[][] M5 = multiply(add(A11, A12), B22);\n\n            // M6:=(A1+A2)\u00d7(B4)\n            int[][] M6 = multiply(sub(A21, A11), add(B11, B12));\n\n            // M7:=A4\u00d7(B3\u2212B1)\n            int[][] M7 = multiply(sub(A12, A22), add(B21, B22));\n\n            // P:=M2+M3\u2212M6\u2212M7\n            int[][] C11 = add(sub(add(M1, M4), M5), M7);\n\n            // Q:=M4+M6\n            int[][] C12 = add(M3, M5);\n\n            // R:=M5+M7\n            int[][] C21 = add(M2, M4);\n\n            // S:=M1\u2212M3\u2212M4\u2212M5\n            int[][] C22 = add(sub(add(M1, M3), M2), M6);\n\n            join(C11, R, 0, 0);\n            join(C12, R, 0, n / 2);\n            join(C21, R, n / 2, 0);\n            join(C22, R, n / 2, n / 2);\n        }\n\n        return R;\n    }\n\n    // Function to subtract two matrices\n    public int[][] sub(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] - B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Function to add two matrices\n    public int[][] add(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] + B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Function to split parent matrix into child matrices\n    public void split(int[][] P, int[][] C, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                C[i1][j1] = P[i2][j2];\n            }\n        }\n    }\n\n    // Function to join child matrices into (to) parent matrix\n    public void join(int[][] C, int[][] P, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                P[i2][j2] = C[i1][j1];\n            }\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.divideandconquer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass StrassenMatrixMultiplicationTest {\n\n    StrassenMatrixMultiplication SMM = new StrassenMatrixMultiplication();\n\n    // Strassen Matrix Multiplication can only be allplied to matrices of size 2^n\n    // and has to be a Square Matrix\n\n    @Test\n    public void StrassenMatrixMultiplicationTest2x2() {\n        int[][] A = { { 1, 2 }, { 3, 4 } };\n        int[][] B = { { 5, 6 }, { 7, 8 } };\n        int[][] expResult = { { 19, 22 }, { 43, 50 } };\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    void StrassenMatrixMultiplicationTest4x4() {\n        int[][] A = { { 1, 2, 5, 4 }, { 9, 3, 0, 6 }, { 4, 6, 3, 1 }, { 0, 2, 0, 6 } };\n        int[][] B = { { 1, 0, 4, 1 }, { 1, 2, 0, 2 }, { 0, 3, 1, 3 }, { 1, 8, 1, 2 } };\n        int[][] expResult = { { 7, 51, 13, 28 }, { 18, 54, 42, 27 }, { 11, 29, 20, 27 }, { 8, 52, 6, 16 } };\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    void StrassenMatrixMultiplicationTestNegetiveNumber4x4() {\n        int[][] A = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };\n        int[][] B = { { 1, -2, -3, 4 }, { 4, -3, -2, 1 }, { 5, -6, -7, 8 }, { 8, -7, -6, -5 } };\n        int[][] expResult = { { 56, -54, -52, 10 }, { 128, -126, -124, 42 }, { 200, -198, -196, 74 },\n                { 272, -270, -268, 106 } };\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.divideandconquer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass StrassenMatrixMultiplicationTest {\n\n    StrassenMatrixMultiplication SMM = new StrassenMatrixMultiplication();\n\n    // Strassen Matrix Multiplication can only be allplied to matrices of size 2^n\n    // and has to be a Square Matrix\n\n    @Test\n    public void StrassenMatrixMultiplicationTest2x2() {\n        int[][] A = {{1, 2}, {3, 4}};\n        int[][] B = {{5, 6}, {7, 8}};\n        int[][] expResult = {{19, 22}, {43, 50}};\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    void StrassenMatrixMultiplicationTest4x4() {\n        int[][] A = {{1, 2, 5, 4}, {9, 3, 0, 6}, {4, 6, 3, 1}, {0, 2, 0, 6}};\n        int[][] B = {{1, 0, 4, 1}, {1, 2, 0, 2}, {0, 3, 1, 3}, {1, 8, 1, 2}};\n        int[][] expResult = {{7, 51, 13, 28}, {18, 54, 42, 27}, {11, 29, 20, 27}, {8, 52, 6, 16}};\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    void StrassenMatrixMultiplicationTestNegetiveNumber4x4() {\n        int[][] A = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n        int[][] B = {{1, -2, -3, 4}, {4, -3, -2, 1}, {5, -6, -7, 8}, {8, -7, -6, -5}};\n        int[][] expResult = {{56, -54, -52, 10}, {128, -126, -124, 42}, {200, -198, -196, 74},\n            {272, -270, -268, 106}};\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/EggDropping.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/EggDroppingTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * DynamicProgramming solution for the Egg Dropping Puzzle\n */\npublic class EggDropping {\n\n    // min trials with n eggs and m floors\n    public static int minTrials(int n, int m) {\n        int[][] eggFloor = new int[n + 1][m + 1];\n        int result, x;\n\n        for (int i = 1; i <= n; i++) {\n            eggFloor[i][0] = 0; // Zero trial for zero floor.\n            eggFloor[i][1] = 1; // One trial for one floor\n        }\n\n        // j trials for only 1 egg\n        for (int j = 1; j <= m; j++) {\n            eggFloor[1][j] = j;\n        }\n\n        // Using bottom-up approach in DP\n        for (int i = 2; i <= n; i++) {\n            for (int j = 2; j <= m; j++) {\n                eggFloor[i][j] = Integer.MAX_VALUE;\n                for (x = 1; x <= j; x++) {\n                    result =\n                        1 +\n                        Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\n\n                    // choose min of all values for particular x\n                    if (result < eggFloor[i][j]) {\n                        eggFloor[i][j] = result;\n                    }\n                }\n            }\n        }\n\n        return eggFloor[n][m];\n    }\n\n    public static void main(String[] args) {\n        int n = 2, m = 4;\n        // result outputs min no. of trials in worst case for n eggs and m floors\n        int result = minTrials(n, m);\n        System.out.println(result);\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * DynamicProgramming solution for the Egg Dropping Puzzle\n */\npublic class EggDropping {\n\n    // min trials with n eggs and m floors\n    public static int minTrials(int n, int m) {\n        int[][] eggFloor = new int[n + 1][m + 1];\n        int result, x;\n\n        for (int i = 1; i <= n; i++) {\n            eggFloor[i][0] = 0; // Zero trial for zero floor.\n            eggFloor[i][1] = 1; // One trial for one floor\n        }\n\n        // j trials for only 1 egg\n        for (int j = 1; j <= m; j++) {\n            eggFloor[1][j] = j;\n        }\n\n        // Using bottom-up approach in DP\n        for (int i = 2; i <= n; i++) {\n            for (int j = 2; j <= m; j++) {\n                eggFloor[i][j] = Integer.MAX_VALUE;\n                for (x = 1; x <= j; x++) {\n                    result = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\n\n                    // choose min of all values for particular x\n                    if (result < eggFloor[i][j]) {\n                        eggFloor[i][j] = result;\n                    }\n                }\n            }\n        }\n\n        return eggFloor[n][m];\n    }\n\n    public static void main(String[] args) {\n        int n = 2, m = 4;\n        // result outputs min no. of trials in worst case for n eggs and m floors\n        int result = minTrials(n, m);\n        System.out.println(result);\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class EggDroppingTest {\n\n    @Test\n    void hasMultipleEggSingleFloor(){\n        assertEquals(1,EggDropping.minTrials(3,1));\n    }\n\n    @Test\n    void hasSingleEggSingleFloor(){\n        assertEquals(1,EggDropping.minTrials(1,1));\n    }\n\n    @Test\n    void hasSingleEggMultipleFloor(){\n        assertEquals(3,EggDropping.minTrials(1,3));\n    }\n\n    @Test\n    void hasMultipleEggMultipleFloor(){\n        assertEquals(7,EggDropping.minTrials(100,101));\n    }\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class EggDroppingTest {\n\n    @Test\n    void hasMultipleEggSingleFloor() {\n        assertEquals(1, EggDropping.minTrials(3, 1));\n    }\n\n    @Test\n    void hasSingleEggSingleFloor() {\n        assertEquals(1, EggDropping.minTrials(1, 1));\n    }\n\n    @Test\n    void hasSingleEggMultipleFloor() {\n        assertEquals(3, EggDropping.minTrials(1, 3));\n    }\n\n    @Test\n    void hasMultipleEggMultipleFloor() {\n        assertEquals(7, EggDropping.minTrials(100, 101));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/Knapsack.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/KnapsackMemoizationTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * A DynamicProgramming based solution for 0-1 Knapsack problem\n */\npublic class Knapsack {\n\n    private static int knapSack(int W, int[] wt, int[] val, int n)\n        throws IllegalArgumentException {\n        if (wt == null || val == null) {\n            throw new IllegalArgumentException();\n        }\n        int i, w;\n        int[][] rv = new int[n + 1][W + 1]; // rv means return value\n\n        // Build table rv[][] in bottom up manner\n        for (i = 0; i <= n; i++) {\n            for (w = 0; w <= W; w++) {\n                if (i == 0 || w == 0) {\n                    rv[i][w] = 0;\n                } else if (wt[i - 1] <= w) {\n                    rv[i][w] =\n                        Math.max(\n                            val[i - 1] + rv[i - 1][w - wt[i - 1]],\n                            rv[i - 1][w]\n                        );\n                } else {\n                    rv[i][w] = rv[i - 1][w];\n                }\n            }\n        }\n\n        return rv[n][W];\n    }\n\n    // Driver program to test above function\n    public static void main(String[] args) {\n        int[] val = new int[] { 50, 100, 130 };\n        int[] wt = new int[] { 10, 20, 40 };\n        int W = 50;\n        System.out.println(knapSack(W, wt, val, val.length));\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * A DynamicProgramming based solution for 0-1 Knapsack problem\n */\npublic class Knapsack {\n\n    private static int knapSack(int W, int[] wt, int[] val, int n) throws IllegalArgumentException {\n        if (wt == null || val == null) {\n            throw new IllegalArgumentException();\n        }\n        int i, w;\n        int[][] rv = new int[n + 1][W + 1]; // rv means return value\n\n        // Build table rv[][] in bottom up manner\n        for (i = 0; i <= n; i++) {\n            for (w = 0; w <= W; w++) {\n                if (i == 0 || w == 0) {\n                    rv[i][w] = 0;\n                } else if (wt[i - 1] <= w) {\n                    rv[i][w] = Math.max(val[i - 1] + rv[i - 1][w - wt[i - 1]], rv[i - 1][w]);\n                } else {\n                    rv[i][w] = rv[i - 1][w];\n                }\n            }\n        }\n\n        return rv[n][W];\n    }\n\n    // Driver program to test above function\n    public static void main(String[] args) {\n        int[] val = new int[] {50, 100, 130};\n        int[] wt = new int[] {10, 20, 40};\n        int W = 50;\n        System.out.println(knapSack(W, wt, val, val.length));\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KnapsackMemoizationTest {\n\n    KnapsackMemoization knapsackMemoization = new KnapsackMemoization();\n\n    @Test\n    void Test1() {\n        int[] weight = { 1, 3, 4, 5 };\n        int[] value = { 1, 4, 5, 7 };\n        int capacity = 10;\n        assertEquals(13, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test2() {\n        int[] weight = { 95, 4, 60, 32, 23, 72, 80, 62, 65, 46 };\n        int[] value = { 55, 10, 47, 5, 4, 50, 8, 61, 85, 87 };\n        int capacity = 269;\n        assertEquals(295, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test3() {\n        int[] weight = { 10, 20, 30 };\n        int[] value = { 60, 100, 120 };\n        int capacity = 50;\n        assertEquals(220, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KnapsackMemoizationTest {\n\n    KnapsackMemoization knapsackMemoization = new KnapsackMemoization();\n\n    @Test\n    void Test1() {\n        int[] weight = {1, 3, 4, 5};\n        int[] value = {1, 4, 5, 7};\n        int capacity = 10;\n        assertEquals(13, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test2() {\n        int[] weight = {95, 4, 60, 32, 23, 72, 80, 62, 65, 46};\n        int[] value = {55, 10, 47, 5, 4, 50, 8, 61, 85, 87};\n        int capacity = 269;\n        assertEquals(295, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test3() {\n        int[] weight = {10, 20, 30};\n        int[] value = {60, 100, 120};\n        int capacity = 50;\n        assertEquals(220, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/KnapsackMemoization.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/KnapsackMemoizationTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * Recursive Solution for 0-1 knapsack with memoization\n * This method is basically an extension to the recursive approach so that we\n * can overcome the problem of calculating redundant cases and thus increased\n * complexity. We can solve this problem by simply creating a 2-D array that can\n * store a particular state (n, w) if we get it the first time.\n */\npublic class KnapsackMemoization {\n\n    int knapSack(int capacity, int[] weights, int[] profits, int numOfItems) {\n\n        // Declare the table dynamically\n        int[][] dpTable = new int[numOfItems + 1][capacity + 1];\n\n        // Loop to initially fill the table with -1\n        for (int i = 0; i < numOfItems + 1; i++) {\n            for (int j = 0; j < capacity + 1; j++) {\n                dpTable[i][j] = -1;\n            }\n        }\n\n        return solveKnapsackRecursive(capacity, weights, profits, numOfItems, dpTable);\n    }\n\n    // Returns the value of maximum profit using recursive approach\n    int solveKnapsackRecursive(int capacity, int[] weights,\n                               int[] profits, int numOfItems,\n                               int[][] dpTable) {\n        // Base condition\n        if (numOfItems == 0 || capacity == 0) {\n            return 0;\n        }\n\n        if (dpTable[numOfItems][capacity] != -1) {\n            return dpTable[numOfItems][capacity];\n        }\n\n        if (weights[numOfItems - 1] > capacity) {\n            // Store the value of function call stack in table\n            dpTable[numOfItems][capacity] = solveKnapsackRecursive(capacity, weights, profits, numOfItems - 1, dpTable);\n            return dpTable[numOfItems][capacity];\n        } else {\n            // Return value of table after storing\n            return dpTable[numOfItems][capacity] = Math.max((profits[numOfItems - 1] + solveKnapsackRecursive(capacity - weights[numOfItems - 1], weights, profits, numOfItems - 1, dpTable)),\n                    solveKnapsackRecursive(capacity, weights, profits, numOfItems - 1, dpTable));\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * Recursive Solution for 0-1 knapsack with memoization\n * This method is basically an extension to the recursive approach so that we\n * can overcome the problem of calculating redundant cases and thus increased\n * complexity. We can solve this problem by simply creating a 2-D array that can\n * store a particular state (n, w) if we get it the first time.\n */\npublic class KnapsackMemoization {\n\n    int knapSack(int capacity, int[] weights, int[] profits, int numOfItems) {\n\n        // Declare the table dynamically\n        int[][] dpTable = new int[numOfItems + 1][capacity + 1];\n\n        // Loop to initially fill the table with -1\n        for (int i = 0; i < numOfItems + 1; i++) {\n            for (int j = 0; j < capacity + 1; j++) {\n                dpTable[i][j] = -1;\n            }\n        }\n\n        return solveKnapsackRecursive(capacity, weights, profits, numOfItems, dpTable);\n    }\n\n    // Returns the value of maximum profit using recursive approach\n    int solveKnapsackRecursive(\n        int capacity, int[] weights, int[] profits, int numOfItems, int[][] dpTable) {\n        // Base condition\n        if (numOfItems == 0 || capacity == 0) {\n            return 0;\n        }\n\n        if (dpTable[numOfItems][capacity] != -1) {\n            return dpTable[numOfItems][capacity];\n        }\n\n        if (weights[numOfItems - 1] > capacity) {\n            // Store the value of function call stack in table\n            dpTable[numOfItems][capacity]\n                = solveKnapsackRecursive(capacity, weights, profits, numOfItems - 1, dpTable);\n            return dpTable[numOfItems][capacity];\n        } else {\n            // Return value of table after storing\n            return dpTable[numOfItems][capacity]\n                = Math.max((profits[numOfItems - 1]\n                               + solveKnapsackRecursive(capacity - weights[numOfItems - 1], weights,\n                                   profits, numOfItems - 1, dpTable)),\n                    solveKnapsackRecursive(capacity, weights, profits, numOfItems - 1, dpTable));\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KnapsackMemoizationTest {\n\n    KnapsackMemoization knapsackMemoization = new KnapsackMemoization();\n\n    @Test\n    void Test1() {\n        int[] weight = { 1, 3, 4, 5 };\n        int[] value = { 1, 4, 5, 7 };\n        int capacity = 10;\n        assertEquals(13, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test2() {\n        int[] weight = { 95, 4, 60, 32, 23, 72, 80, 62, 65, 46 };\n        int[] value = { 55, 10, 47, 5, 4, 50, 8, 61, 85, 87 };\n        int capacity = 269;\n        assertEquals(295, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test3() {\n        int[] weight = { 10, 20, 30 };\n        int[] value = { 60, 100, 120 };\n        int capacity = 50;\n        assertEquals(220, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KnapsackMemoizationTest {\n\n    KnapsackMemoization knapsackMemoization = new KnapsackMemoization();\n\n    @Test\n    void Test1() {\n        int[] weight = {1, 3, 4, 5};\n        int[] value = {1, 4, 5, 7};\n        int capacity = 10;\n        assertEquals(13, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test2() {\n        int[] weight = {95, 4, 60, 32, 23, 72, 80, 62, 65, 46};\n        int[] value = {55, 10, 47, 5, 4, 50, 8, 61, 85, 87};\n        int capacity = 269;\n        assertEquals(295, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test3() {\n        int[] weight = {10, 20, 30};\n        int[] value = {60, 100, 120};\n        int capacity = 50;\n        assertEquals(220, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/LevenshteinDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/LevenshteinDistanceTests.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * @author Kshitij VERMA (github.com/kv19971) LEVENSHTEIN DISTANCE dyamic\n * programming implementation to show the difference between two strings\n * (https://en.wikipedia.org/wiki/Levenshtein_distance)\n */\npublic class LevenshteinDistance {\n\n    private static int minimum(int a, int b, int c) {\n        if (a < b && a < c) {\n            return a;\n        } else if (b < a && b < c) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n\n    public static int calculateLevenshteinDistance(String str1, String str2) {\n        int len1 = str1.length() + 1;\n        int len2 = str2.length() + 1;\n        int[][] distanceMat = new int[len1][len2];\n        for (int i = 0; i < len1; i++) {\n            distanceMat[i][0] = i;\n        }\n        for (int j = 0; j < len2; j++) {\n            distanceMat[0][j] = j;\n        }\n        for (int i = 1; i < len1; i++) {\n            for (int j = 1; j < len2; j++) {\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    distanceMat[i][j] = distanceMat[i - 1][j - 1];\n                } else {\n                    distanceMat[i][j] =\n                            1 + minimum(\n                                    distanceMat[i - 1][j],\n                                    distanceMat[i - 1][j - 1],\n                                    distanceMat[i][j - 1]\n                            );\n                }\n            }\n        }\n        return distanceMat[len1 - 1][len2 - 1];\n    }\n\n    public static void main(String[] args) {\n        String str1 = \"\"; // enter your string here\n        String str2 = \"\"; // enter your string here\n\n        System.out.print(\n                \"Levenshtein distance between \" + str1 + \" and \" + str2 + \" is: \"\n        );\n        System.out.println(calculateLevenshteinDistance(str1, str2));\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * @author Kshitij VERMA (github.com/kv19971) LEVENSHTEIN DISTANCE dyamic\n * programming implementation to show the difference between two strings\n * (https://en.wikipedia.org/wiki/Levenshtein_distance)\n */\npublic class LevenshteinDistance {\n\n    private static int minimum(int a, int b, int c) {\n        if (a < b && a < c) {\n            return a;\n        } else if (b < a && b < c) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n\n    public static int calculateLevenshteinDistance(String str1, String str2) {\n        int len1 = str1.length() + 1;\n        int len2 = str2.length() + 1;\n        int[][] distanceMat = new int[len1][len2];\n        for (int i = 0; i < len1; i++) {\n            distanceMat[i][0] = i;\n        }\n        for (int j = 0; j < len2; j++) {\n            distanceMat[0][j] = j;\n        }\n        for (int i = 1; i < len1; i++) {\n            for (int j = 1; j < len2; j++) {\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    distanceMat[i][j] = distanceMat[i - 1][j - 1];\n                } else {\n                    distanceMat[i][j] = 1\n                        + minimum(distanceMat[i - 1][j], distanceMat[i - 1][j - 1],\n                            distanceMat[i][j - 1]);\n                }\n            }\n        }\n        return distanceMat[len1 - 1][len2 - 1];\n    }\n\n    public static void main(String[] args) {\n        String str1 = \"\"; // enter your string here\n        String str2 = \"\"; // enter your string here\n\n        System.out.print(\"Levenshtein distance between \" + str1 + \" and \" + str2 + \" is: \");\n        System.out.println(calculateLevenshteinDistance(str1, str2));\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class LevenshteinDistanceTests {\n\n    @ParameterizedTest\n    @CsvSource({\"dog,cat,3\", \"sunday,saturday,3\", \"cat,cats,1\", \"rain,train,1\"})\n    void levenshteinDistanceTest(String str1, String str2, int distance) {\n        int result = LevenshteinDistance.calculateLevenshteinDistance(str1, str2);\n        assertEquals(distance, result);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\npublic class LevenshteinDistanceTests {\n\n    @ParameterizedTest\n    @CsvSource({\"dog,cat,3\", \"sunday,saturday,3\", \"cat,cats,1\", \"rain,train,1\"})\n    void levenshteinDistanceTest(String str1, String str2, int distance) {\n        int result = LevenshteinDistance.calculateLevenshteinDistance(str1, str2);\n        assertEquals(distance, result);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/OptimalJobScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/OptimalJobSchedulingTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * This class refers to the Optimal Job Scheduling problem with the following constrains:\n *  - precedence relation between the processes\n *  - machine pair dependent transportation delays\n *\n * https://en.wikipedia.org/wiki/Optimal_job_scheduling\n *\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobScheduling {\n\n    private final int numberProcesses;\n    private final int numberMachines;\n    private final int[][] Run;\n    private final int[][] Transfer;\n    private final int[][] Cost;\n\n    /**\n     * Constructor of the class.\n     * @param numberProcesses ,refers to the number of precedent processes(N)\n     * @param numberMachines ,refers to the number of different machines in our disposal(M)\n     * @param Run , N*M matrix refers to the cost of running each process to each machine\n     * @param Transfer ,M*M symmetric matrix refers to the transportation delay for each pair of machines\n     */\n    public OptimalJobScheduling(int numberProcesses, int numberMachines, int[][] Run, int[][] Transfer) {\n        this.numberProcesses = numberProcesses;\n        this.numberMachines = numberMachines;\n        this.Run = Run;\n        this.Transfer = Transfer;\n        this.Cost = new int[numberProcesses][numberMachines];\n    }\n\n    /**\n     * Function which computes the cost of process scheduling to a number of VMs.\n     */\n    public void execute(){\n        this.calculateCost();\n        this.showResults();\n    }\n\n    /**\n     * Function which computes the cost of running each Process to each and every Machine\n     */\n    private void calculateCost(){\n\n        for (int i=0; i < numberProcesses; i++){           //for each Process\n\n            for (int j=0; j < numberMachines; j++) {       //for each Machine\n\n                Cost[i][j] = runningCost(i, j);\n            }\n        }\n    }\n\n    /**\n     * Function which returns the minimum cost of running a certain Process to a certain Machine.In order for the Machine to execute the Process ,he requires the output\n     * of the previously executed Process, which may have been executed to the same Machine or some other.If the previous Process has been executed to another Machine,we\n     * have to transfer her result, which means extra cost for transferring the data from one Machine to another(if the previous Process has been executed to the same\n     * Machine, there is no transport cost).\n     *\n     * @param process ,refers to the Process\n     * @param machine ,refers to the Machine\n     * @return the minimum cost of executing the process to the certain machine.\n     */\n    private int runningCost(int process, int machine) {\n\n        if (process==0)                         //refers to the first process,which does not require for a previous one to have been executed\n            return Run[process][machine];\n        else {\n\n            int[] runningCosts = new int[numberMachines];     //stores the costs of executing our Process depending on the Machine the previous one was executed\n\n            for (int k=0; k < numberMachines; k++)                                                     //computes the cost of executing the previous process to each and every Machine\n                runningCosts[k] = Cost[process-1][k] + Transfer[k][machine] + Run[process][machine];   //transferring the result to our Machine and executing the Process to our Machine\n\n            return findMin(runningCosts);                     //returns the minimum running cost\n        }\n    }\n\n    /**\n     * Function used in order to return the minimum Cost.\n     * @param cost ,an Array of size M which refers to the costs of executing a Process to each Machine\n     * @return the minimum cost\n     */\n    private int findMin(int[] cost) {\n\n        int min=0;\n\n        for (int i=1;i<cost.length;i++){\n\n            if (cost[i]<cost[min])\n                min=i;\n        }\n        return cost[min];\n    }\n\n    /**\n     * Method used in order to present the overall costs.\n     */\n    private void showResults(){\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++) {\n                System.out.print(Cost[i][j]);\n                System.out.print(\" \");\n            }\n\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    /**\n     * Getter for the running Cost of i process on j machine.\n     */\n    public int getCost(int process,int machine) {\n        return Cost[process][machine];\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * This class refers to the Optimal Job Scheduling problem with the following constrains:\n *  - precedence relation between the processes\n *  - machine pair dependent transportation delays\n *\n * https://en.wikipedia.org/wiki/Optimal_job_scheduling\n *\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobScheduling {\n\n    private final int numberProcesses;\n    private final int numberMachines;\n    private final int[][] Run;\n    private final int[][] Transfer;\n    private final int[][] Cost;\n\n    /**\n     * Constructor of the class.\n     * @param numberProcesses ,refers to the number of precedent processes(N)\n     * @param numberMachines ,refers to the number of different machines in our disposal(M)\n     * @param Run , N*M matrix refers to the cost of running each process to each machine\n     * @param Transfer ,M*M symmetric matrix refers to the transportation delay for each pair of\n     *     machines\n     */\n    public OptimalJobScheduling(\n        int numberProcesses, int numberMachines, int[][] Run, int[][] Transfer) {\n        this.numberProcesses = numberProcesses;\n        this.numberMachines = numberMachines;\n        this.Run = Run;\n        this.Transfer = Transfer;\n        this.Cost = new int[numberProcesses][numberMachines];\n    }\n\n    /**\n     * Function which computes the cost of process scheduling to a number of VMs.\n     */\n    public void execute() {\n        this.calculateCost();\n        this.showResults();\n    }\n\n    /**\n     * Function which computes the cost of running each Process to each and every Machine\n     */\n    private void calculateCost() {\n\n        for (int i = 0; i < numberProcesses; i++) { // for each Process\n\n            for (int j = 0; j < numberMachines; j++) { // for each Machine\n\n                Cost[i][j] = runningCost(i, j);\n            }\n        }\n    }\n\n    /**\n     * Function which returns the minimum cost of running a certain Process to a certain Machine.In\n     * order for the Machine to execute the Process ,he requires the output of the previously\n     * executed Process, which may have been executed to the same Machine or some other.If the\n     * previous Process has been executed to another Machine,we have to transfer her result, which\n     * means extra cost for transferring the data from one Machine to another(if the previous\n     * Process has been executed to the same Machine, there is no transport cost).\n     *\n     * @param process ,refers to the Process\n     * @param machine ,refers to the Machine\n     * @return the minimum cost of executing the process to the certain machine.\n     */\n    private int runningCost(int process, int machine) {\n\n        if (process == 0) // refers to the first process,which does not require for a previous one\n                          // to have been executed\n            return Run[process][machine];\n        else {\n\n            int[] runningCosts\n                = new int[numberMachines]; // stores the costs of executing our Process depending on\n                                           // the Machine the previous one was executed\n\n            for (int k = 0; k < numberMachines; k++) // computes the cost of executing the previous\n                                                     // process to each and every Machine\n                runningCosts[k] = Cost[process - 1][k] + Transfer[k][machine]\n                    + Run[process][machine]; // transferring the result to our Machine and executing\n                                             // the Process to our Machine\n\n            return findMin(runningCosts); // returns the minimum running cost\n        }\n    }\n\n    /**\n     * Function used in order to return the minimum Cost.\n     * @param cost ,an Array of size M which refers to the costs of executing a Process to each\n     *     Machine\n     * @return the minimum cost\n     */\n    private int findMin(int[] cost) {\n\n        int min = 0;\n\n        for (int i = 1; i < cost.length; i++) {\n\n            if (cost[i] < cost[min]) min = i;\n        }\n        return cost[min];\n    }\n\n    /**\n     * Method used in order to present the overall costs.\n     */\n    private void showResults() {\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n                System.out.print(Cost[i][j]);\n                System.out.print(\" \");\n            }\n\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    /**\n     * Getter for the running Cost of i process on j machine.\n     */\n    public int getCost(int process, int machine) {\n        return Cost[process][machine];\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobSchedulingTest {\n\n    @Test\n    public void testOptimalJobScheduling1(){\n\n        int numberProcesses = 5;\n        int numberMachines = 4;\n\n        int[][] Run = {\n                {5, 1, 3, 2},\n                {4, 2, 1, 3},\n                {1, 5, 2, 1},\n                {2, 3, 4, 2},\n                {1, 1, 3, 1}};\n\n        int[][] Transfer = {\n                {0, 1, 2, 4},\n                {1, 0, 2, 3},\n                {2, 2, 0, 1},\n                {4, 3, 1, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses,numberMachines,Run,Transfer);\n\n        opt.execute();\n\n\n        int[][] costs = {\n                {5, 1, 3, 2},\n                {6, 3, 4, 5},\n                {5, 8, 6, 6},\n                {7, 9, 10, 8},\n                {8, 9, 12, 9}};\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++){\n\n                assertEquals(costs[i][j],opt.getCost(i,j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling2(){\n\n        int numberProcesses = 3;\n        int numberMachines = 3;\n\n        int[][] Run = {\n                {5, 1, 3},\n                {4, 2, 1},\n                {1, 5, 2}};\n\n        int[][] Transfer = {\n                {0, 1, 2},\n                {1, 0, 2},\n                {2, 2, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses,numberMachines,Run,Transfer);\n\n        opt.execute();\n\n        int[][] costs = {\n                {5, 1, 3},\n                {6, 3, 4},\n                {5, 8, 6}};\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++){\n\n                assertEquals(costs[i][j],opt.getCost(i,j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling3(){\n\n        int numberProcesses = 6;\n        int numberMachines = 4;\n\n        int[][] Run = {\n                {5, 1, 3, 2},\n                {4, 2, 1, 1},\n                {1, 5, 2, 6},\n                {1, 1, 2, 3},\n                {2, 1, 4, 6},\n                {3, 2, 2, 3},\n        };\n\n        int[][] Transfer = {\n                {0, 1, 2, 1},\n                {1, 0, 2, 3},\n                {2, 2, 0, 2},\n                {1, 3, 2, 0},\n        };\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses,numberMachines,Run,Transfer);\n\n        opt.execute();\n\n        int[][] costs = {\n                {5, 1, 3, 2},\n                {6, 3, 4, 3},\n                {5, 8, 6, 9},\n                {6, 7, 8, 9},\n                {8, 8, 12, 13},\n                {11, 10, 12, 12}};\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++){\n\n                assertEquals(costs[i][j],opt.getCost(i,j));\n            }\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobSchedulingTest {\n\n    @Test\n    public void testOptimalJobScheduling1() {\n\n        int numberProcesses = 5;\n        int numberMachines = 4;\n\n        int[][] Run = {{5, 1, 3, 2}, {4, 2, 1, 3}, {1, 5, 2, 1}, {2, 3, 4, 2}, {1, 1, 3, 1}};\n\n        int[][] Transfer = {{0, 1, 2, 4}, {1, 0, 2, 3}, {2, 2, 0, 1}, {4, 3, 1, 0}};\n\n        OptimalJobScheduling opt\n            = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 5}, {5, 8, 6, 6}, {7, 9, 10, 8}, {8, 9, 12, 9}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling2() {\n\n        int numberProcesses = 3;\n        int numberMachines = 3;\n\n        int[][] Run = {{5, 1, 3}, {4, 2, 1}, {1, 5, 2}};\n\n        int[][] Transfer = {{0, 1, 2}, {1, 0, 2}, {2, 2, 0}};\n\n        OptimalJobScheduling opt\n            = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3}, {6, 3, 4}, {5, 8, 6}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling3() {\n\n        int numberProcesses = 6;\n        int numberMachines = 4;\n\n        int[][] Run = {\n            {5, 1, 3, 2},\n            {4, 2, 1, 1},\n            {1, 5, 2, 6},\n            {1, 1, 2, 3},\n            {2, 1, 4, 6},\n            {3, 2, 2, 3},\n        };\n\n        int[][] Transfer = {\n            {0, 1, 2, 1},\n            {1, 0, 2, 3},\n            {2, 2, 0, 2},\n            {1, 3, 2, 0},\n        };\n\n        OptimalJobScheduling opt\n            = new OptimalJobScheduling(numberProcesses, numberMachines, Run, Transfer);\n\n        opt.execute();\n\n        int[][] costs = {{5, 1, 3, 2}, {6, 3, 4, 3}, {5, 8, 6, 9}, {6, 7, 8, 9}, {8, 8, 12, 13},\n            {11, 10, 12, 12}};\n\n        for (int i = 0; i < numberProcesses; i++) {\n\n            for (int j = 0; j < numberMachines; j++) {\n\n                assertEquals(costs[i][j], opt.getCost(i, j));\n            }\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/PartitionProblem.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/PartitionProblemTest.java",
        "product_old_content": "/**\n * @author Md Asif Joardar\n *\n * Description: The partition problem is a classic problem in computer science\n * that asks whether a given set can be partitioned into two subsets such that\n * the sum of elements in each subset is the same.\n *\n * Example:\n * Consider nums = {1, 2, 3}\n * We can split the array \"nums\" into two partitions, where each having a sum of 3.\n * nums1 = {1, 2}\n * nums2 = {3}\n *\n * The time complexity of the solution is O(n \u00d7 sum) and requires O(n \u00d7 sum) space\n */\n\npackage com.thealgorithms.dynamicprogramming;\n\nimport java.util.Arrays;\n\npublic class PartitionProblem {\n\n    /**\n     * Test if a set of integers can be partitioned into two subsets such that the sum of elements\n     * in each subset is the same.\n     *\n     * @param nums the array contains integers.\n     * @return {@code true} if two subset exists, otherwise {@code false}.\n     */\n    public static boolean partition(int[] nums)\n    {\n        // calculate the sum of all the elements in the array\n        int sum = Arrays.stream(nums).sum();\n\n        // it will return true if the sum is even and the array can be divided into two subarrays/subset with equal sum.\n        // and here i reuse the SubsetSum class from dynamic programming section to check if there is exists a\n        // subsetsum into nums[] array same as the given sum\n        return (sum & 1) == 0 && SubsetSum.subsetSum(nums, sum/2);\n    }\n}",
        "product_new_content": "/**\n * @author Md Asif Joardar\n *\n * Description: The partition problem is a classic problem in computer science\n * that asks whether a given set can be partitioned into two subsets such that\n * the sum of elements in each subset is the same.\n *\n * Example:\n * Consider nums = {1, 2, 3}\n * We can split the array \"nums\" into two partitions, where each having a sum of 3.\n * nums1 = {1, 2}\n * nums2 = {3}\n *\n * The time complexity of the solution is O(n \u00d7 sum) and requires O(n \u00d7 sum) space\n */\n\npackage com.thealgorithms.dynamicprogramming;\n\nimport java.util.Arrays;\n\npublic class PartitionProblem {\n\n    /**\n     * Test if a set of integers can be partitioned into two subsets such that the sum of elements\n     * in each subset is the same.\n     *\n     * @param nums the array contains integers.\n     * @return {@code true} if two subset exists, otherwise {@code false}.\n     */\n    public static boolean partition(int[] nums) {\n        // calculate the sum of all the elements in the array\n        int sum = Arrays.stream(nums).sum();\n\n        // it will return true if the sum is even and the array can be divided into two\n        // subarrays/subset with equal sum. and here i reuse the SubsetSum class from dynamic\n        // programming section to check if there is exists a subsetsum into nums[] array same as the\n        // given sum\n        return (sum & 1) == 0 && SubsetSum.subsetSum(nums, sum / 2);\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PartitionProblemTest {\n    @Test\n    public void testIfSumOfTheArrayIsOdd(){\n        assertFalse(PartitionProblem.partition(new int[]{1, 2, 2}));\n    }\n    @Test\n    public void testIfSizeOfTheArrayIsOne(){\n        assertFalse(PartitionProblem.partition(new int[]{2}));\n    }\n    @Test\n    public void testIfSumOfTheArrayIsEven1(){\n        assertTrue(PartitionProblem.partition(new int[]{1, 2, 3, 6}));\n    }\n    @Test\n    public void testIfSumOfTheArrayIsEven2(){\n        assertFalse(PartitionProblem.partition(new int[]{1, 2, 3, 8}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass PartitionProblemTest {\n    @Test\n    public void testIfSumOfTheArrayIsOdd() {\n        assertFalse(PartitionProblem.partition(new int[] {1, 2, 2}));\n    }\n    @Test\n    public void testIfSizeOfTheArrayIsOne() {\n        assertFalse(PartitionProblem.partition(new int[] {2}));\n    }\n    @Test\n    public void testIfSumOfTheArrayIsEven1() {\n        assertTrue(PartitionProblem.partition(new int[] {1, 2, 3, 6}));\n    }\n    @Test\n    public void testIfSumOfTheArrayIsEven2() {\n        assertFalse(PartitionProblem.partition(new int[] {1, 2, 3, 8}));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/SubsetCount.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/SubsetCountTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * Find the number of subsets present in the given array with a sum equal to target.\n * Based on Solution discussed on StackOverflow(https://stackoverflow.com/questions/22891076/count-number-of-subsets-with-sum-equal-to-k)\n * @author Samrat Podder(https://github.com/samratpodder)\n */\npublic class SubsetCount {\n\n\n    /**\n     * Dynamic Programming Implementation.\n     * Method to find out the number of subsets present in the given array with a sum equal to target.\n     * Time Complexity is O(n*target) and Space Complexity is O(n*target)\n     * @param arr is the input array on which subsets are  to searched\n     * @param target is the sum of each element of the subset taken together\n     *\n     */\n    public int getCount(int[] arr, int target){\n        /**\n         * Base Cases - If target becomes zero, we have reached the required sum for the subset\n         * If we reach the end of the array arr then, either if target==arr[end], then we add one to the final count\n         * Otherwise we add 0 to the final count\n         */\n        int n = arr.length;\n        int[][] dp = new int[n][target+1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n        if(arr[0]<=target) dp[0][arr[0]] = 1;\n        for(int t=1;t<=target;t++){\n            for (int idx = 1; idx < n; idx++) {\n                int notpick = dp[idx-1][t];\n                int pick =0;\n                if(arr[idx]<=t) pick+=dp[idx-1][target-t];\n                dp[idx][target] = pick+notpick;\n            }\n        }\n        return dp[n-1][target];\n    }\n\n\n    /**\n     * This Method is a Space Optimized version of the getCount(int[], int) method and solves the same problem\n     * This approach is a bit better in terms of Space Used\n     * Time Complexity is O(n*target) and Space Complexity is O(target)\n     * @param arr is the input array on which subsets are  to searched\n     * @param target is the sum of each element of the subset taken together\n     */\n    public int getCountSO(int[] arr, int target){\n        int n = arr.length;\n        int[] prev =new int[target+1];\n        prev[0] =1;\n        if(arr[0]<=target) prev[arr[0]] = 1;\n        for(int ind = 1; ind<n; ind++){\n            int[] cur =new int[target+1];\n            cur[0]=1;\n            for(int t= 1; t<=target; t++){\n                int notTaken = prev[t];\n                int taken = 0;\n                if(arr[ind]<=t) taken = prev[t-arr[ind]];\n                cur[t]= notTaken + taken;\n            }\n            prev = cur;\n        }\n        return prev[target];\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * Find the number of subsets present in the given array with a sum equal to target.\n * Based on Solution discussed on\n * StackOverflow(https://stackoverflow.com/questions/22891076/count-number-of-subsets-with-sum-equal-to-k)\n * @author Samrat Podder(https://github.com/samratpodder)\n */\npublic class SubsetCount {\n\n    /**\n     * Dynamic Programming Implementation.\n     * Method to find out the number of subsets present in the given array with a sum equal to\n     * target. Time Complexity is O(n*target) and Space Complexity is O(n*target)\n     * @param arr is the input array on which subsets are  to searched\n     * @param target is the sum of each element of the subset taken together\n     *\n     */\n    public int getCount(int[] arr, int target) {\n        /**\n         * Base Cases - If target becomes zero, we have reached the required sum for the subset\n         * If we reach the end of the array arr then, either if target==arr[end], then we add one to\n         * the final count Otherwise we add 0 to the final count\n         */\n        int n = arr.length;\n        int[][] dp = new int[n][target + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n        if (arr[0] <= target) dp[0][arr[0]] = 1;\n        for (int t = 1; t <= target; t++) {\n            for (int idx = 1; idx < n; idx++) {\n                int notpick = dp[idx - 1][t];\n                int pick = 0;\n                if (arr[idx] <= t) pick += dp[idx - 1][target - t];\n                dp[idx][target] = pick + notpick;\n            }\n        }\n        return dp[n - 1][target];\n    }\n\n    /**\n     * This Method is a Space Optimized version of the getCount(int[], int) method and solves the\n     * same problem This approach is a bit better in terms of Space Used Time Complexity is\n     * O(n*target) and Space Complexity is O(target)\n     * @param arr is the input array on which subsets are  to searched\n     * @param target is the sum of each element of the subset taken together\n     */\n    public int getCountSO(int[] arr, int target) {\n        int n = arr.length;\n        int[] prev = new int[target + 1];\n        prev[0] = 1;\n        if (arr[0] <= target) prev[arr[0]] = 1;\n        for (int ind = 1; ind < n; ind++) {\n            int[] cur = new int[target + 1];\n            cur[0] = 1;\n            for (int t = 1; t <= target; t++) {\n                int notTaken = prev[t];\n                int taken = 0;\n                if (arr[ind] <= t) taken = prev[t - arr[ind]];\n                cur[t] = notTaken + taken;\n            }\n            prev = cur;\n        }\n        return prev[target];\n    }\n}",
        "test_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class SubsetCountTest {\n    public static SubsetCount obj = new SubsetCount();\n\n    @Test\n    void hasMultipleSubset(){\n        int[] arr = new int[]{1,2,3,3};\n        assertEquals(3, obj.getCount(arr, 6));\n    }\n    @Test\n    void singleElementSubset(){\n        int[] arr = new int[]{1,1,1,1};\n        assertEquals(4, obj.getCount(arr, 1));\n    }\n\n    @Test\n    void hasMultipleSubsetSO(){\n        int[] arr = new int[]{1,2,3,3};\n        assertEquals(3, obj.getCountSO(arr, 6));\n    }\n    @Test\n    void singleSubsetSO(){\n        int[] arr = new int[]{1,1,1,1};\n        assertEquals(1,obj.getCountSO(arr, 4));\n    }\n}",
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SubsetCountTest {\n    public static SubsetCount obj = new SubsetCount();\n\n    @Test\n    void hasMultipleSubset() {\n        int[] arr = new int[] {1, 2, 3, 3};\n        assertEquals(3, obj.getCount(arr, 6));\n    }\n    @Test\n    void singleElementSubset() {\n        int[] arr = new int[] {1, 1, 1, 1};\n        assertEquals(4, obj.getCount(arr, 1));\n    }\n\n    @Test\n    void hasMultipleSubsetSO() {\n        int[] arr = new int[] {1, 2, 3, 3};\n        assertEquals(3, obj.getCountSO(arr, 6));\n    }\n    @Test\n    void singleSubsetSO() {\n        int[] arr = new int[] {1, 1, 1, 1};\n        assertEquals(1, obj.getCountSO(arr, 4));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/geometry/GrahamScan.java",
        "test_file_path": "src/test/java/com/thealgorithms/geometry/GrahamScanTest.java",
        "product_old_content": "package com.thealgorithms.geometry;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Stack;\n\n/*\n * A Java program that computes the convex hull using the Graham Scan algorithm\n * In the best case, time complexity is O(n), while in the worst case, it is log(n).\n * O(n) space complexity\n *\n * This algorithm is only applicable to integral coordinates.\n *\n * Reference:\n * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_algorithm.cpp\n * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_functions.hpp\n * https://algs4.cs.princeton.edu/99hull/GrahamScan.java.html\n */\npublic class GrahamScan {\n    private final Stack<Point> hull = new Stack<>();\n\n    public GrahamScan(Point[] points) {\n\n        /*\n         * pre-process the points by sorting them with respect to the bottom-most point, then we'll push the\n         * first point in the array to be our first extreme point.\n         */\n        Arrays.sort(points);\n        Arrays.sort(points, 1, points.length, points[0].polarOrder());\n        hull.push(points[0]);\n\n        // find index of first point not equal to a[0] (indexPoint1) and the first point that's not\n        // collinear with either (indexPoint2).\n        int indexPoint1;\n        for (indexPoint1 = 1; indexPoint1 < points.length; indexPoint1++)\n            if (!points[0].equals(points[indexPoint1])) break;\n        if (indexPoint1 == points.length) return;\n\n        int indexPoint2;\n        for (indexPoint2 = indexPoint1+1; indexPoint2 < points.length; indexPoint2++)\n            if (Point.orientation(points[0], points[indexPoint1], points[indexPoint2]) != 0) break;\n        hull.push(points[indexPoint2-1]);\n\n        // Now we simply add the point to the stack based on the orientation.\n        for (int i = indexPoint2; i < points.length; i++) {\n            Point top = hull.pop();\n            while (Point.orientation(hull.peek(), top, points[i]) <= 0) {\n                top = hull.pop();\n            }\n            hull.push(top);\n            hull.push(points[i]);\n        }\n    }\n\n    /**\n     * @return A stack of points representing the convex hull.\n     */\n    public Iterable<Point> hull() {\n        Stack<Point> s = new Stack<>();\n        for (Point p : hull) s.push(p);\n        return s;\n    }\n\n    public record Point(int x, int y) implements Comparable<Point> {\n\n        /**\n         * Default constructor\n         * @param x x-coordinate\n         * @param y y-coordinate\n         */\n        public Point { }\n\n            /**\n             * @return the x-coordinate\n             */\n            @Override\n            public int x() {\n                return x;\n            }\n\n            /**\n             * @return the y-coordinate\n             */\n            @Override\n            public int y() { return y; }\n\n            /**\n             * Finds the orientation of ordered triplet.\n             *\n             * @param a Co-ordinates of point a <int, int>\n             * @param b Co-ordinates of point a <int, int>\n             * @param c Co-ordinates of point a <int, int>\n             * @return { -1, 0, +1 } if a -\u2192 b -\u2192 c is a { clockwise, collinear; counterclockwise } turn.\n             */\n            public static int orientation(Point a, Point b, Point c) {\n                int val = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n                if (val == 0) {\n                    return 0;\n                }\n                return (val > 0) ? +1 : -1;\n            }\n\n            /**\n             * @param p2 Co-ordinate of point to compare to.\n             * This function will compare the points and will return a positive integer it the\n             * point is greater than the argument point and a negative integer if the point is\n             * less than the argument point.\n             */\n            public int compareTo(Point p2) {\n                if (this.y < p2.y) return -1;\n                if (this.y > p2.y) return +1;\n                if (this.x < p2.x) return -1;\n                if (this.x > p2.x) return +1;\n                return 0;\n            }\n\n            /**\n             * A helper function that will let us sort points by their polar order\n             * This function will compare the angle between 2 polar Co-ordinates\n             *\n             * @return the comparator\n             */\n            public Comparator<Point> polarOrder() {\n                return new PolarOrder();\n            }\n\n            private class PolarOrder implements Comparator<Point> {\n                public int compare(Point p1, Point p2) {\n                    int dx1 = p1.x - x;\n                    int dy1 = p1.y - y;\n                    int dx2 = p2.x - x;\n                    int dy2 = p2.y - y;\n\n                    if (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below\n                    else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above\n                    else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal\n                        if (dx1 >= 0 && dx2 < 0) return -1;\n                        else if (dx2 >= 0 && dx1 < 0) return +1;\n                        else return 0;\n                    } else return -orientation(Point.this, p1, p2);     // both above or below\n                }\n            }\n\n            /**\n             * Override of the toString method, necessary to compute the difference\n             * between the expected result and the derived result\n             *\n             * @return a string representation of any given 2D point in the format (x, y)\n             */\n            @Override\n            public String toString() {\n                return \"(\" + x + \", \" + y + \")\";\n            }\n        }\n}",
        "product_new_content": "package com.thealgorithms.geometry;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Stack;\n\n/*\n * A Java program that computes the convex hull using the Graham Scan algorithm\n * In the best case, time complexity is O(n), while in the worst case, it is log(n).\n * O(n) space complexity\n *\n * This algorithm is only applicable to integral coordinates.\n *\n * Reference:\n * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_algorithm.cpp\n * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_functions.hpp\n * https://algs4.cs.princeton.edu/99hull/GrahamScan.java.html\n */\npublic class GrahamScan {\n    private final Stack<Point> hull = new Stack<>();\n\n    public GrahamScan(Point[] points) {\n\n        /*\n         * pre-process the points by sorting them with respect to the bottom-most point, then we'll\n         * push the first point in the array to be our first extreme point.\n         */\n        Arrays.sort(points);\n        Arrays.sort(points, 1, points.length, points[0].polarOrder());\n        hull.push(points[0]);\n\n        // find index of first point not equal to a[0] (indexPoint1) and the first point that's not\n        // collinear with either (indexPoint2).\n        int indexPoint1;\n        for (indexPoint1 = 1; indexPoint1 < points.length; indexPoint1++)\n            if (!points[0].equals(points[indexPoint1])) break;\n        if (indexPoint1 == points.length) return;\n\n        int indexPoint2;\n        for (indexPoint2 = indexPoint1 + 1; indexPoint2 < points.length; indexPoint2++)\n            if (Point.orientation(points[0], points[indexPoint1], points[indexPoint2]) != 0) break;\n        hull.push(points[indexPoint2 - 1]);\n\n        // Now we simply add the point to the stack based on the orientation.\n        for (int i = indexPoint2; i < points.length; i++) {\n            Point top = hull.pop();\n            while (Point.orientation(hull.peek(), top, points[i]) <= 0) {\n                top = hull.pop();\n            }\n            hull.push(top);\n            hull.push(points[i]);\n        }\n    }\n\n    /**\n     * @return A stack of points representing the convex hull.\n     */\n    public Iterable<Point> hull() {\n        Stack<Point> s = new Stack<>();\n        for (Point p : hull) s.push(p);\n        return s;\n    }\n\n    public record Point(int x, int y) implements Comparable<Point> {\n\n        /**\n         * Default constructor\n         * @param x x-coordinate\n         * @param y y-coordinate\n         */\n        public Point {\n        }\n\n        /**\n         * @return the x-coordinate\n         */\n        @Override\n        public int x() {\n            return x;\n        }\n\n        /**\n         * @return the y-coordinate\n         */\n        @Override\n        public int y() {\n            return y;\n        }\n\n        /**\n         * Finds the orientation of ordered triplet.\n         *\n         * @param a Co-ordinates of point a <int, int>\n         * @param b Co-ordinates of point a <int, int>\n         * @param c Co-ordinates of point a <int, int>\n         * @return { -1, 0, +1 } if a -\u2192 b -\u2192 c is a { clockwise, collinear; counterclockwise }\n         *     turn.\n         */\n        public static int orientation(Point a, Point b, Point c) {\n            int val = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n            if (val == 0) {\n                return 0;\n            }\n            return (val > 0) ? +1 : -1;\n        }\n\n        /**\n         * @param p2 Co-ordinate of point to compare to.\n         * This function will compare the points and will return a positive integer it the\n         * point is greater than the argument point and a negative integer if the point is\n         * less than the argument point.\n         */\n        public int compareTo(Point p2) {\n            if (this.y < p2.y) return -1;\n            if (this.y > p2.y) return +1;\n            if (this.x < p2.x) return -1;\n            if (this.x > p2.x) return +1;\n            return 0;\n        }\n\n        /**\n         * A helper function that will let us sort points by their polar order\n         * This function will compare the angle between 2 polar Co-ordinates\n         *\n         * @return the comparator\n         */\n        public Comparator<Point> polarOrder() {\n            return new PolarOrder();\n        }\n\n        private class PolarOrder implements Comparator<Point> {\n            public int compare(Point p1, Point p2) {\n                int dx1 = p1.x - x;\n                int dy1 = p1.y - y;\n                int dx2 = p2.x - x;\n                int dy2 = p2.y - y;\n\n                if (dy1 >= 0 && dy2 < 0)\n                    return -1; // q1 above; q2 below\n                else if (dy2 >= 0 && dy1 < 0)\n                    return +1; // q1 below; q2 above\n                else if (dy1 == 0 && dy2 == 0) { // 3-collinear and horizontal\n                    if (dx1 >= 0 && dx2 < 0)\n                        return -1;\n                    else if (dx2 >= 0 && dx1 < 0)\n                        return +1;\n                    else\n                        return 0;\n                } else\n                    return -orientation(Point.this, p1, p2); // both above or below\n            }\n        }\n\n        /**\n         * Override of the toString method, necessary to compute the difference\n         * between the expected result and the derived result\n         *\n         * @return a string representation of any given 2D point in the format (x, y)\n         */\n        @Override\n        public String toString() {\n            return \"(\" + x + \", \" + y + \")\";\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.geometry;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class GrahamScanTest {\n    @Test\n    void testGrahamScan() {\n        GrahamScan.Point[] points = {new GrahamScan.Point(0, 3), new GrahamScan.Point(1, 1),\n                new GrahamScan.Point(2, 2), new GrahamScan.Point(4, 4),\n                new GrahamScan.Point(0, 0), new GrahamScan.Point(1, 2),\n                new GrahamScan.Point(3, 1), new GrahamScan.Point(3, 3)};\n        String expectedResult = \"[(0, 0), (3, 1), (4, 4), (0, 3)]\";\n\n        GrahamScan graham = new GrahamScan(points);\n        assertEquals(expectedResult, graham.hull().toString());\n    }\n}",
        "test_new_content": "package com.thealgorithms.geometry;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class GrahamScanTest {\n    @Test\n    void testGrahamScan() {\n        GrahamScan.Point[] points = {new GrahamScan.Point(0, 3), new GrahamScan.Point(1, 1),\n            new GrahamScan.Point(2, 2), new GrahamScan.Point(4, 4), new GrahamScan.Point(0, 0),\n            new GrahamScan.Point(1, 2), new GrahamScan.Point(3, 1), new GrahamScan.Point(3, 3)};\n        String expectedResult = \"[(0, 0), (3, 1), (4, 4), (0, 3)]\";\n\n        GrahamScan graham = new GrahamScan(points);\n        assertEquals(expectedResult, graham.hull().toString());\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/io/BufferedReader.java",
        "test_file_path": "src/test/java/com/thealgorithms/io/BufferedReaderTest.java",
        "product_old_content": "package com.thealgorithms.io;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Mimics the actions of the Original buffered reader\n * implements other actions, such as peek(n) to lookahead,\n * block() to read a chunk of size {BUFFER SIZE}\n * <p>\n * Author: Kumaraswamy B.G (Xoma Dev)\n */\npublic class BufferedReader {\n\n  private static final int DEFAULT_BUFFER_SIZE = 5;\n\n  /**\n   * Maximum number of bytes the buffer can hold.\n   * Value is changed when encountered Eof to not\n   * cause overflow read of 0 bytes\n   */\n\n  private int bufferSize;\n  private final byte[] buffer;\n\n  /**\n   * posRead -> indicates the next byte to read\n   */\n  private int posRead = 0, bufferPos = 0;\n\n  private boolean foundEof = false;\n\n  private InputStream input;\n\n  public BufferedReader(byte[] input) throws IOException {\n    this(new ByteArrayInputStream(input));\n  }\n\n  public BufferedReader(InputStream input) throws IOException {\n    this(input, DEFAULT_BUFFER_SIZE);\n  }\n\n  public BufferedReader(InputStream input, int bufferSize) throws IOException {\n    this.input = input;\n    if (input.available() == -1)\n      throw new IOException(\"Empty or already closed stream provided\");\n\n    this.bufferSize = bufferSize;\n    buffer = new byte[bufferSize];\n  }\n\n  /**\n   * Reads a single byte from the stream\n   */\n  public int read() throws IOException {\n    if (needsRefill()) {\n      if (foundEof)\n        return -1;\n      // the buffer is empty, or the buffer has\n      // been completely read and needs to be refilled\n      refill();\n    }\n    return buffer[posRead++] & 0xff; // read and un-sign it\n  }\n\n  /**\n   * Number of bytes not yet been read\n   */\n\n  public int available() throws IOException {\n    int available = input.available();\n    if (needsRefill())\n      // since the block is already empty,\n      // we have no responsibility yet\n      return available;\n    return bufferPos - posRead + available;\n  }\n\n  /**\n   * Returns the next character\n   */\n\n  public int peek() throws IOException {\n    return peek(1);\n  }\n\n  /**\n   * Peeks and returns a value located at next {n}\n   */\n\n  public int peek(int n) throws IOException {\n    int available = available();\n    if (n >= available)\n      throw new IOException(\"Out of range, available %d, but trying with %d\"\n              .formatted(available, n));\n    pushRefreshData();\n\n    if (n >= bufferSize)\n      throw new IllegalAccessError(\"Cannot peek %s, maximum upto %s (Buffer Limit)\"\n              .formatted(n, bufferSize));\n    return buffer[n];\n  }\n\n  /**\n   * Removes the already read bytes from the buffer\n   * in-order to make space for new bytes to be filled up.\n   * <p>\n   * This may also do the job to read first time data (whole buffer is empty)\n   */\n\n  private void pushRefreshData() throws IOException {\n    for (int i = posRead, j = 0; i < bufferSize; i++, j++)\n      buffer[j] = buffer[i];\n\n    bufferPos -= posRead;\n    posRead = 0;\n\n    // fill out the spaces that we've\n    // emptied\n    justRefill();\n  }\n\n  /**\n   * Reads one complete block of size {bufferSize}\n   * if found eof, the total length of array will\n   * be that of what's available\n   *\n   * @return a completed block\n   */\n  public byte[] readBlock() throws IOException {\n    pushRefreshData();\n\n    byte[] cloned = new byte[bufferSize];\n    // arraycopy() function is better than clone()\n    if (bufferPos >= 0)\n      System.arraycopy(buffer,\n              0,\n              cloned,\n              0,\n              // important to note that, bufferSize does not stay constant\n              // once the class is defined. See justRefill() function\n              bufferSize);\n    // we assume that already a chunk\n    // has been read\n    refill();\n    return cloned;\n  }\n\n  private boolean needsRefill() {\n    return bufferPos == 0 || posRead == bufferSize;\n  }\n\n  private void refill() throws IOException {\n    posRead = 0;\n    bufferPos = 0;\n    justRefill();\n  }\n\n  private void justRefill() throws IOException {\n    assertStreamOpen();\n\n    // try to fill in the maximum we can until\n    // we reach EOF\n    while (bufferPos < bufferSize) {\n      int read = input.read();\n      if (read == -1) {\n        // reached end-of-file, no more data left\n        // to be read\n        foundEof = true;\n        // rewrite the BUFFER_SIZE, to know that we've reached\n        // EOF when requested refill\n        bufferSize = bufferPos;\n      }\n      buffer[bufferPos++] = (byte) read;\n    }\n  }\n\n  private void assertStreamOpen() {\n    if (input == null)\n      throw new IllegalStateException(\"Input Stream already closed!\");\n  }\n\n  public void close() throws IOException {\n    if (input != null) {\n      try {\n        input.close();\n      } finally {\n        input = null;\n      }\n    }\n  }\n}",
        "product_new_content": "package com.thealgorithms.io;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Mimics the actions of the Original buffered reader\n * implements other actions, such as peek(n) to lookahead,\n * block() to read a chunk of size {BUFFER SIZE}\n * <p>\n * Author: Kumaraswamy B.G (Xoma Dev)\n */\npublic class BufferedReader {\n\n    private static final int DEFAULT_BUFFER_SIZE = 5;\n\n    /**\n     * Maximum number of bytes the buffer can hold.\n     * Value is changed when encountered Eof to not\n     * cause overflow read of 0 bytes\n     */\n\n    private int bufferSize;\n    private final byte[] buffer;\n\n    /**\n     * posRead -> indicates the next byte to read\n     */\n    private int posRead = 0, bufferPos = 0;\n\n    private boolean foundEof = false;\n\n    private InputStream input;\n\n    public BufferedReader(byte[] input) throws IOException {\n        this(new ByteArrayInputStream(input));\n    }\n\n    public BufferedReader(InputStream input) throws IOException {\n        this(input, DEFAULT_BUFFER_SIZE);\n    }\n\n    public BufferedReader(InputStream input, int bufferSize) throws IOException {\n        this.input = input;\n        if (input.available() == -1)\n            throw new IOException(\"Empty or already closed stream provided\");\n\n        this.bufferSize = bufferSize;\n        buffer = new byte[bufferSize];\n    }\n\n    /**\n     * Reads a single byte from the stream\n     */\n    public int read() throws IOException {\n        if (needsRefill()) {\n            if (foundEof) return -1;\n            // the buffer is empty, or the buffer has\n            // been completely read and needs to be refilled\n            refill();\n        }\n        return buffer[posRead++] & 0xff; // read and un-sign it\n    }\n\n    /**\n     * Number of bytes not yet been read\n     */\n\n    public int available() throws IOException {\n        int available = input.available();\n        if (needsRefill())\n            // since the block is already empty,\n            // we have no responsibility yet\n            return available;\n        return bufferPos - posRead + available;\n    }\n\n    /**\n     * Returns the next character\n     */\n\n    public int peek() throws IOException {\n        return peek(1);\n    }\n\n    /**\n     * Peeks and returns a value located at next {n}\n     */\n\n    public int peek(int n) throws IOException {\n        int available = available();\n        if (n >= available)\n            throw new IOException(\n                \"Out of range, available %d, but trying with %d\".formatted(available, n));\n        pushRefreshData();\n\n        if (n >= bufferSize)\n            throw new IllegalAccessError(\n                \"Cannot peek %s, maximum upto %s (Buffer Limit)\".formatted(n, bufferSize));\n        return buffer[n];\n    }\n\n    /**\n     * Removes the already read bytes from the buffer\n     * in-order to make space for new bytes to be filled up.\n     * <p>\n     * This may also do the job to read first time data (whole buffer is empty)\n     */\n\n    private void pushRefreshData() throws IOException {\n        for (int i = posRead, j = 0; i < bufferSize; i++, j++) buffer[j] = buffer[i];\n\n        bufferPos -= posRead;\n        posRead = 0;\n\n        // fill out the spaces that we've\n        // emptied\n        justRefill();\n    }\n\n    /**\n     * Reads one complete block of size {bufferSize}\n     * if found eof, the total length of array will\n     * be that of what's available\n     *\n     * @return a completed block\n     */\n    public byte[] readBlock() throws IOException {\n        pushRefreshData();\n\n        byte[] cloned = new byte[bufferSize];\n        // arraycopy() function is better than clone()\n        if (bufferPos >= 0)\n            System.arraycopy(buffer, 0, cloned, 0,\n                // important to note that, bufferSize does not stay constant\n                // once the class is defined. See justRefill() function\n                bufferSize);\n        // we assume that already a chunk\n        // has been read\n        refill();\n        return cloned;\n    }\n\n    private boolean needsRefill() {\n        return bufferPos == 0 || posRead == bufferSize;\n    }\n\n    private void refill() throws IOException {\n        posRead = 0;\n        bufferPos = 0;\n        justRefill();\n    }\n\n    private void justRefill() throws IOException {\n        assertStreamOpen();\n\n        // try to fill in the maximum we can until\n        // we reach EOF\n        while (bufferPos < bufferSize) {\n            int read = input.read();\n            if (read == -1) {\n                // reached end-of-file, no more data left\n                // to be read\n                foundEof = true;\n                // rewrite the BUFFER_SIZE, to know that we've reached\n                // EOF when requested refill\n                bufferSize = bufferPos;\n            }\n            buffer[bufferPos++] = (byte) read;\n        }\n    }\n\n    private void assertStreamOpen() {\n        if (input == null) throw new IllegalStateException(\"Input Stream already closed!\");\n    }\n\n    public void close() throws IOException {\n        if (input != null) {\n            try {\n                input.close();\n            } finally {\n                input = null;\n            }\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.io;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BufferedReaderTest {\n  @Test\n  public void testPeeks() throws IOException {\n    String text = \"Hello!\\nWorld!\";\n    int len = text.length();\n    byte[] bytes = text.getBytes();\n\n    ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n    BufferedReader reader = new BufferedReader(input);\n\n    // read the first letter\n    assertEquals(reader.read(), 'H');\n    len--;\n    assertEquals(reader.available(), len);\n\n    // position: H[e]llo!\\nWorld!\n    // reader.read() will be == 'e'\n    assertEquals(reader.peek(1), 'l');\n    assertEquals(reader.peek(2), 'l'); // second l\n    assertEquals(reader.peek(3), 'o');\n  }\n\n  @Test\n  public void testMixes() throws IOException {\n    String text = \"Hello!\\nWorld!\";\n    int len = text.length();\n    byte[] bytes = text.getBytes();\n\n    ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n    BufferedReader reader = new BufferedReader(input);\n\n    // read the first letter\n    assertEquals(reader.read(), 'H'); // first letter\n    len--;\n\n    assertEquals(reader.peek(1), 'l'); // third later (second letter after 'H')\n    assertEquals(reader.read(), 'e'); // second letter\n    len--;\n    assertEquals(reader.available(), len);\n\n    // position: H[e]llo!\\nWorld!\n    assertEquals(reader.peek(2), 'o'); // second l\n    assertEquals(reader.peek(3), '!');\n    assertEquals(reader.peek(4), '\\n');\n\n    assertEquals(reader.read(), 'l'); // third letter\n    assertEquals(reader.peek(1), 'o'); // fourth letter\n\n    for (int i = 0; i < 6; i++)\n      reader.read();\n    try {\n      System.out.println((char) reader.peek(4));\n    } catch (Exception ignored) {\n      System.out.println(\"[cached intentional error]\");\n      // intentional, for testing purpose\n    }\n  }\n\n  @Test\n  public void testBlockPractical() throws IOException {\n    String text = \"!Hello\\nWorld!\";\n    byte[] bytes = text.getBytes();\n    int len = bytes.length;\n\n    ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n    BufferedReader reader = new BufferedReader(input);\n\n\n    assertEquals(reader.peek(), 'H');\n    assertEquals(reader.read(), '!'); // read the first letter\n    len--;\n\n    // this only reads the next 5 bytes (Hello) because\n    // the default buffer size = 5\n    assertEquals(new String(reader.readBlock()), \"Hello\");\n    len -= 5;\n    assertEquals(reader.available(), len);\n\n    // maybe kind of a practical demonstration / use case\n    if (reader.read() == '\\n') {\n      assertEquals(reader.read(), 'W');\n      assertEquals(reader.read(), 'o');\n\n      // the rest of the blocks\n      assertEquals(new String(reader.readBlock()), \"rld!\");\n    } else {\n      // should not reach\n      throw new IOException(\"Something not right\");\n    }\n  }\n}",
        "test_new_content": "package com.thealgorithms.io;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\nclass BufferedReaderTest {\n    @Test\n    public void testPeeks() throws IOException {\n        String text = \"Hello!\\nWorld!\";\n        int len = text.length();\n        byte[] bytes = text.getBytes();\n\n        ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n        BufferedReader reader = new BufferedReader(input);\n\n        // read the first letter\n        assertEquals(reader.read(), 'H');\n        len--;\n        assertEquals(reader.available(), len);\n\n        // position: H[e]llo!\\nWorld!\n        // reader.read() will be == 'e'\n        assertEquals(reader.peek(1), 'l');\n        assertEquals(reader.peek(2), 'l'); // second l\n        assertEquals(reader.peek(3), 'o');\n    }\n\n    @Test\n    public void testMixes() throws IOException {\n        String text = \"Hello!\\nWorld!\";\n        int len = text.length();\n        byte[] bytes = text.getBytes();\n\n        ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n        BufferedReader reader = new BufferedReader(input);\n\n        // read the first letter\n        assertEquals(reader.read(), 'H'); // first letter\n        len--;\n\n        assertEquals(reader.peek(1), 'l'); // third later (second letter after 'H')\n        assertEquals(reader.read(), 'e'); // second letter\n        len--;\n        assertEquals(reader.available(), len);\n\n        // position: H[e]llo!\\nWorld!\n        assertEquals(reader.peek(2), 'o'); // second l\n        assertEquals(reader.peek(3), '!');\n        assertEquals(reader.peek(4), '\\n');\n\n        assertEquals(reader.read(), 'l'); // third letter\n        assertEquals(reader.peek(1), 'o'); // fourth letter\n\n        for (int i = 0; i < 6; i++) reader.read();\n        try {\n            System.out.println((char) reader.peek(4));\n        } catch (Exception ignored) {\n            System.out.println(\"[cached intentional error]\");\n            // intentional, for testing purpose\n        }\n    }\n\n    @Test\n    public void testBlockPractical() throws IOException {\n        String text = \"!Hello\\nWorld!\";\n        byte[] bytes = text.getBytes();\n        int len = bytes.length;\n\n        ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n        BufferedReader reader = new BufferedReader(input);\n\n        assertEquals(reader.peek(), 'H');\n        assertEquals(reader.read(), '!'); // read the first letter\n        len--;\n\n        // this only reads the next 5 bytes (Hello) because\n        // the default buffer size = 5\n        assertEquals(new String(reader.readBlock()), \"Hello\");\n        len -= 5;\n        assertEquals(reader.available(), len);\n\n        // maybe kind of a practical demonstration / use case\n        if (reader.read() == '\\n') {\n            assertEquals(reader.read(), 'W');\n            assertEquals(reader.read(), 'o');\n\n            // the rest of the blocks\n            assertEquals(new String(reader.readBlock()), \"rld!\");\n        } else {\n            // should not reach\n            throw new IOException(\"Something not right\");\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ADTFraction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ADTFractionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic record ADTFraction(int numerator, int denominator) {\n    /**\n     * Initializes a newly created {@code ADTFraction} object so that it represents\n     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.\n     *\n     * @param numerator   The fraction numerator\n     * @param denominator The fraction denominator\n     */\n    public ADTFraction {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be 0\");\n        }\n    }\n\n    /**\n     * Add two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to add\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction plus(ADTFraction fraction) {\n        var numerator =\n            this.denominator *\n            fraction.numerator +\n            this.numerator *\n            fraction.denominator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Multiply fraction by a number.\n     *\n     * @param number the number to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(int number) {\n        return times(new ADTFraction(number, 1));\n    }\n\n    /**\n     * Multiply two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(ADTFraction fraction) {\n        var numerator = this.numerator * fraction.numerator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Generates the reciprocal of the fraction.\n     *\n     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched\n     */\n    public ADTFraction reciprocal() {\n        return new ADTFraction(this.denominator, this.numerator);\n    }\n\n    /**\n     * Calculates the result of the fraction.\n     *\n     * @return The numerical result of the division between {@code numerator} and {@code denominator}\n     */\n    public float value() {\n        return (float) this.numerator / this.denominator;\n    }\n\n    /**\n     * Returns a string representation of this {@code ADTFraction} in the format\n     * {@code numerator}/{@code denominator}.\n     *\n     * @return A string representation of this {@code ADTFraction}\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%d/%d\", this.numerator, this.denominator);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic record ADTFraction(int numerator, int denominator) {\n    /**\n     * Initializes a newly created {@code ADTFraction} object so that it represents\n     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.\n     *\n     * @param numerator   The fraction numerator\n     * @param denominator The fraction denominator\n     */\n    public ADTFraction {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be 0\");\n        }\n    }\n\n    /**\n     * Add two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to add\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction plus(ADTFraction fraction) {\n        var numerator\n            = this.denominator * fraction.numerator + this.numerator * fraction.denominator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Multiply fraction by a number.\n     *\n     * @param number the number to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(int number) {\n        return times(new ADTFraction(number, 1));\n    }\n\n    /**\n     * Multiply two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(ADTFraction fraction) {\n        var numerator = this.numerator * fraction.numerator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Generates the reciprocal of the fraction.\n     *\n     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched\n     */\n    public ADTFraction reciprocal() {\n        return new ADTFraction(this.denominator, this.numerator);\n    }\n\n    /**\n     * Calculates the result of the fraction.\n     *\n     * @return The numerical result of the division between {@code numerator} and {@code\n     *     denominator}\n     */\n    public float value() {\n        return (float) this.numerator / this.denominator;\n    }\n\n    /**\n     * Returns a string representation of this {@code ADTFraction} in the format\n     * {@code numerator}/{@code denominator}.\n     *\n     * @return A string representation of this {@code ADTFraction}\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%d/%d\", this.numerator, this.denominator);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ADTFractionTest {\n\n    private final ADTFraction fraction1 = new ADTFraction(3, 5);\n    private final ADTFraction fraction2 = new ADTFraction(7, 8);\n\n    @Test\n    void testConstructorWithDenominatorEqualToZero() {\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> new ADTFraction(1, 0)\n        );\n        assertEquals(\"Denominator cannot be 0\", exception.getMessage());\n    }\n\n    @Test\n    public void testPlus() {\n        assertEquals(new ADTFraction(59, 40), fraction1.plus(fraction2));\n    }\n\n    @Test\n    public void testTimes() {\n        assertEquals(new ADTFraction(12, 5), fraction1.times(4));\n        assertEquals(new ADTFraction(21, 40), fraction1.times(fraction2));\n    }\n\n    @Test\n    public void testReciprocal() {\n        assertEquals(new ADTFraction(5, 3), fraction1.reciprocal());\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(0.6F, fraction1.value());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        ADTFraction fraction3 = new ADTFraction(3, 5);\n        assertTrue(fraction1.equals(fraction3) && fraction3.equals(fraction1));\n        assertEquals(fraction1.hashCode(), fraction3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"3/5\", fraction1.toString());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ADTFractionTest {\n\n    private final ADTFraction fraction1 = new ADTFraction(3, 5);\n    private final ADTFraction fraction2 = new ADTFraction(7, 8);\n\n    @Test\n    void testConstructorWithDenominatorEqualToZero() {\n        Exception exception\n            = assertThrows(IllegalArgumentException.class, () -> new ADTFraction(1, 0));\n        assertEquals(\"Denominator cannot be 0\", exception.getMessage());\n    }\n\n    @Test\n    public void testPlus() {\n        assertEquals(new ADTFraction(59, 40), fraction1.plus(fraction2));\n    }\n\n    @Test\n    public void testTimes() {\n        assertEquals(new ADTFraction(12, 5), fraction1.times(4));\n        assertEquals(new ADTFraction(21, 40), fraction1.times(fraction2));\n    }\n\n    @Test\n    public void testReciprocal() {\n        assertEquals(new ADTFraction(5, 3), fraction1.reciprocal());\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(0.6F, fraction1.value());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        ADTFraction fraction3 = new ADTFraction(3, 5);\n        assertTrue(fraction1.equals(fraction3) && fraction3.equals(fraction1));\n        assertEquals(fraction1.hashCode(), fraction3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"3/5\", fraction1.toString());\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMin {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute min value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute min value\n     */\n    public static int getMinValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMinWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays\n            .stream(numbers)\n            .skip(1)\n            .filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value))\n            .forEach(number -> absMinWrapper.value = number);\n\n        return absMinWrapper.value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMin {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute min value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute min value\n     */\n    public static int getMinValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMinWrapper = new Object() { int value = numbers[0]; };\n\n        Arrays.stream(numbers)\n            .skip(1)\n            .filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value))\n            .forEach(number -> absMinWrapper.value = number);\n\n        return absMinWrapper.value;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMinTest {\n\n    @Test\n    void testGetMinValue() {\n        assertEquals(0, AbsoluteMin.getMinValue(4, 0, 16));\n        assertEquals(-2, AbsoluteMin.getMinValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMinValueWithNoArguments() {\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> AbsoluteMin.getMinValue()\n        );\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMinTest {\n\n    @Test\n    void testGetMinValue() {\n        assertEquals(0, AbsoluteMin.getMinValue(4, 0, 16));\n        assertEquals(-2, AbsoluteMin.getMinValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMinValueWithNoArguments() {\n        Exception exception\n            = assertThrows(IllegalArgumentException.class, () -> AbsoluteMin.getMinValue());\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Area.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AreaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(\n        final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1))\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            ()\n                -> assertThrows(\n                    IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AutomorphicNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Wikipedia link for Automorphic Number : https://en.wikipedia.org/wiki/Automorphic_number\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\n\nimport java.math.BigInteger;\n\npublic class AutomorphicNumber {\n\n    /**\n     * A function to check if a number is Automorphic number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic(long n) {\n        if (n < 0)\n            return false;\n        long square = n * n; // Calculating square of the number\n        long t = n, numberOfdigits = 0;\n        while (t > 0) {\n            numberOfdigits++; // Calculating number of digits in n\n            t /= 10;\n        }\n        long lastDigits = square % (long) Math.pow(10, numberOfdigits); // Extracting last Digits of square\n        return n == lastDigits;\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using String functions\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic2(long n) {\n        if (n < 0)\n            return false;\n        long square = n * n; // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using BigInteger\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic3(String s) {\n        BigInteger n = new BigInteger(s);\n        if (n.signum() == -1) \n            return false; //if number is negative, return false\n        BigInteger square = n.multiply(n); // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Wikipedia link for Automorphic Number : https://en.wikipedia.org/wiki/Automorphic_number\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\n\nimport java.math.BigInteger;\n\npublic class AutomorphicNumber {\n\n    /**\n     * A function to check if a number is Automorphic number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic(long n) {\n        if (n < 0) return false;\n        long square = n * n; // Calculating square of the number\n        long t = n, numberOfdigits = 0;\n        while (t > 0) {\n            numberOfdigits++; // Calculating number of digits in n\n            t /= 10;\n        }\n        long lastDigits\n            = square % (long) Math.pow(10, numberOfdigits); // Extracting last Digits of square\n        return n == lastDigits;\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using String functions\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic2(long n) {\n        if (n < 0) return false;\n        long square = n * n; // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using BigInteger\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic3(String s) {\n        BigInteger n = new BigInteger(s);\n        if (n.signum() == -1) return false; // if number is negative, return false\n        BigInteger square = n.multiply(n); // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AutomorphicNumberTest {\n\n    @Test\n    void testAutomorphicNumber() {\n        int[] trueTestCases = { 0, 1, 25, 625, 12890625};\n        int[] falseTestCases = { -5, 2, 26, 1234 };\n        for (Integer n : trueTestCases) {\n            assertTrue(AutomorphicNumber.isAutomorphic(n));\n            assertTrue(AutomorphicNumber.isAutomorphic2(n));\n            assertTrue(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(AutomorphicNumber.isAutomorphic(n));\n            assertFalse(AutomorphicNumber.isAutomorphic2(n));\n            assertFalse(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        assertTrue(AutomorphicNumber.isAutomorphic3(\"59918212890625\")); // Special case for BigInteger\n        assertFalse(AutomorphicNumber.isAutomorphic3(\"12345678912345\")); // Special case for BigInteger\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AutomorphicNumberTest {\n\n    @Test\n    void testAutomorphicNumber() {\n        int[] trueTestCases = {0, 1, 25, 625, 12890625};\n        int[] falseTestCases = {-5, 2, 26, 1234};\n        for (Integer n : trueTestCases) {\n            assertTrue(AutomorphicNumber.isAutomorphic(n));\n            assertTrue(AutomorphicNumber.isAutomorphic2(n));\n            assertTrue(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(AutomorphicNumber.isAutomorphic(n));\n            assertFalse(AutomorphicNumber.isAutomorphic2(n));\n            assertFalse(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        assertTrue(\n            AutomorphicNumber.isAutomorphic3(\"59918212890625\")); // Special case for BigInteger\n        assertFalse(\n            AutomorphicNumber.isAutomorphic3(\"12345678912345\")); // Special case for BigInteger\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DistanceFormula.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DistanceFormulaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class DistanceFormula {\n\n    public static double euclideanDistance(\n        double x1,\n        double y1,\n        double x2,\n        double y2\n    ) {\n        double dX = Math.pow(x2 - x1, 2);\n        double dY = Math.pow(y2 - x1, 2);\n        return Math.sqrt(dX + dY);\n    }\n\n    public static double manhattanDistance(\n        double x1,\n        double y1,\n        double x2,\n        double y2\n    ) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n\n    public static int hammingDistance(int[] b1, int[] b2) {\n        int d = 0;\n\n        if (b1.length != b2.length) {\n            return -1; // error, both array must be have the same length\n        }\n\n        for (int i = 0; i < b1.length; i++) {\n            d += Math.abs(b1[i] - b2[i]);\n        }\n\n        return d;\n    }\n\n    public static double minkowskiDistance(double[] p1, double[] p2, int p) {\n        double d = 0;\n        double distance = 0.0;\n\n        if (p1.length != p2.length) {\n            return -1; // error, both array must be have the same length\n        }\n\n        for (int i = 0; i < p1.length; i++) {\n            distance += Math.abs(Math.pow(p1[i] - p2[i], p));\n        }\n\n        distance = Math.pow(distance, (double) 1 / p);\n        d = distance;\n        return d;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class DistanceFormula {\n\n    public static double euclideanDistance(double x1, double y1, double x2, double y2) {\n        double dX = Math.pow(x2 - x1, 2);\n        double dY = Math.pow(y2 - x1, 2);\n        return Math.sqrt(dX + dY);\n    }\n\n    public static double manhattanDistance(double x1, double y1, double x2, double y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n\n    public static int hammingDistance(int[] b1, int[] b2) {\n        int d = 0;\n\n        if (b1.length != b2.length) {\n            return -1; // error, both array must be have the same length\n        }\n\n        for (int i = 0; i < b1.length; i++) {\n            d += Math.abs(b1[i] - b2[i]);\n        }\n\n        return d;\n    }\n\n    public static double minkowskiDistance(double[] p1, double[] p2, int p) {\n        double d = 0;\n        double distance = 0.0;\n\n        if (p1.length != p2.length) {\n            return -1; // error, both array must be have the same length\n        }\n\n        for (int i = 0; i < p1.length; i++) {\n            distance += Math.abs(Math.pow(p1[i] - p2[i], p));\n        }\n\n        distance = Math.pow(distance, (double) 1 / p);\n        d = distance;\n        return d;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DistanceFormulaTest {\n\n    @Test\n    void euclideanTest1() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(1, 1, 2, 2),\n            1.4142135623730951\n        );\n    }\n\n    @Test\n    void euclideanTest2() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(1, 3, 8, 0),\n            7.0710678118654755\n        );\n    }\n\n    @Test\n    void euclideanTest3() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(2.4, 9.1, 55.1, 100),\n            110.91911467371168\n        );\n    }\n\n    @Test\n    void euclideanTest4() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(1000, 13, 20000, 84),\n            19022.067605809836\n        );\n    }\n\n    @Test\n    public void manhattantest1() {\n        assertEquals(DistanceFormula.manhattanDistance(1, 2, 3, 4), 4);\n    }\n\n    @Test\n    public void manhattantest2() {\n        assertEquals(\n            DistanceFormula.manhattanDistance(6.5, 8.4, 20.1, 13.6),\n            18.8\n        );\n    }\n\n    @Test\n    public void manhattanTest3() {\n        assertEquals(\n            DistanceFormula.manhattanDistance(10.112, 50, 8, 25.67),\n            26.442\n        );\n    }\n\n    @Test\n    public void hammingTest1() {\n        int[] array1 = { 1, 1, 1, 1 };\n        int[] array2 = { 0, 0, 0, 0 };\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 4);\n    }\n\n    @Test\n    public void hammingTest2() {\n        int[] array1 = { 1, 1, 1, 1 };\n        int[] array2 = { 1, 1, 1, 1 };\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 0);\n    }\n\n    @Test\n    public void hammingTest3() {\n        int[] array1 = { 1, 0, 0, 1, 1, 0, 1, 1, 0 };\n        int[] array2 = { 0, 1, 0, 0, 1, 1, 1, 0, 0 };\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 5);\n    }\n\n    @Test\n    public void minkowskiTest1() {\n        double[] array1 = { 1, 3, 8, 5 };\n        double[] array2 = { 4, 2, 6, 9 };\n        assertEquals(DistanceFormula.minkowskiDistance(array1, array2, 1), 10);\n    }\n\n    @Test\n    public void minkowskiTest2() {\n        double[] array1 = { 1, 3, 8, 5 };\n        double[] array2 = { 4, 2, 6, 9 };\n        assertEquals(\n            DistanceFormula.minkowskiDistance(array1, array2, 2),\n            5.477225575051661\n        );\n    }\n\n    @Test\n    public void minkowskiTest3() {\n        double[] array1 = { 1, 3, 8, 5 };\n        double[] array2 = { 4, 2, 6, 9 };\n        assertEquals(\n            DistanceFormula.minkowskiDistance(array1, array2, 3),\n            4.641588833612778\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DistanceFormulaTest {\n\n    @Test\n    void euclideanTest1() {\n        Assertions.assertEquals(DistanceFormula.euclideanDistance(1, 1, 2, 2), 1.4142135623730951);\n    }\n\n    @Test\n    void euclideanTest2() {\n        Assertions.assertEquals(DistanceFormula.euclideanDistance(1, 3, 8, 0), 7.0710678118654755);\n    }\n\n    @Test\n    void euclideanTest3() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(2.4, 9.1, 55.1, 100), 110.91911467371168);\n    }\n\n    @Test\n    void euclideanTest4() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(1000, 13, 20000, 84), 19022.067605809836);\n    }\n\n    @Test\n    public void manhattantest1() {\n        assertEquals(DistanceFormula.manhattanDistance(1, 2, 3, 4), 4);\n    }\n\n    @Test\n    public void manhattantest2() {\n        assertEquals(DistanceFormula.manhattanDistance(6.5, 8.4, 20.1, 13.6), 18.8);\n    }\n\n    @Test\n    public void manhattanTest3() {\n        assertEquals(DistanceFormula.manhattanDistance(10.112, 50, 8, 25.67), 26.442);\n    }\n\n    @Test\n    public void hammingTest1() {\n        int[] array1 = {1, 1, 1, 1};\n        int[] array2 = {0, 0, 0, 0};\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 4);\n    }\n\n    @Test\n    public void hammingTest2() {\n        int[] array1 = {1, 1, 1, 1};\n        int[] array2 = {1, 1, 1, 1};\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 0);\n    }\n\n    @Test\n    public void hammingTest3() {\n        int[] array1 = {1, 0, 0, 1, 1, 0, 1, 1, 0};\n        int[] array2 = {0, 1, 0, 0, 1, 1, 1, 0, 0};\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 5);\n    }\n\n    @Test\n    public void minkowskiTest1() {\n        double[] array1 = {1, 3, 8, 5};\n        double[] array2 = {4, 2, 6, 9};\n        assertEquals(DistanceFormula.minkowskiDistance(array1, array2, 1), 10);\n    }\n\n    @Test\n    public void minkowskiTest2() {\n        double[] array1 = {1, 3, 8, 5};\n        double[] array2 = {4, 2, 6, 9};\n        assertEquals(DistanceFormula.minkowskiDistance(array1, array2, 2), 5.477225575051661);\n    }\n\n    @Test\n    public void minkowskiTest3() {\n        double[] array1 = {1, 3, 8, 5};\n        double[] array2 = {4, 2, 6, 9};\n        assertEquals(DistanceFormula.minkowskiDistance(array1, array2, 3), 4.641588833612778);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DudeneyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DudeneyNumberTest.java",
        "product_old_content": "/**\n * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.\n * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.\n *          Since, the sum of the digits is equal to the cube root of the entered number;\n *          it is a Dudeney Number.\n */\npackage com.thealgorithms.maths;\n\nimport java.io.*;\n\npublic class DudeneyNumber {\n\n    //returns True if the number is a Dudeney number and False if it is not a Dudeney number.\n    public static boolean isDudeney(int n) {\n        // Calculating Cube Root\n        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));\n        // If the number is not a perfect cube the method returns false.\n        if (cube_root * cube_root * cube_root != n) {\n            return false;\n        }\n        int sum_of_digits = 0; // Stores the sums of the digit of the entered number\n        int temp = n; //A temporary variable to store the entered number\n        // Loop to calculate sum of the digits.\n        while (temp > 0) {\n            // Extracting Last digit of the number\n            int rem = temp % 10;\n\n            // Calculating sum of digits.\n            sum_of_digits += rem;\n\n            // Removing the last digit\n            temp /= 10;\n        }\n\n        //If the cube root of the number is not equal to the sum of its digits we return false.\n        return cube_root == sum_of_digits;\n    }\n}",
        "product_new_content": "/**\n * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.\n * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.\n *          Since, the sum of the digits is equal to the cube root of the entered number;\n *          it is a Dudeney Number.\n */\npackage com.thealgorithms.maths;\n\nimport java.io.*;\n\npublic class DudeneyNumber {\n\n    // returns True if the number is a Dudeney number and False if it is not a Dudeney number.\n    public static boolean isDudeney(int n) {\n        // Calculating Cube Root\n        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));\n        // If the number is not a perfect cube the method returns false.\n        if (cube_root * cube_root * cube_root != n) {\n            return false;\n        }\n        int sum_of_digits = 0; // Stores the sums of the digit of the entered number\n        int temp = n; // A temporary variable to store the entered number\n        // Loop to calculate sum of the digits.\n        while (temp > 0) {\n            // Extracting Last digit of the number\n            int rem = temp % 10;\n\n            // Calculating sum of digits.\n            sum_of_digits += rem;\n\n            // Removing the last digit\n            temp /= 10;\n        }\n\n        // If the cube root of the number is not equal to the sum of its digits we return false.\n        return cube_root == sum_of_digits;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass DudeneyNumberTest {\n\n    @Test\n    void isDudeney() {\n        final int validDudeneyNumber = 512;\n        final int invalidDudeneyNumber = 125;\n\n        assertTrue(() -> DudeneyNumber.isDudeney(validDudeneyNumber));\n        assertFalse(() -> DudeneyNumber.isDudeney(invalidDudeneyNumber));\n\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass DudeneyNumberTest {\n\n    @Test\n    void isDudeney() {\n        final int validDudeneyNumber = 512;\n        final int invalidDudeneyNumber = 125;\n\n        assertTrue(() -> DudeneyNumber.isDudeney(validDudeneyNumber));\n        assertFalse(() -> DudeneyNumber.isDudeney(invalidDudeneyNumber));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FrizzyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FrizzyNumberTest.java",
        "product_old_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find the FrizzyNumber*/\n\n\npackage com.thealgorithms.maths;\n\npublic class FrizzyNumber {\n\n    /**\n     * Returns the n-th number that is a sum of powers\n     * of the given base.\n     * Example: base = 3 and n = 4\n     * Ascending order of sums of powers of 3 =\n     * 3^0 = 1, 3^1 = 3, 3^1 + 3^0 = 4, 3^2 + 3^0 = 9\n     * Ans = 9\n     * \n     * @param base The base whose n-th sum of powers is required\n     * @param n    Index from ascending order of sum of powers of base\n     * @return n-th sum of powers of base\n     */\n    public static double getNthFrizzy(int base, int n) {\n        double final1 = 0.0;\n        int i = 0;\n        do\n        {\n            final1 += Math.pow(base, i++) * (n % 2);\n        } while ((n /= 2) > 0);\n        return final1;\n    }\n}",
        "product_new_content": "/**\n * Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find the FrizzyNumber*/\n\npackage com.thealgorithms.maths;\n\npublic class FrizzyNumber {\n\n    /**\n     * Returns the n-th number that is a sum of powers\n     * of the given base.\n     * Example: base = 3 and n = 4\n     * Ascending order of sums of powers of 3 =\n     * 3^0 = 1, 3^1 = 3, 3^1 + 3^0 = 4, 3^2 + 3^0 = 9\n     * Ans = 9\n     *\n     * @param base The base whose n-th sum of powers is required\n     * @param n    Index from ascending order of sum of powers of base\n     * @return n-th sum of powers of base\n     */\n    public static double getNthFrizzy(int base, int n) {\n        double final1 = 0.0;\n        int i = 0;\n        do {\n            final1 += Math.pow(base, i++) * (n % 2);\n        } while ((n /= 2) > 0);\n        return final1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class FrizzyNumberTest {\n    @Test\n    public void testFrizziesForBase2() {\n        assertEquals(\n                1,\n                FrizzyNumber.getNthFrizzy(2, 1));\n        assertEquals(\n                3,\n                FrizzyNumber.getNthFrizzy(2, 3));\n        assertEquals(\n                1000,\n                FrizzyNumber.getNthFrizzy(2, 1000));\n    }\n\n    @Test\n    public void testFrizziesForBase3() {\n        assertEquals(\n                1,\n                FrizzyNumber.getNthFrizzy(3, 1));\n        assertEquals(\n                3,\n                FrizzyNumber.getNthFrizzy(3, 2));\n        assertEquals(\n                29430,\n                FrizzyNumber.getNthFrizzy(3, 1000));\n    }\n\n    @Test\n    public void testFrizziesForBase69() {\n        assertEquals(\n                1,\n                FrizzyNumber.getNthFrizzy(69, 1));\n        assertEquals(\n                69,\n                FrizzyNumber.getNthFrizzy(69, 2));\n        assertEquals(\n                328510,\n                FrizzyNumber.getNthFrizzy(69, 9));\n        assertEquals(\n                333340,\n                FrizzyNumber.getNthFrizzy(69, 15));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class FrizzyNumberTest {\n    @Test\n    public void testFrizziesForBase2() {\n        assertEquals(1, FrizzyNumber.getNthFrizzy(2, 1));\n        assertEquals(3, FrizzyNumber.getNthFrizzy(2, 3));\n        assertEquals(1000, FrizzyNumber.getNthFrizzy(2, 1000));\n    }\n\n    @Test\n    public void testFrizziesForBase3() {\n        assertEquals(1, FrizzyNumber.getNthFrizzy(3, 1));\n        assertEquals(3, FrizzyNumber.getNthFrizzy(3, 2));\n        assertEquals(29430, FrizzyNumber.getNthFrizzy(3, 1000));\n    }\n\n    @Test\n    public void testFrizziesForBase69() {\n        assertEquals(1, FrizzyNumber.getNthFrizzy(69, 1));\n        assertEquals(69, FrizzyNumber.getNthFrizzy(69, 2));\n        assertEquals(328510, FrizzyNumber.getNthFrizzy(69, 9));\n        assertEquals(333340, FrizzyNumber.getNthFrizzy(69, 15));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/GCD.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GCDTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * @brief computes gcd of an array of numbers\n     *\n     * @param numbers the input array\n     * @return gcd of all of the numbers in the input array\n     */\n    public static int gcd(int[] numbers) {\n        int result = 0;\n        for (final var number : numbers) {\n            result = gcd(result, number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * @brief computes gcd of an array of numbers\n     *\n     * @param numbers the input array\n     * @return gcd of all of the numbers in the input array\n     */\n    public static int gcd(int[] numbers) {\n        int result = 0;\n        for (final var number : numbers) {\n            result = gcd(result, number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = {4, 16, 32};\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\"gcd(40,24)=%d gcd(24,40)=%d%n\", gcd(40, 24), gcd(24, 40)); // => 8\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-1, 0)\n        );\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(10, -2)\n        );\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-5, -3)\n        );\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n    \n    @Test\n    void testArrayGcd1() {\n        Assertions.assertEquals(GCD.gcd(new int[]{9, 6}), 3);\n    }\n\n    @Test\n    void testArrayGcd2() {\n        Assertions.assertEquals(GCD.gcd(new int[]{2*3*5*7, 2*5*5*5, 2*5*11, 5*5*5*13}), 5);\n    }\n    \n    @Test\n    void testArrayGcdForEmptyInput() {\n        Assertions.assertEquals(GCD.gcd(new int[]{}), 0);\n    }    \n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-1, 0));\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(10, -2));\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-5, -3));\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n\n    @Test\n    void testArrayGcd1() {\n        Assertions.assertEquals(GCD.gcd(new int[] {9, 6}), 3);\n    }\n\n    @Test\n    void testArrayGcd2() {\n        Assertions.assertEquals(\n            GCD.gcd(new int[] {2 * 3 * 5 * 7, 2 * 5 * 5 * 5, 2 * 5 * 11, 5 * 5 * 5 * 13}), 5);\n    }\n\n    @Test\n    void testArrayGcdForEmptyInput() {\n        Assertions.assertEquals(GCD.gcd(new int[] {}), 0);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/HarshadNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/HarshadNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n// Wikipedia for Harshad Number : https://en.wikipedia.org/wiki/Harshad_number\n\npublic class HarshadNumber {\n\n    /**\n     * A function to check if a number is Harshad number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Harshad number, otherwise\n     *         {@code false}\n     */\n    public static boolean isHarshad(long n) {\n        if (n <= 0)\n            return false;\n\n        long t = n;\n        int sumOfDigits = 0;\n        while (t > 0) {\n            sumOfDigits += t % 10;\n            t /= 10;\n        }\n\n        return n % sumOfDigits == 0;\n    }\n\n    /**\n     * A function to check if a number is Harshad number or not\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Harshad number, otherwise\n     *         {@code false}\n     */\n    public static boolean isHarshad(String s) {\n        long n = Long.valueOf(s);\n        if (n <= 0)\n            return false;\n\n        int sumOfDigits = 0;\n        for (char ch : s.toCharArray()) {\n            sumOfDigits += ch - '0';\n        }\n\n        return n % sumOfDigits == 0;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n// Wikipedia for Harshad Number : https://en.wikipedia.org/wiki/Harshad_number\n\npublic class HarshadNumber {\n\n    /**\n     * A function to check if a number is Harshad number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Harshad number, otherwise\n     *         {@code false}\n     */\n    public static boolean isHarshad(long n) {\n        if (n <= 0) return false;\n\n        long t = n;\n        int sumOfDigits = 0;\n        while (t > 0) {\n            sumOfDigits += t % 10;\n            t /= 10;\n        }\n\n        return n % sumOfDigits == 0;\n    }\n\n    /**\n     * A function to check if a number is Harshad number or not\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Harshad number, otherwise\n     *         {@code false}\n     */\n    public static boolean isHarshad(String s) {\n        long n = Long.valueOf(s);\n        if (n <= 0) return false;\n\n        int sumOfDigits = 0;\n        for (char ch : s.toCharArray()) {\n            sumOfDigits += ch - '0';\n        }\n\n        return n % sumOfDigits == 0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class HarshadNumberTest {\n\n    @Test\n    public void harshadNumber() {\n        \n        assertTrue(HarshadNumber.isHarshad(18));\n        assertFalse(HarshadNumber.isHarshad(-18));\n        assertFalse(HarshadNumber.isHarshad(19));\n        assertTrue(HarshadNumber.isHarshad(999999999));\n        assertFalse(HarshadNumber.isHarshad(0));\n\n        assertTrue(HarshadNumber.isHarshad(\"18\"));\n        assertFalse(HarshadNumber.isHarshad(\"-18\"));\n        assertFalse(HarshadNumber.isHarshad(\"19\"));\n        assertTrue(HarshadNumber.isHarshad(\"999999999\"));\n        assertTrue(HarshadNumber.isHarshad(\"99999999999100\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HarshadNumberTest {\n\n    @Test\n    public void harshadNumber() {\n\n        assertTrue(HarshadNumber.isHarshad(18));\n        assertFalse(HarshadNumber.isHarshad(-18));\n        assertFalse(HarshadNumber.isHarshad(19));\n        assertTrue(HarshadNumber.isHarshad(999999999));\n        assertFalse(HarshadNumber.isHarshad(0));\n\n        assertTrue(HarshadNumber.isHarshad(\"18\"));\n        assertFalse(HarshadNumber.isHarshad(\"-18\"));\n        assertFalse(HarshadNumber.isHarshad(\"19\"));\n        assertTrue(HarshadNumber.isHarshad(\"999999999\"));\n        assertTrue(HarshadNumber.isHarshad(\"99999999999100\"));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/KaprekarNumbers.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/KaprekarNumbersTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n    /* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n    // Provides a list of kaprekarNumber in a range\n    public static List<Long> kaprekarNumberInRange(long start, long end)\n        throws Exception {\n        long n = end - start;\n        if (n < 0) throw new Exception(\"Invalid range\");\n        ArrayList<Long> list = new ArrayList<>();\n\n        for (long i = start; i <= end; i++) {\n            if (isKaprekarNumber(i)) list.add(i);\n        }\n\n        return list;\n    }\n\n    // Checks whether a given number is Kaprekar Number or not\n    public static boolean isKaprekarNumber(long num) {\n        String number = Long.toString(num);\n        BigInteger originalNumber = BigInteger.valueOf(num);\n        BigInteger numberSquared = originalNumber.multiply(originalNumber);\n        if (number.length() == numberSquared.toString().length()) {\n            return number.equals(numberSquared.toString());\n        } else {\n            BigInteger leftDigits1 = BigInteger.ZERO;\n            BigInteger leftDigits2;\n            if (numberSquared.toString().contains(\"0\")) {\n                leftDigits1 =\n                    new BigInteger(\n                        numberSquared\n                            .toString()\n                            .substring(0, numberSquared.toString().indexOf(\"0\"))\n                    );\n            }\n            leftDigits2 =\n                new BigInteger(\n                    numberSquared\n                        .toString()\n                        .substring(\n                            0,\n                            (\n                                numberSquared.toString().length() -\n                                number.length()\n                            )\n                        )\n                );\n            BigInteger rightDigits = new BigInteger(\n                numberSquared\n                    .toString()\n                    .substring(\n                        numberSquared.toString().length() - number.length()\n                    )\n            );\n            String x = leftDigits1.add(rightDigits).toString();\n            String y = leftDigits2.add(rightDigits).toString();\n            return (number.equals(x)) || (number.equals(y));\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n    /* This program demonstrates if a given number is Kaprekar Number or not.\n        Kaprekar Number: A Kaprekar number is an n-digit number which its square can be split into\n       two parts where the right part has n digits and sum of these parts is equal to the original\n       number. */\n\n    // Provides a list of kaprekarNumber in a range\n    public static List<Long> kaprekarNumberInRange(long start, long end) throws Exception {\n        long n = end - start;\n        if (n < 0) throw new Exception(\"Invalid range\");\n        ArrayList<Long> list = new ArrayList<>();\n\n        for (long i = start; i <= end; i++) {\n            if (isKaprekarNumber(i)) list.add(i);\n        }\n\n        return list;\n    }\n\n    // Checks whether a given number is Kaprekar Number or not\n    public static boolean isKaprekarNumber(long num) {\n        String number = Long.toString(num);\n        BigInteger originalNumber = BigInteger.valueOf(num);\n        BigInteger numberSquared = originalNumber.multiply(originalNumber);\n        if (number.length() == numberSquared.toString().length()) {\n            return number.equals(numberSquared.toString());\n        } else {\n            BigInteger leftDigits1 = BigInteger.ZERO;\n            BigInteger leftDigits2;\n            if (numberSquared.toString().contains(\"0\")) {\n                leftDigits1 = new BigInteger(\n                    numberSquared.toString().substring(0, numberSquared.toString().indexOf(\"0\")));\n            }\n            leftDigits2 = new BigInteger(numberSquared.toString().substring(\n                0, (numberSquared.toString().length() - number.length())));\n            BigInteger rightDigits = new BigInteger(numberSquared.toString().substring(\n                numberSquared.toString().length() - number.length()));\n            String x = leftDigits1.add(rightDigits).toString();\n            String y = leftDigits2.add(rightDigits).toString();\n            return (number.equals(x)) || (number.equals(y));\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KaprekarNumbersTest {\n\n    @Test\n    void testFor1() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(1));\n    }\n\n    @Test\n    void testFor45() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(45));\n    }\n\n    @Test\n    void testFor297() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(297));\n    }\n\n    @Test\n    void testFor2223() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n    }\n\n    @Test\n    void testFor857143() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n    }\n\n    @Test\n    void testFor3() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(3));\n    }\n\n    @Test\n    void testFor26() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(26));\n    }\n\n    @Test\n    void testFor98() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(98));\n    }\n\n    @Test\n    void testForRangeOfNumber() {\n        try {\n            List<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(\n                1,\n                100000\n            );\n            long[] allTheNumbers = {\n                1,\n                9,\n                45,\n                55,\n                99,\n                297,\n                703,\n                999,\n                2223,\n                2728,\n                4950,\n                5050,\n                7272,\n                7777,\n                9999,\n                17344,\n                22222,\n                77778,\n                82656,\n                95121,\n                99999,\n            };\n            for (long i : allTheNumbers) {\n                assert rangedNumbers.contains(i);\n            }\n        } catch (Exception e) {\n            assert false;\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class KaprekarNumbersTest {\n\n    @Test\n    void testFor1() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(1));\n    }\n\n    @Test\n    void testFor45() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(45));\n    }\n\n    @Test\n    void testFor297() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(297));\n    }\n\n    @Test\n    void testFor2223() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n    }\n\n    @Test\n    void testFor857143() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n    }\n\n    @Test\n    void testFor3() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(3));\n    }\n\n    @Test\n    void testFor26() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(26));\n    }\n\n    @Test\n    void testFor98() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(98));\n    }\n\n    @Test\n    void testForRangeOfNumber() {\n        try {\n            List<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(1, 100000);\n            long[] allTheNumbers = {\n                1,\n                9,\n                45,\n                55,\n                99,\n                297,\n                703,\n                999,\n                2223,\n                2728,\n                4950,\n                5050,\n                7272,\n                7777,\n                9999,\n                17344,\n                22222,\n                77778,\n                82656,\n                95121,\n                99999,\n            };\n            for (long i : allTheNumbers) {\n                assert rangedNumbers.contains(i);\n            }\n        } catch (Exception e) {\n            assert false;\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LeonardoNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LeonardoNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n /**\n  * https://en.wikipedia.org/wiki/Leonardo_number\n  */\npublic class LeonardoNumber {\n\n    /**\n     * Calculate nth Leonardo Number (1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, ...)\n     *\n     * @param n the index of Leonardo Number to calculate\n     * @return nth number of Leonardo sequences\n     */\n    public static int leonardoNumber(int n) {\n        if (n < 0) {\n            throw new ArithmeticException();\n        }\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Leonardo_number\n */\npublic class LeonardoNumber {\n\n    /**\n     * Calculate nth Leonardo Number (1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, ...)\n     *\n     * @param n the index of Leonardo Number to calculate\n     * @return nth number of Leonardo sequences\n     */\n    public static int leonardoNumber(int n) {\n        if (n < 0) {\n            throw new ArithmeticException();\n        }\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class LeonardoNumberTest {\n    @Test\n    void leonardoNumberNegative() {\n        assertThrows(ArithmeticException.class, ()-> LeonardoNumber.leonardoNumber(-1));\n    }\n    @Test\n    void leonardoNumberZero() {\n        assertEquals(1, LeonardoNumber.leonardoNumber(0));\n    }\n    @Test\n    void leonardoNumberOne() {\n        assertEquals(1, LeonardoNumber.leonardoNumber(1));\n    }\n    @Test\n    void leonardoNumberFive() {\n        assertEquals(15, LeonardoNumber.leonardoNumber(5));\n    }\n    @Test\n    void leonardoNumberTwenty() {\n        assertEquals(21891 , LeonardoNumber.leonardoNumber(20));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LeonardoNumberTest {\n    @Test\n    void leonardoNumberNegative() {\n        assertThrows(ArithmeticException.class, () -> LeonardoNumber.leonardoNumber(-1));\n    }\n    @Test\n    void leonardoNumberZero() {\n        assertEquals(1, LeonardoNumber.leonardoNumber(0));\n    }\n    @Test\n    void leonardoNumberOne() {\n        assertEquals(1, LeonardoNumber.leonardoNumber(1));\n    }\n    @Test\n    void leonardoNumberFive() {\n        assertEquals(15, LeonardoNumber.leonardoNumber(5));\n    }\n    @Test\n    void leonardoNumberTwenty() {\n        assertEquals(21891, LeonardoNumber.leonardoNumber(20));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LiouvilleLambdaFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LiouvilleLambdaFunctionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for liouville lambda function\n * For any positive integer n, define \u03bb(n) as the sum of the primitive nth roots of unity.\n * It has values in {\u22121, 1} depending on the factorization of n into prime factors:\n *   \u03bb(n) = +1 if n is a positive integer with an even number of prime factors.\n *   \u03bb(n) = \u22121 if n is a positive integer with an odd number of prime factors.\n * Wikipedia: https://en.wikipedia.org/wiki/Liouville_function\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class LiouvilleLambdaFunction {\n\n    /**\n     * This method returns \u03bb(n) of given number n\n     *\n     * @param number Integer value which \u03bb(n) is to be calculated\n     * @return  1 when number has even number of prime factors\n     *         -1 when number has odd number of prime factors\n     * @throws IllegalArgumentException when number is negative\n     */\n    static int liouvilleLambda(int number) {\n        if (number <= 0) {\n            //throw exception when number is less than or is zero\n            throw new IllegalArgumentException(\n                \"Number must be greater than zero.\"\n            );\n        }\n\n        //return 1 if size of prime factor list is even, -1 otherwise\n        return PrimeFactorization.pfactors(number).size() % 2 == 0 ? 1 : -1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for liouville lambda function\n * For any positive integer n, define \u03bb(n) as the sum of the primitive nth roots of unity.\n * It has values in {\u22121, 1} depending on the factorization of n into prime factors:\n *   \u03bb(n) = +1 if n is a positive integer with an even number of prime factors.\n *   \u03bb(n) = \u22121 if n is a positive integer with an odd number of prime factors.\n * Wikipedia: https://en.wikipedia.org/wiki/Liouville_function\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class LiouvilleLambdaFunction {\n\n    /**\n     * This method returns \u03bb(n) of given number n\n     *\n     * @param number Integer value which \u03bb(n) is to be calculated\n     * @return  1 when number has even number of prime factors\n     *         -1 when number has odd number of prime factors\n     * @throws IllegalArgumentException when number is negative\n     */\n    static int liouvilleLambda(int number) {\n        if (number <= 0) {\n            // throw exception when number is less than or is zero\n            throw new IllegalArgumentException(\"Number must be greater than zero.\");\n        }\n\n        // return 1 if size of prime factor list is even, -1 otherwise\n        return PrimeFactorization.pfactors(number).size() % 2 == 0 ? 1 : -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass LiouvilleLambdaFunctionTest {\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsZero() {\n        //given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                LiouvilleLambdaFunction.liouvilleLambda(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsNegative() {\n        //given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                LiouvilleLambdaFunction.liouvilleLambda(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnNegativeOne() {\n        //given\n        int number = 11;\n        int expectedOutput = -1;\n\n        //when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        //then\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnPositiveOne() {\n        //given\n        int number = 10;\n        int expectedOutput = 1;\n\n        //when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        //then\n        assertEquals(expectedOutput, actualOutput);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass LiouvilleLambdaFunctionTest {\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsZero() {\n        // given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class,\n            () -> { LiouvilleLambdaFunction.liouvilleLambda(number); });\n        String actualMessage = exception.getMessage();\n\n        // then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsNegative() {\n        // given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class,\n            () -> { LiouvilleLambdaFunction.liouvilleLambda(number); });\n        String actualMessage = exception.getMessage();\n\n        // then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnNegativeOne() {\n        // given\n        int number = 11;\n        int expectedOutput = -1;\n\n        // when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        // then\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnPositiveOne() {\n        // given\n        int number = 10;\n        int expectedOutput = 1;\n\n        // when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        // then\n        assertEquals(expectedOutput, actualOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LongDivision.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LongDivisionTest.java",
        "product_old_content": "//        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n//\n//        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, \n//        and -2.7335 would be truncated to -2.\n//        My method used Long Division, here is the source \"https://en.wikipedia.org/wiki/Long_division\"\n\npackage com.thealgorithms.maths;\n\npublic class LongDivision {\npublic static int divide(int dividend, int divisor) {\n        long new_dividend_1 = dividend;\n        long new_divisor_1 = divisor;\n\n        if(divisor == 0){\n            return 0;\n        }\n        if (dividend < 0) {\n            new_dividend_1 = new_dividend_1 * -1;\n        }\n        if (divisor < 0) {\n            new_divisor_1 = new_divisor_1 * -1;\n        }\n\n        if (dividend == 0 || new_dividend_1 < new_divisor_1) {\n            return 0;\n        }\n\n        StringBuilder answer = new StringBuilder();\n\n        String dividend_string = \"\" + new_dividend_1;\n        int last_index = 0;\n\n        String remainder = \"\";\n\n\n        for (int i = 0; i < dividend_string.length(); i++) {\n            String part_v1 = remainder + \"\" + dividend_string.substring(last_index, i + 1);\n            long part_1 = Long.parseLong(part_v1);\n            if (part_1 > new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == 0) {\n                answer.append(0);\n            } else if (part_1 < new_divisor_1) {\n                answer.append(0);\n            }\n            if (!(part_1 == 0)) {\n                remainder = String.valueOf(part_1);\n            }else{\n                remainder = \"\";\n            }\n\n            last_index++;\n        }\n\n        if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {\n            try {\n                return Integer.parseInt(answer.toString()) * (-1);\n            } catch (NumberFormatException e) {\n                return -2147483648;\n            }\n        }\n        try {\n            return Integer.parseInt(answer.toString());\n        } catch (NumberFormatException e) {\n            return 2147483647;\n        }\n\n    }\n}",
        "product_new_content": "//        Given two integers dividend and divisor, divide two integers without using multiplication,\n//        division, and mod operator.\n//\n//        The integer division should truncate toward zero, which means losing its fractional part.\n//        For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. My\n//        method used Long Division, here is the source\n//        \"https://en.wikipedia.org/wiki/Long_division\"\n\npackage com.thealgorithms.maths;\n\npublic class LongDivision {\n    public static int divide(int dividend, int divisor) {\n        long new_dividend_1 = dividend;\n        long new_divisor_1 = divisor;\n\n        if (divisor == 0) {\n            return 0;\n        }\n        if (dividend < 0) {\n            new_dividend_1 = new_dividend_1 * -1;\n        }\n        if (divisor < 0) {\n            new_divisor_1 = new_divisor_1 * -1;\n        }\n\n        if (dividend == 0 || new_dividend_1 < new_divisor_1) {\n            return 0;\n        }\n\n        StringBuilder answer = new StringBuilder();\n\n        String dividend_string = \"\" + new_dividend_1;\n        int last_index = 0;\n\n        String remainder = \"\";\n\n        for (int i = 0; i < dividend_string.length(); i++) {\n            String part_v1 = remainder + \"\" + dividend_string.substring(last_index, i + 1);\n            long part_1 = Long.parseLong(part_v1);\n            if (part_1 > new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == 0) {\n                answer.append(0);\n            } else if (part_1 < new_divisor_1) {\n                answer.append(0);\n            }\n            if (!(part_1 == 0)) {\n                remainder = String.valueOf(part_1);\n            } else {\n                remainder = \"\";\n            }\n\n            last_index++;\n        }\n\n        if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {\n            try {\n                return Integer.parseInt(answer.toString()) * (-1);\n            } catch (NumberFormatException e) {\n                return -2147483648;\n            }\n        }\n        try {\n            return Integer.parseInt(answer.toString());\n        } catch (NumberFormatException e) {\n            return 2147483647;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LongDivisionTest {\n\n    // Requirement: Dividend (positive) is  greater than divisor (positive), returns correct integer after division\n    @Test\n    void testOne() {\n        assertEquals(3, LongDivision.divide(10,3));\n    }\n\n    // Requirement: Dividend (positive) is  greater than divisor (negative), returns correct integer after division\n    @Test\n    void testTwo() {\n        assertEquals(-2, LongDivision.divide(7,-3));\n    }\n  \n    // Requirement: Dividend (positive) is  greater than divisor (negative), returns correct integer after division\n    // Basically the same as in the first test\n    @Test\n    void testThree() {\n        assertEquals(10, LongDivision.divide(105,10));\n    }\n\n    // Requirement: Dividend (negative), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is less than 0.\n    @Test\n    void testNegativeDividend() {\n        assertEquals(-1, LongDivision.divide(-5,3));\n    }\n\t\n    // Requirement: Dividend (positive), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is less than the divisor. The test should return 0 in this case. \n    @Test\n    void testDividendLessThanDivisor() {\n        assertEquals(0, LongDivision.divide(3,5));\n    }\n\n    // Requirement: Dividend (neither), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is 0. This should return a 0.\n    @Test\n    void testDividendIsZero() {\n        assertEquals(0, LongDivision.divide(0,5));\n    }\n\n    // Requirement: Dividend (positive), divisor (neither), returns correct integer after division\n    // Tests the case where the divisor is 0. This should return a 0.\n    @Test\n    void testDivisionByZero() {\n        assertEquals(0, LongDivision.divide(5,0));  \n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LongDivisionTest {\n\n    // Requirement: Dividend (positive) is  greater than divisor (positive), returns correct integer\n    // after division\n    @Test\n    void testOne() {\n        assertEquals(3, LongDivision.divide(10, 3));\n    }\n\n    // Requirement: Dividend (positive) is  greater than divisor (negative), returns correct integer\n    // after division\n    @Test\n    void testTwo() {\n        assertEquals(-2, LongDivision.divide(7, -3));\n    }\n\n    // Requirement: Dividend (positive) is  greater than divisor (negative), returns correct integer\n    // after division Basically the same as in the first test\n    @Test\n    void testThree() {\n        assertEquals(10, LongDivision.divide(105, 10));\n    }\n\n    // Requirement: Dividend (negative), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is less than 0.\n    @Test\n    void testNegativeDividend() {\n        assertEquals(-1, LongDivision.divide(-5, 3));\n    }\n\n    // Requirement: Dividend (positive), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is less than the divisor. The test should return 0 in this\n    // case.\n    @Test\n    void testDividendLessThanDivisor() {\n        assertEquals(0, LongDivision.divide(3, 5));\n    }\n\n    // Requirement: Dividend (neither), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is 0. This should return a 0.\n    @Test\n    void testDividendIsZero() {\n        assertEquals(0, LongDivision.divide(0, 5));\n    }\n\n    // Requirement: Dividend (positive), divisor (neither), returns correct integer after division\n    // Tests the case where the divisor is 0. This should return a 0.\n    @Test\n    void testDivisionByZero() {\n        assertEquals(0, LongDivision.divide(5, 0));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LucasSeries.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LucasSeriesTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Lucas_number\n */\npublic class LucasSeries {\n\n    /**\n     * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using recursion\n     *\n     * @param n nth\n     * @return nth number of Lucas Series\n     */\n    public static int lucasSeries(int n) {\n        return n == 1\n            ? 2\n            : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);\n    }\n\n    /**\n     * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using iteration\n     *\n     * @param n nth\n     * @return nth number of lucas series\n     */\n    public static int lucasSeriesIteration(int n) {\n        int previous = 2;\n        int current = 1;\n        for (int i = 1; i < n; i++) {\n            int next = previous + current;\n            previous = current;\n            current = next;\n        }\n        return previous;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Lucas_number\n */\npublic class LucasSeries {\n\n    /**\n     * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using recursion\n     *\n     * @param n nth\n     * @return nth number of Lucas Series\n     */\n    public static int lucasSeries(int n) {\n        return n == 1 ? 2 : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);\n    }\n\n    /**\n     * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using iteration\n     *\n     * @param n nth\n     * @return nth number of lucas series\n     */\n    public static int lucasSeriesIteration(int n) {\n        int previous = 2;\n        int current = 1;\n        for (int i = 1; i < n; i++) {\n            int next = previous + current;\n            previous = current;\n            current = next;\n        }\n        return previous;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class LucasSeriesTest {\n    @Test\n    void lucasSeriesTwo() {\n        assertEquals(2, LucasSeries.lucasSeries(1));\n        assertEquals(2, LucasSeries.lucasSeriesIteration(1));\n    }\n    @Test\n    void lucasSeriesOne() {\n        assertEquals(1, LucasSeries.lucasSeries(2));\n        assertEquals(1, LucasSeries.lucasSeriesIteration(2));\n    }\n    @Test\n    void lucasSeriesSeven() {\n        assertEquals(7, LucasSeries.lucasSeries(5));\n        assertEquals(7, LucasSeries.lucasSeriesIteration(5));\n    }\n    @Test\n    void lucasSeriesEleven() {\n        assertEquals(123, LucasSeries.lucasSeries(11));\n        assertEquals(123, LucasSeries.lucasSeriesIteration(11));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LucasSeriesTest {\n    @Test\n    void lucasSeriesTwo() {\n        assertEquals(2, LucasSeries.lucasSeries(1));\n        assertEquals(2, LucasSeries.lucasSeriesIteration(1));\n    }\n    @Test\n    void lucasSeriesOne() {\n        assertEquals(1, LucasSeries.lucasSeries(2));\n        assertEquals(1, LucasSeries.lucasSeriesIteration(2));\n    }\n    @Test\n    void lucasSeriesSeven() {\n        assertEquals(7, LucasSeries.lucasSeries(5));\n        assertEquals(7, LucasSeries.lucasSeriesIteration(5));\n    }\n    @Test\n    void lucasSeriesEleven() {\n        assertEquals(123, LucasSeries.lucasSeries(11));\n        assertEquals(123, LucasSeries.lucasSeriesIteration(11));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Median.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MedianTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Median\n */\npublic class Median {\n\n    /**\n     * Calculate average median\n     * @param values sorted numbers to find median of\n     * @return median of given {@code values}\n     */\n    public static double median(int[] values) {\n        Arrays.sort(values);\n        int length = values.length;\n        return length % 2 == 0\n            ? (values[length / 2] + values[length / 2 - 1]) / 2.0\n            : values[length / 2];\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Median\n */\npublic class Median {\n\n    /**\n     * Calculate average median\n     * @param values sorted numbers to find median of\n     * @return median of given {@code values}\n     */\n    public static double median(int[] values) {\n        Arrays.sort(values);\n        int length = values.length;\n        return length % 2 == 0 ? (values[length / 2] + values[length / 2 - 1]) / 2.0\n                               : values[length / 2];\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class MedianTest {\n    @Test\n    void medianSingleValue() {\n        int[] arr = {0};\n        assertEquals(0, Median.median(arr));\n    }\n\n    @Test\n    void medianTwoValues() {\n        int[] arr = {1, 2};\n        assertEquals(1.5, Median.median(arr));\n    }\n\n    @Test\n    void medianThreeValues() {\n        int[] arr = {1, 2, 3};\n        assertEquals(2, Median.median(arr));\n    }\n\n    @Test\n    void medianDecimalValueReturn() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 8, 9};\n        assertEquals(4.5, Median.median(arr));\n    }\n\n    @Test\n    void medianNegativeValues() {\n        int[] arr = {-27, -16, -7, -4, -2, -1};\n        assertEquals(-5.5, Median.median(arr));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MedianTest {\n    @Test\n    void medianSingleValue() {\n        int[] arr = {0};\n        assertEquals(0, Median.median(arr));\n    }\n\n    @Test\n    void medianTwoValues() {\n        int[] arr = {1, 2};\n        assertEquals(1.5, Median.median(arr));\n    }\n\n    @Test\n    void medianThreeValues() {\n        int[] arr = {1, 2, 3};\n        assertEquals(2, Median.median(arr));\n    }\n\n    @Test\n    void medianDecimalValueReturn() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 8, 9};\n        assertEquals(4.5, Median.median(arr));\n    }\n\n    @Test\n    void medianNegativeValues() {\n        int[] arr = {-27, -16, -7, -4, -2, -1};\n        assertEquals(-5.5, Median.median(arr));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/MobiusFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MobiusFunctionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for mobius function\n * For any positive integer n, define \u03bc(n) as the sum of the primitive nth roots of unity.\n * It has values in {\u22121, 0, 1} depending on the factorization of n into prime factors:\n *   \u03bc(n) = +1 if n is a square-free positive integer with an even number of prime factors.\n *   \u03bc(n) = \u22121 if n is a square-free positive integer with an odd number of prime factors.\n *   \u03bc(n) = 0 if n has a squared prime factor.\n * Wikipedia: https://en.wikipedia.org/wiki/M%C3%B6bius_function\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\npublic class MobiusFunction {\n\n    /**\n     * This method returns \u03bc(n) of given number n\n     *\n     * @param number Integer value which \u03bc(n) is to be calculated\n     * @return  1 when number is less than or equals 1\n     *            or number has even number of prime factors\n     *          0 when number has repeated prime factor\n     *         -1 when number has odd number of prime factors\n     */\n    static int mobius(int number) {\n        if (number <= 0) {\n            //throw exception when number is less than or is zero\n            throw new IllegalArgumentException(\n                \"Number must be greater than zero.\"\n            );\n        }\n\n        if (number == 1) {\n            //return 1 if number passed is less or is 1\n            return 1;\n        }\n\n        int primeFactorCount = 0;\n\n        for (int i = 1; i <= number; i++) {\n            //find prime factors of number\n            if (number % i == 0 && PrimeCheck.isPrime(i)) {\n                //check if number is divisible by square of prime factor\n                if (number % (i * i) == 0) {\n                    //if number is divisible by square of prime factor\n                    return 0;\n                }\n                /*increment primeFactorCount by 1 \n\t\t\t\tif number is not divisible by square of found prime factor*/\n                primeFactorCount++;\n            }\n        }\n\n        return (primeFactorCount % 2 == 0) ? 1 : -1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for mobius function\n * For any positive integer n, define \u03bc(n) as the sum of the primitive nth roots of unity.\n * It has values in {\u22121, 0, 1} depending on the factorization of n into prime factors:\n *   \u03bc(n) = +1 if n is a square-free positive integer with an even number of prime factors.\n *   \u03bc(n) = \u22121 if n is a square-free positive integer with an odd number of prime factors.\n *   \u03bc(n) = 0 if n has a squared prime factor.\n * Wikipedia: https://en.wikipedia.org/wiki/M%C3%B6bius_function\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\npublic class MobiusFunction {\n\n    /**\n     * This method returns \u03bc(n) of given number n\n     *\n     * @param number Integer value which \u03bc(n) is to be calculated\n     * @return  1 when number is less than or equals 1\n     *            or number has even number of prime factors\n     *          0 when number has repeated prime factor\n     *         -1 when number has odd number of prime factors\n     */\n    static int mobius(int number) {\n        if (number <= 0) {\n            // throw exception when number is less than or is zero\n            throw new IllegalArgumentException(\"Number must be greater than zero.\");\n        }\n\n        if (number == 1) {\n            // return 1 if number passed is less or is 1\n            return 1;\n        }\n\n        int primeFactorCount = 0;\n\n        for (int i = 1; i <= number; i++) {\n            // find prime factors of number\n            if (number % i == 0 && PrimeCheck.isPrime(i)) {\n                // check if number is divisible by square of prime factor\n                if (number % (i * i) == 0) {\n                    // if number is divisible by square of prime factor\n                    return 0;\n                }\n                /*increment primeFactorCount by 1\n                                if number is not divisible by square of found prime factor*/\n                primeFactorCount++;\n            }\n        }\n\n        return (primeFactorCount % 2 == 0) ? 1 : -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass MobiusFunctionTest {\n\n    @Test\n    void testMobiusForZero() {\n        //given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                MobiusFunction.mobius(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testMobiusForNegativeNumber() {\n        //given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                MobiusFunction.mobius(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testMobiusFunction() {\n        int[] expectedResultArray = {\n            1,\n            -1,\n            -1,\n            0,\n            -1,\n            1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            -1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            -1,\n            0,\n            1,\n            1,\n            -1,\n            0,\n            0,\n            1,\n            0,\n            0,\n            -1,\n            -1,\n            -1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            1,\n            1,\n            0,\n            -1,\n            -1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0,\n            -1,\n            0,\n            1,\n            0,\n            1,\n            1,\n            -1,\n            0,\n            -1,\n            1,\n            0,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            -1,\n            1,\n            0,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            0,\n            0,\n        };\n\n        for (int i = 1; i <= 100; i++) {\n            //given\n            int expectedValue = expectedResultArray[i - 1];\n\n            //when\n            int actualValue = MobiusFunction.mobius(i);\n\n            //then\n            assertEquals(expectedValue, actualValue);\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass MobiusFunctionTest {\n\n    @Test\n    void testMobiusForZero() {\n        // given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        // when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class, () -> { MobiusFunction.mobius(number); });\n        String actualMessage = exception.getMessage();\n\n        // then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testMobiusForNegativeNumber() {\n        // given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        // when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class, () -> { MobiusFunction.mobius(number); });\n        String actualMessage = exception.getMessage();\n\n        // then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testMobiusFunction() {\n        int[] expectedResultArray = {\n            1,\n            -1,\n            -1,\n            0,\n            -1,\n            1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            -1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            -1,\n            0,\n            1,\n            1,\n            -1,\n            0,\n            0,\n            1,\n            0,\n            0,\n            -1,\n            -1,\n            -1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            1,\n            1,\n            0,\n            -1,\n            -1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0,\n            -1,\n            0,\n            1,\n            0,\n            1,\n            1,\n            -1,\n            0,\n            -1,\n            1,\n            0,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            -1,\n            1,\n            0,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            0,\n            0,\n        };\n\n        for (int i = 1; i <= 100; i++) {\n            // given\n            int expectedValue = expectedResultArray[i - 1];\n\n            // when\n            int actualValue = MobiusFunction.mobius(i);\n\n            // then\n            assertEquals(expectedValue, actualValue);\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/NthUglyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/NthUglyNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.lang.IllegalArgumentException;\n\n\n/**\n * @brief class computing the n-th ugly number (when they are sorted)\n * @details the ugly numbers with base [2, 3, 5] are all numbers of the form 2^a*3^b^5^c,\n *   where the exponents a, b, c are non-negative integers.\n *   Some properties of ugly numbers:\n *     - base [2, 3, 5] ugly numbers are the 5-smooth numbers, cf. https://oeis.org/A051037\n *     - base [2, 3, 5, 7] ugly numbers are 7-smooth numbers, cf. https://oeis.org/A002473\n *     - base [2] ugly numbers are the non-negative powers of 2,\n *     - the base [2, 3, 5] ugly numbers are the same as base [5, 6, 2, 3, 5] ugly numbers\n */\npublic class NthUglyNumber {\n    ArrayList<Long> uglyNumbers = new ArrayList<>(Arrays.asList(1L));\n    final int[] baseNumbers;\n    HashMap<Integer, Integer> positions = new HashMap<>();\n\n    /**\n     * @brief initialized the object allowing to compute ugly numbers with given base\n     * @param baseNumbers the given base of ugly numbers\n     * @exception IllegalArgumentException baseNumber is empty\n     */\n    NthUglyNumber(int[] baseNumbers) {\n        if (baseNumbers.length == 0) {\n            throw new IllegalArgumentException(\"baseNumbers must be non-empty.\");\n        }\n\n        this.baseNumbers = baseNumbers;\n        for (final var baseNumber : baseNumbers) {\n            this.positions.put(baseNumber, 0);\n        }\n    }\n\n    /**\n     * @param n the zero-based-index of the queried ugly number\n     * @exception IllegalArgumentException n is negative\n     * @return the n-th ugly number (starting from index 0)\n     */\n    public Long get(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative.\");\n        }\n\n        while (uglyNumbers.size() <= n) {\n            addUglyNumber();\n        }\n\n        return uglyNumbers.get(n);\n    }\n\n    private void addUglyNumber() {\n        uglyNumbers.add(computeMinimalCandidate());\n        updatePositions();\n    }\n\n    private void updatePositions() {\n        final var lastUglyNumber = uglyNumbers.get(uglyNumbers.size() - 1);\n        for (final var baseNumber : baseNumbers) {\n            if (computeCandidate(baseNumber) == lastUglyNumber) {\n                positions.put(baseNumber, positions.get(baseNumber) + 1);\n            }\n        }\n    }\n\n    private long computeCandidate(int candidateBase) {\n        return candidateBase * uglyNumbers.get(positions.get(candidateBase));\n    }\n\n    private long computeMinimalCandidate() {\n        long res = Long.MAX_VALUE;\n        for (final var baseNumber : baseNumbers) {\n            res = Math.min(res, computeCandidate(baseNumber));\n        }\n        return res;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.lang.IllegalArgumentException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * @brief class computing the n-th ugly number (when they are sorted)\n * @details the ugly numbers with base [2, 3, 5] are all numbers of the form 2^a*3^b^5^c,\n *   where the exponents a, b, c are non-negative integers.\n *   Some properties of ugly numbers:\n *     - base [2, 3, 5] ugly numbers are the 5-smooth numbers, cf. https://oeis.org/A051037\n *     - base [2, 3, 5, 7] ugly numbers are 7-smooth numbers, cf. https://oeis.org/A002473\n *     - base [2] ugly numbers are the non-negative powers of 2,\n *     - the base [2, 3, 5] ugly numbers are the same as base [5, 6, 2, 3, 5] ugly numbers\n */\npublic class NthUglyNumber {\n    ArrayList<Long> uglyNumbers = new ArrayList<>(Arrays.asList(1L));\n    final int[] baseNumbers;\n    HashMap<Integer, Integer> positions = new HashMap<>();\n\n    /**\n     * @brief initialized the object allowing to compute ugly numbers with given base\n     * @param baseNumbers the given base of ugly numbers\n     * @exception IllegalArgumentException baseNumber is empty\n     */\n    NthUglyNumber(int[] baseNumbers) {\n        if (baseNumbers.length == 0) {\n            throw new IllegalArgumentException(\"baseNumbers must be non-empty.\");\n        }\n\n        this.baseNumbers = baseNumbers;\n        for (final var baseNumber : baseNumbers) {\n            this.positions.put(baseNumber, 0);\n        }\n    }\n\n    /**\n     * @param n the zero-based-index of the queried ugly number\n     * @exception IllegalArgumentException n is negative\n     * @return the n-th ugly number (starting from index 0)\n     */\n    public Long get(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative.\");\n        }\n\n        while (uglyNumbers.size() <= n) {\n            addUglyNumber();\n        }\n\n        return uglyNumbers.get(n);\n    }\n\n    private void addUglyNumber() {\n        uglyNumbers.add(computeMinimalCandidate());\n        updatePositions();\n    }\n\n    private void updatePositions() {\n        final var lastUglyNumber = uglyNumbers.get(uglyNumbers.size() - 1);\n        for (final var baseNumber : baseNumbers) {\n            if (computeCandidate(baseNumber) == lastUglyNumber) {\n                positions.put(baseNumber, positions.get(baseNumber) + 1);\n            }\n        }\n    }\n\n    private long computeCandidate(int candidateBase) {\n        return candidateBase * uglyNumbers.get(positions.get(candidateBase));\n    }\n\n    private long computeMinimalCandidate() {\n        long res = Long.MAX_VALUE;\n        for (final var baseNumber : baseNumbers) {\n            res = Math.min(res, computeCandidate(baseNumber));\n        }\n        return res;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\n\nimport org.junit.jupiter.api.Test;\n\npublic class NthUglyNumberTest {\n    @Test\n    public void testGetWithNewObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(9, 12L);\n        testCases.put(19, 36L);\n        testCases.put(52, 270L);\n        testCases.put(1078, 84934656L);\n        testCases.put(1963, 6973568802L);\n\n        for (final var tc : testCases.entrySet()) {\n            var uglyNumbers = new NthUglyNumber(new int[] {2, 3, 5});\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n\n            var otherUglyNumbers = new NthUglyNumber(new int[] {5, 25, 6, 2, 3, 5});\n            assertEquals(otherUglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testGetWithSameObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(6, 7L);\n        testCases.put(1499, 1984500L);\n        testCases.put(1572, 2449440L);\n        testCases.put(1658, 3072000L);\n        testCases.put(6625, 4300800000L);\n\n        var uglyNumbers = new NthUglyNumber(new int[] {7, 2, 5, 3});\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n        \n        assertEquals(uglyNumbers.get(999), 385875);\n    }\n\n    @Test\n    public void testGetWithBase1() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1});\n        assertEquals(uglyNumbers.get(10), 1);\n    }\n\n    @Test\n    public void testGetWithBase2() {\n        var uglyNumbers = new NthUglyNumber(new int[] {2});\n        assertEquals(uglyNumbers.get(5), 32);\n    }\n\n\n    @Test\n    public void testGetThrowsAnErrorForNegativeInput() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1, 2});\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> uglyNumbers.get(-1)\n        );\n    }\n\n    @Test\n    public void testConstructorThrowsAnErrorForEmptyInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> new NthUglyNumber(new int[] {})\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\npublic class NthUglyNumberTest {\n    @Test\n    public void testGetWithNewObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(9, 12L);\n        testCases.put(19, 36L);\n        testCases.put(52, 270L);\n        testCases.put(1078, 84934656L);\n        testCases.put(1963, 6973568802L);\n\n        for (final var tc : testCases.entrySet()) {\n            var uglyNumbers = new NthUglyNumber(new int[] {2, 3, 5});\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n\n            var otherUglyNumbers = new NthUglyNumber(new int[] {5, 25, 6, 2, 3, 5});\n            assertEquals(otherUglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testGetWithSameObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(6, 7L);\n        testCases.put(1499, 1984500L);\n        testCases.put(1572, 2449440L);\n        testCases.put(1658, 3072000L);\n        testCases.put(6625, 4300800000L);\n\n        var uglyNumbers = new NthUglyNumber(new int[] {7, 2, 5, 3});\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n\n        assertEquals(uglyNumbers.get(999), 385875);\n    }\n\n    @Test\n    public void testGetWithBase1() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1});\n        assertEquals(uglyNumbers.get(10), 1);\n    }\n\n    @Test\n    public void testGetWithBase2() {\n        var uglyNumbers = new NthUglyNumber(new int[] {2});\n        assertEquals(uglyNumbers.get(5), 32);\n    }\n\n    @Test\n    public void testGetThrowsAnErrorForNegativeInput() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1, 2});\n        assertThrows(IllegalArgumentException.class, () -> uglyNumbers.get(-1));\n    }\n\n    @Test\n    public void testConstructorThrowsAnErrorForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> new NthUglyNumber(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PascalTriangle.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PascalTriangleTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class PascalTriangle {\n\n    /**\n     *In mathematics, Pascal's triangle is a triangular array of the binomial coefficients that arises\n     * in probability theory, combinatorics, and algebra. In much of the Western world, it is named after\n     * the French mathematician Blaise Pascal, although other mathematicians studied it centuries before\n     * him in India, Persia, China, Germany, and Italy.\n     *\n     * The rows of Pascal's triangle are conventionally enumerated starting with row n=0 at the top (the 0th row).\n     * The entries in each row are numbered from the left beginning with k=0 and are usually staggered relative\n     * to the numbers in the adjacent rows. The triangle may be constructed in the following manner:\n     * In row 0 (the topmost row), there is a unique nonzero entry 1. Each entry of each subsequent row is\n     * constructed by adding the number above and to the left with the number above and to the right, treating\n     * blank entries as 0. For example, the initial number in the first (or any other) row is 1 (the sum of 0 and 1),\n     * whereas the numbers 1 and 3 in the third row are added to produce the number 4 in the fourth row. *\n     *\n     *<p>\n     *     link:-https://en.wikipedia.org/wiki/Pascal%27s_triangle\n     *\n     * <p>\n     *     Example:-\n     *                  1\n     *                1   1\n     *              1   2   1\n     *            1   3   3   1\n     *          1   4   6   4   1\n     *        1   5  10   10  5   1\n     *      1   6  15  20   15  6   1\n     *    1   7  21  35   35  21  7   1\n     *  1   8  28  56  70   56   28  8   1\n     *\n     */\n\n    public static int[][] pascal(int n) {\n        /**\n         * @param arr  An auxiliary array to store generated pascal triangle values\n         * @return\n         */\n        int[][] arr = new int[n][n];\n        /**\n         * @param line Iterate through every line and print integer(s) in it\n         * @param i Represents the column number of the element we are currently on\n         */\n        for (int line = 0; line < n; line++) {\n            /**\n             *  @Every line has number of integers equal to line number\n             */\n            for (int i = 0; i <= line; i++) {\n                // First and last values in every row are 1\n                if (line == i || i == 0) arr[line][i] = 1;\n                // The rest elements are sum of values just above and left of above\n                else arr[line][i] = arr[line - 1][i - 1] + arr[line - 1][i];\n            }\n        }\n\n        return arr;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class PascalTriangle {\n\n    /**\n     *In mathematics, Pascal's triangle is a triangular array of the binomial coefficients that\n     *arises in probability theory, combinatorics, and algebra. In much of the Western world, it is\n     *named after the French mathematician Blaise Pascal, although other mathematicians studied it\n     *centuries before him in India, Persia, China, Germany, and Italy.\n     *\n     * The rows of Pascal's triangle are conventionally enumerated starting with row n=0 at the top\n     *(the 0th row). The entries in each row are numbered from the left beginning with k=0 and are\n     *usually staggered relative to the numbers in the adjacent rows. The triangle may be\n     *constructed in the following manner: In row 0 (the topmost row), there is a unique nonzero\n     *entry 1. Each entry of each subsequent row is constructed by adding the number above and to\n     *the left with the number above and to the right, treating blank entries as 0. For example, the\n     *initial number in the first (or any other) row is 1 (the sum of 0 and 1), whereas the numbers\n     *1 and 3 in the third row are added to produce the number 4 in the fourth row. *\n     *\n     *<p>\n     *     link:-https://en.wikipedia.org/wiki/Pascal%27s_triangle\n     *\n     * <p>\n     *     Example:-\n     *                  1\n     *                1   1\n     *              1   2   1\n     *            1   3   3   1\n     *          1   4   6   4   1\n     *        1   5  10   10  5   1\n     *      1   6  15  20   15  6   1\n     *    1   7  21  35   35  21  7   1\n     *  1   8  28  56  70   56   28  8   1\n     *\n     */\n\n    public static int[][] pascal(int n) {\n        /**\n         * @param arr  An auxiliary array to store generated pascal triangle values\n         * @return\n         */\n        int[][] arr = new int[n][n];\n        /**\n         * @param line Iterate through every line and print integer(s) in it\n         * @param i Represents the column number of the element we are currently on\n         */\n        for (int line = 0; line < n; line++) {\n            /**\n             *  @Every line has number of integers equal to line number\n             */\n            for (int i = 0; i <= line; i++) {\n                // First and last values in every row are 1\n                if (line == i || i == 0) arr[line][i] = 1;\n                // The rest elements are sum of values just above and left of above\n                else\n                    arr[line][i] = arr[line - 1][i - 1] + arr[line - 1][i];\n            }\n        }\n\n        return arr;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass PascalTriangleTest {\n\n    @Test\n    void testForOne() {\n        int[][] result = PascalTriangle.pascal(1);\n        int[][] expected = { { 1 } };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForTwo() {\n        int[][] result = PascalTriangle.pascal(2);\n        int[][] expected = { { 1, 0 }, { 1, 1 } };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForFive() {\n        int[][] result = PascalTriangle.pascal(5);\n        int[][] expected = {\n            { 1, 0, 0, 0, 0 },\n            { 1, 1, 0, 0, 0 },\n            { 1, 2, 1, 0, 0 },\n            { 1, 3, 3, 1, 0 },\n            { 1, 4, 6, 4, 1 },\n        };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForEight() {\n        int[][] result = PascalTriangle.pascal(8);\n        int[][] expected = {\n            { 1, 0, 0, 0, 0, 0, 0, 0 },\n            { 1, 1, 0, 0, 0, 0, 0, 0 },\n            { 1, 2, 1, 0, 0, 0, 0, 0 },\n            { 1, 3, 3, 1, 0, 0, 0, 0 },\n            { 1, 4, 6, 4, 1, 0, 0, 0 },\n            { 1, 5, 10, 10, 5, 1, 0, 0 },\n            { 1, 6, 15, 20, 15, 6, 1, 0 },\n            { 1, 7, 21, 35, 35, 21, 7, 1 },\n        };\n        assertArrayEquals(expected, result);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass PascalTriangleTest {\n\n    @Test\n    void testForOne() {\n        int[][] result = PascalTriangle.pascal(1);\n        int[][] expected = {{1}};\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForTwo() {\n        int[][] result = PascalTriangle.pascal(2);\n        int[][] expected = {{1, 0}, {1, 1}};\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForFive() {\n        int[][] result = PascalTriangle.pascal(5);\n        int[][] expected = {\n            {1, 0, 0, 0, 0},\n            {1, 1, 0, 0, 0},\n            {1, 2, 1, 0, 0},\n            {1, 3, 3, 1, 0},\n            {1, 4, 6, 4, 1},\n        };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForEight() {\n        int[][] result = PascalTriangle.pascal(8);\n        int[][] expected = {\n            {1, 0, 0, 0, 0, 0, 0, 0},\n            {1, 1, 0, 0, 0, 0, 0, 0},\n            {1, 2, 1, 0, 0, 0, 0, 0},\n            {1, 3, 3, 1, 0, 0, 0, 0},\n            {1, 4, 6, 4, 1, 0, 0, 0},\n            {1, 5, 10, 10, 5, 1, 0, 0},\n            {1, 6, 15, 20, 15, 6, 1, 0},\n            {1, 7, 21, 35, 35, 21, 7, 1},\n        };\n        assertArrayEquals(expected, result);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PerfectNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PerfectNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * In number theory, a perfect number is a positive integer that is equal to the\n * sum of its positive divisors, excluding the number itself. For instance, 6\n * has divisors 1, 2 and 3 (excluding itself), and 1 + 2 + 3 = 6, so 6 is a\n * perfect number.\n *\n * link:https://en.wikipedia.org/wiki/Perfect_number\n */\npublic class PerfectNumber {\n\n    /**\n     * Check if {@code number} is perfect number or not\n     *\n     * @param number the number\n     * @return {@code true} if {@code number} is perfect number, otherwise false\n     */\n    public static boolean isPerfectNumber(int number) {\n        if (number <= 0)\n            return false;\n        int sum = 0;\n        /* sum of its positive divisors */\n        for (int i = 1; i < number; ++i) {\n            if (number % i == 0) {\n                sum += i;\n            }\n        }\n        return sum == number;\n    }\n    \n    /**\n     * Check if {@code n} is perfect number or not\n     *\n     * @param n the number\n     * @return {@code true} if {@code number} is perfect number, otherwise false\n     */\n    public static boolean isPerfectNumber2(int n) {\n        if (n <= 0)\n            return false;\n        int sum = 1;\n        double root = Math.sqrt(n);\n        \n        /*\n         * We can get the factors after the root by dividing number by its factors\n         * before the root.\n         * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n         * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n         * Now by dividing 100 by each factor before 10 we get:\n         * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n         * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n         */\n        for (int i = 2; i <= root; i++) {\n            if (n % i == 0) {\n                sum += i + n / i;\n            }\n        }\n        \n        // if n is a perfect square then its root was added twice in above loop, so subtracting root from sum\n        if (root == (int) root)\n            sum -= root;\n\n        return sum == n;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * In number theory, a perfect number is a positive integer that is equal to the\n * sum of its positive divisors, excluding the number itself. For instance, 6\n * has divisors 1, 2 and 3 (excluding itself), and 1 + 2 + 3 = 6, so 6 is a\n * perfect number.\n *\n * link:https://en.wikipedia.org/wiki/Perfect_number\n */\npublic class PerfectNumber {\n\n    /**\n     * Check if {@code number} is perfect number or not\n     *\n     * @param number the number\n     * @return {@code true} if {@code number} is perfect number, otherwise false\n     */\n    public static boolean isPerfectNumber(int number) {\n        if (number <= 0) return false;\n        int sum = 0;\n        /* sum of its positive divisors */\n        for (int i = 1; i < number; ++i) {\n            if (number % i == 0) {\n                sum += i;\n            }\n        }\n        return sum == number;\n    }\n\n    /**\n     * Check if {@code n} is perfect number or not\n     *\n     * @param n the number\n     * @return {@code true} if {@code number} is perfect number, otherwise false\n     */\n    public static boolean isPerfectNumber2(int n) {\n        if (n <= 0) return false;\n        int sum = 1;\n        double root = Math.sqrt(n);\n\n        /*\n         * We can get the factors after the root by dividing number by its factors\n         * before the root.\n         * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n         * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n         * Now by dividing 100 by each factor before 10 we get:\n         * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n         * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n         */\n        for (int i = 2; i <= root; i++) {\n            if (n % i == 0) {\n                sum += i + n / i;\n            }\n        }\n\n        // if n is a perfect square then its root was added twice in above loop, so subtracting root\n        // from sum\n        if (root == (int) root) sum -= root;\n\n        return sum == n;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\nclass PerfectNumberTest {\n\n    @Test\n    public void perfectNumber() {\n        int[] trueTestCases = { 6, 28, 496, 8128, 33550336 };\n        int[] falseTestCases = { -6, 0, 1, 9, 123 };\n        for (Integer n : trueTestCases) {\n            assertTrue(PerfectNumber.isPerfectNumber(n));\n            assertTrue(PerfectNumber.isPerfectNumber2(n));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(PerfectNumber.isPerfectNumber(n));\n            assertFalse(PerfectNumber.isPerfectNumber2(n));\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass PerfectNumberTest {\n\n    @Test\n    public void perfectNumber() {\n        int[] trueTestCases = {6, 28, 496, 8128, 33550336};\n        int[] falseTestCases = {-6, 0, 1, 9, 123};\n        for (Integer n : trueTestCases) {\n            assertTrue(PerfectNumber.isPerfectNumber(n));\n            assertTrue(PerfectNumber.isPerfectNumber2(n));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(PerfectNumber.isPerfectNumber(n));\n            assertFalse(PerfectNumber.isPerfectNumber2(n));\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Perimeter.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PerimeterTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n// Perimeter of different 2D geometrical shapes\npublic class Perimeter {\n\n    /**\n     * Calculate the Perimeter of regular polygon (equals sides)\n     * Examples of regular polygon are Equilateral Triangle, Square, Regular Pentagon, Regular Hexagon. \n     * \n     * @param n for number of sides.\n     * @param side for length of each side.\n     * @return Perimeter of given polygon\n     */\n    public static float perimeterRegularPolygon(int n, float side) {\n        return n * side;\n    }\n\n    /**\n     * Calculate the Perimeter of irregular polygon (unequals sides)\n     * Examples of irregular polygon are scalent triangle, irregular quadrilateral, irregular Pentagon, irregular Hexagon. \n     * \n     * @param side1 for length of side 1\n     * @param side2 for length of side 2\n     * @param side3 for length of side 3\n     * @param sides for length of remaining sides\n     * @return Perimeter of given trapezoid.\n     */\n    public static float perimeterIrregularPolygon(float side1, float side2, float side3, float... sides) {\n        float perimeter = side1 + side2 + side3;\n        for (float side : sides) {\n            perimeter += side;\n        }\n        return perimeter;\n    }\n\n    /**\n     * Calculate the Perimeter of rectangle\n     * \n     * @param length for length of rectangle\n     * @param breadth for breadth of rectangle\n     * @return Perimeter of given rectangle\n     */\n    public static float perimeterRectangle(float length, float breadth) {\n        return 2 * (length + breadth);\n    }\n\n    /**\n     * Calculate the Perimeter or Circumference of circle.\n     * \n     * @param r for radius of circle.\n     * @return circumference of given circle.\n     */\n    public static double perimeterCircle(float r) {\n        return 2 * Math.PI * r;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n// Perimeter of different 2D geometrical shapes\npublic class Perimeter {\n\n    /**\n     * Calculate the Perimeter of regular polygon (equals sides)\n     * Examples of regular polygon are Equilateral Triangle, Square, Regular Pentagon, Regular\n     * Hexagon.\n     *\n     * @param n for number of sides.\n     * @param side for length of each side.\n     * @return Perimeter of given polygon\n     */\n    public static float perimeterRegularPolygon(int n, float side) {\n        return n * side;\n    }\n\n    /**\n     * Calculate the Perimeter of irregular polygon (unequals sides)\n     * Examples of irregular polygon are scalent triangle, irregular quadrilateral, irregular\n     * Pentagon, irregular Hexagon.\n     *\n     * @param side1 for length of side 1\n     * @param side2 for length of side 2\n     * @param side3 for length of side 3\n     * @param sides for length of remaining sides\n     * @return Perimeter of given trapezoid.\n     */\n    public static float perimeterIrregularPolygon(\n        float side1, float side2, float side3, float... sides) {\n        float perimeter = side1 + side2 + side3;\n        for (float side : sides) {\n            perimeter += side;\n        }\n        return perimeter;\n    }\n\n    /**\n     * Calculate the Perimeter of rectangle\n     *\n     * @param length for length of rectangle\n     * @param breadth for breadth of rectangle\n     * @return Perimeter of given rectangle\n     */\n    public static float perimeterRectangle(float length, float breadth) {\n        return 2 * (length + breadth);\n    }\n\n    /**\n     * Calculate the Perimeter or Circumference of circle.\n     *\n     * @param r for radius of circle.\n     * @return circumference of given circle.\n     */\n    public static double perimeterCircle(float r) {\n        return 2 * Math.PI * r;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PerimeterTest {\n\n    // Perimeter of Regular polygon\n    @Test\n    void testcase1() {\n        Assertions.assertEquals(20.0, Perimeter.perimeterRegularPolygon(4, 5));\n    }\n\n    @Test\n    void testcase2() {\n        Assertions.assertEquals(30.0, Perimeter.perimeterRegularPolygon(5, 6));\n    }\n\n    // Perimeter of Rectangle\n    @Test\n    void testcase3() {\n        Assertions.assertEquals(18.0, Perimeter.perimeterRectangle(4, 5));\n    }\n\n    @Test\n    void testcase4() {\n        Assertions.assertEquals(14.0, Perimeter.perimeterRectangle(4, 3));\n    }\n\n    // Circumference/Perimeter of a circle\n    @Test\n    void testcase5() {\n        Assertions.assertEquals(31.41592653589793, Perimeter.perimeterCircle(5));\n    }\n\n    @Test\n    void testcase6() {\n        Assertions.assertEquals(43.982297150257104, Perimeter.perimeterCircle(7));\n    }\n  \n    // Perimeter of Irregular polygon\n    @Test\n    void testcase7() {\n        Assertions.assertEquals(12.0, Perimeter.perimeterIrregularPolygon(4, 5, 3));\n    }\n\n    @Test\n    void testcase8() {\n        Assertions.assertEquals(21.0, Perimeter.perimeterIrregularPolygon(3, 4, 5, 3, 6));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PerimeterTest {\n\n    // Perimeter of Regular polygon\n    @Test\n    void testcase1() {\n        Assertions.assertEquals(20.0, Perimeter.perimeterRegularPolygon(4, 5));\n    }\n\n    @Test\n    void testcase2() {\n        Assertions.assertEquals(30.0, Perimeter.perimeterRegularPolygon(5, 6));\n    }\n\n    // Perimeter of Rectangle\n    @Test\n    void testcase3() {\n        Assertions.assertEquals(18.0, Perimeter.perimeterRectangle(4, 5));\n    }\n\n    @Test\n    void testcase4() {\n        Assertions.assertEquals(14.0, Perimeter.perimeterRectangle(4, 3));\n    }\n\n    // Circumference/Perimeter of a circle\n    @Test\n    void testcase5() {\n        Assertions.assertEquals(31.41592653589793, Perimeter.perimeterCircle(5));\n    }\n\n    @Test\n    void testcase6() {\n        Assertions.assertEquals(43.982297150257104, Perimeter.perimeterCircle(7));\n    }\n\n    // Perimeter of Irregular polygon\n    @Test\n    void testcase7() {\n        Assertions.assertEquals(12.0, Perimeter.perimeterIrregularPolygon(4, 5, 3));\n    }\n\n    @Test\n    void testcase8() {\n        Assertions.assertEquals(21.0, Perimeter.perimeterIrregularPolygon(3, 4, 5, 3, 6));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PollardRho.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PollardRhoTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for pollard rho algorithm\n * The algorithm is used to factorize a number n = pq,\n * where p is a non-trivial factor. \n * Pollard's rho algorithm is an algorithm for integer factorization\n * and it takes as its inputs n, the integer to be factored; \n * and g(x), a polynomial in x computed modulo n.\n * In the original algorithm, g(x) = ((x ^ 2) \u2212 1) mod n,\n * but nowadays it is more common to use g(x) = ((x ^ 2) + 1 ) mod n. \n * The output is either a non-trivial factor of n, or failure.\n * It performs the following steps:\n *     x \u2190 2\n *     y \u2190 2\n *     d \u2190 1\n\n *     while d = 1:\n *         x \u2190 g(x)\n *         y \u2190 g(g(y))\n *         d \u2190 gcd(|x - y|, n)\n\n *     if d = n: \n *         return failure\n *     else:\n *         return d\n\n * Here x and y corresponds to xi and xj in the previous section. \n * Note that this algorithm may fail to find a nontrivial factor even when n is composite.\n * In that case, the method can be tried again, using a starting value other than 2 or a different g(x)\n * \n * Wikipedia: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\npublic class PollardRho {\n\n    /**\n     * This method returns a polynomial in x computed modulo n\n     *\n     * @param base Integer base of the polynomial\n     * @param modulus Integer is value which is to be used to perform modulo operation over the polynomial\n     * @return Integer (((base * base) - 1) % modulus)\n     */\n    static int g(int base, int modulus) {\n        return ((base * base) - 1) % modulus;\n    }\n\n    /**\n     * This method returns a non-trivial factor of given integer number\n     *\n     * @param number Integer is a integer value whose non-trivial factor is to be found\n     * @return Integer non-trivial factor of number\n     * @throws RuntimeException object if GCD of given number cannot be found\n     */\n    static int pollardRho(int number) {\n        int x = 2, y = 2, d = 1;\n        while (d == 1) {\n            //tortoise move\n            x = g(x, number);\n\n            //hare move\n            y = g(g(y, number), number);\n\n            //check GCD of |x-y| and number\n            d = GCD.gcd(Math.abs(x - y), number);\n        }\n        if (d == number) {\n            throw new RuntimeException(\"GCD cannot be found.\");\n        }\n        return d;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for pollard rho algorithm\n * The algorithm is used to factorize a number n = pq,\n * where p is a non-trivial factor.\n * Pollard's rho algorithm is an algorithm for integer factorization\n * and it takes as its inputs n, the integer to be factored;\n * and g(x), a polynomial in x computed modulo n.\n * In the original algorithm, g(x) = ((x ^ 2) \u2212 1) mod n,\n * but nowadays it is more common to use g(x) = ((x ^ 2) + 1 ) mod n.\n * The output is either a non-trivial factor of n, or failure.\n * It performs the following steps:\n *     x \u2190 2\n *     y \u2190 2\n *     d \u2190 1\n\n *     while d = 1:\n *         x \u2190 g(x)\n *         y \u2190 g(g(y))\n *         d \u2190 gcd(|x - y|, n)\n\n *     if d = n:\n *         return failure\n *     else:\n *         return d\n\n * Here x and y corresponds to xi and xj in the previous section.\n * Note that this algorithm may fail to find a nontrivial factor even when n is composite.\n * In that case, the method can be tried again, using a starting value other than 2 or a different\n g(x)\n *\n * Wikipedia: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\npublic class PollardRho {\n\n    /**\n     * This method returns a polynomial in x computed modulo n\n     *\n     * @param base Integer base of the polynomial\n     * @param modulus Integer is value which is to be used to perform modulo operation over the\n     *     polynomial\n     * @return Integer (((base * base) - 1) % modulus)\n     */\n    static int g(int base, int modulus) {\n        return ((base * base) - 1) % modulus;\n    }\n\n    /**\n     * This method returns a non-trivial factor of given integer number\n     *\n     * @param number Integer is a integer value whose non-trivial factor is to be found\n     * @return Integer non-trivial factor of number\n     * @throws RuntimeException object if GCD of given number cannot be found\n     */\n    static int pollardRho(int number) {\n        int x = 2, y = 2, d = 1;\n        while (d == 1) {\n            // tortoise move\n            x = g(x, number);\n\n            // hare move\n            y = g(g(y, number), number);\n\n            // check GCD of |x-y| and number\n            d = GCD.gcd(Math.abs(x - y), number);\n        }\n        if (d == number) {\n            throw new RuntimeException(\"GCD cannot be found.\");\n        }\n        return d;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass PollardRhoTest {\n\n    @Test\n    void testPollardRhoForNumber315MustReturn5() {\n        //given\n        int number = 315;\n        int expectedResult = 5;\n\n        //when\n        int actualResult = PollardRho.pollardRho(number);\n\n        //then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber187MustReturn11() {\n        //given\n        int number = 187;\n        int expectedResult = 11;\n\n        //when\n        int actualResult = PollardRho.pollardRho(number);\n\n        //then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber239MustThrowException() {\n        //given\n        int number = 239;\n        String expectedMessage = \"GCD cannot be found.\";\n\n        //when\n        Exception exception = assertThrows(\n            RuntimeException.class,\n            () -> {\n                PollardRho.pollardRho(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass PollardRhoTest {\n\n    @Test\n    void testPollardRhoForNumber315MustReturn5() {\n        // given\n        int number = 315;\n        int expectedResult = 5;\n\n        // when\n        int actualResult = PollardRho.pollardRho(number);\n\n        // then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber187MustReturn11() {\n        // given\n        int number = 187;\n        int expectedResult = 11;\n\n        // when\n        int actualResult = PollardRho.pollardRho(number);\n\n        // then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber239MustThrowException() {\n        // given\n        int number = 239;\n        String expectedMessage = \"GCD cannot be found.\";\n\n        // when\n        Exception exception\n            = assertThrows(RuntimeException.class, () -> { PollardRho.pollardRho(number); });\n        String actualMessage = exception.getMessage();\n\n        // then\n        assertEquals(expectedMessage, actualMessage);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PronicNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PronicNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Pronic Number\n * Pronic Number: A number n is a pronic number if\n * it is equal to product of two consecutive numbers m and m+1.\n * Wikipedia: https://en.wikipedia.org/wiki/Pronic_number\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class PronicNumber {\n\n    /**\n     * This method checks if the given number is pronic number or non-pronic number\n     *\n     * @param input_number Integer value which is to be checked if is a pronic number or not\n     * @return true if input number is a pronic number, false otherwise\n     */\n    static boolean isPronic(int input_number) {\n        //Iterating from 0 to input_number\n        for (int i = 0; i <= input_number; i++) {\n            //Checking if product of i and (i+1) is equals input_number\n            if (i * (i + 1) == input_number && i != input_number) {\n                //return true if product of i and (i+1) is equals input_number\n                return true;\n            }\n        }\n\n        //return false if product of i and (i+1) for all values from 0 to input_number is not equals input_number\n        return false;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Pronic Number\n * Pronic Number: A number n is a pronic number if\n * it is equal to product of two consecutive numbers m and m+1.\n * Wikipedia: https://en.wikipedia.org/wiki/Pronic_number\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class PronicNumber {\n\n    /**\n     * This method checks if the given number is pronic number or non-pronic number\n     *\n     * @param input_number Integer value which is to be checked if is a pronic number or not\n     * @return true if input number is a pronic number, false otherwise\n     */\n    static boolean isPronic(int input_number) {\n        // Iterating from 0 to input_number\n        for (int i = 0; i <= input_number; i++) {\n            // Checking if product of i and (i+1) is equals input_number\n            if (i * (i + 1) == input_number && i != input_number) {\n                // return true if product of i and (i+1) is equals input_number\n                return true;\n            }\n        }\n\n        // return false if product of i and (i+1) for all values from 0 to input_number is not\n        // equals input_number\n        return false;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PronicNumberTest {\n\n    @Test\n    void testForPronicNumber() {\n        //given\n        int number = 30;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n\n        //then\n        assertTrue(result);\n    }\n\n    @Test\n    void testForNonPronicNumber() {\n        //given\n        int number = 21;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n\n        //then\n        assertFalse(result);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PronicNumberTest {\n\n    @Test\n    void testForPronicNumber() {\n        // given\n        int number = 30;\n\n        // when\n        boolean result = PronicNumber.isPronic(number);\n\n        // then\n        assertTrue(result);\n    }\n\n    @Test\n    void testForNonPronicNumber() {\n        // given\n        int number = 21;\n\n        // when\n        boolean result = PronicNumber.isPronic(number);\n\n        // then\n        assertFalse(result);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SquareFreeInteger.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SquareFreeIntegerTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n/*\n * Java program for Square free integer\n * This class has a function which checks \n * if an integer has repeated prime factors\n * and will return false if the number has repeated prime factors.\n * true otherwise\n * Wikipedia: https://en.wikipedia.org/wiki/Square-free_integer\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class SquareFreeInteger {\n    /**\n     * This method returns whether an integer is square free\n     *\n     * @param number Integer value which is to be checked\n     * @return false when number has repeated prime factors\n     *         true when number has non repeated prime factors\n     * @throws IllegalArgumentException when number is negative or zero\n     */\n\tpublic static boolean isSquareFreeInteger(int number) {\n\t\t\n\t\tif(number <= 0) {\n\t\t\t//throw exception when number is less than or is zero\n\t\t\tthrow new IllegalArgumentException(\"Number must be greater than zero.\");\n\t\t}\n\t\t\n\t\t//Store prime factors of number which is passed as argument\n\t\t//in a list \n\t\tList<Integer> primeFactorsList = PrimeFactorization.pfactors(number);\n\t\t\n\t\t//Create set from list of prime factors of integer number\n\t\t//if size of list and set is equal then the argument passed to this method is square free\n\t\t//if size of list and set is not equal then the argument passed to this method is not square free\n\t\treturn primeFactorsList.size() == new HashSet<>(primeFactorsList).size();\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n/*\n * Java program for Square free integer\n * This class has a function which checks\n * if an integer has repeated prime factors\n * and will return false if the number has repeated prime factors.\n * true otherwise\n * Wikipedia: https://en.wikipedia.org/wiki/Square-free_integer\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class SquareFreeInteger {\n    /**\n     * This method returns whether an integer is square free\n     *\n     * @param number Integer value which is to be checked\n     * @return false when number has repeated prime factors\n     *         true when number has non repeated prime factors\n     * @throws IllegalArgumentException when number is negative or zero\n     */\n    public static boolean isSquareFreeInteger(int number) {\n\n        if (number <= 0) {\n            // throw exception when number is less than or is zero\n            throw new IllegalArgumentException(\"Number must be greater than zero.\");\n        }\n\n        // Store prime factors of number which is passed as argument\n        // in a list\n        List<Integer> primeFactorsList = PrimeFactorization.pfactors(number);\n\n        // Create set from list of prime factors of integer number\n        // if size of list and set is equal then the argument passed to this method is square free\n        // if size of list and set is not equal then the argument passed to this method is not\n        // square free\n        return primeFactorsList.size() == new HashSet<>(primeFactorsList).size();\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nclass SquareFreeIntegerTest {\n\n\t@Test\n\tvoid testIsSquareFreeInteger() {\n\n\t\t//given\n\t\tList<Integer> listOfSquareFreeIntegers = List.of(1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35, 37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55, 57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71, 73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89, 91, 93, 94, 95, 97, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 118, 119, 122, 123, 127, 129, 130, 131, 133, 134, 137, 138, 139, 141, 142, 143, 145, 146, 149, 151, 154, 155, 157, 158, 159, 161, 163, 165, 166, 167, 170, 173, 174, 177, 178, 179, 181, 182, 183, 185, 186, 187, 190, 191, 193, 194, 195, 197, 199, 201, 202, 203, 205, 206, 209, 210, 211, 213, 214, 215, 217, 218, 219, 221, 222, 223, 226, 227, 229, 230, 231, 233, 235, 237, 238, 239, 241, 246, 247, 249, 251, 253, 254, 255, 257, 258, 259, 262, 263, 265, 266, 267, 269, 271, 273, 274, 277, 278, 281, 282, 283, 285, 286, 287, 290, 291, 293, 295, 298, 299, 301, 302, 303, 305, 307, 309, 310, 311, 313, 314, 317, 318, 319, 321, 322, 323, 326, 327, 329, 330, 331, 334, 335, 337, 339, 341, 345, 346, 347, 349, 353, 354, 355, 357, 358, 359, 362, 365, 366, 367, 370, 371, 373, 374, 377, 379, 381, 382, 383, 385, 386, 389, 390, 391, 393, 394, 395, 397, 398, 399, 401, 402, 403, 406, 407, 409, 410, 411, 413, 415, 417, 418, 419, 421, 422, 426, 427, 429, 430, 431, 433, 434, 435, 437, 438, 439, 442, 443, 445, 446, 447, 449, 451, 453, 454, 455, 457, 458, 461, 462, 463, 465, 466, 467, 469, 470, 471, 473, 474, 478, 479, 481, 482, 483, 485, 487, 489, 491, 493, 494, 497, 498, 499, 501, 502, 503, 505, 506, 509, 510, 511, 514, 515, 517, 518, 519, 521, 523, 526, 527, 530, 533, 534, 535, 537, 538, 541, 542, 543, 545, 546, 547, 551, 553, 554, 555, 557, 559, 561, 562, 563, 565, 566, 569, 570, 571, 573, 574, 577, 579, 581, 582, 583, 586, 587, 589, 590, 591, 593, 595, 597, 598, 599, 601, 602, 606, 607, 609, 610, 611, 613, 614, 615, 617, 618, 619, 622, 623, 626, 627, 629, 631, 633, 634, 635, 638, 641, 642, 643, 645, 646, 647, 649, 651, 653, 654, 655, 658, 659, 661, 662, 663, 665, 667, 669, 670, 671, 673, 674, 677, 678, 679, 681, 682, 683, 685, 687, 689, 690, 691, 694, 695, 697, 698, 699, 701, 703, 705, 706, 707, 709, 710, 713, 714, 715, 717, 718, 719, 721, 723, 727, 730, 731, 733, 734, 737, 739, 741, 742, 743, 745, 746, 749, 751, 753, 754, 755, 757, 758, 759, 761, 762, 763, 766, 767, 769, 770, 771, 773, 777, 778, 779, 781, 782, 785, 786, 787, 789, 790, 791, 793, 794, 795, 797, 798, 799, 802, 803, 805, 806, 807, 809, 811, 813, 814, 815, 817, 818, 821, 822, 823, 826, 827, 829, 830, 831, 834, 835, 838, 839, 842, 843, 849, 851, 853, 854, 857, 858, 859, 861, 862, 863, 865, 866, 869, 870, 871, 874, 877, 878, 879, 881, 883, 885, 886, 887, 889, 890, 893, 894, 895, 897, 898, 899, 901, 902, 903, 905, 906, 907, 910, 911, 913, 914, 915, 917, 919, 921, 922, 923, 926, 929, 930, 933, 934, 935, 937, 938, 939, 941, 942, 943, 946, 947, 949, 951, 953, 955, 957, 958, 959, 962, 965, 966, 967, 969, 970, 971, 973, 974, 977, 978, 979, 982, 983, 985, 986, 987, 989, 991, 993, 994, 995, 997, 998, 1001, 1002, 1003, 1005, 1006, 1007, 1009, 1010, 1011, 1013, 1015, 1018, 1019, 1021, 1022, 1023, 1027, 1030, 1031, 1033, 1034, 1037, 1038, 1039, 1041, 1042, 1043, 1045, 1046, 1047, 1049, 1051, 1054, 1055, 1057, 1059, 1061, 1063, 1065, 1066, 1067, 1069, 1070, 1073, 1074, 1077, 1079, 1081, 1082, 1085, 1086, 1087, 1090, 1091, 1093, 1094, 1095, 1097, 1099, 1101, 1102, 1103, 1105, 1106, 1109, 1110, 1111, 1113, 1114, 1115, 1117, 1118, 1119, 1121, 1122, 1123, 1126, 1129, 1130, 1131, 1133, 1135, 1137, 1138, 1139, 1141, 1142, 1145, 1146, 1147, 1149, 1151, 1153, 1154, 1155, 1157, 1158, 1159, 1162, 1163, 1165, 1166, 1167, 1169, 1171, 1173, 1174, 1177, 1178, 1181, 1182, 1185, 1186, 1187, 1189, 1190, 1191, 1193, 1194, 1195, 1198, 1199, 1201, 1202, 1203, 1205, 1207, 1209, 1211, 1213, 1214, 1217, 1218, 1219, 1221, 1222, 1223, 1226, 1227, 1229, 1230, 1231, 1234, 1235, 1237, 1238, 1239, 1241, 1243, 1245, 1246, 1247, 1249, 1253, 1254, 1255, 1257, 1258, 1259, 1261, 1262, 1263, 1265, 1266, 1267, 1270, 1271, 1273, 1277, 1279, 1281, 1282, 1283, 1285, 1286, 1289, 1290, 1291, 1293, 1294, 1295, 1297, 1298, 1299, 1301, 1302, 1303, 1306, 1307, 1309, 1310, 1311, 1313, 1315, 1317, 1318, 1319, 1321, 1322, 1326, 1327, 1329, 1330, 1333, 1334, 1335, 1337, 1338, 1339, 1342, 1343, 1345, 1346, 1347, 1349, 1351, 1353, 1354, 1355, 1357, 1358, 1361, 1362, 1363, 1365, 1366, 1367, 1370, 1371, 1373, 1374, 1378, 1379, 1381, 1382, 1383, 1385, 1387, 1389, 1390, 1391, 1393, 1394, 1397, 1398, 1399, 1401, 1402, 1403, 1405, 1406, 1407, 1409, 1410, 1411, 1414, 1415, 1417, 1418, 1419, 1423, 1426, 1427, 1429, 1430, 1433, 1434, 1435, 1437, 1438, 1439, 1441, 1442, 1443, 1446, 1447, 1451, 1453, 1454, 1455, 1457, 1459, 1461, 1462, 1463, 1465, 1466, 1469, 1471, 1473, 1474, 1477, 1478, 1479, 1481, 1482, 1483, 1486, 1487, 1489, 1490, 1491, 1493, 1495, 1497, 1498, 1499, 1501, 1502, 1505, 1506, 1507, 1509, 1510, 1511, 1513, 1514, 1515, 1517, 1518, 1522, 1523, 1526, 1527, 1529, 1531, 1533, 1534, 1535, 1537, 1538, 1541, 1542, 1543, 1545, 1546, 1547, 1549, 1551, 1553, 1554, 1555, 1558, 1559, 1561, 1562, 1563, 1565, 1567, 1569, 1570, 1571, 1574, 1577, 1578, 1579, 1581, 1582, 1583, 1585, 1586, 1589, 1590, 1591, 1594, 1595, 1597, 1598, 1599, 1601, 1603, 1605, 1606, 1607, 1609, 1610, 1613, 1614, 1615, 1618, 1619, 1621, 1622, 1623, 1626, 1627, 1630, 1631, 1633, 1634, 1635, 1637, 1639, 1641, 1642, 1643, 1645, 1646, 1649, 1651, 1653, 1654, 1655, 1657, 1658, 1659, 1661, 1662, 1663, 1667, 1669, 1670, 1671, 1673, 1677, 1678, 1679, 1685, 1686, 1687, 1689, 1691, 1693, 1695, 1697, 1698, 1699, 1702, 1703, 1705, 1706, 1707, 1709, 1711, 1713, 1714, 1717, 1718, 1721, 1722, 1723, 1726, 1727, 1729, 1730, 1731, 1733, 1735, 1738, 1739, 1741, 1742, 1743, 1745, 1747, 1749, 1751, 1753, 1754, 1757, 1758, 1759, 1761, 1762, 1763, 1765, 1766, 1767, 1769, 1770, 1771, 1774, 1777, 1778, 1779, 1781, 1783, 1785, 1786, 1787, 1789, 1790, 1793, 1794, 1795, 1797, 1798, 1799, 1801, 1802, 1803, 1806, 1807, 1810, 1811, 1814, 1817, 1819, 1821, 1822, 1823, 1826, 1829, 1830, 1831, 1833, 1834, 1835, 1837, 1838, 1839, 1841, 1842, 1843, 1846, 1847, 1851, 1853, 1855, 1857, 1858, 1861, 1865, 1866, 1867, 1869, 1870, 1871, 1873, 1874, 1877, 1878, 1879, 1882, 1883, 1885, 1886, 1887, 1889, 1891, 1893, 1894, 1895, 1897, 1898, 1901, 1902, 1903, 1905, 1906, 1907, 1909, 1910, 1913, 1914, 1915, 1918, 1919, 1921, 1923, 1927, 1929, 1930, 1931, 1933, 1934, 1937, 1938, 1939, 1941, 1942, 1943, 1945, 1946, 1947, 1949, 1951, 1954, 1955, 1957, 1958, 1959, 1961, 1963, 1965, 1966, 1967, 1969, 1970, 1973, 1974, 1977, 1978, 1979, 1981, 1982, 1983, 1985, 1986, 1987, 1990, 1991, 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2005, 2006, 2010, 2011, 2013, 2014, 2015, 2017, 2018, 2019, 2021, 2022, 2026, 2027, 2029, 2030, 2031, 2033, 2035, 2037, 2038, 2039, 2041, 2042, 2045, 2046, 2047, 2049, 2051, 2053, 2054, 2055, 2059, 2062, 2063, 2065, 2066, 2067, 2069, 2071, 2073, 2074, 2077, 2078, 2081, 2082, 2083, 2085, 2086, 2087, 2089, 2090, 2091, 2093, 2094, 2095, 2098, 2099, 2101, 2102, 2103, 2105, 2109, 2110, 2111, 2113, 2114, 2117, 2118, 2119, 2121, 2122, 2123, 2126, 2127, 2129, 2130, 2131, 2134, 2135, 2137, 2138, 2139, 2141, 2143, 2145, 2146, 2147, 2149, 2153, 2154, 2155, 2157, 2158, 2159, 2161, 2162, 2163, 2165, 2167, 2170, 2171, 2173, 2174, 2177, 2179, 2181, 2182, 2183, 2185, 2186, 2189, 2190, 2191, 2193, 2194, 2195, 2198, 2199, 2201, 2202, 2203, 2206, 2207, 2210, 2211, 2213, 2215, 2217, 2218, 2219, 2221, 2222, 2226, 2227, 2229, 2230, 2231, 2233, 2234, 2235, 2237, 2238, 2239, 2242, 2243, 2245, 2246, 2247, 2249, 2251, 2253, 2255, 2257, 2258, 2261, 2262, 2263, 2265, 2266, 2267, 2269, 2270, 2271, 2273, 2274, 2278, 2279, 2281, 2282, 2283, 2285, 2287, 2289, 2290, 2291, 2293, 2294, 2297, 2298, 2301, 2302, 2305, 2306, 2307, 2309, 2310, 2311, 2314, 2315, 2317, 2318, 2319, 2321, 2323, 2326, 2327, 2329, 2330, 2333, 2334, 2335, 2337, 2338, 2339, 2341, 2342, 2343, 2345, 2346, 2347, 2351, 2353, 2354, 2355, 2357, 2359, 2361, 2362, 2363, 2365, 2369, 2370, 2371, 2373, 2374, 2377, 2378, 2379, 2381, 2382, 2383, 2386, 2387, 2389, 2390, 2391, 2393, 2395, 2397, 2398, 2399, 2402, 2405, 2406, 2407, 2409, 2410, 2411, 2413, 2414, 2415, 2417, 2418, 2419, 2422, 2423, 2426, 2427, 2429, 2431, 2433, 2434, 2435, 2437, 2438, 2441, 2442, 2443, 2445, 2446, 2447, 2449, 2451, 2453, 2454, 2455, 2458, 2459, 2461, 2462, 2463, 2465, 2467, 2469, 2470, 2471, 2473, 2474, 2477, 2478, 2479, 2481, 2482, 2483, 2485, 2486, 2487, 2489, 2490, 2491, 2494, 2495, 2497, 2498);\n\n\t\tfor(int i = 1; i <=2500; i++) {\n\t\t\t//when\n\t\t\tboolean isNumberSquareFree = SquareFreeInteger.isSquareFreeInteger(i);\n\t\t\tboolean isNumberPresentInList = listOfSquareFreeIntegers.contains(i);\n\n\t\t\t//then\n\t\t\tassertEquals(isNumberSquareFree,isNumberPresentInList);\n\t\t}\n\t}\n\n\t@Test\n\tvoid testIsSquareFreeIntegerThrowExceptionIfNumberIsZero() {\n\t\t//given\n\t\tint number = 0;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(\n\t\t\t\tIllegalArgumentException.class,\n\t\t\t\t() -> {\n\t\t\t\t\tSquareFreeInteger.isSquareFreeInteger(number);\n\t\t\t\t}\n\t\t\t\t);\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testIsSquareFreeIntegerMustThrowExceptionIfNumberIsNegative() {\n\t\t//given\n\t\tint number = -1;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(\n\t\t\t\tIllegalArgumentException.class,\n\t\t\t\t() -> {\n\t\t\t\t\tSquareFreeInteger.isSquareFreeInteger(number);\n\t\t\t\t}\n\t\t\t\t);\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\nclass SquareFreeIntegerTest {\n\n    @Test\n    void testIsSquareFreeInteger() {\n\n        // given\n        List<Integer> listOfSquareFreeIntegers = List.of(1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17,\n            19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35, 37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55,\n            57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71, 73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89,\n            91, 93, 94, 95, 97, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 118,\n            119, 122, 123, 127, 129, 130, 131, 133, 134, 137, 138, 139, 141, 142, 143, 145, 146,\n            149, 151, 154, 155, 157, 158, 159, 161, 163, 165, 166, 167, 170, 173, 174, 177, 178,\n            179, 181, 182, 183, 185, 186, 187, 190, 191, 193, 194, 195, 197, 199, 201, 202, 203,\n            205, 206, 209, 210, 211, 213, 214, 215, 217, 218, 219, 221, 222, 223, 226, 227, 229,\n            230, 231, 233, 235, 237, 238, 239, 241, 246, 247, 249, 251, 253, 254, 255, 257, 258,\n            259, 262, 263, 265, 266, 267, 269, 271, 273, 274, 277, 278, 281, 282, 283, 285, 286,\n            287, 290, 291, 293, 295, 298, 299, 301, 302, 303, 305, 307, 309, 310, 311, 313, 314,\n            317, 318, 319, 321, 322, 323, 326, 327, 329, 330, 331, 334, 335, 337, 339, 341, 345,\n            346, 347, 349, 353, 354, 355, 357, 358, 359, 362, 365, 366, 367, 370, 371, 373, 374,\n            377, 379, 381, 382, 383, 385, 386, 389, 390, 391, 393, 394, 395, 397, 398, 399, 401,\n            402, 403, 406, 407, 409, 410, 411, 413, 415, 417, 418, 419, 421, 422, 426, 427, 429,\n            430, 431, 433, 434, 435, 437, 438, 439, 442, 443, 445, 446, 447, 449, 451, 453, 454,\n            455, 457, 458, 461, 462, 463, 465, 466, 467, 469, 470, 471, 473, 474, 478, 479, 481,\n            482, 483, 485, 487, 489, 491, 493, 494, 497, 498, 499, 501, 502, 503, 505, 506, 509,\n            510, 511, 514, 515, 517, 518, 519, 521, 523, 526, 527, 530, 533, 534, 535, 537, 538,\n            541, 542, 543, 545, 546, 547, 551, 553, 554, 555, 557, 559, 561, 562, 563, 565, 566,\n            569, 570, 571, 573, 574, 577, 579, 581, 582, 583, 586, 587, 589, 590, 591, 593, 595,\n            597, 598, 599, 601, 602, 606, 607, 609, 610, 611, 613, 614, 615, 617, 618, 619, 622,\n            623, 626, 627, 629, 631, 633, 634, 635, 638, 641, 642, 643, 645, 646, 647, 649, 651,\n            653, 654, 655, 658, 659, 661, 662, 663, 665, 667, 669, 670, 671, 673, 674, 677, 678,\n            679, 681, 682, 683, 685, 687, 689, 690, 691, 694, 695, 697, 698, 699, 701, 703, 705,\n            706, 707, 709, 710, 713, 714, 715, 717, 718, 719, 721, 723, 727, 730, 731, 733, 734,\n            737, 739, 741, 742, 743, 745, 746, 749, 751, 753, 754, 755, 757, 758, 759, 761, 762,\n            763, 766, 767, 769, 770, 771, 773, 777, 778, 779, 781, 782, 785, 786, 787, 789, 790,\n            791, 793, 794, 795, 797, 798, 799, 802, 803, 805, 806, 807, 809, 811, 813, 814, 815,\n            817, 818, 821, 822, 823, 826, 827, 829, 830, 831, 834, 835, 838, 839, 842, 843, 849,\n            851, 853, 854, 857, 858, 859, 861, 862, 863, 865, 866, 869, 870, 871, 874, 877, 878,\n            879, 881, 883, 885, 886, 887, 889, 890, 893, 894, 895, 897, 898, 899, 901, 902, 903,\n            905, 906, 907, 910, 911, 913, 914, 915, 917, 919, 921, 922, 923, 926, 929, 930, 933,\n            934, 935, 937, 938, 939, 941, 942, 943, 946, 947, 949, 951, 953, 955, 957, 958, 959,\n            962, 965, 966, 967, 969, 970, 971, 973, 974, 977, 978, 979, 982, 983, 985, 986, 987,\n            989, 991, 993, 994, 995, 997, 998, 1001, 1002, 1003, 1005, 1006, 1007, 1009, 1010, 1011,\n            1013, 1015, 1018, 1019, 1021, 1022, 1023, 1027, 1030, 1031, 1033, 1034, 1037, 1038,\n            1039, 1041, 1042, 1043, 1045, 1046, 1047, 1049, 1051, 1054, 1055, 1057, 1059, 1061,\n            1063, 1065, 1066, 1067, 1069, 1070, 1073, 1074, 1077, 1079, 1081, 1082, 1085, 1086,\n            1087, 1090, 1091, 1093, 1094, 1095, 1097, 1099, 1101, 1102, 1103, 1105, 1106, 1109,\n            1110, 1111, 1113, 1114, 1115, 1117, 1118, 1119, 1121, 1122, 1123, 1126, 1129, 1130,\n            1131, 1133, 1135, 1137, 1138, 1139, 1141, 1142, 1145, 1146, 1147, 1149, 1151, 1153,\n            1154, 1155, 1157, 1158, 1159, 1162, 1163, 1165, 1166, 1167, 1169, 1171, 1173, 1174,\n            1177, 1178, 1181, 1182, 1185, 1186, 1187, 1189, 1190, 1191, 1193, 1194, 1195, 1198,\n            1199, 1201, 1202, 1203, 1205, 1207, 1209, 1211, 1213, 1214, 1217, 1218, 1219, 1221,\n            1222, 1223, 1226, 1227, 1229, 1230, 1231, 1234, 1235, 1237, 1238, 1239, 1241, 1243,\n            1245, 1246, 1247, 1249, 1253, 1254, 1255, 1257, 1258, 1259, 1261, 1262, 1263, 1265,\n            1266, 1267, 1270, 1271, 1273, 1277, 1279, 1281, 1282, 1283, 1285, 1286, 1289, 1290,\n            1291, 1293, 1294, 1295, 1297, 1298, 1299, 1301, 1302, 1303, 1306, 1307, 1309, 1310,\n            1311, 1313, 1315, 1317, 1318, 1319, 1321, 1322, 1326, 1327, 1329, 1330, 1333, 1334,\n            1335, 1337, 1338, 1339, 1342, 1343, 1345, 1346, 1347, 1349, 1351, 1353, 1354, 1355,\n            1357, 1358, 1361, 1362, 1363, 1365, 1366, 1367, 1370, 1371, 1373, 1374, 1378, 1379,\n            1381, 1382, 1383, 1385, 1387, 1389, 1390, 1391, 1393, 1394, 1397, 1398, 1399, 1401,\n            1402, 1403, 1405, 1406, 1407, 1409, 1410, 1411, 1414, 1415, 1417, 1418, 1419, 1423,\n            1426, 1427, 1429, 1430, 1433, 1434, 1435, 1437, 1438, 1439, 1441, 1442, 1443, 1446,\n            1447, 1451, 1453, 1454, 1455, 1457, 1459, 1461, 1462, 1463, 1465, 1466, 1469, 1471,\n            1473, 1474, 1477, 1478, 1479, 1481, 1482, 1483, 1486, 1487, 1489, 1490, 1491, 1493,\n            1495, 1497, 1498, 1499, 1501, 1502, 1505, 1506, 1507, 1509, 1510, 1511, 1513, 1514,\n            1515, 1517, 1518, 1522, 1523, 1526, 1527, 1529, 1531, 1533, 1534, 1535, 1537, 1538,\n            1541, 1542, 1543, 1545, 1546, 1547, 1549, 1551, 1553, 1554, 1555, 1558, 1559, 1561,\n            1562, 1563, 1565, 1567, 1569, 1570, 1571, 1574, 1577, 1578, 1579, 1581, 1582, 1583,\n            1585, 1586, 1589, 1590, 1591, 1594, 1595, 1597, 1598, 1599, 1601, 1603, 1605, 1606,\n            1607, 1609, 1610, 1613, 1614, 1615, 1618, 1619, 1621, 1622, 1623, 1626, 1627, 1630,\n            1631, 1633, 1634, 1635, 1637, 1639, 1641, 1642, 1643, 1645, 1646, 1649, 1651, 1653,\n            1654, 1655, 1657, 1658, 1659, 1661, 1662, 1663, 1667, 1669, 1670, 1671, 1673, 1677,\n            1678, 1679, 1685, 1686, 1687, 1689, 1691, 1693, 1695, 1697, 1698, 1699, 1702, 1703,\n            1705, 1706, 1707, 1709, 1711, 1713, 1714, 1717, 1718, 1721, 1722, 1723, 1726, 1727,\n            1729, 1730, 1731, 1733, 1735, 1738, 1739, 1741, 1742, 1743, 1745, 1747, 1749, 1751,\n            1753, 1754, 1757, 1758, 1759, 1761, 1762, 1763, 1765, 1766, 1767, 1769, 1770, 1771,\n            1774, 1777, 1778, 1779, 1781, 1783, 1785, 1786, 1787, 1789, 1790, 1793, 1794, 1795,\n            1797, 1798, 1799, 1801, 1802, 1803, 1806, 1807, 1810, 1811, 1814, 1817, 1819, 1821,\n            1822, 1823, 1826, 1829, 1830, 1831, 1833, 1834, 1835, 1837, 1838, 1839, 1841, 1842,\n            1843, 1846, 1847, 1851, 1853, 1855, 1857, 1858, 1861, 1865, 1866, 1867, 1869, 1870,\n            1871, 1873, 1874, 1877, 1878, 1879, 1882, 1883, 1885, 1886, 1887, 1889, 1891, 1893,\n            1894, 1895, 1897, 1898, 1901, 1902, 1903, 1905, 1906, 1907, 1909, 1910, 1913, 1914,\n            1915, 1918, 1919, 1921, 1923, 1927, 1929, 1930, 1931, 1933, 1934, 1937, 1938, 1939,\n            1941, 1942, 1943, 1945, 1946, 1947, 1949, 1951, 1954, 1955, 1957, 1958, 1959, 1961,\n            1963, 1965, 1966, 1967, 1969, 1970, 1973, 1974, 1977, 1978, 1979, 1981, 1982, 1983,\n            1985, 1986, 1987, 1990, 1991, 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2005,\n            2006, 2010, 2011, 2013, 2014, 2015, 2017, 2018, 2019, 2021, 2022, 2026, 2027, 2029,\n            2030, 2031, 2033, 2035, 2037, 2038, 2039, 2041, 2042, 2045, 2046, 2047, 2049, 2051,\n            2053, 2054, 2055, 2059, 2062, 2063, 2065, 2066, 2067, 2069, 2071, 2073, 2074, 2077,\n            2078, 2081, 2082, 2083, 2085, 2086, 2087, 2089, 2090, 2091, 2093, 2094, 2095, 2098,\n            2099, 2101, 2102, 2103, 2105, 2109, 2110, 2111, 2113, 2114, 2117, 2118, 2119, 2121,\n            2122, 2123, 2126, 2127, 2129, 2130, 2131, 2134, 2135, 2137, 2138, 2139, 2141, 2143,\n            2145, 2146, 2147, 2149, 2153, 2154, 2155, 2157, 2158, 2159, 2161, 2162, 2163, 2165,\n            2167, 2170, 2171, 2173, 2174, 2177, 2179, 2181, 2182, 2183, 2185, 2186, 2189, 2190,\n            2191, 2193, 2194, 2195, 2198, 2199, 2201, 2202, 2203, 2206, 2207, 2210, 2211, 2213,\n            2215, 2217, 2218, 2219, 2221, 2222, 2226, 2227, 2229, 2230, 2231, 2233, 2234, 2235,\n            2237, 2238, 2239, 2242, 2243, 2245, 2246, 2247, 2249, 2251, 2253, 2255, 2257, 2258,\n            2261, 2262, 2263, 2265, 2266, 2267, 2269, 2270, 2271, 2273, 2274, 2278, 2279, 2281,\n            2282, 2283, 2285, 2287, 2289, 2290, 2291, 2293, 2294, 2297, 2298, 2301, 2302, 2305,\n            2306, 2307, 2309, 2310, 2311, 2314, 2315, 2317, 2318, 2319, 2321, 2323, 2326, 2327,\n            2329, 2330, 2333, 2334, 2335, 2337, 2338, 2339, 2341, 2342, 2343, 2345, 2346, 2347,\n            2351, 2353, 2354, 2355, 2357, 2359, 2361, 2362, 2363, 2365, 2369, 2370, 2371, 2373,\n            2374, 2377, 2378, 2379, 2381, 2382, 2383, 2386, 2387, 2389, 2390, 2391, 2393, 2395,\n            2397, 2398, 2399, 2402, 2405, 2406, 2407, 2409, 2410, 2411, 2413, 2414, 2415, 2417,\n            2418, 2419, 2422, 2423, 2426, 2427, 2429, 2431, 2433, 2434, 2435, 2437, 2438, 2441,\n            2442, 2443, 2445, 2446, 2447, 2449, 2451, 2453, 2454, 2455, 2458, 2459, 2461, 2462,\n            2463, 2465, 2467, 2469, 2470, 2471, 2473, 2474, 2477, 2478, 2479, 2481, 2482, 2483,\n            2485, 2486, 2487, 2489, 2490, 2491, 2494, 2495, 2497, 2498);\n\n        for (int i = 1; i <= 2500; i++) {\n            // when\n            boolean isNumberSquareFree = SquareFreeInteger.isSquareFreeInteger(i);\n            boolean isNumberPresentInList = listOfSquareFreeIntegers.contains(i);\n\n            // then\n            assertEquals(isNumberSquareFree, isNumberPresentInList);\n        }\n    }\n\n    @Test\n    void testIsSquareFreeIntegerThrowExceptionIfNumberIsZero() {\n        // given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class,\n            () -> { SquareFreeInteger.isSquareFreeInteger(number); });\n        String actualMessage = exception.getMessage();\n\n        // then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testIsSquareFreeIntegerMustThrowExceptionIfNumberIsNegative() {\n        // given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        // when\n        Exception exception = assertThrows(IllegalArgumentException.class,\n            () -> { SquareFreeInteger.isSquareFreeInteger(number); });\n        String actualMessage = exception.getMessage();\n\n        // then\n        assertEquals(expectedMessage, actualMessage);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SumWithoutArithmeticOperators.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SumWithoutArithmeticOperatorsTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class SumWithoutArithmeticOperators {\n\n    /**\n        * Calculate the sum of two numbers a and b without using any arithmetic operators (+, -, *, /).\n        * All the integers associated are unsigned 32-bit integers\n        *https://stackoverflow.com/questions/365522/what-is-the-best-way-to-add-two-numbers-without-using-the-operator\n        *@param a - It is the first number \n        *@param b - It is the second number\n        *@return returns an integer which is the sum of the first and second number\n    */ \n\n    public int getSum(int a, int b){\n        if(b==0) return a;\n        int sum = a^b;\n        int carry = (a&b)<<1;\n        return getSum(sum, carry);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class SumWithoutArithmeticOperators {\n\n    /**\n     * Calculate the sum of two numbers a and b without using any arithmetic operators (+, -, *, /).\n     * All the integers associated are unsigned 32-bit integers\n     *https://stackoverflow.com/questions/365522/what-is-the-best-way-to-add-two-numbers-without-using-the-operator\n     *@param a - It is the first number\n     *@param b - It is the second number\n     *@return returns an integer which is the sum of the first and second number\n     */\n\n    public int getSum(int a, int b) {\n        if (b == 0) return a;\n        int sum = a ^ b;\n        int carry = (a & b) << 1;\n        return getSum(sum, carry);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class SumWithoutArithmeticOperatorsTest {\n    SumWithoutArithmeticOperators obj = new SumWithoutArithmeticOperators();\n\n    @Test\n    void addZerotoZero(){\n        assertEquals(0,obj.getSum(0, 0));\n    }\n\n    @Test\n    void addZerotoNumber(){\n        assertEquals(5,obj.getSum(0, 5));\n        assertEquals(28,obj.getSum(28, 0));\n    }\n\n    @Test\n    void addOddtoEven(){\n        assertEquals(13,obj.getSum(3, 10));\n        assertEquals(55,obj.getSum(49, 6));\n    }\n\n    @Test\n    void addEventoOdd(){\n        assertEquals(13,obj.getSum(10, 3));\n        assertEquals(41,obj.getSum(40, 1));\n    }\n\n    @Test\n    void addRandoms(){\n        assertEquals(88,obj.getSum(44, 44));\n        assertEquals(370,obj.getSum(100, 270));\n        assertEquals(3,obj.getSum(1, 2));\n        assertEquals(5,obj.getSum(2, 3));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SumWithoutArithmeticOperatorsTest {\n    SumWithoutArithmeticOperators obj = new SumWithoutArithmeticOperators();\n\n    @Test\n    void addZerotoZero() {\n        assertEquals(0, obj.getSum(0, 0));\n    }\n\n    @Test\n    void addZerotoNumber() {\n        assertEquals(5, obj.getSum(0, 5));\n        assertEquals(28, obj.getSum(28, 0));\n    }\n\n    @Test\n    void addOddtoEven() {\n        assertEquals(13, obj.getSum(3, 10));\n        assertEquals(55, obj.getSum(49, 6));\n    }\n\n    @Test\n    void addEventoOdd() {\n        assertEquals(13, obj.getSum(10, 3));\n        assertEquals(41, obj.getSum(40, 1));\n    }\n\n    @Test\n    void addRandoms() {\n        assertEquals(88, obj.getSum(44, 44));\n        assertEquals(370, obj.getSum(100, 270));\n        assertEquals(3, obj.getSum(1, 2));\n        assertEquals(5, obj.getSum(2, 3));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/TwinPrime.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/TwinPrimeTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n/*\n * Java program to find 'twin prime' of a prime number\n * Twin Prime: Twin prime of a number n is (n+2) \n * if and only if n & (n+2) are prime.\n * Wikipedia: https://en.wikipedia.org/wiki/Twin_prime\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class TwinPrime {\n\t\n\t/**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */\n\tstatic int getTwinPrime(int inputNumber) {\n\t\t\n\t\t//if inputNumber and (inputNumber + 2) are both prime \n\t\t//then return (inputNumber + 2) as a result\n\t\tif(PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2) ) {\n\t\t\treturn inputNumber + 2;\n\t\t}\n\t\t//if any one from inputNumber and (inputNumber + 2) or if both of them are not prime \n\t\t//then return -1 as a result\n\t\treturn -1;\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.maths;\n/*\n * Java program to find 'twin prime' of a prime number\n * Twin Prime: Twin prime of a number n is (n+2)\n * if and only if n & (n+2) are prime.\n * Wikipedia: https://en.wikipedia.org/wiki/Twin_prime\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class TwinPrime {\n\n    /**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */\n    static int getTwinPrime(int inputNumber) {\n\n        // if inputNumber and (inputNumber + 2) are both prime\n        // then return (inputNumber + 2) as a result\n        if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n            return inputNumber + 2;\n        }\n        // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n        // then return -1 as a result\n        return -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass TwinPrimeTest {\n\n\t@Test\n\tvoid shouldReturn7() {\n\t\t//given\n\t\tint number = 5;\n\t\tint expectedResult = 7;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n\t\n\t@Test\n\tvoid shouldReturn5() {\n\t\t//given\n\t\tint number = 3;\n\t\tint expectedResult = 5;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n\t\n\t@Test\n\tvoid shouldReturnNegative1() {\n\t\t//given\n\t\tint number = 4;\n\t\tint expectedResult = -1;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n\t\n\t@Test\n\tvoid shouldReturn19() {\n\t\t//given\n\t\tint number = 17;\n\t\tint expectedResult = 19;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass TwinPrimeTest {\n\n    @Test\n    void shouldReturn7() {\n        // given\n        int number = 5;\n        int expectedResult = 7;\n\n        // when\n        int actualResult = TwinPrime.getTwinPrime(number);\n\n        // then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void shouldReturn5() {\n        // given\n        int number = 3;\n        int expectedResult = 5;\n\n        // when\n        int actualResult = TwinPrime.getTwinPrime(number);\n\n        // then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void shouldReturnNegative1() {\n        // given\n        int number = 4;\n        int expectedResult = -1;\n\n        // when\n        int actualResult = TwinPrime.getTwinPrime(number);\n\n        // then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void shouldReturn19() {\n        // given\n        int number = 17;\n        int expectedResult = 19;\n\n        // when\n        int actualResult = TwinPrime.getTwinPrime(number);\n\n        // then\n        assertEquals(expectedResult, actualResult);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/CRC16.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/CRC16Test.java",
        "product_old_content": "package com.thealgorithms.others;\n\n/**\n * Generates a crc16 checksum for a given string \n */\npublic class CRC16 {\n\n    public static void main(String[] args) {\n        System.out.println(crc16(\"Hello World!\"));\n    }\n\n\tpublic static String crc16(String message) {\n\t\tint crc = 0xFFFF; // initial value\n\t\tint polynomial = 0x1021; // 0001 0000 0010 0001 (0, 5, 12)\n\t\tbyte[] bytes = message.getBytes();\n\n\t\tfor (byte b : bytes) {\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tboolean bit = ((b >> (7 - i) & 1) == 1);\n\t\t\t\tboolean c15 = ((crc >> 15 & 1) == 1);\n\t\t\t\tcrc <<= 1;\n\t\t\t\tif (c15 ^ bit)\n\t\t\t\t\tcrc ^= polynomial;\n\t\t\t}\n\t\t}\n\t\tcrc &= 0xffff;\n\t\treturn Integer.toHexString(crc).toUpperCase();\n\t}\n}",
        "product_new_content": "package com.thealgorithms.others;\n\n/**\n * Generates a crc16 checksum for a given string\n */\npublic class CRC16 {\n\n    public static void main(String[] args) {\n        System.out.println(crc16(\"Hello World!\"));\n    }\n\n    public static String crc16(String message) {\n        int crc = 0xFFFF; // initial value\n        int polynomial = 0x1021; // 0001 0000 0010 0001 (0, 5, 12)\n        byte[] bytes = message.getBytes();\n\n        for (byte b : bytes) {\n            for (int i = 0; i < 8; i++) {\n                boolean bit = ((b >> (7 - i) & 1) == 1);\n                boolean c15 = ((crc >> 15 & 1) == 1);\n                crc <<= 1;\n                if (c15 ^ bit) crc ^= polynomial;\n            }\n        }\n        crc &= 0xffff;\n        return Integer.toHexString(crc).toUpperCase();\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass CRC16Test {\n\n    CRC16 crc = new CRC16();\n\n    @Test\n    void testCRC16() {\n        // given\n        String textToCRC16 = \"hacktoberfest!\";\n\n        // when\n        String resultCRC16 = crc.crc16(textToCRC16); // Algorithm CRC16-CCITT-FALSE\n\n        // then\n        assertEquals(\"10FC\", resultCRC16);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass CRC16Test {\n\n    CRC16 crc = new CRC16();\n\n    @Test\n    void testCRC16() {\n        // given\n        String textToCRC16 = \"hacktoberfest!\";\n\n        // when\n        String resultCRC16 = crc.crc16(textToCRC16); // Algorithm CRC16-CCITT-FALSE\n\n        // then\n        assertEquals(\"10FC\", resultCRC16);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/Conway.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/ConwayTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.*;\n\npublic class Conway {\n\n    /*\n     * This class will generate the conway sequence also known as the look and say sequence.\n     * To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n     *1 is read off as \"one 1\" or 11.\n     *11 is read off as \"two 1s\" or 21.\n     *21 is read off as \"one 2, one 1\" or 1211.\n     *1211 is read off as \"one 1, one 2, two 1s\" or 111221.\n     *111221 is read off as \"three 1s, two 2s, one 1\" or 312211.\n     * https://en.wikipedia.org/wiki/Look-and-say_sequence\n     * */\n\n    private static final StringBuilder builder = new StringBuilder();\n\n    protected static List<String> generateList(String originalString, int maxIteration) {\n        List<String> numbers = new ArrayList<>();\n        for(int i=0; i<maxIteration; i++) {\n            originalString = generateNextElement(originalString);\n            numbers.add(originalString);\n        }\n        return numbers;\n    }\n\n\n    public static String generateNextElement(String originalString) {\n        builder.setLength(0);\n        String[] stp = originalString.split(\"(?<=(.))(?!\\\\1)\");\n        Arrays.stream(stp).forEach(s -> builder.append(s.length()).append(s.charAt(0)));\n        return builder.toString();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.*;\n\npublic class Conway {\n\n    /*\n     * This class will generate the conway sequence also known as the look and say sequence.\n     * To generate a member of the sequence from the previous member, read off the digits of the\n     *previous member, counting the number of digits in groups of the same digit. For example: 1 is\n     *read off as \"one 1\" or 11. 11 is read off as \"two 1s\" or 21. 21 is read off as \"one 2, one 1\"\n     *or 1211. 1211 is read off as \"one 1, one 2, two 1s\" or 111221. 111221 is read off as \"three\n     *1s, two 2s, one 1\" or 312211. https://en.wikipedia.org/wiki/Look-and-say_sequence\n     * */\n\n    private static final StringBuilder builder = new StringBuilder();\n\n    protected static List<String> generateList(String originalString, int maxIteration) {\n        List<String> numbers = new ArrayList<>();\n        for (int i = 0; i < maxIteration; i++) {\n            originalString = generateNextElement(originalString);\n            numbers.add(originalString);\n        }\n        return numbers;\n    }\n\n    public static String generateNextElement(String originalString) {\n        builder.setLength(0);\n        String[] stp = originalString.split(\"(?<=(.))(?!\\\\1)\");\n        Arrays.stream(stp).forEach(s -> builder.append(s.length()).append(s.charAt(0)));\n        return builder.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ConwayTest {\n    @Test\n    public void testGenerateWith1(){\n        assertEquals(\"31131211131221\", Conway.generateList(\"1\", 8).get(7));\n    }\n\n    @Test\n    public void testGenerateWith123456(){\n        assertEquals(\"13211321322113311213212312311211131122211213211331121321122112133221123113112221131112212211131221121321131211132221123113112221131112311332211211131221131211132211121312211231131112311211232221143113112221131112311332111213122112311311123112112322211531131122211311123113321112131221123113111231121123222116\", Conway.generateList(\"123456\", 20).get(11));\n    }\n\n    @Test\n    public void testGenerateWith1A1Z3E1R1T3G1F1D2E1S1C(){\n        assertEquals(\"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211A311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211Z111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312113221133211322112211213322112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133112132123222113221321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211R311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211T111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312113221133211322112211213322112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133112132123222113221321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211G311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211F311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211D111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211S311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211C\", Conway.generateList(\"1A1Z3E1R1T3G1F1D2E1S1C\", 20).get(19));\n    }\n\n    @Test\n    public void testGenerateNextElementWith1(){\n        assertEquals(\"11\", Conway.generateNextElement(\"1\"));\n    }\n\n    @Test\n    public void testGenerateNextElementWith123456(){\n        assertEquals(\"111213141516\", Conway.generateNextElement(\"123456\"));\n    }\n\n    @Test\n    public void testGenerateNextElementWith1A1Z3E1R1T3G1F1D2E1S1C(){\n        assertEquals(\"111A111Z131E111R111T131G111F111D121E111S111C\", Conway.generateNextElement(\"1A1Z3E1R1T3G1F1D2E1S1C\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ConwayTest {\n    @Test\n    public void testGenerateWith1() {\n        assertEquals(\"31131211131221\", Conway.generateList(\"1\", 8).get(7));\n    }\n\n    @Test\n    public void testGenerateWith123456() {\n        assertEquals(\n            \"13211321322113311213212312311211131122211213211331121321122112133221123113112221131112212211131221121321131211132221123113112221131112311332211211131221131211132211121312211231131112311211232221143113112221131112311332111213122112311311123112112322211531131122211311123113321112131221123113111231121123222116\",\n            Conway.generateList(\"123456\", 20).get(11));\n    }\n\n    @Test\n    public void testGenerateWith1A1Z3E1R1T3G1F1D2E1S1C() {\n        assertEquals(\n            \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211A311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211Z111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312113221133211322112211213322112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133112132123222113221321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211R311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211T111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312113221133211322112211213322112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133112132123222113221321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211G311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211F311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211D111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211S311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211C\",\n            Conway.generateList(\"1A1Z3E1R1T3G1F1D2E1S1C\", 20).get(19));\n    }\n\n    @Test\n    public void testGenerateNextElementWith1() {\n        assertEquals(\"11\", Conway.generateNextElement(\"1\"));\n    }\n\n    @Test\n    public void testGenerateNextElementWith123456() {\n        assertEquals(\"111213141516\", Conway.generateNextElement(\"123456\"));\n    }\n\n    @Test\n    public void testGenerateNextElementWith1A1Z3E1R1T3G1F1D2E1S1C() {\n        assertEquals(\"111A111Z131E111R111T131G111F111D121E111S111C\",\n            Conway.generateNextElement(\"1A1Z3E1R1T3G1F1D2E1S1C\"));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/LineSweep.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/LineSweepTest.java",
        "product_old_content": "package com.thealgorithms.others;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/* Line Sweep algorithm can be used to solve range problems by first sorting the list of ranges\n * by the start value of the range in non-decreasing order and doing a \"sweep\" through the number\n * line(x-axis) by incrementing the start point by 1 and decrementing the end point+1 by 1 on the\n * number line.\n * An overlapping range is defined as (StartA <= EndB) AND (EndA >= StartB)\n * References\n * https://en.wikipedia.org/wiki/Sweep_line_algorithm\n * https://en.wikipedia.org/wiki/De_Morgan%27s_laws>\n */\npublic class LineSweep {\n\n    /**  Find Maximum end point\n     *   param = ranges : Array of range[start,end]\n     *   return Maximum Endpoint\n     */\n    public static int FindMaximumEndPoint (int[][]ranges){\n         Arrays.sort(ranges, Comparator.comparingInt(a->a[1]));\n         return ranges[ranges.length-1][1];\n     }\n\n    /**  Find if any ranges overlap\n     *   param = ranges : Array of range[start,end]\n     *   return true if overlap exists false otherwise.\n     */\n    public static boolean isOverlap(int[][] ranges) {\n\n        int maximumEndPoint = FindMaximumEndPoint(ranges);\n        Arrays.sort(ranges, Comparator.comparingInt(a->a[0]));\n        int[] numberLine = new int[maximumEndPoint+2];\n        for (int[] range : ranges) {\n\n            int start = range[0];\n            int end = range[1];\n\n            numberLine[start] += 1;\n            numberLine[end+1] -= 1;\n        }\n\n        int current = 0;\n        int overlaps = 0;\n        for (int num : numberLine) {\n            current += num;\n            overlaps = Math.max(overlaps, current);\n        }\n        return overlaps >1 ;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/* Line Sweep algorithm can be used to solve range problems by first sorting the list of ranges\n * by the start value of the range in non-decreasing order and doing a \"sweep\" through the number\n * line(x-axis) by incrementing the start point by 1 and decrementing the end point+1 by 1 on the\n * number line.\n * An overlapping range is defined as (StartA <= EndB) AND (EndA >= StartB)\n * References\n * https://en.wikipedia.org/wiki/Sweep_line_algorithm\n * https://en.wikipedia.org/wiki/De_Morgan%27s_laws>\n */\npublic class LineSweep {\n\n    /**\n     * Find Maximum end point\n     *   param = ranges : Array of range[start,end]\n     *   return Maximum Endpoint\n     */\n    public static int FindMaximumEndPoint(int[][] ranges) {\n        Arrays.sort(ranges, Comparator.comparingInt(a -> a[1]));\n        return ranges[ranges.length - 1][1];\n    }\n\n    /**\n     * Find if any ranges overlap\n     *   param = ranges : Array of range[start,end]\n     *   return true if overlap exists false otherwise.\n     */\n    public static boolean isOverlap(int[][] ranges) {\n\n        int maximumEndPoint = FindMaximumEndPoint(ranges);\n        Arrays.sort(ranges, Comparator.comparingInt(a -> a[0]));\n        int[] numberLine = new int[maximumEndPoint + 2];\n        for (int[] range : ranges) {\n\n            int start = range[0];\n            int end = range[1];\n\n            numberLine[start] += 1;\n            numberLine[end + 1] -= 1;\n        }\n\n        int current = 0;\n        int overlaps = 0;\n        for (int num : numberLine) {\n            current += num;\n            overlaps = Math.max(overlaps, current);\n        }\n        return overlaps > 1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\npublic class LineSweepTest {\n\n\n    @Test\n    void testForOverlap(){\n        int[][]arr = {{0,10},{7,20},{15,24}};\n        assertTrue(LineSweep.isOverlap(arr));\n    }\n\n    @Test\n    void testForNoOverlap(){\n        int[][]arr = {{0,10},{11,20},{21,24}};\n        assertFalse(LineSweep.isOverlap(arr));\n    }\n    @Test\n    void testForOverlapWhenEndAEqualsStartBAndViceVersa(){\n        int[][]arr = {{0,10},{10,20},{21,24}};\n        assertTrue(LineSweep.isOverlap(arr));\n    }\n    @Test\n    void testForMaximumEndPoint(){\n        int[][]arr = {{10,20},{1,100},{14,16},{1,8}};\n        assertEquals(100,LineSweep.FindMaximumEndPoint(arr));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\npublic class LineSweepTest {\n\n    @Test\n    void testForOverlap() {\n        int[][] arr = {{0, 10}, {7, 20}, {15, 24}};\n        assertTrue(LineSweep.isOverlap(arr));\n    }\n\n    @Test\n    void testForNoOverlap() {\n        int[][] arr = {{0, 10}, {11, 20}, {21, 24}};\n        assertFalse(LineSweep.isOverlap(arr));\n    }\n    @Test\n    void testForOverlapWhenEndAEqualsStartBAndViceVersa() {\n        int[][] arr = {{0, 10}, {10, 20}, {21, 24}};\n        assertTrue(LineSweep.isOverlap(arr));\n    }\n    @Test\n    void testForMaximumEndPoint() {\n        int[][] arr = {{10, 20}, {1, 100}, {14, 16}, {1, 8}};\n        assertEquals(100, LineSweep.FindMaximumEndPoint(arr));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/LowestBasePalindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/LowestBasePalindromeTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @brief Class for finding the lowest base in which a given integer is a palindrome.\n     cf. https://oeis.org/A016026\n */\nfinal public class LowestBasePalindrome {\n    private LowestBasePalindrome() {\n    }\n\n    private static void checkBase(int base) {\n        if (base <= 1) {\n            throw new IllegalArgumentException(\"base must be greater than 1.\");\n        }\n    }\n\n    private static void checkNumber(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"number must be nonnegative.\");\n        }\n    }\n\n    /**\n     * @brief computes the representation of the input number in given base\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return the list containing the digits of the input number in the given base, the most significant digit is at the end of the array\n     */\n    public static ArrayList<Integer> computeDigitsInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n        var result = new ArrayList<Integer>();\n        while (number > 0) {\n            result.add(number % base);\n            number /= base;\n        }\n        return result;\n    }\n\n    /**\n     * @brief checks if the input array is a palindrome\n     * @brief list the input array\n     * @return true, if the input array is a palindrome, false otherwise\n     */\n    public static boolean isPalindromic(ArrayList<Integer> list) {\n        for (int pos = 0; pos < list.size()/2; ++pos) {\n            if(list.get(pos) != list.get(list.size()-1-pos)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @brief checks if representation of the input number in given base is a palindrome\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return true, if the input number represented in the given base is a palindrome, false otherwise\n     */\n    public static boolean isPalindromicInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n\n        if (number <= 1) {\n            return true;\n        }\n\n        if (number % base == 0) {\n            // the last digit of number written in base is 0\n            return false;\n        }\n\n        return isPalindromic(computeDigitsInBase(number, base));\n    }\n\n    /**\n     * @brief finds the smallest base for which the representation of the input number is a palindrome\n     * @param number the input number\n     * @exception IllegalArgumentException number is negative\n     * @return the smallest base for which the representation of the input number is a palindrome\n     */\n    public static int lowestBasePalindrome(int number) {\n        int base = 2;\n        while(!isPalindromicInBase(number, base)) {\n            ++base;\n        }\n        return base;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @brief Class for finding the lowest base in which a given integer is a palindrome.\n     cf. https://oeis.org/A016026\n */\nfinal public class LowestBasePalindrome {\n    private LowestBasePalindrome() {\n    }\n\n    private static void checkBase(int base) {\n        if (base <= 1) {\n            throw new IllegalArgumentException(\"base must be greater than 1.\");\n        }\n    }\n\n    private static void checkNumber(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"number must be nonnegative.\");\n        }\n    }\n\n    /**\n     * @brief computes the representation of the input number in given base\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return the list containing the digits of the input number in the given base, the most\n     *     significant digit is at the end of the array\n     */\n    public static ArrayList<Integer> computeDigitsInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n        var result = new ArrayList<Integer>();\n        while (number > 0) {\n            result.add(number % base);\n            number /= base;\n        }\n        return result;\n    }\n\n    /**\n     * @brief checks if the input array is a palindrome\n     * @brief list the input array\n     * @return true, if the input array is a palindrome, false otherwise\n     */\n    public static boolean isPalindromic(ArrayList<Integer> list) {\n        for (int pos = 0; pos < list.size() / 2; ++pos) {\n            if (list.get(pos) != list.get(list.size() - 1 - pos)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @brief checks if representation of the input number in given base is a palindrome\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return true, if the input number represented in the given base is a palindrome, false\n     *     otherwise\n     */\n    public static boolean isPalindromicInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n\n        if (number <= 1) {\n            return true;\n        }\n\n        if (number % base == 0) {\n            // the last digit of number written in base is 0\n            return false;\n        }\n\n        return isPalindromic(computeDigitsInBase(number, base));\n    }\n\n    /**\n     * @brief finds the smallest base for which the representation of the input number is a\n     * palindrome\n     * @param number the input number\n     * @exception IllegalArgumentException number is negative\n     * @return the smallest base for which the representation of the input number is a palindrome\n     */\n    public static int lowestBasePalindrome(int number) {\n        int base = 2;\n        while (!isPalindromicInBase(number, base)) {\n            ++base;\n        }\n        return base;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LowestBasePalindromeTest {\n    @Test\n    public void testIsPalindromicPositive() {\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>()));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 2, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2))));\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicInBasePositive() {\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(1, 190));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(0, 11));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(10101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(23, 22));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(1010, 10));\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(123, 10));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForNegativeNumbers() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> LowestBasePalindrome.isPalindromicInBase(-1, 5)\n        );\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForWrongBases() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> LowestBasePalindrome.isPalindromicInBase(10, 1)\n        );\n    }\n\n    @Test\n    public void testLowestBasePalindrome() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 2);\n        testCases.put(1, 2);\n        testCases.put(2, 3);\n        testCases.put(3, 2);\n        testCases.put(10, 3);\n        testCases.put(11, 10);\n        testCases.put(15, 2);\n        testCases.put(39, 12);\n        testCases.put(44, 10);\n        testCases.put(58, 28);\n        testCases.put(69, 22);\n        testCases.put(79, 78);\n        testCases.put(87, 28);\n        testCases.put(90, 14);\n        testCases.put(5591, 37);\n        testCases.put(5895, 130);\n        testCases.put(9950, 198);\n        testCases.put(9974, 4986);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(LowestBasePalindrome.lowestBasePalindrome(tc.getKey()), tc.getValue());\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\npublic class LowestBasePalindromeTest {\n    @Test\n    public void testIsPalindromicPositive() {\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>()));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 1))));\n        assertTrue(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1))));\n        assertTrue(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 2, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicNegative() {\n        assertFalse(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2))));\n        assertFalse(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicInBasePositive() {\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(1, 190));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(0, 11));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(10101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(23, 22));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(1010, 10));\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(123, 10));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForNegativeNumbers() {\n        assertThrows(\n            IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(-1, 5));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForWrongBases() {\n        assertThrows(\n            IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(10, 1));\n    }\n\n    @Test\n    public void testLowestBasePalindrome() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 2);\n        testCases.put(1, 2);\n        testCases.put(2, 3);\n        testCases.put(3, 2);\n        testCases.put(10, 3);\n        testCases.put(11, 10);\n        testCases.put(15, 2);\n        testCases.put(39, 12);\n        testCases.put(44, 10);\n        testCases.put(58, 28);\n        testCases.put(69, 22);\n        testCases.put(79, 78);\n        testCases.put(87, 28);\n        testCases.put(90, 14);\n        testCases.put(5591, 37);\n        testCases.put(5895, 130);\n        testCases.put(9950, 198);\n        testCases.put(9974, 4986);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(LowestBasePalindrome.lowestBasePalindrome(tc.getKey()), tc.getValue());\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/PasswordGen.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/PasswordGenTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Creates a random password from ASCII letters Given password length bounds\n *\n * @author AKS1996\n * @date 2017.10.25\n */\nclass PasswordGen {\n\n    public static void main(String[] args) {\n        String password = generatePassword(8, 16);\n        System.out.print(\"Password: \" + password);\n    }\n\n    static String generatePassword(int min_length, int max_length) {\n        Random random = new Random();\n\n        String upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        String lower = \"abcdefghijklmnopqrstuvwxyz\";\n        String numbers = \"0123456789\";\n        String specialChars = \"!@#$%^&*(){}?\";\n\n        String allChars = upper + lower + numbers + specialChars;\n\n        List<Character> letters = new ArrayList<Character>();\n        for (char c : allChars.toCharArray()) {\n            letters.add(c);\n        }\n\n        // Inbuilt method to randomly shuffle a elements of a list\n        Collections.shuffle(letters);\n        StringBuilder password = new StringBuilder();\n\n        // Note that size of the password is also random\n        for (\n            int i = random.nextInt(max_length - min_length) + min_length;\n            i > 0;\n            --i\n        ) {\n            password.append(letters.get(random.nextInt(letters.size())));\n        }\n\n        return password.toString();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Creates a random password from ASCII letters Given password length bounds\n *\n * @author AKS1996\n * @date 2017.10.25\n */\nclass PasswordGen {\n\n    public static void main(String[] args) {\n        String password = generatePassword(8, 16);\n        System.out.print(\"Password: \" + password);\n    }\n\n    static String generatePassword(int min_length, int max_length) {\n        Random random = new Random();\n\n        String upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        String lower = \"abcdefghijklmnopqrstuvwxyz\";\n        String numbers = \"0123456789\";\n        String specialChars = \"!@#$%^&*(){}?\";\n\n        String allChars = upper + lower + numbers + specialChars;\n\n        List<Character> letters = new ArrayList<Character>();\n        for (char c : allChars.toCharArray()) {\n            letters.add(c);\n        }\n\n        // Inbuilt method to randomly shuffle a elements of a list\n        Collections.shuffle(letters);\n        StringBuilder password = new StringBuilder();\n\n        // Note that size of the password is also random\n        for (int i = random.nextInt(max_length - min_length) + min_length; i > 0; --i) {\n            password.append(letters.get(random.nextInt(letters.size())));\n        }\n\n        return password.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PasswordGenTest {\n\n    @Test\n    public void failGenerationWithSameMinMaxLengthTest() {\n        int length = 10;\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                PasswordGen.generatePassword(length, length);\n            }\n        );\n    }\n\n    @Test\n    public void generateOneCharacterPassword() {\n        String tempPassword = PasswordGen.generatePassword(1, 2);\n        assertTrue(tempPassword.length() == 1);\n    }\n\n    @Test\n    public void failGenerationWithMinLengthSmallerThanMaxLengthTest() {\n        int minLength = 10;\n        int maxLength = 5;\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                PasswordGen.generatePassword(minLength, maxLength);\n            }\n        );\n    }\n\n    @Test\n    public void generatePasswordNonEmptyTest() {\n        String tempPassword = PasswordGen.generatePassword(8, 16);\n        assertTrue(tempPassword.length() != 0);\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PasswordGenTest {\n\n    @Test\n    public void failGenerationWithSameMinMaxLengthTest() {\n        int length = 10;\n        assertThrows(IllegalArgumentException.class,\n            () -> { PasswordGen.generatePassword(length, length); });\n    }\n\n    @Test\n    public void generateOneCharacterPassword() {\n        String tempPassword = PasswordGen.generatePassword(1, 2);\n        assertTrue(tempPassword.length() == 1);\n    }\n\n    @Test\n    public void failGenerationWithMinLengthSmallerThanMaxLengthTest() {\n        int minLength = 10;\n        int maxLength = 5;\n        assertThrows(IllegalArgumentException.class,\n            () -> { PasswordGen.generatePassword(minLength, maxLength); });\n    }\n\n    @Test\n    public void generatePasswordNonEmptyTest() {\n        String tempPassword = PasswordGen.generatePassword(8, 16);\n        assertTrue(tempPassword.length() != 0);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/cn/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/cn/HammingDistanceTest.java",
        "product_old_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n    public int getHammingDistanceBetweenBits(\n        String senderBits,\n        String receiverBits\n    ) {\n        if (senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\n                \"Sender and Receiver bits should be same\"\n            );\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < senderData.length; i++) {\n            totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if (totalErrorBitCount == 0) {\n            System.out.println(\"No Error bit in data segments\");\n        } else {\n            System.out.println(\"Total Error bit count \" + totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n    public int getHammingDistanceBetweenBits(String senderBits, String receiverBits) {\n        if (senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\"Sender and Receiver bits should be same\");\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < senderData.length; i++) {\n            totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if (totalErrorBitCount == 0) {\n            System.out.println(\"No Error bit in data segments\");\n        } else {\n            System.out.println(\"Total Error bit count \" + totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n    void initialize() {\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits() {\n        String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        String senderBits = \"10010101101010000100110100\", receiverBits =\n            \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                int answer = hd.getHammingDistanceBetweenBits(\n                    senderBits,\n                    receiverBits\n                );\n            }\n        );\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String senderBits = \"10010101101010000100110100\", receiverBits =\n            \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n}",
        "test_new_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n    void initialize() {\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits() {\n        String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        String senderBits = \"10010101101010000100110100\",\n               receiverBits = \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class,\n            () -> { int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String senderBits = \"10010101101010000100110100\",\n               receiverBits = \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/FCFSScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/FCFSSchedulingTest.java",
        "product_old_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\n\nimport java.util.List;\n\n/**\n * Non-pre-emptive First Come First Serve scheduling. This can be understood here - https://www.scaler.com/topics/first-come-first-serve/\n */\npublic class FCFSScheduling {\n\n    private List<ProcessDetails> processes;\n\n    FCFSScheduling(final List<ProcessDetails> processes) {\n        this.processes = processes;\n    }\n\n    public void scheduleProcesses() {\n        evaluateWaitingTime();\n        evaluateTurnAroundTime();\n    }\n\n    private void evaluateWaitingTime() {\n        int processesNumber = processes.size();\n\n        if(processesNumber == 0) {\n            return;\n        }\n\n        int waitingTime = 0;\n        int burstTime = processes.get(0).getBurstTime();\n\n        processes.get(0).setWaitingTime(waitingTime); // for the first process, waiting time will be 0.\n\n        for(int i=1; i<processesNumber; i++) {\n           processes.get(i).setWaitingTime(waitingTime + burstTime);\n           waitingTime = processes.get(i).getWaitingTime();\n           burstTime = processes.get(i).getBurstTime();\n        }\n    }\n\n    private void evaluateTurnAroundTime() {\n        for(int i=0; i<processes.size(); i++) {\n            processes.get(i).setTurnAroundTimeTime(processes.get(i).getBurstTime() + processes.get(i).getWaitingTime());\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.List;\n\n/**\n * Non-pre-emptive First Come First Serve scheduling. This can be understood here -\n * https://www.scaler.com/topics/first-come-first-serve/\n */\npublic class FCFSScheduling {\n\n    private List<ProcessDetails> processes;\n\n    FCFSScheduling(final List<ProcessDetails> processes) {\n        this.processes = processes;\n    }\n\n    public void scheduleProcesses() {\n        evaluateWaitingTime();\n        evaluateTurnAroundTime();\n    }\n\n    private void evaluateWaitingTime() {\n        int processesNumber = processes.size();\n\n        if (processesNumber == 0) {\n            return;\n        }\n\n        int waitingTime = 0;\n        int burstTime = processes.get(0).getBurstTime();\n\n        processes.get(0).setWaitingTime(\n            waitingTime); // for the first process, waiting time will be 0.\n\n        for (int i = 1; i < processesNumber; i++) {\n            processes.get(i).setWaitingTime(waitingTime + burstTime);\n            waitingTime = processes.get(i).getWaitingTime();\n            burstTime = processes.get(i).getBurstTime();\n        }\n    }\n\n    private void evaluateTurnAroundTime() {\n        for (int i = 0; i < processes.size(); i++) {\n            processes.get(i).setTurnAroundTimeTime(\n                processes.get(i).getBurstTime() + processes.get(i).getWaitingTime());\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class FCFSSchedulingTest {\n\n\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForFCFS();\n        final FCFSScheduling fcfsScheduling = new FCFSScheduling(processes); // for sending to FCFS\n\n        fcfsScheduling.scheduleProcesses();\n\n        assertEquals(3, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(0, processes.get(0).getWaitingTime());\n        assertEquals(10, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(10, processes.get(1).getWaitingTime());\n        assertEquals(15, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(15, processes.get(2).getWaitingTime());\n        assertEquals(23, processes.get(2).getTurnAroundTimeTime());\n\n    }\n\n    private List<ProcessDetails> addProcessesForFCFS() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 10);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 5);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 8);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n\n        return processDetails;\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class FCFSSchedulingTest {\n\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForFCFS();\n        final FCFSScheduling fcfsScheduling = new FCFSScheduling(processes); // for sending to FCFS\n\n        fcfsScheduling.scheduleProcesses();\n\n        assertEquals(3, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(0, processes.get(0).getWaitingTime());\n        assertEquals(10, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(10, processes.get(1).getWaitingTime());\n        assertEquals(15, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(15, processes.get(2).getWaitingTime());\n        assertEquals(23, processes.get(2).getTurnAroundTimeTime());\n    }\n\n    private List<ProcessDetails> addProcessesForFCFS() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 10);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 5);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 8);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n\n        return processDetails;\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/RRScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/RRSchedulingTest.java",
        "product_old_content": "/**\n * @author Md Asif Joardar\n */\n\npackage com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/**\n * The Round-robin scheduling algorithm is a kind of preemptive First come, First Serve CPU Scheduling algorithm.\n * This can be understood here - https://www.scaler.com/topics/round-robin-scheduling-in-os/\n */\n\npublic class RRScheduling {\n    private List<ProcessDetails> processes;\n    private int quantumTime;\n\n    RRScheduling(final List<ProcessDetails> processes, int quantumTime) {\n        this.processes = processes;\n        this.quantumTime = quantumTime;\n    }\n\n    public void scheduleProcesses() {\n        evaluateTurnAroundTime();\n        evaluateWaitingTime();\n    }\n\n    private void evaluateTurnAroundTime() {\n        int processesNumber = processes.size();\n\n        if(processesNumber == 0) {\n            return;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        int currentTime = 0; // keep track of the time\n        int completed = 0;\n        int[] mark = new int[processesNumber];\n        Arrays.fill(mark, 0);\n        mark[0] = 1;\n\n        // a copy of burst time to store the remaining burst time\n        int[] remainingBurstTime = new int[processesNumber];\n        for (int i = 0; i < processesNumber; i++) {\n            remainingBurstTime[i] = processes.get(i).getBurstTime();\n        }\n\n        while (completed != processesNumber){\n            int index = queue.poll();\n\n            if(remainingBurstTime[index] == processes.get(index).getBurstTime()){\n                currentTime = Math.max(currentTime, processes.get(index).getArrivalTime());\n            }\n\n            if(remainingBurstTime[index] - quantumTime > 0){\n                remainingBurstTime[index] -= quantumTime;\n                currentTime += quantumTime;\n            } else {\n                currentTime += remainingBurstTime[index];\n                processes.get(index).setTurnAroundTimeTime(currentTime - processes.get(index).getArrivalTime());\n                completed++;\n                remainingBurstTime[index]=0;\n            }\n\n            // If some process has arrived when this process was executing, insert them into the queue.\n            for (int i=1; i < processesNumber; i++){\n                if(remainingBurstTime[i] > 0 && processes.get(i).getArrivalTime() <= currentTime && mark[i] == 0){\n                    mark[i]=1;\n                    queue.add(i);\n                }\n            }\n\n            // If the current process has burst time remaining, push the process into the queue again.\n            if(remainingBurstTime[index] > 0) queue.add(index);\n\n            // If the queue is empty, pick the first process from the list that is not completed.\n            if(queue.isEmpty()){\n                for (int i=1; i<processesNumber; i++){\n                    if (remainingBurstTime[i] > 0){\n                        mark[i] = 1;\n                        queue.add(i);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    private void evaluateWaitingTime() {\n        for (int i = 0; i < processes.size(); i++)\n            processes.get(i).setWaitingTime(processes.get(i).getTurnAroundTimeTime() - processes.get(i).getBurstTime());\n    }\n}",
        "product_new_content": "/**\n * @author Md Asif Joardar\n */\n\npackage com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/**\n * The Round-robin scheduling algorithm is a kind of preemptive First come, First Serve CPU\n * Scheduling algorithm. This can be understood here -\n * https://www.scaler.com/topics/round-robin-scheduling-in-os/\n */\n\npublic class RRScheduling {\n    private List<ProcessDetails> processes;\n    private int quantumTime;\n\n    RRScheduling(final List<ProcessDetails> processes, int quantumTime) {\n        this.processes = processes;\n        this.quantumTime = quantumTime;\n    }\n\n    public void scheduleProcesses() {\n        evaluateTurnAroundTime();\n        evaluateWaitingTime();\n    }\n\n    private void evaluateTurnAroundTime() {\n        int processesNumber = processes.size();\n\n        if (processesNumber == 0) {\n            return;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        int currentTime = 0; // keep track of the time\n        int completed = 0;\n        int[] mark = new int[processesNumber];\n        Arrays.fill(mark, 0);\n        mark[0] = 1;\n\n        // a copy of burst time to store the remaining burst time\n        int[] remainingBurstTime = new int[processesNumber];\n        for (int i = 0; i < processesNumber; i++) {\n            remainingBurstTime[i] = processes.get(i).getBurstTime();\n        }\n\n        while (completed != processesNumber) {\n            int index = queue.poll();\n\n            if (remainingBurstTime[index] == processes.get(index).getBurstTime()) {\n                currentTime = Math.max(currentTime, processes.get(index).getArrivalTime());\n            }\n\n            if (remainingBurstTime[index] - quantumTime > 0) {\n                remainingBurstTime[index] -= quantumTime;\n                currentTime += quantumTime;\n            } else {\n                currentTime += remainingBurstTime[index];\n                processes.get(index).setTurnAroundTimeTime(\n                    currentTime - processes.get(index).getArrivalTime());\n                completed++;\n                remainingBurstTime[index] = 0;\n            }\n\n            // If some process has arrived when this process was executing, insert them into the\n            // queue.\n            for (int i = 1; i < processesNumber; i++) {\n                if (remainingBurstTime[i] > 0 && processes.get(i).getArrivalTime() <= currentTime\n                    && mark[i] == 0) {\n                    mark[i] = 1;\n                    queue.add(i);\n                }\n            }\n\n            // If the current process has burst time remaining, push the process into the queue\n            // again.\n            if (remainingBurstTime[index] > 0) queue.add(index);\n\n            // If the queue is empty, pick the first process from the list that is not completed.\n            if (queue.isEmpty()) {\n                for (int i = 1; i < processesNumber; i++) {\n                    if (remainingBurstTime[i] > 0) {\n                        mark[i] = 1;\n                        queue.add(i);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    private void evaluateWaitingTime() {\n        for (int i = 0; i < processes.size(); i++)\n            processes.get(i).setWaitingTime(\n                processes.get(i).getTurnAroundTimeTime() - processes.get(i).getBurstTime());\n    }\n}",
        "test_old_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass RRSchedulingTest {\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForRR();\n        final RRScheduling rrScheduling = new RRScheduling(processes, 4); // for sending to RR with quantum value 4\n\n        rrScheduling.scheduleProcesses();\n\n        assertEquals(6, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(12, processes.get(0).getWaitingTime());\n        assertEquals(17, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(16, processes.get(1).getWaitingTime());\n        assertEquals(22, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(6, processes.get(2).getWaitingTime());\n        assertEquals(9, processes.get(2).getTurnAroundTimeTime());\n\n        assertEquals(\"P4\", processes.get(3).getProcessId());\n        assertEquals(8, processes.get(3).getWaitingTime());\n        assertEquals(9, processes.get(3).getTurnAroundTimeTime());\n\n        assertEquals(\"P5\", processes.get(4).getProcessId());\n        assertEquals(15, processes.get(4).getWaitingTime());\n        assertEquals(20, processes.get(4).getTurnAroundTimeTime());\n\n        assertEquals(\"P6\", processes.get(5).getProcessId());\n        assertEquals(11, processes.get(5).getWaitingTime());\n        assertEquals(15, processes.get(5).getTurnAroundTimeTime());\n\n    }\n\n    private List<ProcessDetails> addProcessesForRR() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 5);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 6);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 3);\n        final ProcessDetails process4 = new ProcessDetails(\"P4\", 3, 1);\n        final ProcessDetails process5 = new ProcessDetails(\"P5\", 4, 5);\n        final ProcessDetails process6 = new ProcessDetails(\"P6\", 6, 4);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n        processDetails.add(process4);\n        processDetails.add(process5);\n        processDetails.add(process6);\n\n        return processDetails;\n    }\n}",
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\nclass RRSchedulingTest {\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForRR();\n        final RRScheduling rrScheduling\n            = new RRScheduling(processes, 4); // for sending to RR with quantum value 4\n\n        rrScheduling.scheduleProcesses();\n\n        assertEquals(6, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(12, processes.get(0).getWaitingTime());\n        assertEquals(17, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(16, processes.get(1).getWaitingTime());\n        assertEquals(22, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(6, processes.get(2).getWaitingTime());\n        assertEquals(9, processes.get(2).getTurnAroundTimeTime());\n\n        assertEquals(\"P4\", processes.get(3).getProcessId());\n        assertEquals(8, processes.get(3).getWaitingTime());\n        assertEquals(9, processes.get(3).getTurnAroundTimeTime());\n\n        assertEquals(\"P5\", processes.get(4).getProcessId());\n        assertEquals(15, processes.get(4).getWaitingTime());\n        assertEquals(20, processes.get(4).getTurnAroundTimeTime());\n\n        assertEquals(\"P6\", processes.get(5).getProcessId());\n        assertEquals(11, processes.get(5).getWaitingTime());\n        assertEquals(15, processes.get(5).getTurnAroundTimeTime());\n    }\n\n    private List<ProcessDetails> addProcessesForRR() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 5);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 6);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 3);\n        final ProcessDetails process4 = new ProcessDetails(\"P4\", 3, 1);\n        final ProcessDetails process5 = new ProcessDetails(\"P5\", 4, 5);\n        final ProcessDetails process6 = new ProcessDetails(\"P6\", 6, 4);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n        processDetails.add(process4);\n        processDetails.add(process5);\n        processDetails.add(process6);\n\n        return processDetails;\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/SJFScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/SJFSchedulingTest.java",
        "product_old_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\n\nimport java.util.ArrayList;\n\n/**\n * Implementation of Shortest Job First Algorithm: The algorithm allows the waiting process with the minimal burst time to be executed first.\n * see more here: https://www.guru99.com/shortest-job-first-sjf-scheduling.html\n */\n\npublic class SJFScheduling {\n    protected ArrayList<ProcessDetails> processes;\n    protected ArrayList<String>schedule ;\n\n    /**\n     * a simple constructor\n     * @param processes a list of processes the user wants to schedule\n     *  it also sorts the processes based on the time of their arrival\n     */\n    SJFScheduling(final ArrayList<ProcessDetails> processes) {\n        this.processes = processes;\n        schedule=new ArrayList<>();\n        sortByArrivalTime();\n    }\nprotected void sortByArrivalTime() {\n        int size=processes.size(),i,j;\n        ProcessDetails temp;\n        for(i=0;i<size;i++)\n        {\n            for(j=i+1;j<size-1;j++)\n            {\n                if(processes.get(j).getArrivalTime()>processes.get(j+1).getArrivalTime())\n                {\n                    temp=processes.get(j);\n                    processes.set(j,processes.get(j+1));\n                    processes.set(j+1,temp);\n                }\n            }\n        }\n\n}\n\n    /**\n     * this functions returns the order of the executions\n     */\n\n    public void scheduleProcesses() {\n        ArrayList<ProcessDetails> ready=new ArrayList<>();\n\n        int size = processes.size(),runtime,time=0;\n        int executed=0,j,k=0;\n        ProcessDetails running;\n\n        if (size == 0) {\n            return;\n        }\n\n\n        while(executed<size)\n        {\n            while(k<size && processes.get(k).getArrivalTime()<=time)//here we find the processes that have arrived.\n            {\n                ready.add(processes.get(k));\n                k++;\n            }\n\n            running=findShortestJob(ready);\n            if(running==null)\n            {\n                  time++;\n            }\n            else {\n                  runtime = running.getBurstTime();\n                  for (j = 0; j < runtime; j++) {\n                      time++;}\n                  schedule.add(running.getProcessId());\n                  ready.remove(running);\n                  executed++;\n                  }\n        }\n\n\n    }\n\n    /**\n     * this function evaluates the shortest job of all the ready processes (based on  a process burst time)\n     * @param ReadyProcesses an array list of ready processes\n     * @return returns the process' with the shortest burst time OR NULL if there are no ready processes\n     */\n    private ProcessDetails findShortestJob(ArrayList<ProcessDetails> ReadyProcesses) {\n        if (ReadyProcesses.isEmpty()){\n            return null;\n        }\n        int i,size = ReadyProcesses.size();\n        int minBurstTime = ReadyProcesses.get(0).getBurstTime(), temp, positionOfShortestJob = 0;\n\n\n        for (i = 1; i < size; i++) {\n            temp = ReadyProcesses.get(i).getBurstTime();\n            if (minBurstTime > temp  ) {\n                minBurstTime = temp;\n                positionOfShortestJob = i;\n            }\n        }\n\n        return ReadyProcesses.get(positionOfShortestJob);\n    }\n\n\n\n\n\n    }",
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\n\n/**\n * Implementation of Shortest Job First Algorithm: The algorithm allows the waiting process with the\n * minimal burst time to be executed first. see more here:\n * https://www.guru99.com/shortest-job-first-sjf-scheduling.html\n */\n\npublic class SJFScheduling {\n    protected ArrayList<ProcessDetails> processes;\n    protected ArrayList<String> schedule;\n\n    /**\n     * a simple constructor\n     * @param processes a list of processes the user wants to schedule\n     *  it also sorts the processes based on the time of their arrival\n     */\n    SJFScheduling(final ArrayList<ProcessDetails> processes) {\n        this.processes = processes;\n        schedule = new ArrayList<>();\n        sortByArrivalTime();\n    }\n    protected void sortByArrivalTime() {\n        int size = processes.size(), i, j;\n        ProcessDetails temp;\n        for (i = 0; i < size; i++) {\n            for (j = i + 1; j < size - 1; j++) {\n                if (processes.get(j).getArrivalTime() > processes.get(j + 1).getArrivalTime()) {\n                    temp = processes.get(j);\n                    processes.set(j, processes.get(j + 1));\n                    processes.set(j + 1, temp);\n                }\n            }\n        }\n    }\n\n    /**\n     * this functions returns the order of the executions\n     */\n\n    public void scheduleProcesses() {\n        ArrayList<ProcessDetails> ready = new ArrayList<>();\n\n        int size = processes.size(), runtime, time = 0;\n        int executed = 0, j, k = 0;\n        ProcessDetails running;\n\n        if (size == 0) {\n            return;\n        }\n\n        while (executed < size) {\n            while (k < size\n                && processes.get(k).getArrivalTime()\n                    <= time) // here we find the processes that have arrived.\n            {\n                ready.add(processes.get(k));\n                k++;\n            }\n\n            running = findShortestJob(ready);\n            if (running == null) {\n                time++;\n            } else {\n                runtime = running.getBurstTime();\n                for (j = 0; j < runtime; j++) {\n                    time++;\n                }\n                schedule.add(running.getProcessId());\n                ready.remove(running);\n                executed++;\n            }\n        }\n    }\n\n    /**\n     * this function evaluates the shortest job of all the ready processes (based on  a process\n     * burst time)\n     * @param ReadyProcesses an array list of ready processes\n     * @return returns the process' with the shortest burst time OR NULL if there are no ready\n     *     processes\n     */\n    private ProcessDetails findShortestJob(ArrayList<ProcessDetails> ReadyProcesses) {\n        if (ReadyProcesses.isEmpty()) {\n            return null;\n        }\n        int i, size = ReadyProcesses.size();\n        int minBurstTime = ReadyProcesses.get(0).getBurstTime(), temp, positionOfShortestJob = 0;\n\n        for (i = 1; i < size; i++) {\n            temp = ReadyProcesses.get(i).getBurstTime();\n            if (minBurstTime > temp) {\n                minBurstTime = temp;\n                positionOfShortestJob = i;\n            }\n        }\n\n        return ReadyProcesses.get(positionOfShortestJob);\n    }\n}",
        "test_old_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SJFSchedulingTest {\n    private  ArrayList<ProcessDetails> process;\n    void initialisation0()\n    {\n\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,6));\n        process.add(new ProcessDetails(\"2\",1,2));\n    }\n    void initialisation1()\n    {\n\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,6));\n        process.add(new ProcessDetails(\"2\",1,2));\n        process.add(new ProcessDetails(\"3\",4 ,3));\n        process.add(new ProcessDetails(\"4\",3,1));\n        process.add(new ProcessDetails(\"5\",6 ,4));\n        process.add(new ProcessDetails(\"6\",5,5));\n    }\n\n    void initialisation2()\n    {\n\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,3));\n        process.add(new ProcessDetails(\"2\",1,2));\n        process.add(new ProcessDetails(\"3\",2 ,1));\n\n    }\n    void initialisation3(){\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,3));\n        process.add(new ProcessDetails(\"2\",5,2));\n        process.add(new ProcessDetails(\"3\",9 ,1));\n    }\n    @Test\n    void constructor()\n    {\n        initialisation0();\n        SJFScheduling a=new SJFScheduling(process);\n         assertEquals( 6,a.processes.get(0).getBurstTime());\n        assertEquals( 2,a.processes.get(1).getBurstTime());\n    }\n\n     @Test\n    void sort()\n    {\n        initialisation1();\n        SJFScheduling a=new SJFScheduling(process);\n        a.sortByArrivalTime();\n        assertEquals(\"1\",a.processes.get(0).getProcessId());\n        assertEquals(\"2\",a.processes.get(1).getProcessId());\n        assertEquals(\"3\",a.processes.get(3).getProcessId());\n        assertEquals(\"4\",a.processes.get(2).getProcessId());\n        assertEquals(\"5\",a.processes.get(5).getProcessId());\n        assertEquals(\"6\",a.processes.get(4).getProcessId());\n\n    }\n\n    @Test\n    void scheduling(){\n        initialisation1();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"4\"  , a.schedule.get(1));\n        assertEquals(  \"2\" , a.schedule.get(2));\n        assertEquals(  \"3\" , a.schedule.get(3));\n        assertEquals(\"5\"   , a.schedule.get(4));\n        assertEquals(   \"6\", a.schedule.get(5));\n\n\n    }\n\n    @Test\n    void schedulingOf_TwoProcesses(){\n        initialisation0();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"2\"  , a.schedule.get(1));\n    }\n\n    @Test\n    void schedulingOfA_ShortestJobArrivingLast(){\n        initialisation2();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"3\"  , a.schedule.get(1));\n        assertEquals( \"2\"  , a.schedule.get(2));\n    }\n    @Test\n    void scheduling_WithProcessesNotComingBackToBack(){\n        initialisation3();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"2\"  , a.schedule.get(1));\n        assertEquals( \"3\"  , a.schedule.get(2));\n    }\n    @Test\n    void schedulingOf_nothing(){\n        process=new ArrayList<>();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertTrue( a.schedule.isEmpty());\n\n    }\n}",
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\n\nclass SJFSchedulingTest {\n    private ArrayList<ProcessDetails> process;\n    void initialisation0() {\n\n        process = new ArrayList<>();\n        process.add(new ProcessDetails(\"1\", 0, 6));\n        process.add(new ProcessDetails(\"2\", 1, 2));\n    }\n    void initialisation1() {\n\n        process = new ArrayList<>();\n        process.add(new ProcessDetails(\"1\", 0, 6));\n        process.add(new ProcessDetails(\"2\", 1, 2));\n        process.add(new ProcessDetails(\"3\", 4, 3));\n        process.add(new ProcessDetails(\"4\", 3, 1));\n        process.add(new ProcessDetails(\"5\", 6, 4));\n        process.add(new ProcessDetails(\"6\", 5, 5));\n    }\n\n    void initialisation2() {\n\n        process = new ArrayList<>();\n        process.add(new ProcessDetails(\"1\", 0, 3));\n        process.add(new ProcessDetails(\"2\", 1, 2));\n        process.add(new ProcessDetails(\"3\", 2, 1));\n    }\n    void initialisation3() {\n        process = new ArrayList<>();\n        process.add(new ProcessDetails(\"1\", 0, 3));\n        process.add(new ProcessDetails(\"2\", 5, 2));\n        process.add(new ProcessDetails(\"3\", 9, 1));\n    }\n    @Test\n    void constructor() {\n        initialisation0();\n        SJFScheduling a = new SJFScheduling(process);\n        assertEquals(6, a.processes.get(0).getBurstTime());\n        assertEquals(2, a.processes.get(1).getBurstTime());\n    }\n\n    @Test\n    void sort() {\n        initialisation1();\n        SJFScheduling a = new SJFScheduling(process);\n        a.sortByArrivalTime();\n        assertEquals(\"1\", a.processes.get(0).getProcessId());\n        assertEquals(\"2\", a.processes.get(1).getProcessId());\n        assertEquals(\"3\", a.processes.get(3).getProcessId());\n        assertEquals(\"4\", a.processes.get(2).getProcessId());\n        assertEquals(\"5\", a.processes.get(5).getProcessId());\n        assertEquals(\"6\", a.processes.get(4).getProcessId());\n    }\n\n    @Test\n    void scheduling() {\n        initialisation1();\n        SJFScheduling a = new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals(\"1\", a.schedule.get(0));\n        assertEquals(\"4\", a.schedule.get(1));\n        assertEquals(\"2\", a.schedule.get(2));\n        assertEquals(\"3\", a.schedule.get(3));\n        assertEquals(\"5\", a.schedule.get(4));\n        assertEquals(\"6\", a.schedule.get(5));\n    }\n\n    @Test\n    void schedulingOf_TwoProcesses() {\n        initialisation0();\n        SJFScheduling a = new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals(\"1\", a.schedule.get(0));\n        assertEquals(\"2\", a.schedule.get(1));\n    }\n\n    @Test\n    void schedulingOfA_ShortestJobArrivingLast() {\n        initialisation2();\n        SJFScheduling a = new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals(\"1\", a.schedule.get(0));\n        assertEquals(\"3\", a.schedule.get(1));\n        assertEquals(\"2\", a.schedule.get(2));\n    }\n    @Test\n    void scheduling_WithProcessesNotComingBackToBack() {\n        initialisation3();\n        SJFScheduling a = new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals(\"1\", a.schedule.get(0));\n        assertEquals(\"2\", a.schedule.get(1));\n        assertEquals(\"3\", a.schedule.get(2));\n    }\n    @Test\n    void schedulingOf_nothing() {\n        process = new ArrayList<>();\n        SJFScheduling a = new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertTrue(a.schedule.isEmpty());\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BinarySearch2dArrayTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n            T[] array,\n            T key,\n            int left,\n            int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.printf(\n                \"Should be found: %d. Found %d at index %d. An array length %d%n\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.printf(\"Found by system method at an index: %d. Is equal: %b%n\", toCheck, toCheck == atIndex);\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream.generate(() -> r.nextInt(maxElement))\n                                 .limit(size)\n                                 .sorted()\n                                 .boxed()\n                                 .toArray(Integer[] ::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.printf(\"Should be found: %d. Found %d at index %d. An array length %d%n\",\n            shouldBeFound, integers[atIndex], atIndex, size);\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.printf(\n            \"Found by system method at an index: %d. Is equal: %b%n\", toCheck, toCheck == atIndex);\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1, -1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = {{1, 2, 3, 4}};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is\n        // fulfilled.\n        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length / 2 - 1][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class,\n            () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1, -1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = {{1, 2, 3, 4}};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is\n        // fulfilled.\n        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length / 2 - 1][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch2dArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BinarySearch2dArrayTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\n/*\nTo apply this method, the provided array must be strictly sorted. In this method, two pointers, one at 0th row\n& the other at the last row are taken & the searching is done on the basis of the middle element of the middle column.\nIf that element is equal to target, its coordinates are returned, else if it is smaller than the target, the rows above\nthat element are ignored (because the elements above it will also be smaller than the target), else that element is\ngreater than the target, then the rows below it are ignored.\n */\npublic class BinarySearch2dArray {\n\n    static int[] BinarySearch(int[][] arr, int target) {\n        int rowCount = arr.length, colCount = arr[0].length;\n\n        if (rowCount == 1) {\n            return binarySearch(arr, target, 0, 0, colCount);\n        }\n\n        int startRow = 0, endRow = rowCount - 1, midCol = colCount / 2;\n\n        while (startRow < endRow - 1) {\n            int midRow = startRow + (endRow - startRow) / 2; //getting the index of middle row\n\n            if (arr[midRow][midCol] == target) {\n                return new int[] { midRow, midCol };\n            } else if (arr[midRow][midCol] < target) startRow =\n                midRow; else endRow = midRow;\n        }\n        /*\n            if the above search fails to find the target element, these conditions will be used to find the target\n            element, which further uses the binary search algorithm in the places which were left unexplored.\n             */\n        if (arr[startRow][midCol] == target) return new int[] {\n            startRow,\n            midCol,\n        };\n\n        if (arr[endRow][midCol] == target) return new int[] { endRow, midCol };\n\n        if (target <= arr[startRow][midCol - 1]) return binarySearch(\n            arr,\n            target,\n            startRow,\n            0,\n            midCol - 1\n        );\n\n        if (\n            target >= arr[startRow][midCol + 1] &&\n            target <= arr[startRow][colCount - 1]\n        ) return binarySearch(arr, target, startRow, midCol + 1, colCount - 1);\n\n        if (target <= arr[endRow][midCol - 1]) return binarySearch(\n            arr,\n            target,\n            endRow,\n            0,\n            midCol - 1\n        ); else return binarySearch(\n            arr,\n            target,\n            endRow,\n            midCol + 1,\n            colCount - 1\n        );\n    }\n\n    static int[] binarySearch(\n        int[][] arr,\n        int target,\n        int row,\n        int colStart,\n        int colEnd\n    ) {\n        while (colStart <= colEnd) {\n            int midIndex = colStart + (colEnd - colStart) / 2;\n\n            if (arr[row][midIndex] == target) return new int[] {\n                row,\n                midIndex,\n            }; else if (arr[row][midIndex] < target) colStart =\n                midIndex + 1; else colEnd = midIndex - 1;\n        }\n\n        return new int[] { -1, -1 };\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\n/*\nTo apply this method, the provided array must be strictly sorted. In this method, two pointers, one\nat 0th row & the other at the last row are taken & the searching is done on the basis of the middle\nelement of the middle column. If that element is equal to target, its coordinates are returned, else\nif it is smaller than the target, the rows above that element are ignored (because the elements\nabove it will also be smaller than the target), else that element is greater than the target, then\nthe rows below it are ignored.\n */\npublic class BinarySearch2dArray {\n\n    static int[] BinarySearch(int[][] arr, int target) {\n        int rowCount = arr.length, colCount = arr[0].length;\n\n        if (rowCount == 1) {\n            return binarySearch(arr, target, 0, 0, colCount);\n        }\n\n        int startRow = 0, endRow = rowCount - 1, midCol = colCount / 2;\n\n        while (startRow < endRow - 1) {\n            int midRow = startRow + (endRow - startRow) / 2; // getting the index of middle row\n\n            if (arr[midRow][midCol] == target) {\n                return new int[] {midRow, midCol};\n            } else if (arr[midRow][midCol] < target)\n                startRow = midRow;\n            else\n                endRow = midRow;\n        }\n        /*\n            if the above search fails to find the target element, these conditions will be used to\n           find the target element, which further uses the binary search algorithm in the places\n           which were left unexplored.\n             */\n        if (arr[startRow][midCol] == target)\n            return new int[] {\n                startRow,\n                midCol,\n            };\n\n        if (arr[endRow][midCol] == target) return new int[] {endRow, midCol};\n\n        if (target <= arr[startRow][midCol - 1])\n            return binarySearch(arr, target, startRow, 0, midCol - 1);\n\n        if (target >= arr[startRow][midCol + 1] && target <= arr[startRow][colCount - 1])\n            return binarySearch(arr, target, startRow, midCol + 1, colCount - 1);\n\n        if (target <= arr[endRow][midCol - 1])\n            return binarySearch(arr, target, endRow, 0, midCol - 1);\n        else\n            return binarySearch(arr, target, endRow, midCol + 1, colCount - 1);\n    }\n\n    static int[] binarySearch(int[][] arr, int target, int row, int colStart, int colEnd) {\n        while (colStart <= colEnd) {\n            int midIndex = colStart + (colEnd - colStart) / 2;\n\n            if (arr[row][midIndex] == target)\n                return new int[] {\n                    row,\n                    midIndex,\n                };\n            else if (arr[row][midIndex] < target)\n                colStart = midIndex + 1;\n            else\n                colEnd = midIndex - 1;\n        }\n\n        return new int[] {-1, -1};\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterAll;\n\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 1, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 1, 3 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 0, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 0, 0 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 2, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 2, 2 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { -1, -1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = { { 1, 2, 3, 4 }};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = { { 1, 2, 3, 4, 5 }, { 6, 7, 8, 9, 10 }, { 11, 12, 13, 14, 15} };\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is fulfilled.\n        assertEquals(arr[arr.length/2][arr[0].length/2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length/2-1][arr[0].length/2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.*;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1, 3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0, 0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2, 2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1, -1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with input arrays consisting only of one row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestOneRow() {\n        int[][] arr = {{1, 2, 3, 4}};\n        int target = 2;\n\n        // Assert that the requirement, that the array only has one row, is fulfilled.\n        assertEquals(arr.length, 1);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle of the input.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetInMiddle() {\n        int[][] arr = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};\n        int target = 8;\n        // Assert that the requirement, that the target is in the middle row and middle column, is\n        // fulfilled.\n        assertEquals(arr[arr.length / 2][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with the target in the middle column,\n     * in the row above the middle row.\n     */\n    @Test\n    public void BinarySearch2dArrayTestTargetAboveMiddleRowInMiddleColumn() {\n        int[][] arr = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        int target = 3;\n\n        // Assert that the requirement, that he target is in the middle column,\n        // in an array with an even number of columns, and on the row \"above\" the middle row.\n        assertEquals(arr[0].length % 2, 0);\n        assertEquals(arr[arr.length / 2 - 1][arr[0].length / 2], target);\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    /**\n     * Test if the method works with an empty array.\n     */\n    @Test\n    public void BinarySearch2dArrayTestEmptyArray() {\n        int[][] arr = {};\n        int target = 5;\n\n        // Assert that an empty array is not valid input for the method.\n        assertThrows(ArrayIndexOutOfBoundsException.class,\n            () -> BinarySearch2dArray.BinarySearch(arr, target));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/searches/HowManyTimesRotated.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/HowManyTimesRotatedTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/*\n    Problem Statement: \n    Given an array, find out how many times it has to been rotated \n    from its initial sorted position.\n    Input-Output:\n    Eg. [11,12,15,18,2,5,6,8]\n    It has been rotated: 4 times\n    (One rotation means putting the first element to the end)\n    Note: The array cannot contain duplicates\n\n    Logic: \n    The position of the minimum element will give the number of times the array has been rotated\n    from its initial sorted position.\n    Eg. For [2,5,6,8,11,12,15,18], 1 rotation gives [5,6,8,11,12,15,18,2], 2 rotations [6,8,11,12,15,18,2,5] and so on.\n    Finding the minimum element will take O(N) time but, we can  use Binary Search to find the mimimum element, we can reduce the complexity to O(log N).\n    If we look at the rotated array, to identify the minimum element (say a[i]), we observe that  a[i-1]>a[i]<a[i+1].\n\n    Some other test cases: \n    1. [1,2,3,4] Number of rotations: 0 or 4(Both valid)\n    2. [15,17,2,3,5] Number of rotations: 3\n */\nclass HowManyTimesRotated {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        System.out.println(\n            \"The array has been rotated \" + rotated(a) + \" times\"\n        );\n        sc.close();\n    }\n\n    public static int rotated(int[] a) {\n        int low = 0;\n        int high = a.length - 1;\n        int mid = 0; // low + (high-low)/2 = (low + high)/2\n\n        while (low <= high) {\n            mid = low + (high - low) / 2;\n\n            if (a[mid] < a[mid - 1] && a[mid] < a[mid + 1]) {\n                break;\n            } else if (a[mid] > a[mid - 1] && a[mid] < a[mid + 1]) {\n                high = mid + 1;\n            } else if (a[mid] > a[mid - 1] && a[mid] > a[mid + 1]) {\n                low = mid - 1;\n            }\n        }\n\n        return mid;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/*\n    Problem Statement:\n    Given an array, find out how many times it has to been rotated\n    from its initial sorted position.\n    Input-Output:\n    Eg. [11,12,15,18,2,5,6,8]\n    It has been rotated: 4 times\n    (One rotation means putting the first element to the end)\n    Note: The array cannot contain duplicates\n\n    Logic:\n    The position of the minimum element will give the number of times the array has been rotated\n    from its initial sorted position.\n    Eg. For [2,5,6,8,11,12,15,18], 1 rotation gives [5,6,8,11,12,15,18,2], 2 rotations\n   [6,8,11,12,15,18,2,5] and so on. Finding the minimum element will take O(N) time but, we can  use\n   Binary Search to find the mimimum element, we can reduce the complexity to O(log N). If we look\n   at the rotated array, to identify the minimum element (say a[i]), we observe that\n   a[i-1]>a[i]<a[i+1].\n\n    Some other test cases:\n    1. [1,2,3,4] Number of rotations: 0 or 4(Both valid)\n    2. [15,17,2,3,5] Number of rotations: 3\n */\nclass HowManyTimesRotated {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        System.out.println(\"The array has been rotated \" + rotated(a) + \" times\");\n        sc.close();\n    }\n\n    public static int rotated(int[] a) {\n        int low = 0;\n        int high = a.length - 1;\n        int mid = 0; // low + (high-low)/2 = (low + high)/2\n\n        while (low <= high) {\n            mid = low + (high - low) / 2;\n\n            if (a[mid] < a[mid - 1] && a[mid] < a[mid + 1]) {\n                break;\n            } else if (a[mid] > a[mid - 1] && a[mid] < a[mid + 1]) {\n                high = mid + 1;\n            } else if (a[mid] > a[mid - 1] && a[mid] > a[mid + 1]) {\n                low = mid - 1;\n            }\n        }\n\n        return mid;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HowManyTimesRotatedTest {\n\n    @Test\n    public void testHowManyTimesRotated() {\n        int[] arr1 = {5, 1,2,3,4};\n        assertEquals(1, HowManyTimesRotated.rotated(arr1));\n        int[] arr2 = {15,17,2,3,5};\n        assertEquals(2, HowManyTimesRotated.rotated(arr2));\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HowManyTimesRotatedTest {\n\n    @Test\n    public void testHowManyTimesRotated() {\n        int[] arr1 = {5, 1, 2, 3, 4};\n        assertEquals(1, HowManyTimesRotated.rotated(arr1));\n        int[] arr2 = {15, 17, 2, 3, 5};\n        assertEquals(2, HowManyTimesRotated.rotated(arr2));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/searches/QuickSelect.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/QuickSelectTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/**\n * An implementation of the Quickselect algorithm as described\n * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>.\n */\npublic final class QuickSelect {\n\n    /**\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\n     * be at index n if the list was sorted.\n     * <p>\n     * Calling this function might change the order of elements in {@code list}.\n     *\n     * @param list the list of elements\n     * @param n    the index\n     * @param <T>  the type of list elements\n     * @return the n-th largest element in the list\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\n     *                                   the number of elements in the list\n     * @throws IllegalArgumentException  if the list is empty\n     * @throws NullPointerException      if {@code list} is null\n     */\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\n        Objects.requireNonNull(list, \"The list of elements must not be null.\");\n\n        if (list.size() == 0) {\n            String msg = \"The list of elements must not be empty.\";\n            throw new IllegalArgumentException(msg);\n        }\n\n        if (n < 0) {\n            String msg = \"The index must not be negative.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        if (n >= list.size()) {\n            String msg = \"The index must be less than the number of elements.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        int index = selectIndex(list, n);\n        return list.get(index);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n        List<T> list,\n        int n\n    ) {\n        return selectIndex(list, 0, list.size() - 1, n);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n        List<T> list,\n        int left,\n        int right,\n        int n\n    ) {\n        while (true) {\n            if (left == right) return left;\n            int pivotIndex = pivot(list, left, right);\n            pivotIndex = partition(list, left, right, pivotIndex, n);\n            if (n == pivotIndex) {\n                return n;\n            } else if (n < pivotIndex) {\n                right = pivotIndex - 1;\n            } else {\n                left = pivotIndex + 1;\n            }\n        }\n    }\n\n    private static <T extends Comparable<T>> int partition(\n        List<T> list,\n        int left,\n        int right,\n        int pivotIndex,\n        int n\n    ) {\n        T pivotValue = list.get(pivotIndex);\n        Collections.swap(list, pivotIndex, right);\n        int storeIndex = left;\n\n        for (int i = left; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) < 0) {\n                Collections.swap(list, storeIndex, i);\n                storeIndex++;\n            }\n        }\n\n        int storeIndexEq = storeIndex;\n\n        for (int i = storeIndex; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) == 0) {\n                Collections.swap(list, storeIndexEq, i);\n                storeIndexEq++;\n            }\n        }\n\n        Collections.swap(list, right, storeIndexEq);\n\n        return (n < storeIndex) ? storeIndex : Math.min(n, storeIndexEq);\n    }\n\n    private static <T extends Comparable<T>> int pivot(\n        List<T> list,\n        int left,\n        int right\n    ) {\n        if (right - left < 5) {\n            return partition5(list, left, right);\n        }\n\n        for (int i = left; i < right; i += 5) {\n            int subRight = i + 4;\n            if (subRight > right) {\n                subRight = right;\n            }\n            int median5 = partition5(list, i, subRight);\n            int rightIndex = left + (i - left) / 5;\n            Collections.swap(list, median5, rightIndex);\n        }\n\n        int mid = (right - left) / 10 + left + 1;\n        int rightIndex = left + (right - left) / 5;\n        return selectIndex(list, left, rightIndex, mid);\n    }\n\n    private static <T extends Comparable<T>> int partition5(\n        List<T> list,\n        int left,\n        int right\n    ) {\n        List<T> ts = list.subList(left, right);\n        ts.sort(Comparator.naturalOrder());\n        return (left + right) >>> 1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/**\n * An implementation of the Quickselect algorithm as described\n * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>.\n */\npublic final class QuickSelect {\n\n    /**\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\n     * be at index n if the list was sorted.\n     * <p>\n     * Calling this function might change the order of elements in {@code list}.\n     *\n     * @param list the list of elements\n     * @param n    the index\n     * @param <T>  the type of list elements\n     * @return the n-th largest element in the list\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\n     *                                   the number of elements in the list\n     * @throws IllegalArgumentException  if the list is empty\n     * @throws NullPointerException      if {@code list} is null\n     */\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\n        Objects.requireNonNull(list, \"The list of elements must not be null.\");\n\n        if (list.size() == 0) {\n            String msg = \"The list of elements must not be empty.\";\n            throw new IllegalArgumentException(msg);\n        }\n\n        if (n < 0) {\n            String msg = \"The index must not be negative.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        if (n >= list.size()) {\n            String msg = \"The index must be less than the number of elements.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        int index = selectIndex(list, n);\n        return list.get(index);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {\n        return selectIndex(list, 0, list.size() - 1, n);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n        List<T> list, int left, int right, int n) {\n        while (true) {\n            if (left == right) return left;\n            int pivotIndex = pivot(list, left, right);\n            pivotIndex = partition(list, left, right, pivotIndex, n);\n            if (n == pivotIndex) {\n                return n;\n            } else if (n < pivotIndex) {\n                right = pivotIndex - 1;\n            } else {\n                left = pivotIndex + 1;\n            }\n        }\n    }\n\n    private static <T extends Comparable<T>> int partition(\n        List<T> list, int left, int right, int pivotIndex, int n) {\n        T pivotValue = list.get(pivotIndex);\n        Collections.swap(list, pivotIndex, right);\n        int storeIndex = left;\n\n        for (int i = left; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) < 0) {\n                Collections.swap(list, storeIndex, i);\n                storeIndex++;\n            }\n        }\n\n        int storeIndexEq = storeIndex;\n\n        for (int i = storeIndex; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) == 0) {\n                Collections.swap(list, storeIndexEq, i);\n                storeIndexEq++;\n            }\n        }\n\n        Collections.swap(list, right, storeIndexEq);\n\n        return (n < storeIndex) ? storeIndex : Math.min(n, storeIndexEq);\n    }\n\n    private static <T extends Comparable<T>> int pivot(List<T> list, int left, int right) {\n        if (right - left < 5) {\n            return partition5(list, left, right);\n        }\n\n        for (int i = left; i < right; i += 5) {\n            int subRight = i + 4;\n            if (subRight > right) {\n                subRight = right;\n            }\n            int median5 = partition5(list, i, subRight);\n            int rightIndex = left + (i - left) / 5;\n            Collections.swap(list, median5, rightIndex);\n        }\n\n        int mid = (right - left) / 10 + left + 1;\n        int rightIndex = left + (right - left) / 5;\n        return selectIndex(list, left, rightIndex, mid);\n    }\n\n    private static <T extends Comparable<T>> int partition5(List<T> list, int left, int right) {\n        List<T> ts = list.subList(left, right);\n        ts.sort(Comparator.naturalOrder());\n        return (left + right) >>> 1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport org.junit.jupiter.api.Test;\n\nclass QuickSelectTest {\n\n    @Test\n    void quickSelectMinimumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int minimum = QuickSelect.select(elements, 0);\n        assertEquals(42, minimum);\n    }\n\n    @Test\n    void quickSelectMinimumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n\n        assertEquals(42, minimum1);\n        assertEquals(42, minimum2);\n    }\n\n    @Test\n    void quickSelectMinimumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n        int minimum3 = QuickSelect.select(elements3, 0);\n\n        assertEquals(1, minimum1);\n        assertEquals(1, minimum2);\n        assertEquals(1, minimum3);\n    }\n\n    @Test\n    void quickSelectMinimumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, 0);\n        int expected = elements.stream().min(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMaximumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int maximum = QuickSelect.select(elements, 0);\n        assertEquals(42, maximum);\n    }\n\n    @Test\n    void quickSelectMaximumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int maximum1 = QuickSelect.select(elements1, 1);\n        int maximum2 = QuickSelect.select(elements2, 1);\n\n        assertEquals(90, maximum1);\n        assertEquals(90, maximum2);\n    }\n\n    @Test\n    void quickSelectMaximumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int maximum1 = QuickSelect.select(elements1, 2);\n        int maximum2 = QuickSelect.select(elements2, 2);\n        int maximum3 = QuickSelect.select(elements3, 2);\n\n        assertEquals(3, maximum1);\n        assertEquals(3, maximum2);\n        assertEquals(3, maximum3);\n    }\n\n    @Test\n    void quickSelectMaximumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, NUM_RND_ELEMENTS - 1);\n        int expected = elements.stream().max(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMedianOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int median = QuickSelect.select(elements, 0);\n        assertEquals(42, median);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int median1 = QuickSelect.select(elements1, 1);\n        int median2 = QuickSelect.select(elements2, 1);\n        int median3 = QuickSelect.select(elements3, 1);\n\n        assertEquals(2, median1);\n        assertEquals(2, median2);\n        assertEquals(2, median3);\n    }\n\n    @Test\n    void quickSelectMedianOfManyElements() {\n        int medianIndex = NUM_RND_ELEMENTS / 2;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, medianIndex);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(medianIndex), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 2);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(2), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOfManyElements() {\n        int percentile30th = NUM_RND_ELEMENTS / 10 * 3;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile30th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile30th), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 6);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(6), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOfManyElements() {\n        int percentile70th = NUM_RND_ELEMENTS / 10 * 7;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile70th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile70th), actual);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeCharacters() {\n        List<Character> elements = Arrays.asList('X', 'Z', 'Y');\n        char actual = QuickSelect.select(elements, 1);\n        assertEquals(actual, 'Y');\n    }\n\n    @Test\n    void quickSelectMedianOfManyCharacters() {\n        List<Character> elements = generateRandomCharacters(NUM_RND_ELEMENTS);\n        char actual = QuickSelect.select(elements, NUM_RND_ELEMENTS / 30);\n\n        List<Character> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(NUM_RND_ELEMENTS / 30), actual);\n    }\n\n    @Test\n    void quickSelectNullList() {\n        NullPointerException exception = assertThrows(\n            NullPointerException.class,\n            () -> QuickSelect.select(null, 0)\n        );\n        String expectedMsg = \"The list of elements must not be null.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectEmptyList() {\n        List<String> objects = Collections.emptyList();\n        IllegalArgumentException exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> QuickSelect.select(objects, 0)\n        );\n        String expectedMsg = \"The list of elements must not be empty.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfLeftBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n            IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), -1)\n        );\n        String expectedMsg = \"The index must not be negative.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfRightBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n            IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), 1)\n        );\n        String expectedMsg =\n            \"The index must be less than the number of elements.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    private static final int NUM_RND_ELEMENTS = 99;\n    private static final Random RANDOM = new Random(42);\n    private static final int ASCII_A = 0x41;\n    private static final int ASCII_Z = 0x5A;\n\n    private static List<Integer> generateRandomIntegers(int n) {\n        return RANDOM.ints(n).boxed().collect(Collectors.toList());\n    }\n\n    private static List<Character> generateRandomCharacters(int n) {\n        return RANDOM\n            .ints(n, ASCII_A, ASCII_Z)\n            .mapToObj(i -> (char) i)\n            .collect(Collectors.toList());\n    }\n\n    private static <T extends Comparable<T>> List<T> getSortedCopyOfList(\n        List<T> list\n    ) {\n        return list.stream().sorted().collect(Collectors.toList());\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport org.junit.jupiter.api.Test;\n\nclass QuickSelectTest {\n\n    @Test\n    void quickSelectMinimumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int minimum = QuickSelect.select(elements, 0);\n        assertEquals(42, minimum);\n    }\n\n    @Test\n    void quickSelectMinimumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n\n        assertEquals(42, minimum1);\n        assertEquals(42, minimum2);\n    }\n\n    @Test\n    void quickSelectMinimumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n        int minimum3 = QuickSelect.select(elements3, 0);\n\n        assertEquals(1, minimum1);\n        assertEquals(1, minimum2);\n        assertEquals(1, minimum3);\n    }\n\n    @Test\n    void quickSelectMinimumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, 0);\n        int expected = elements.stream().min(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMaximumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int maximum = QuickSelect.select(elements, 0);\n        assertEquals(42, maximum);\n    }\n\n    @Test\n    void quickSelectMaximumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int maximum1 = QuickSelect.select(elements1, 1);\n        int maximum2 = QuickSelect.select(elements2, 1);\n\n        assertEquals(90, maximum1);\n        assertEquals(90, maximum2);\n    }\n\n    @Test\n    void quickSelectMaximumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int maximum1 = QuickSelect.select(elements1, 2);\n        int maximum2 = QuickSelect.select(elements2, 2);\n        int maximum3 = QuickSelect.select(elements3, 2);\n\n        assertEquals(3, maximum1);\n        assertEquals(3, maximum2);\n        assertEquals(3, maximum3);\n    }\n\n    @Test\n    void quickSelectMaximumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, NUM_RND_ELEMENTS - 1);\n        int expected = elements.stream().max(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMedianOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int median = QuickSelect.select(elements, 0);\n        assertEquals(42, median);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int median1 = QuickSelect.select(elements1, 1);\n        int median2 = QuickSelect.select(elements2, 1);\n        int median3 = QuickSelect.select(elements3, 1);\n\n        assertEquals(2, median1);\n        assertEquals(2, median2);\n        assertEquals(2, median3);\n    }\n\n    @Test\n    void quickSelectMedianOfManyElements() {\n        int medianIndex = NUM_RND_ELEMENTS / 2;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, medianIndex);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(medianIndex), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 2);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(2), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOfManyElements() {\n        int percentile30th = NUM_RND_ELEMENTS / 10 * 3;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile30th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile30th), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 6);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(6), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOfManyElements() {\n        int percentile70th = NUM_RND_ELEMENTS / 10 * 7;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile70th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile70th), actual);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeCharacters() {\n        List<Character> elements = Arrays.asList('X', 'Z', 'Y');\n        char actual = QuickSelect.select(elements, 1);\n        assertEquals(actual, 'Y');\n    }\n\n    @Test\n    void quickSelectMedianOfManyCharacters() {\n        List<Character> elements = generateRandomCharacters(NUM_RND_ELEMENTS);\n        char actual = QuickSelect.select(elements, NUM_RND_ELEMENTS / 30);\n\n        List<Character> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(NUM_RND_ELEMENTS / 30), actual);\n    }\n\n    @Test\n    void quickSelectNullList() {\n        NullPointerException exception\n            = assertThrows(NullPointerException.class, () -> QuickSelect.select(null, 0));\n        String expectedMsg = \"The list of elements must not be null.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectEmptyList() {\n        List<String> objects = Collections.emptyList();\n        IllegalArgumentException exception\n            = assertThrows(IllegalArgumentException.class, () -> QuickSelect.select(objects, 0));\n        String expectedMsg = \"The list of elements must not be empty.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfLeftBound() {\n        IndexOutOfBoundsException exception = assertThrows(IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), -1));\n        String expectedMsg = \"The index must not be negative.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfRightBound() {\n        IndexOutOfBoundsException exception = assertThrows(IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), 1));\n        String expectedMsg = \"The index must be less than the number of elements.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    private static final int NUM_RND_ELEMENTS = 99;\n    private static final Random RANDOM = new Random(42);\n    private static final int ASCII_A = 0x41;\n    private static final int ASCII_Z = 0x5A;\n\n    private static List<Integer> generateRandomIntegers(int n) {\n        return RANDOM.ints(n).boxed().collect(Collectors.toList());\n    }\n\n    private static List<Character> generateRandomCharacters(int n) {\n        return RANDOM.ints(n, ASCII_A, ASCII_Z)\n            .mapToObj(i -> (char) i)\n            .collect(Collectors.toList());\n    }\n\n    private static <T extends Comparable<T>> List<T> getSortedCopyOfList(List<T> list) {\n        return list.stream().sorted().collect(Collectors.toList());\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.MatrixSearchAlgorithm;\n\n/**\n * The search is for any array which is sorted row and column-wise too. For ex :\n * {{10, 20, 30, 40},\n *  {15, 25, 35, 45},\n *  {18, 28, 38, 48},\n *  {21, 31, 41, 51}}\n *\n * This array is sorted in both row and column manner.\n * In this two pointers are taken, the first points to the 0th row and the second one points to end column, and then the\n * element corresponding to the pointers placed in the array is compared with the target that either its equal, greater or\n * smaller than the target. If the element is equal to the target, the co-ordinates of that element is returned i.e. an\n * array of the two pointers will be returned, else if the target is greater than corresponding element then the pointer\n * pointing to the 0th row will be incremented by 1, else if the target is lesser than the corresponding element then the\n * pointer pointing to the end column will be decremented by 1. And if the element doesn't exist in the array, an array\n * {-1, -1} will be returned.\n */\npublic class RowColumnWiseSorted2dArrayBinarySearch\n  implements MatrixSearchAlgorithm {\n\n  @Override\n  public <T extends Comparable<T>> int[] find(T[][] matrix, T key) {\n    return search(matrix, key);\n  }\n\n  public static <T extends Comparable<T>> int[] search(T[][] matrix, T target) {\n    int rowPointer = 0; //The pointer at 0th row\n    int colPointer = matrix.length - 1; //The pointer at end column\n\n    while (rowPointer < matrix.length && colPointer >= 0) {\n      int comp = target.compareTo(matrix[rowPointer][colPointer]);\n\n      if (comp == 0) {\n        return new int[] { rowPointer, colPointer };\n      } else if (comp > 0) {\n        rowPointer++; //Incrementing the row pointer if the target is greater\n      } else {\n        colPointer--; //Decrementing the column pointer if the target is lesser\n      }\n    }\n    return new int[] { -1, -1 }; //The not found condition\n  }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.MatrixSearchAlgorithm;\n\n/**\n * The search is for any array which is sorted row and column-wise too. For ex :\n * {{10, 20, 30, 40},\n *  {15, 25, 35, 45},\n *  {18, 28, 38, 48},\n *  {21, 31, 41, 51}}\n *\n * This array is sorted in both row and column manner.\n * In this two pointers are taken, the first points to the 0th row and the second one points to end\n * column, and then the element corresponding to the pointers placed in the array is compared with\n * the target that either its equal, greater or smaller than the target. If the element is equal to\n * the target, the co-ordinates of that element is returned i.e. an array of the two pointers will\n * be returned, else if the target is greater than corresponding element then the pointer pointing\n * to the 0th row will be incremented by 1, else if the target is lesser than the corresponding\n * element then the pointer pointing to the end column will be decremented by 1. And if the element\n * doesn't exist in the array, an array\n * {-1, -1} will be returned.\n */\npublic class RowColumnWiseSorted2dArrayBinarySearch implements MatrixSearchAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> int[] find(T[][] matrix, T key) {\n        return search(matrix, key);\n    }\n\n    public static <T extends Comparable<T>> int[] search(T[][] matrix, T target) {\n        int rowPointer = 0; // The pointer at 0th row\n        int colPointer = matrix.length - 1; // The pointer at end column\n\n        while (rowPointer < matrix.length && colPointer >= 0) {\n            int comp = target.compareTo(matrix[rowPointer][colPointer]);\n\n            if (comp == 0) {\n                return new int[] {rowPointer, colPointer};\n            } else if (comp > 0) {\n                rowPointer++; // Incrementing the row pointer if the target is greater\n            } else {\n                colPointer--; // Decrementing the column pointer if the target is lesser\n            }\n        }\n        return new int[] {-1, -1}; // The not found condition\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RowColumnWiseSorted2dArrayBinarySearchTest {\n\n  @Test\n  public void rowColumnSorted2dArrayBinarySearchTestMiddle() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 35;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 1, 2 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArrayBinarySearchTestSide() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 48;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 2, 3 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestUpper() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 20;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 0, 1 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestUpperSide() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 40;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 0, 3 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestLower() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 31;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 3, 1 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestLowerSide() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 51;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 3, 3 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestNotFound() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 101;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { -1, -1 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RowColumnWiseSorted2dArrayBinarySearchTest {\n\n    @Test\n    public void rowColumnSorted2dArrayBinarySearchTestMiddle() {\n        Integer[][] arr = {\n            {10, 20, 30, 40},\n            {15, 25, 35, 45},\n            {18, 28, 38, 48},\n            {21, 31, 41, 51},\n        };\n        Integer target = 35;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {1, 2};\n        assertEquals(expected[0], ans[0]);\n        assertEquals(expected[1], ans[1]);\n    }\n\n    @Test\n    public void rowColumnSorted2dArrayBinarySearchTestSide() {\n        Integer[][] arr = {\n            {10, 20, 30, 40},\n            {15, 25, 35, 45},\n            {18, 28, 38, 48},\n            {21, 31, 41, 51},\n        };\n        Integer target = 48;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {2, 3};\n        assertEquals(expected[0], ans[0]);\n        assertEquals(expected[1], ans[1]);\n    }\n\n    @Test\n    public void rowColumnSorted2dArray_BinarySearchTestUpper() {\n        Integer[][] arr = {\n            {10, 20, 30, 40},\n            {15, 25, 35, 45},\n            {18, 28, 38, 48},\n            {21, 31, 41, 51},\n        };\n        Integer target = 20;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0, 1};\n        assertEquals(expected[0], ans[0]);\n        assertEquals(expected[1], ans[1]);\n    }\n\n    @Test\n    public void rowColumnSorted2dArray_BinarySearchTestUpperSide() {\n        Integer[][] arr = {\n            {10, 20, 30, 40},\n            {15, 25, 35, 45},\n            {18, 28, 38, 48},\n            {21, 31, 41, 51},\n        };\n        Integer target = 40;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0, 3};\n        assertEquals(expected[0], ans[0]);\n        assertEquals(expected[1], ans[1]);\n    }\n\n    @Test\n    public void rowColumnSorted2dArray_BinarySearchTestLower() {\n        Integer[][] arr = {\n            {10, 20, 30, 40},\n            {15, 25, 35, 45},\n            {18, 28, 38, 48},\n            {21, 31, 41, 51},\n        };\n        Integer target = 31;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3, 1};\n        assertEquals(expected[0], ans[0]);\n        assertEquals(expected[1], ans[1]);\n    }\n\n    @Test\n    public void rowColumnSorted2dArray_BinarySearchTestLowerSide() {\n        Integer[][] arr = {\n            {10, 20, 30, 40},\n            {15, 25, 35, 45},\n            {18, 28, 38, 48},\n            {21, 31, 41, 51},\n        };\n        Integer target = 51;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3, 3};\n        assertEquals(expected[0], ans[0]);\n        assertEquals(expected[1], ans[1]);\n    }\n\n    @Test\n    public void rowColumnSorted2dArray_BinarySearchTestNotFound() {\n        Integer[][] arr = {\n            {10, 20, 30, 40},\n            {15, 25, 35, 45},\n            {18, 28, 38, 48},\n            {21, 31, 41, 51},\n        };\n        Integer target = 101;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {-1, -1};\n        assertEquals(expected[0], ans[0]);\n        assertEquals(expected[1], ans[1]);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/searches/SearchInARowAndColWiseSortedMatrix.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/TestSearchInARowAndColWiseSortedMatrix.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport java.util.Arrays;\n\npublic class SearchInARowAndColWiseSortedMatrix {\n    /**\n     * Search a key in row and column wise sorted matrix\n     *\n     * @param matrix matrix to be searched\n     * @param value  Key being searched for\n     * @author Sadiul Hakim : https://github.com/sadiul-hakim\n     */\n\n    public int[] search(int[][] matrix, int value) {\n        int n = matrix.length;\n        // This variable iterates over rows\n        int i = 0;\n        // This variable iterates over columns\n        int j = n - 1;\n        int[] result = { -1, -1 };\n\n        while (i < n && j >= 0) {\n            if (matrix[i][j] == value) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n            if (value > matrix[i][j]) {\n                i++;\n            } else {\n                j--;\n            }\n\n        }\n        return result;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport java.util.Arrays;\n\npublic class SearchInARowAndColWiseSortedMatrix {\n    /**\n     * Search a key in row and column wise sorted matrix\n     *\n     * @param matrix matrix to be searched\n     * @param value  Key being searched for\n     * @author Sadiul Hakim : https://github.com/sadiul-hakim\n     */\n\n    public int[] search(int[][] matrix, int value) {\n        int n = matrix.length;\n        // This variable iterates over rows\n        int i = 0;\n        // This variable iterates over columns\n        int j = n - 1;\n        int[] result = {-1, -1};\n\n        while (i < n && j >= 0) {\n            if (matrix[i][j] == value) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n            if (value > matrix[i][j]) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class TestSearchInARowAndColWiseSortedMatrix {\n    @Test\n    public void searchItem() {\n        int[][] matrix = {\n                { 3, 4, 5, 6, 7 },\n                { 8, 9, 10, 11, 12 },\n                { 14, 15, 16, 17, 18 },\n                { 23, 24, 25, 26, 27 },\n                { 30, 31, 32, 33, 34 }\n        };\n\n        var test = new SearchInARowAndColWiseSortedMatrix();\n        int[] res = test.search(matrix, 16);\n        int[] expectedResult = { 2, 2 };\n        assertArrayEquals(expectedResult, res);\n    }\n\n    @Test\n    public void notFound() {\n        int[][] matrix = {\n                { 3, 4, 5, 6, 7 },\n                { 8, 9, 10, 11, 12 },\n                { 14, 15, 16, 17, 18 },\n                { 23, 24, 25, 26, 27 },\n                { 30, 31, 32, 33, 34 }\n        };\n\n        var test = new SearchInARowAndColWiseSortedMatrix();\n        int[] res = test.search(matrix, 96);\n        int[] expectedResult = { -1, -1 };\n        assertArrayEquals(expectedResult, res);\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class TestSearchInARowAndColWiseSortedMatrix {\n    @Test\n    public void searchItem() {\n        int[][] matrix = {{3, 4, 5, 6, 7}, {8, 9, 10, 11, 12}, {14, 15, 16, 17, 18},\n            {23, 24, 25, 26, 27}, {30, 31, 32, 33, 34}};\n\n        var test = new SearchInARowAndColWiseSortedMatrix();\n        int[] res = test.search(matrix, 16);\n        int[] expectedResult = {2, 2};\n        assertArrayEquals(expectedResult, res);\n    }\n\n    @Test\n    public void notFound() {\n        int[][] matrix = {{3, 4, 5, 6, 7}, {8, 9, 10, 11, 12}, {14, 15, 16, 17, 18},\n            {23, 24, 25, 26, 27}, {30, 31, 32, 33, 34}};\n\n        var test = new SearchInARowAndColWiseSortedMatrix();\n        int[] res = test.search(matrix, 96);\n        int[] expectedResult = {-1, -1};\n        assertArrayEquals(expectedResult, res);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\nimport java.util.*;\npublic class sortOrderAgnosticBinarySearch {\n    public static int find(int[] arr, int key){\n        int start = 0;\n        int end = arr.length-1;\n        boolean arrDescending = arr[start]>arr[end];  //checking for Array is in ascending order or descending order.\n        while(start<=end){\n            int mid = end-start/2;\n            if (arr[mid]==key){\n                return mid;\n            }\n            if(arrDescending){       // boolean is true then our array is in descending order \n                if(key<arr[mid]){\n                    start=mid+1;\n                }\n                else{\n                    end=mid-1;\n                }\n            }\n            else {         // otherwise our array is in ascending order \n                if(key>arr[mid]){\n                   start=mid+1;\n               }\n               else{\n                   end=mid-1;\n               }\n            }\n        }\n        return -1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\nimport java.util.*;\npublic class sortOrderAgnosticBinarySearch {\n    public static int find(int[] arr, int key) {\n        int start = 0;\n        int end = arr.length - 1;\n        boolean arrDescending = arr[start]\n            > arr[end]; // checking for Array is in ascending order or descending order.\n        while (start <= end) {\n            int mid = end - start / 2;\n            if (arr[mid] == key) {\n                return mid;\n            }\n            if (arrDescending) { // boolean is true then our array is in descending order\n                if (key < arr[mid]) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            } else { // otherwise our array is in ascending order\n                if (key > arr[mid]) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int[] arr = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int[] arr = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest {\n\n    @Test\n    public void testAscending() {\n        int[] arr = {1, 2, 3, 4, 5}; // for ascending order.\n        int target = 2;\n        int ans = sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted, ans);\n    }\n\n    @Test\n    public void testDescending() {\n        int[] arr = {5, 4, 3, 2, 1}; // for descending order.\n        int target = 2;\n        int ans = sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted, ans);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BeadSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BeadSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n\n//BeadSort Algorithm(wikipedia) : https://en.wikipedia.org/wiki/Bead_sort\n//BeadSort can't sort negative number, Character, String. It can sort positive number only\n\npublic class BeadSort {\n    public int[] sort(int[] unsorted) {\n    int[] sorted = new int[unsorted.length];\n    int max = 0;\n    for(int i = 0; i < unsorted.length; i++) {\n    max = Math.max(max, unsorted[i]);\n    }\n\n    char[][] grid = new char[unsorted.length][max];\n    int[] count = new int[max];\n\n    for(int i = 0; i < unsorted.length; i++) {\n        for(int j = 0; j < max; j++) {\n            grid[i][j] = '-';\n         }\n     }\n\n    for(int i = 0; i < max; i++) {\n        count[i] = 0;\n    }\n\n        for(int i = 0; i < unsorted.length; i++) {\n            int k = 0;\n            for(int j = 0; j < unsorted[i]; j++) {\n                grid[count[max - k - 1]++][k] = '*';\n                k++;\n             }\n        }\n\n        for(int i = 0; i < unsorted.length; i++) {\n            int k = 0;\n            for(int j = 0; j < max && grid[unsorted.length - 1 - i][j] == '*'; j++) {\n                k++;\n            }\n            sorted[i] = k;\n        }\n        return sorted;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n// BeadSort Algorithm(wikipedia) : https://en.wikipedia.org/wiki/Bead_sort\n// BeadSort can't sort negative number, Character, String. It can sort positive number only\n\npublic class BeadSort {\n    public int[] sort(int[] unsorted) {\n        int[] sorted = new int[unsorted.length];\n        int max = 0;\n        for (int i = 0; i < unsorted.length; i++) {\n            max = Math.max(max, unsorted[i]);\n        }\n\n        char[][] grid = new char[unsorted.length][max];\n        int[] count = new int[max];\n\n        for (int i = 0; i < unsorted.length; i++) {\n            for (int j = 0; j < max; j++) {\n                grid[i][j] = '-';\n            }\n        }\n\n        for (int i = 0; i < max; i++) {\n            count[i] = 0;\n        }\n\n        for (int i = 0; i < unsorted.length; i++) {\n            int k = 0;\n            for (int j = 0; j < unsorted[i]; j++) {\n                grid[count[max - k - 1]++][k] = '*';\n                k++;\n            }\n        }\n\n        for (int i = 0; i < unsorted.length; i++) {\n            int k = 0;\n            for (int j = 0; j < max && grid[unsorted.length - 1 - i][j] == '*'; j++) {\n                k++;\n            }\n            sorted[i] = k;\n        }\n        return sorted;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BeadSortTest {\n    //BeadSort can't sort negative number, Character, String. It can sort positive number only\n    private BeadSort beadSort = new BeadSort();\n    \n    @Test\n    public void beadSortEmptyArray() {\n        int[] inputArray = {};\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void beadSortSingleIntegerArray() {\n        int[] inputArray = { 4 };\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortNonDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 99, 27, 15, 23, 36 };\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 27, 36, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n    \n    @Test\n    public void bogoSortDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 27, 15, 23, 27, 36, 23 };\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 23, 27, 27, 36};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BeadSortTest {\n    // BeadSort can't sort negative number, Character, String. It can sort positive number only\n    private BeadSort beadSort = new BeadSort();\n\n    @Test\n    public void beadSortEmptyArray() {\n        int[] inputArray = {};\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void beadSortSingleIntegerArray() {\n        int[] inputArray = {4};\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {4};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortNonDuplicateIntegerArray() {\n        int[] inputArray = {6, 1, 99, 27, 15, 23, 36};\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 27, 36, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortDuplicateIntegerArray() {\n        int[] inputArray = {6, 1, 27, 15, 23, 27, 36, 23};\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 23, 27, 27, 36};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BogoSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BogoSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\n/**\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\npublic class BogoSort implements SortAlgorithm {\n\n    private static final Random random = new Random();\n\n    private static <T extends Comparable<T>> boolean isSorted(T[] array) {\n        for (int i = 0; i < array.length - 1; i++) {\n            if (SortUtils.less(array[i + 1], array[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Randomly shuffles the array\n    private static <T> void nextPermutation(T[] array) {\n        int length = array.length;\n\n        for (int i = 0; i < array.length; i++) {\n            int randomIndex = i + random.nextInt(length - i);\n            SortUtils.swap(array, randomIndex, i);\n        }\n    }\n\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        while (!isSorted(array)) {\n            nextPermutation(array);\n        }\n        return array;\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Integer Input\n        Integer[] integers = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n\n        BogoSort bogoSort = new BogoSort();\n\n        // print a sorted array\n        SortUtils.print(bogoSort.sort(integers));\n\n        // String Input\n        String[] strings = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n\n        SortUtils.print(bogoSort.sort(strings));\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\n/**\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\npublic class BogoSort implements SortAlgorithm {\n\n    private static final Random random = new Random();\n\n    private static <T extends Comparable<T>> boolean isSorted(T[] array) {\n        for (int i = 0; i < array.length - 1; i++) {\n            if (SortUtils.less(array[i + 1], array[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Randomly shuffles the array\n    private static <T> void nextPermutation(T[] array) {\n        int length = array.length;\n\n        for (int i = 0; i < array.length; i++) {\n            int randomIndex = i + random.nextInt(length - i);\n            SortUtils.swap(array, randomIndex, i);\n        }\n    }\n\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        while (!isSorted(array)) {\n            nextPermutation(array);\n        }\n        return array;\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Integer Input\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n\n        BogoSort bogoSort = new BogoSort();\n\n        // print a sorted array\n        SortUtils.print(bogoSort.sort(integers));\n\n        // String Input\n        String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n\n        SortUtils.print(bogoSort.sort(strings));\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BogoSortTest {\n\t\n    private BogoSort bogoSort = new BogoSort();\n\t\n    @Test\n    public void bogoSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortSingleIntegerArray() {\n        Integer[] inputArray = { 4 };\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortSingleStringArray() {\n        String[] inputArray = { \"s\" };\n        String[] outputArray = bogoSort.sort(inputArray);\n        String[] expectedOutput = { \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortNonDuplicateIntegerArray() {\n        Integer[] inputArray = { 6, -1, 99, 27, -15, 23, -36 };\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = { -36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n    \n    @Test\n    public void bogoSortDuplicateIntegerArray() {\n        Integer[] inputArray = { 6, -1, 27, -15, 23, 27, -36, 23 };\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = { -36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortNonDuplicateStringArray() {\n        String[] inputArray = { \"s\", \"b\", \"k\", \"a\", \"d\", \"c\", \"h\" };\n        String[] outputArray = bogoSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"h\", \"k\", \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortDuplicateStringArray() {\n        String[] inputArray = { \"s\", \"b\", \"d\", \"a\", \"d\", \"c\", \"h\", \"b\" };\n        String[] outputArray = bogoSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"b\", \"c\", \"d\", \"d\", \"h\", \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BogoSortTest {\n\n    private BogoSort bogoSort = new BogoSort();\n\n    @Test\n    public void bogoSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortSingleIntegerArray() {\n        Integer[] inputArray = {4};\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = {4};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortSingleStringArray() {\n        String[] inputArray = {\"s\"};\n        String[] outputArray = bogoSort.sort(inputArray);\n        String[] expectedOutput = {\"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortNonDuplicateIntegerArray() {\n        Integer[] inputArray = {6, -1, 99, 27, -15, 23, -36};\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = {-36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortDuplicateIntegerArray() {\n        Integer[] inputArray = {6, -1, 27, -15, 23, 27, -36, 23};\n        Integer[] outputArray = bogoSort.sort(inputArray);\n        Integer[] expectedOutput = {-36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortNonDuplicateStringArray() {\n        String[] inputArray = {\"s\", \"b\", \"k\", \"a\", \"d\", \"c\", \"h\"};\n        String[] outputArray = bogoSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"h\", \"k\", \"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortDuplicateStringArray() {\n        String[] inputArray = {\"s\", \"b\", \"d\", \"a\", \"d\", \"c\", \"h\", \"b\"};\n        String[] outputArray = bogoSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"b\", \"c\", \"d\", \"d\", \"h\", \"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BucketSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BucketSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Bucket_sort\n */\npublic class BucketSort {\n\n    public static void main(String[] args) {\n        int[] arr = new int[10];\n\n        /* generate 10 random numbers from -50 to 49 */\n        Random random = new Random();\n        for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random.nextInt(100) - 50;\n        }\n\n        bucketSort(arr);\n\n        /* check array is sorted or not */\n        for (int i = 0, limit = arr.length - 1; i < limit; ++i) {\n            assert arr[i] <= arr[i + 1];\n        }\n    }\n\n    /**\n     * BucketSort algorithms implements\n     *\n     * @param arr the array contains elements\n     */\n    public static int[] bucketSort(int[] arr) {\n        /* get max value of arr */\n        int max = max(arr);\n\n        /* get min value of arr */\n        int min = min(arr);\n\n        /* number of buckets */\n        int numberOfBuckets = max - min + 1;\n\n        List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);\n\n        /* init buckets */\n        for (int i = 0; i < numberOfBuckets; ++i) {\n            buckets.add(new ArrayList<>());\n        }\n\n        /* store elements to buckets */\n        for (int value : arr) {\n            int hash = hash(value, min, numberOfBuckets);\n            buckets.get(hash).add(value);\n        }\n\n        /* sort individual bucket */\n        for (List<Integer> bucket : buckets) {\n            Collections.sort(bucket);\n        }\n\n        /* concatenate buckets to origin array */\n        int index = 0;\n        for (List<Integer> bucket : buckets) {\n            for (int value : bucket) {\n                arr[index++] = value;\n            }\n        }\n        \n        return arr;\n    }\n\n    /**\n     * Get index of bucket which of our elements gets placed into it.\n     *\n     * @param elem the element of array to be sorted\n     * @param min min value of array\n     * @param numberOfBucket the number of bucket\n     * @return index of bucket\n     */\n    private static int hash(int elem, int min, int numberOfBucket) {\n        return (elem - min) / numberOfBucket;\n    }\n\n    /**\n     * Calculate max value of array\n     *\n     * @param arr the array contains elements\n     * @return max value of given array\n     */\n    public static int max(int[] arr) {\n        int max = arr[0];\n        for (int value : arr) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Calculate min value of array\n     *\n     * @param arr the array contains elements\n     * @return min value of given array\n     */\n    public static int min(int[] arr) {\n        int min = arr[0];\n        for (int value : arr) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Bucket_sort\n */\npublic class BucketSort {\n\n    public static void main(String[] args) {\n        int[] arr = new int[10];\n\n        /* generate 10 random numbers from -50 to 49 */\n        Random random = new Random();\n        for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random.nextInt(100) - 50;\n        }\n\n        bucketSort(arr);\n\n        /* check array is sorted or not */\n        for (int i = 0, limit = arr.length - 1; i < limit; ++i) {\n            assert arr[i] <= arr[i + 1];\n        }\n    }\n\n    /**\n     * BucketSort algorithms implements\n     *\n     * @param arr the array contains elements\n     */\n    public static int[] bucketSort(int[] arr) {\n        /* get max value of arr */\n        int max = max(arr);\n\n        /* get min value of arr */\n        int min = min(arr);\n\n        /* number of buckets */\n        int numberOfBuckets = max - min + 1;\n\n        List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);\n\n        /* init buckets */\n        for (int i = 0; i < numberOfBuckets; ++i) {\n            buckets.add(new ArrayList<>());\n        }\n\n        /* store elements to buckets */\n        for (int value : arr) {\n            int hash = hash(value, min, numberOfBuckets);\n            buckets.get(hash).add(value);\n        }\n\n        /* sort individual bucket */\n        for (List<Integer> bucket : buckets) {\n            Collections.sort(bucket);\n        }\n\n        /* concatenate buckets to origin array */\n        int index = 0;\n        for (List<Integer> bucket : buckets) {\n            for (int value : bucket) {\n                arr[index++] = value;\n            }\n        }\n\n        return arr;\n    }\n\n    /**\n     * Get index of bucket which of our elements gets placed into it.\n     *\n     * @param elem the element of array to be sorted\n     * @param min min value of array\n     * @param numberOfBucket the number of bucket\n     * @return index of bucket\n     */\n    private static int hash(int elem, int min, int numberOfBucket) {\n        return (elem - min) / numberOfBucket;\n    }\n\n    /**\n     * Calculate max value of array\n     *\n     * @param arr the array contains elements\n     * @return max value of given array\n     */\n    public static int max(int[] arr) {\n        int max = arr[0];\n        for (int value : arr) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Calculate min value of array\n     *\n     * @param arr the array contains elements\n     * @return min value of given array\n     */\n    public static int min(int[] arr) {\n        int min = arr[0];\n        for (int value : arr) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BucketSortTest {\n\n    @Test\n    public void bucketSortSingleIntegerArray() {\n        int[] inputArray = { 4 };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortNonDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 99, 27, 15, 23, 36 };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 27, 36, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 27, 15, 23, 27, 36, 23 };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 23, 27, 27, 36};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortNonDuplicateIntegerArrayWithNegativeNum() {\n        int[] inputArray = {  6, -1, 99, 27, -15, 23, -36  };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = { -36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortDuplicateIntegerArrayWithNegativeNum() {\n        int[] inputArray = { 6, -1, 27, -15, 23, 27, -36, 23  };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = { -36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BucketSortTest {\n\n    @Test\n    public void bucketSortSingleIntegerArray() {\n        int[] inputArray = {4};\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {4};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortNonDuplicateIntegerArray() {\n        int[] inputArray = {6, 1, 99, 27, 15, 23, 36};\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 27, 36, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortDuplicateIntegerArray() {\n        int[] inputArray = {6, 1, 27, 15, 23, 27, 36, 23};\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 23, 27, 27, 36};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortNonDuplicateIntegerArrayWithNegativeNum() {\n        int[] inputArray = {6, -1, 99, 27, -15, 23, -36};\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {-36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortDuplicateIntegerArrayWithNegativeNum() {\n        int[] inputArray = {6, -1, 27, -15, 23, 27, -36, 23};\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {-36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/CocktailShakerSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/CocktailShakerSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * @author Mateus Bizzo (https://github.com/MattBizzo)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nclass CocktailShakerSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Cocktail Shaker Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        int length = array.length;\n        int left = 0;\n        int right = length - 1;\n        int swappedLeft, swappedRight;\n        while (left < right) {\n            // front\n            swappedRight = 0;\n            for (int i = left; i < right; i++) {\n                if (SortUtils.less(array[i + 1], array[i])) {\n                    SortUtils.swap(array, i, i + 1);\n                    swappedRight = i;\n                }\n            }\n            // back\n            right = swappedRight;\n            swappedLeft = length - 1;\n            for (int j = right; j > left; j--) {\n                if (SortUtils.less(array[j], array[j - 1])) {\n                    SortUtils.swap(array, j - 1, j);\n                    swappedLeft = j;\n                }\n            }\n            left = swappedLeft;\n        }\n        return array;\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Integer Input\n        Integer[] integers = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        CocktailShakerSort shakerSort = new CocktailShakerSort();\n\n        // Output => 1 4 6 9 12 23 54 78 231\n        SortUtils.print(shakerSort.sort(integers));\n\n        // String Input\n        String[] strings = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        SortUtils.print(shakerSort.sort(strings));\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * @author Mateus Bizzo (https://github.com/MattBizzo)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nclass CocktailShakerSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Cocktail Shaker Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        int length = array.length;\n        int left = 0;\n        int right = length - 1;\n        int swappedLeft, swappedRight;\n        while (left < right) {\n            // front\n            swappedRight = 0;\n            for (int i = left; i < right; i++) {\n                if (SortUtils.less(array[i + 1], array[i])) {\n                    SortUtils.swap(array, i, i + 1);\n                    swappedRight = i;\n                }\n            }\n            // back\n            right = swappedRight;\n            swappedLeft = length - 1;\n            for (int j = right; j > left; j--) {\n                if (SortUtils.less(array[j], array[j - 1])) {\n                    SortUtils.swap(array, j - 1, j);\n                    swappedLeft = j;\n                }\n            }\n            left = swappedLeft;\n        }\n        return array;\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Integer Input\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        CocktailShakerSort shakerSort = new CocktailShakerSort();\n\n        // Output => 1 4 6 9 12 23 54 78 231\n        SortUtils.print(shakerSort.sort(integers));\n\n        // String Input\n        String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        SortUtils.print(shakerSort.sort(strings));\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see CocktailShakerSort\n */\npublic class CocktailShakerSortTest {\n    \n    private CocktailShakerSort cocktailShakerSort = new CocktailShakerSort();\n\n    @Test\n    public void cocktailShakerSortEmptyArray(){\n        Integer[] inputArray = {};\n        Integer[] outputArray = cocktailShakerSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void cocktailShakerSortSingleStringElementArray(){\n        String[] inputArray = {\"Test\"};\n        String[] outputArray = cocktailShakerSort.sort(inputArray);\n        String[] expectedOutput = {\"Test\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void cocktailShakerSortIntegerArray(){\n        Integer[] inputArray = { 2, 92, 1, 33, -33, 27, 5, 100, 78, 99, -100};\n        Integer[] outputArray = cocktailShakerSort.sort(inputArray);\n        Integer[] expectedOutput = { -100, -33, 1, 2, 5, 27, 33, 78, 92, 99, 100};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void cocktailShakerSortStringArray(){\n        String[] inputArray = {\n            \"g3x1\",\n            \"dN62\",\n            \"oMdr\",\n            \"KL2b\",\n            \"JddJ\",\n            \"mvE8\",\n            \"Ej7Q\",\n            \"n7n7\",\n            \"LGTg\",\n            \"2E1w\",\n        };\n        String[] outputArray = cocktailShakerSort.sort(inputArray);\n        String[] expectedOutput = {\n            \"2E1w\",\n            \"Ej7Q\",\n            \"JddJ\",\n            \"KL2b\",\n            \"LGTg\",\n            \"dN62\",\n            \"g3x1\",\n            \"mvE8\",\n            \"n7n7\",\n            \"oMdr\",\n        };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see CocktailShakerSort\n */\npublic class CocktailShakerSortTest {\n\n    private CocktailShakerSort cocktailShakerSort = new CocktailShakerSort();\n\n    @Test\n    public void cocktailShakerSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = cocktailShakerSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void cocktailShakerSortSingleStringElementArray() {\n        String[] inputArray = {\"Test\"};\n        String[] outputArray = cocktailShakerSort.sort(inputArray);\n        String[] expectedOutput = {\"Test\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void cocktailShakerSortIntegerArray() {\n        Integer[] inputArray = {2, 92, 1, 33, -33, 27, 5, 100, 78, 99, -100};\n        Integer[] outputArray = cocktailShakerSort.sort(inputArray);\n        Integer[] expectedOutput = {-100, -33, 1, 2, 5, 27, 33, 78, 92, 99, 100};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void cocktailShakerSortStringArray() {\n        String[] inputArray = {\n            \"g3x1\",\n            \"dN62\",\n            \"oMdr\",\n            \"KL2b\",\n            \"JddJ\",\n            \"mvE8\",\n            \"Ej7Q\",\n            \"n7n7\",\n            \"LGTg\",\n            \"2E1w\",\n        };\n        String[] outputArray = cocktailShakerSort.sort(inputArray);\n        String[] expectedOutput = {\n            \"2E1w\",\n            \"Ej7Q\",\n            \"JddJ\",\n            \"KL2b\",\n            \"LGTg\",\n            \"dN62\",\n            \"g3x1\",\n            \"mvE8\",\n            \"n7n7\",\n            \"oMdr\",\n        };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/DualPivotQuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DualPivotQuickSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * Dual Pivot Quick Sort Algorithm\n * \n * @author Debasish Biswas (https://github.com/debasishbsws) *\n * @see SortAlgorithm\n */\npublic class DualPivotQuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Dual pivot Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        dualPivotQuicksort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left  The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void dualPivotQuicksort(T[] array, int left, int right) {\n        if (left < right) {\n            int[] pivots = partition(array, left, right);\n\n            dualPivotQuicksort(array, left, pivots[0] - 1);\n            dualPivotQuicksort(array, pivots[0] + 1, pivots[1] - 1);\n            dualPivotQuicksort(array, pivots[1] + 1, right);\n        }\n    }\n\n    /**\n     * This method finds the partition indices for an array\n     *\n     * @param array The array to be sorted\n     * @param left  The first index of an array\n     * @param right The last index of an array Finds the partition index of an array\n     */\n    private static <T extends Comparable<T>> int[] partition(T[] array, int left, int right) {\n        if (array[left].compareTo(array[right]) > 0)\n            swap(array, left, right);\n\n        T pivot1 = array[left];\n        T pivot2 = array[right];\n\n        int j = left + 1;\n        int less = left + 1;\n        int great = right - 1;\n\n        while (less <= great) {\n            // If element is less than pivot1\n            if (array[less].compareTo(pivot1) < 0) {\n                swap(array, less, left++);\n            }\n\n            // If element is greater or equal to pivot2\n            else if (array[less].compareTo(pivot2) >= 0) {\n                while (less < great && array[great].compareTo(pivot2) > 0)\n                    great--;\n\n                swap(array, less, great--);\n\n                if (array[less].compareTo(pivot1) < 0)\n                    swap(array, less, left++);\n\n            }\n\n            less++;\n        }\n        j--;\n        great++;\n        // Bring the pivots to their appropriate positions\n        swap(array, left, j);\n        swap(array, right, great);\n\n        // return the pivots' indices\n        return new int[] { less, great };\n    }\n\n    private static <T extends Comparable<T>> void swap(T[] array, int left, int right) {\n        T temp = array[left];\n        array[left] = array[right];\n        array[right] = temp;\n    }\n\n    /**\n     * Main method\n     *\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Integer[] array = { 24, 8, -42, 75, -29, -77, 38, 57 };\n        DualPivotQuickSort dualPivotQuickSort = new DualPivotQuickSort();\n        dualPivotQuickSort.sort(array);\n        for (int i = 0; i < array.length; i++) {\n            System.out.print(array[i] + \" \");\n        }\n    }\n\n    /*\n     * References: https://www.geeksforgeeks.org/dual-pivot-quicksort/\n     */\n\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * Dual Pivot Quick Sort Algorithm\n *\n * @author Debasish Biswas (https://github.com/debasishbsws) *\n * @see SortAlgorithm\n */\npublic class DualPivotQuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Dual pivot Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        dualPivotQuicksort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left  The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void dualPivotQuicksort(\n        T[] array, int left, int right) {\n        if (left < right) {\n            int[] pivots = partition(array, left, right);\n\n            dualPivotQuicksort(array, left, pivots[0] - 1);\n            dualPivotQuicksort(array, pivots[0] + 1, pivots[1] - 1);\n            dualPivotQuicksort(array, pivots[1] + 1, right);\n        }\n    }\n\n    /**\n     * This method finds the partition indices for an array\n     *\n     * @param array The array to be sorted\n     * @param left  The first index of an array\n     * @param right The last index of an array Finds the partition index of an array\n     */\n    private static <T extends Comparable<T>> int[] partition(T[] array, int left, int right) {\n        if (array[left].compareTo(array[right]) > 0) swap(array, left, right);\n\n        T pivot1 = array[left];\n        T pivot2 = array[right];\n\n        int j = left + 1;\n        int less = left + 1;\n        int great = right - 1;\n\n        while (less <= great) {\n            // If element is less than pivot1\n            if (array[less].compareTo(pivot1) < 0) {\n                swap(array, less, left++);\n            }\n\n            // If element is greater or equal to pivot2\n            else if (array[less].compareTo(pivot2) >= 0) {\n                while (less < great && array[great].compareTo(pivot2) > 0) great--;\n\n                swap(array, less, great--);\n\n                if (array[less].compareTo(pivot1) < 0) swap(array, less, left++);\n            }\n\n            less++;\n        }\n        j--;\n        great++;\n        // Bring the pivots to their appropriate positions\n        swap(array, left, j);\n        swap(array, right, great);\n\n        // return the pivots' indices\n        return new int[] {less, great};\n    }\n\n    private static <T extends Comparable<T>> void swap(T[] array, int left, int right) {\n        T temp = array[left];\n        array[left] = array[right];\n        array[right] = temp;\n    }\n\n    /**\n     * Main method\n     *\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Integer[] array = {24, 8, -42, 75, -29, -77, 38, 57};\n        DualPivotQuickSort dualPivotQuickSort = new DualPivotQuickSort();\n        dualPivotQuickSort.sort(array);\n        for (int i = 0; i < array.length; i++) {\n            System.out.print(array[i] + \" \");\n        }\n    }\n\n    /*\n     * References: https://www.geeksforgeeks.org/dual-pivot-quicksort/\n     */\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = { 7 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 7 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = { 49, 4, 36, 9, 144, 1 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 4, 9, 36, 49, 144 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = { 49, -36, -124, -49, 12, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { -124, -49, -36, 9, 12, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = { 36, 1, 49, 1, 4, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 1, 4, 9, 36, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = { \"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\" };\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = { \"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\" };\n        assertArrayEquals(expected, sorted);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = {7};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = {49, -36, -124, -49, 12, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {-124, -49, -36, 9, 12, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = {\"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\"};\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = {\"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\"};\n        assertArrayEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/DutchNationalFlagSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DutchNationalFlagSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * The Dutch National Flag Sort sorts a sequence of values into three permutations which are defined by a value given\n * as the indented middle.\n * First permutation: values less than middle.\n * Second permutation: values equal middle.\n * Third permutation: values greater than middle.\n * If no indented middle is given, this implementation will use a value from the given Array.\n * This value is the one positioned in the arrays' middle if the arrays' length is odd.\n * If the arrays' length is even, the value left to the middle will be used.\n * More information and Pseudocode: https://en.wikipedia.org/wiki/Dutch_national_flag_problem\n */\npublic class DutchNationalFlagSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return dutch_national_flag_sort(\n            unsorted,\n            unsorted[(int) Math.ceil((unsorted.length) / 2.0) - 1]\n        );\n    }\n\n    public <T extends Comparable<T>> T[] sort(T[] unsorted, T intendedMiddle) {\n        return dutch_national_flag_sort(unsorted, intendedMiddle);\n    }\n\n    private <T extends Comparable<T>> T[] dutch_national_flag_sort(\n        T[] arr,\n        T intendedMiddle\n    ) {\n        int i = 0;\n        int j = 0;\n        int k = arr.length - 1;\n\n        while (j <= k) {\n            if (0 > arr[j].compareTo(intendedMiddle)) {\n                SortUtils.swap(arr, i, j);\n                j++;\n                i++;\n            } else if (0 < arr[j].compareTo(intendedMiddle)) {\n                SortUtils.swap(arr, j, k);\n                k--;\n            } else {\n                j++;\n            }\n        }\n        return arr;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * The Dutch National Flag Sort sorts a sequence of values into three permutations which are defined\n * by a value given as the indented middle. First permutation: values less than middle. Second\n * permutation: values equal middle. Third permutation: values greater than middle. If no indented\n * middle is given, this implementation will use a value from the given Array. This value is the one\n * positioned in the arrays' middle if the arrays' length is odd. If the arrays' length is even, the\n * value left to the middle will be used. More information and Pseudocode:\n * https://en.wikipedia.org/wiki/Dutch_national_flag_problem\n */\npublic class DutchNationalFlagSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return dutch_national_flag_sort(\n            unsorted, unsorted[(int) Math.ceil((unsorted.length) / 2.0) - 1]);\n    }\n\n    public <T extends Comparable<T>> T[] sort(T[] unsorted, T intendedMiddle) {\n        return dutch_national_flag_sort(unsorted, intendedMiddle);\n    }\n\n    private <T extends Comparable<T>> T[] dutch_national_flag_sort(T[] arr, T intendedMiddle) {\n        int i = 0;\n        int j = 0;\n        int k = arr.length - 1;\n\n        while (j <= k) {\n            if (0 > arr[j].compareTo(intendedMiddle)) {\n                SortUtils.swap(arr, i, j);\n                j++;\n                i++;\n            } else if (0 < arr[j].compareTo(intendedMiddle)) {\n                SortUtils.swap(arr, j, k);\n                k--;\n            } else {\n                j++;\n            }\n        }\n        return arr;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DutchNationalFlagSortTest {\n\n    @Test\n    /*\n      1 will be used as intended middle.\n      Partitions on the result array: [ smaller than 1 , equal 1, greater than 1]\n     */\n    void DNFSTestOdd() {\n        Integer[] integers = { 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 1, 4, 3 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      3 will be used as intended middle.\n      Partitions on the result array: [ smaller than 3 , equal 3, greater than 3]\n     */\n    void DNFSTestEven() {\n        Integer[] integers = { 8, 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 1, 3, 4, 8 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestEvenStrings() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\", \"e\" };\n        String[] stringsResult = { \"a\", \"b\", \"s\", \"e\", \"e\", \"d\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestOddStrings() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\" };\n        String[] stringsResult = { \"a\", \"b\", \"s\", \"e\", \"d\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      0 will be used as intended middle.\n      Partitions on the result array: [ smaller than 0 , equal 0, greater than 0]\n     */\n    void DNFSTestOddMidGiven() {\n        Integer[] integers = { 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 4, 3, 1 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 0);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      4 will be used as intended middle.\n      Partitions on the result array: [ smaller than 4 , equal 4, greater than 4]\n     */\n    void DNFSTestEvenMidGiven() {\n        Integer[] integers = { 8, 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 3, 1, 4, 8 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 4);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"s\" will be used as intended middle.\n      Partitions on the result array: [ smaller than s , equal s, greater than s]\n     */\n    void DNFSTestEvenStringsMidGiven() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\", \"e\" };\n        String[] stringsResult = { \"a\", \"d\", \"b\", \"e\", \"e\", \"s\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"s\");\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"e\" will be used as intended middle.\n      Partitions on the result array: [ smaller than e , equal e, greater than e]\n     */\n    void DNFSTestOddStringsMidGiven() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\" };\n        String[] stringsResult = { \"a\", \"d\", \"b\", \"e\", \"s\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"e\");\n        assertArrayEquals(strings, stringsResult);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DutchNationalFlagSortTest {\n\n    @Test\n    /*\n      1 will be used as intended middle.\n      Partitions on the result array: [ smaller than 1 , equal 1, greater than 1]\n     */\n    void DNFSTestOdd() {\n        Integer[] integers = {1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 1, 4, 3};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      3 will be used as intended middle.\n      Partitions on the result array: [ smaller than 3 , equal 3, greater than 3]\n     */\n    void DNFSTestEven() {\n        Integer[] integers = {8, 1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 1, 3, 4, 8};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestEvenStrings() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\", \"e\"};\n        String[] stringsResult = {\"a\", \"b\", \"s\", \"e\", \"e\", \"d\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestOddStrings() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\"};\n        String[] stringsResult = {\"a\", \"b\", \"s\", \"e\", \"d\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      0 will be used as intended middle.\n      Partitions on the result array: [ smaller than 0 , equal 0, greater than 0]\n     */\n    void DNFSTestOddMidGiven() {\n        Integer[] integers = {1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 4, 3, 1};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 0);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      4 will be used as intended middle.\n      Partitions on the result array: [ smaller than 4 , equal 4, greater than 4]\n     */\n    void DNFSTestEvenMidGiven() {\n        Integer[] integers = {8, 1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 3, 1, 4, 8};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 4);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"s\" will be used as intended middle.\n      Partitions on the result array: [ smaller than s , equal s, greater than s]\n     */\n    void DNFSTestEvenStringsMidGiven() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\", \"e\"};\n        String[] stringsResult = {\"a\", \"d\", \"b\", \"e\", \"e\", \"s\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"s\");\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"e\" will be used as intended middle.\n      Partitions on the result array: [ smaller than e , equal e, greater than e]\n     */\n    void DNFSTestOddStringsMidGiven() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\"};\n        String[] stringsResult = {\"a\", \"d\", \"b\", \"e\", \"s\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"e\");\n        assertArrayEquals(strings, stringsResult);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/MergeSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/MergeSortRecursiveTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\n\n/**\n * Generic merge sort algorithm.\n *\n * @see SortAlgorithm\n */\nclass MergeSort implements SortAlgorithm {\n\n    @SuppressWarnings(\"rawtypes\")\n    private static Comparable[] aux;\n\n    /**\n     * Generic merge sort algorithm implements.\n     *\n     * @param unsorted the array which should be sorted.\n     * @param <T> Comparable class.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        aux = new Comparable[unsorted.length];\n        doSort(unsorted, 0, unsorted.length - 1);\n        return unsorted;\n    }\n\n    /**\n     * @param arr the array to be sorted.\n     * @param left the first index of the array.\n     * @param right the last index of the array.\n     */\n    private static <T extends Comparable<T>> void doSort(T[] arr, int left, int right) {\n        if (left < right) {\n            int mid = (left + right) >>> 1;\n            doSort(arr, left, mid);\n            doSort(arr, mid + 1, right);\n            merge(arr, left, mid, right);\n        }\n    }\n\n    /**\n     * Merges two parts of an array.\n     *\n     * @param arr the array to be merged.\n     * @param left the first index of the array.\n     * @param mid the middle index of the array.\n     * @param right the last index of the array merges two parts of an array in\n     * increasing order.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) {\n        int i = left, j = mid + 1;\n        System.arraycopy(arr, left, aux, left, right + 1 - left);\n\n        for (int k = left; k <= right; k++) {\n            if (j > right) {\n                arr[k] = (T) aux[i++];\n            } else if (i > mid) {\n                arr[k] = (T) aux[j++];\n            } else if (less(aux[j], aux[i])) {\n                arr[k] = (T) aux[j++];\n            } else {\n                arr[k] = (T) aux[i++];\n            }\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\n\n/**\n * Generic merge sort algorithm.\n *\n * @see SortAlgorithm\n */\nclass MergeSort implements SortAlgorithm {\n\n    @SuppressWarnings(\"rawtypes\") private static Comparable[] aux;\n\n    /**\n     * Generic merge sort algorithm implements.\n     *\n     * @param unsorted the array which should be sorted.\n     * @param <T> Comparable class.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        aux = new Comparable[unsorted.length];\n        doSort(unsorted, 0, unsorted.length - 1);\n        return unsorted;\n    }\n\n    /**\n     * @param arr the array to be sorted.\n     * @param left the first index of the array.\n     * @param right the last index of the array.\n     */\n    private static <T extends Comparable<T>> void doSort(T[] arr, int left, int right) {\n        if (left < right) {\n            int mid = (left + right) >>> 1;\n            doSort(arr, left, mid);\n            doSort(arr, mid + 1, right);\n            merge(arr, left, mid, right);\n        }\n    }\n\n    /**\n     * Merges two parts of an array.\n     *\n     * @param arr the array to be merged.\n     * @param left the first index of the array.\n     * @param mid the middle index of the array.\n     * @param right the last index of the array merges two parts of an array in\n     * increasing order.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) {\n        int i = left, j = mid + 1;\n        System.arraycopy(arr, left, aux, left, right + 1 - left);\n\n        for (int k = left; k <= right; k++) {\n            if (j > right) {\n                arr[k] = (T) aux[i++];\n            } else if (i > mid) {\n                arr[k] = (T) aux[j++];\n            } else if (less(aux[j], aux[i])) {\n                arr[k] = (T) aux[j++];\n            } else {\n                arr[k] = (T) aux[i++];\n            }\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MergeSortRecursiveTest {\n\t\n//\tprivate MergeSortRecursive mergeSortRecursive = new MergeSortRecursive();\n\t\n\t@Test\n\tvoid testMergeSortRecursiveCase1 () {\n\t\tMergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(5, 12, 9, 3, 15, 88));\n\t\t\n\t\tList<Integer> expected = Arrays.asList(3, 5, 9, 12, 15, 88);\n\t\tList<Integer> sorted = mergeSortRecursive.mergeSort();\n\t\t\n\t\tassertEquals(expected, sorted);\n\t}\n\t\n\t@Test\n\tvoid testMergeSortRecursiveCase2 () {\n\t\tMergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(-3, 5, 3, 4, 3, 7, 40, -20, 30, 0));\n\t\t\n\t\tList<Integer> expected = Arrays.asList(-20, -3, 0, 3, 3, 4, 5, 7, 30, 40);\n\t\tList<Integer> sorted = mergeSortRecursive.mergeSort();\n\t\t\n\t\tassertEquals(expected, sorted);\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class MergeSortRecursiveTest {\n\n    //\tprivate MergeSortRecursive mergeSortRecursive = new MergeSortRecursive();\n\n    @Test\n    void testMergeSortRecursiveCase1() {\n        MergeSortRecursive mergeSortRecursive\n            = new MergeSortRecursive(Arrays.asList(5, 12, 9, 3, 15, 88));\n\n        List<Integer> expected = Arrays.asList(3, 5, 9, 12, 15, 88);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n\n    @Test\n    void testMergeSortRecursiveCase2() {\n        MergeSortRecursive mergeSortRecursive\n            = new MergeSortRecursive(Arrays.asList(-3, 5, 3, 4, 3, 7, 40, -20, 30, 0));\n\n        List<Integer> expected = Arrays.asList(-20, -3, 0, 3, 3, 4, 5, 7, 30, 40);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/MergeSortRecursive.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/MergeSortRecursiveTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MergeSortRecursive {\n\n    List<Integer> arr;\n\n    public MergeSortRecursive(List<Integer> arr) {\n        this.arr = arr;\n    }\n\n    public List<Integer> mergeSort() {\n        return merge(arr);\n    }\n\n    private static List<Integer> merge(List<Integer> arr) {\n        // base condition\n        if (arr.size() <= 1) {\n            return arr;\n        }\n\n        int arrLength = arr.size();\n        int half = arrLength / 2;\n        List<Integer> arrA = arr.subList(0, half);\n        List<Integer> arrB = arr.subList(half, arr.size());\n\n        // recursion\n        arrA = merge(arrA);\n        arrB = merge(arrB);\n\n        return sort(arrA, arrB);\n    }\n\n    private static List<Integer> sort(\n        List<Integer> unsortedA,\n        List<Integer> unsortedB\n    ) {\n        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {\n            return new ArrayList<>();\n        }\n        if (unsortedA.size() <= 0) {\n            return unsortedB;\n        }\n        if (unsortedB.size() <= 0) {\n            return unsortedA;\n        }\n        if (unsortedA.get(0) <= unsortedB.get(0)) {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                {\n                    add(unsortedA.get(0));\n                }\n            };\n            newAl.addAll(\n                sort(unsortedA.subList(1, unsortedA.size()), unsortedB)\n            );\n            return newAl;\n        } else {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                {\n                    add(unsortedB.get(0));\n                }\n            };\n            newAl.addAll(\n                sort(unsortedA, unsortedB.subList(1, unsortedB.size()))\n            );\n            return newAl;\n        }\n    }\n}\n\nclass App {\n\n    public static void main(String[] args) {\n        MergeSortRecursive sort = new MergeSortRecursive(\n            new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9))\n        );\n        sort.mergeSort();\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MergeSortRecursive {\n\n    List<Integer> arr;\n\n    public MergeSortRecursive(List<Integer> arr) {\n        this.arr = arr;\n    }\n\n    public List<Integer> mergeSort() {\n        return merge(arr);\n    }\n\n    private static List<Integer> merge(List<Integer> arr) {\n        // base condition\n        if (arr.size() <= 1) {\n            return arr;\n        }\n\n        int arrLength = arr.size();\n        int half = arrLength / 2;\n        List<Integer> arrA = arr.subList(0, half);\n        List<Integer> arrB = arr.subList(half, arr.size());\n\n        // recursion\n        arrA = merge(arrA);\n        arrB = merge(arrB);\n\n        return sort(arrA, arrB);\n    }\n\n    private static List<Integer> sort(List<Integer> unsortedA, List<Integer> unsortedB) {\n        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {\n            return new ArrayList<>();\n        }\n        if (unsortedA.size() <= 0) {\n            return unsortedB;\n        }\n        if (unsortedB.size() <= 0) {\n            return unsortedA;\n        }\n        if (unsortedA.get(0) <= unsortedB.get(0)) {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                { add(unsortedA.get(0)); }\n            };\n            newAl.addAll(sort(unsortedA.subList(1, unsortedA.size()), unsortedB));\n            return newAl;\n        } else {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                { add(unsortedB.get(0)); }\n            };\n            newAl.addAll(sort(unsortedA, unsortedB.subList(1, unsortedB.size())));\n            return newAl;\n        }\n    }\n}\n\nclass App {\n\n    public static void main(String[] args) {\n        MergeSortRecursive sort = new MergeSortRecursive(\n            new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9)));\n        sort.mergeSort();\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MergeSortRecursiveTest {\n\t\n//\tprivate MergeSortRecursive mergeSortRecursive = new MergeSortRecursive();\n\t\n\t@Test\n\tvoid testMergeSortRecursiveCase1 () {\n\t\tMergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(5, 12, 9, 3, 15, 88));\n\t\t\n\t\tList<Integer> expected = Arrays.asList(3, 5, 9, 12, 15, 88);\n\t\tList<Integer> sorted = mergeSortRecursive.mergeSort();\n\t\t\n\t\tassertEquals(expected, sorted);\n\t}\n\t\n\t@Test\n\tvoid testMergeSortRecursiveCase2 () {\n\t\tMergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(-3, 5, 3, 4, 3, 7, 40, -20, 30, 0));\n\t\t\n\t\tList<Integer> expected = Arrays.asList(-20, -3, 0, 3, 3, 4, 5, 7, 30, 40);\n\t\tList<Integer> sorted = mergeSortRecursive.mergeSort();\n\t\t\n\t\tassertEquals(expected, sorted);\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class MergeSortRecursiveTest {\n\n    //\tprivate MergeSortRecursive mergeSortRecursive = new MergeSortRecursive();\n\n    @Test\n    void testMergeSortRecursiveCase1() {\n        MergeSortRecursive mergeSortRecursive\n            = new MergeSortRecursive(Arrays.asList(5, 12, 9, 3, 15, 88));\n\n        List<Integer> expected = Arrays.asList(3, 5, 9, 12, 15, 88);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n\n    @Test\n    void testMergeSortRecursiveCase2() {\n        MergeSortRecursive mergeSortRecursive\n            = new MergeSortRecursive(Arrays.asList(-3, 5, 3, 4, 3, 7, 40, -20, 30, 0));\n\n        List<Integer> expected = Arrays.asList(-20, -3, 0, 3, 3, 4, 5, 7, 30, 40);\n        List<Integer> sorted = mergeSortRecursive.mergeSort();\n\n        assertEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/OddEvenSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/OddEvenSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\n// https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\npublic class OddEvenSort {\n\n    public static void main(String[] args) {\n        int[] arr = new int[100];\n\n        Random random = new Random();\n\n        // Print out unsorted elements\n        for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random.nextInt(100) - 50;\n            System.out.println(arr[i]);\n        }\n        System.out.println(\"--------------\");\n\n        oddEvenSort(arr);\n\n        //Print Sorted elements\n        for (int i = 0; i < arr.length - 1; ++i) {\n            System.out.println(arr[i]);\n            assert arr[i] <= arr[i + 1];\n        }\n    }\n\n    /**\n     * Odd Even Sort algorithms implements\n     *\n     * @param arr the array contains elements\n     */\n    public static void oddEvenSort(int[] arr) {\n        boolean sorted = false;\n        while (!sorted) {\n            sorted = true;\n\n            for (int i = 1; i < arr.length - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    swap(arr, i, i + 1);\n                    sorted = false;\n                }\n            }\n\n            for (int i = 0; i < arr.length - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    swap(arr, i, i + 1);\n                    sorted = false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function to swap two array values.\n     *\n     * @param arr the array contains elements\n     * @param i the first index to be swapped\n     * @param j the second index to be swapped\n     */\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\n// https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort\npublic class OddEvenSort {\n\n    public static void main(String[] args) {\n        int[] arr = new int[100];\n\n        Random random = new Random();\n\n        // Print out unsorted elements\n        for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random.nextInt(100) - 50;\n            System.out.println(arr[i]);\n        }\n        System.out.println(\"--------------\");\n\n        oddEvenSort(arr);\n\n        // Print Sorted elements\n        for (int i = 0; i < arr.length - 1; ++i) {\n            System.out.println(arr[i]);\n            assert arr[i] <= arr[i + 1];\n        }\n    }\n\n    /**\n     * Odd Even Sort algorithms implements\n     *\n     * @param arr the array contains elements\n     */\n    public static void oddEvenSort(int[] arr) {\n        boolean sorted = false;\n        while (!sorted) {\n            sorted = true;\n\n            for (int i = 1; i < arr.length - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    swap(arr, i, i + 1);\n                    sorted = false;\n                }\n            }\n\n            for (int i = 0; i < arr.length - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    swap(arr, i, i + 1);\n                    sorted = false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function to swap two array values.\n     *\n     * @param arr the array contains elements\n     * @param i the first index to be swapped\n     * @param j the second index to be swapped\n     */\n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see OddEvenSort\n */\n\npublic class OddEvenSortTest {\n    private OddEvenSort oddEvenSort = new OddEvenSort();\n\n    @Test\n    public void oddEvenSortEmptyArray(){\n        int[] inputArray = {};\n        oddEvenSort.oddEvenSort(inputArray);\n        int[] expectedOutput = {};\n        assertArrayEquals(inputArray, expectedOutput);\n    }\n\n    @Test\n    public void oddEvenSortNaturalNumberArray(){\n        int[] inputArray = {18, 91, 86, 60, 21, 44, 37, 78, 98, 67};\n        oddEvenSort.oddEvenSort(inputArray);\n        int[] expectedOutput = {18, 21, 37, 44, 60, 67, 78, 86, 91, 98};\n        assertArrayEquals(inputArray, expectedOutput);\n    }\n\n    @Test\n    public void oddEvenSortIntegerArray(){\n        int[] inputArray = {57, 69, -45, 12, -85, 3, -76, 36, 67, -14};\n        oddEvenSort.oddEvenSort(inputArray);\n        int[] expectedOutput = {-85, -76, -45, -14, 3, 12, 36, 57, 67, 69};\n        assertArrayEquals(inputArray, expectedOutput);\n    }\n    \n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see OddEvenSort\n */\n\npublic class OddEvenSortTest {\n    private OddEvenSort oddEvenSort = new OddEvenSort();\n\n    @Test\n    public void oddEvenSortEmptyArray() {\n        int[] inputArray = {};\n        oddEvenSort.oddEvenSort(inputArray);\n        int[] expectedOutput = {};\n        assertArrayEquals(inputArray, expectedOutput);\n    }\n\n    @Test\n    public void oddEvenSortNaturalNumberArray() {\n        int[] inputArray = {18, 91, 86, 60, 21, 44, 37, 78, 98, 67};\n        oddEvenSort.oddEvenSort(inputArray);\n        int[] expectedOutput = {18, 21, 37, 44, 60, 67, 78, 86, 91, 98};\n        assertArrayEquals(inputArray, expectedOutput);\n    }\n\n    @Test\n    public void oddEvenSortIntegerArray() {\n        int[] inputArray = {57, 69, -45, 12, -85, 3, -76, 36, 67, -14};\n        oddEvenSort.oddEvenSort(inputArray);\n        int[] expectedOutput = {-85, -76, -45, -14, 3, 12, 36, 57, 67, 69};\n        assertArrayEquals(inputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/QuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DualPivotQuickSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(\n        T[] array,\n        int left,\n        int right\n    ) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Randomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Randomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = { 7 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 7 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = { 49, 4, 36, 9, 144, 1 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 4, 9, 36, 49, 144 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = { 49, -36, -124, -49, 12, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { -124, -49, -36, 9, 12, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = { 36, 1, 49, 1, 4, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 1, 4, 9, 36, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = { \"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\" };\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = { \"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\" };\n        assertArrayEquals(expected, sorted);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = {7};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = {49, -36, -124, -49, 12, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {-124, -49, -36, 9, 12, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = {\"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\"};\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = {\"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\"};\n        assertArrayEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SelectionSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SelectionSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\npublic class SelectionSort implements SortAlgorithm {\n\n    /**\n     * Generic selection sort algorithm in increasing order.\n     *\n     * @param arr the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[minIndex].compareTo(arr[j]) > 0) {\n                    minIndex = j;\n                }\n            }\n            if (minIndex != i) {\n                T temp = arr[i];\n                arr[i] = arr[minIndex];\n                arr[minIndex] = temp;\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Integer[] arr = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        SelectionSort selectionSort = new SelectionSort();\n        Integer[] sorted = selectionSort.sort(arr);\n        for (int i = 0; i < sorted.length - 1; ++i) {\n            assert sorted[i] <= sorted[i + 1];\n        }\n\n        String[] strings = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        String[] sortedStrings = selectionSort.sort(strings);\n        for (int i = 0; i < sortedStrings.length - 1; ++i) {\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\npublic class SelectionSort implements SortAlgorithm {\n\n    /**\n     * Generic selection sort algorithm in increasing order.\n     *\n     * @param arr the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[minIndex].compareTo(arr[j]) > 0) {\n                    minIndex = j;\n                }\n            }\n            if (minIndex != i) {\n                T temp = arr[i];\n                arr[i] = arr[minIndex];\n                arr[minIndex] = temp;\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        SelectionSort selectionSort = new SelectionSort();\n        Integer[] sorted = selectionSort.sort(arr);\n        for (int i = 0; i < sorted.length - 1; ++i) {\n            assert sorted[i] <= sorted[i + 1];\n        }\n\n        String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        String[] sortedStrings = selectionSort.sort(strings);\n        for (int i = 0; i < sortedStrings.length - 1; ++i) {\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SelectionSortTest {\n\n    @Test\n    // valid test case\n    void IntegerArrTest() {\n        Integer[] arr = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(\n            new Integer[] { 1, 4, 6, 9, 12, 23, 54, 78, 231 },\n            selectionSort.sort(arr)\n        );\n    }\n\n    @Test\n    // valid test case\n    void StringArrTest() {\n        String[] arr = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(\n            new String[] { \"a\", \"b\", \"c\", \"d\", \"e\" },\n            selectionSort.sort(arr)\n        );\n    }\n\n    @Test\n    // invalid test case\n    void emptyArrTest() {\n        Integer[] arr = {};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new Integer[] {}, selectionSort.sort(arr));\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SelectionSortTest {\n\n    @Test\n    // valid test case\n    void IntegerArrTest() {\n        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new Integer[] {1, 4, 6, 9, 12, 23, 54, 78, 231}, selectionSort.sort(arr));\n    }\n\n    @Test\n    // valid test case\n    void StringArrTest() {\n        String[] arr = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}, selectionSort.sort(arr));\n    }\n\n    @Test\n    // invalid test case\n    void emptyArrTest() {\n        Integer[] arr = {};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new Integer[] {}, selectionSort.sort(arr));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/ShellSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/ShellSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\npublic class ShellSort implements SortAlgorithm {\n\n    /**\n     * Implements generic shell sort.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the type of elements in the array.\n     * @return the sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        int length = array.length;\n        int gap = 1;\n\n        /* Calculate gap for optimization purpose */\n        while (gap < length / 3) {\n            gap = 3 * gap + 1;\n        }\n\n        for (; gap > 0; gap /= 3) {\n            for (int i = gap; i < length; i++) {\n                int j;\n                T temp = array[i];\n                for (j = i; j >= gap && less(temp, array[j - gap]); j -= gap) {\n                    array[j] = array[j - gap];\n                }\n                array[j] = temp;\n            }\n        }\n        return array;\n    }\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        Integer[] toSort = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n\n        ShellSort sort = new ShellSort();\n        sort.sort(toSort);\n        for (int i = 0; i < toSort.length - 1; ++i) {\n            assert toSort[i] <= toSort[i + 1];\n        }\n        print(toSort);\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\npublic class ShellSort implements SortAlgorithm {\n\n    /**\n     * Implements generic shell sort.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the type of elements in the array.\n     * @return the sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        int length = array.length;\n        int gap = 1;\n\n        /* Calculate gap for optimization purpose */\n        while (gap < length / 3) {\n            gap = 3 * gap + 1;\n        }\n\n        for (; gap > 0; gap /= 3) {\n            for (int i = gap; i < length; i++) {\n                int j;\n                T temp = array[i];\n                for (j = i; j >= gap && less(temp, array[j - gap]); j -= gap) {\n                    array[j] = array[j - gap];\n                }\n                array[j] = temp;\n            }\n        }\n        return array;\n    }\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        Integer[] toSort = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n\n        ShellSort sort = new ShellSort();\n        sort.sort(toSort);\n        for (int i = 0; i < toSort.length - 1; ++i) {\n            assert toSort[i] <= toSort[i + 1];\n        }\n        print(toSort);\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ShellSortTest {\n    \n    private ShellSort shellSort = new ShellSort();\n    \n    @Test\n    public void ShellSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortSingleIntegerArray() {\n        Integer[] inputArray = { 4 };\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortSingleStringArray() {\n        String[] inputArray = { \"s\" };\n        String[] outputArray = shellSort.sort(inputArray);\n        String[] expectedOutput = { \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortNonDuplicateIntegerArray() {\n        Integer[] inputArray = { 6, -1, 99, 27, -15, 23, -36 };\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = { -36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n    \n    @Test\n    public void ShellSortDuplicateIntegerArray() {\n        Integer[] inputArray = { 6, -1, 27, -15, 23, 27, -36, 23 };\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = { -36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortNonDuplicateStringArray() {\n        String[] inputArray = { \"s\", \"b\", \"k\", \"a\", \"d\", \"c\", \"h\" };\n        String[] outputArray = shellSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"h\", \"k\", \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortDuplicateStringArray() {\n        String[] inputArray = { \"s\", \"b\", \"d\", \"a\", \"d\", \"c\", \"h\", \"b\" };\n        String[] outputArray = shellSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"b\", \"c\", \"d\", \"d\", \"h\", \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ShellSortTest {\n\n    private ShellSort shellSort = new ShellSort();\n\n    @Test\n    public void ShellSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortSingleIntegerArray() {\n        Integer[] inputArray = {4};\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = {4};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortSingleStringArray() {\n        String[] inputArray = {\"s\"};\n        String[] outputArray = shellSort.sort(inputArray);\n        String[] expectedOutput = {\"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortNonDuplicateIntegerArray() {\n        Integer[] inputArray = {6, -1, 99, 27, -15, 23, -36};\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = {-36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortDuplicateIntegerArray() {\n        Integer[] inputArray = {6, -1, 27, -15, 23, 27, -36, 23};\n        Integer[] outputArray = shellSort.sort(inputArray);\n        Integer[] expectedOutput = {-36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortNonDuplicateStringArray() {\n        String[] inputArray = {\"s\", \"b\", \"k\", \"a\", \"d\", \"c\", \"h\"};\n        String[] outputArray = shellSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"h\", \"k\", \"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void ShellSortDuplicateStringArray() {\n        String[] inputArray = {\"s\", \"b\", \"d\", \"a\", \"d\", \"c\", \"h\", \"b\"};\n        String[] outputArray = shellSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"b\", \"c\", \"d\", \"d\", \"h\", \"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SimpleSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SimpleSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\npublic class SimpleSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        final int LENGTH = array.length;\n\n        for (int i = 0; i < LENGTH; i++) {\n            for (int j = i + 1; j < LENGTH; j++) {\n                if (less(array[j], array[i])) {\n                    T element = array[j];\n                    array[j] = array[i];\n                    array[i] = element;\n                }\n            }\n        }\n\n        return array;\n    }\n\n    public static void main(String[] args) {\n        // ==== Int =======\n        Integer[] a = { 3, 7, 45, 1, 33, 5, 2, 9 };\n        System.out.print(\"unsorted: \");\n        print(a);\n        System.out.println();\n\n        new SimpleSort().sort(a);\n        System.out.print(\"sorted: \");\n        print(a);\n        System.out.println();\n\n        // ==== String =======\n        String[] b = {\n            \"banana\",\n            \"berry\",\n            \"orange\",\n            \"grape\",\n            \"peach\",\n            \"cherry\",\n            \"apple\",\n            \"pineapple\",\n        };\n        System.out.print(\"unsorted: \");\n        print(b);\n        System.out.println();\n\n        new SimpleSort().sort(b);\n        System.out.print(\"sorted: \");\n        print(b);\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\npublic class SimpleSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        final int LENGTH = array.length;\n\n        for (int i = 0; i < LENGTH; i++) {\n            for (int j = i + 1; j < LENGTH; j++) {\n                if (less(array[j], array[i])) {\n                    T element = array[j];\n                    array[j] = array[i];\n                    array[i] = element;\n                }\n            }\n        }\n\n        return array;\n    }\n\n    public static void main(String[] args) {\n        // ==== Int =======\n        Integer[] a = {3, 7, 45, 1, 33, 5, 2, 9};\n        System.out.print(\"unsorted: \");\n        print(a);\n        System.out.println();\n\n        new SimpleSort().sort(a);\n        System.out.print(\"sorted: \");\n        print(a);\n        System.out.println();\n\n        // ==== String =======\n        String[] b = {\n            \"banana\",\n            \"berry\",\n            \"orange\",\n            \"grape\",\n            \"peach\",\n            \"cherry\",\n            \"apple\",\n            \"pineapple\",\n        };\n        System.out.print(\"unsorted: \");\n        print(b);\n        System.out.println();\n\n        new SimpleSort().sort(b);\n        System.out.print(\"sorted: \");\n        print(b);\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SimpleSortTest {\n    \n    private SimpleSort simpleSort = new SimpleSort();\n    \n    @Test\n    public void simpleSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortSingleIntegerArray() {\n        Integer[] inputArray = { 4 };\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortSingleStringArray() {\n        String[] inputArray = { \"s\" };\n        String[] outputArray = simpleSort.sort(inputArray);\n        String[] expectedOutput = { \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortNonDuplicateIntegerArray() {\n        Integer[] inputArray = { 6, -1, 99, 27, -15, 23, -36 };\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = { -36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n    \n    @Test\n    public void simpleSortDuplicateIntegerArray() {\n        Integer[] inputArray = { 6, -1, 27, -15, 23, 27, -36, 23 };\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = { -36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortNonDuplicateStringArray() {\n        String[] inputArray = { \"s\", \"b\", \"k\", \"a\", \"d\", \"c\", \"h\" };\n        String[] outputArray = simpleSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"h\", \"k\", \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortDuplicateStringArray() {\n        String[] inputArray = { \"s\", \"b\", \"d\", \"a\", \"d\", \"c\", \"h\", \"b\" };\n        String[] outputArray = simpleSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"b\", \"c\", \"d\", \"d\", \"h\", \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class SimpleSortTest {\n\n    private SimpleSort simpleSort = new SimpleSort();\n\n    @Test\n    public void simpleSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortSingleIntegerArray() {\n        Integer[] inputArray = {4};\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = {4};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortSingleStringArray() {\n        String[] inputArray = {\"s\"};\n        String[] outputArray = simpleSort.sort(inputArray);\n        String[] expectedOutput = {\"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortNonDuplicateIntegerArray() {\n        Integer[] inputArray = {6, -1, 99, 27, -15, 23, -36};\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = {-36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortDuplicateIntegerArray() {\n        Integer[] inputArray = {6, -1, 27, -15, 23, 27, -36, 23};\n        Integer[] outputArray = simpleSort.sort(inputArray);\n        Integer[] expectedOutput = {-36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortNonDuplicateStringArray() {\n        String[] inputArray = {\"s\", \"b\", \"k\", \"a\", \"d\", \"c\", \"h\"};\n        String[] outputArray = simpleSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"h\", \"k\", \"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void simpleSortDuplicateStringArray() {\n        String[] inputArray = {\"s\", \"b\", \"d\", \"a\", \"d\", \"c\", \"h\", \"b\"};\n        String[] outputArray = simpleSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"b\", \"c\", \"d\", \"d\", \"h\", \"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SortUtilsRandomGenerator.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SortUtilsRandomGeneratorTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\npublic class SortUtilsRandomGenerator {\n\n    private static final Random random;\n    private static final long seed;\n\n    static {\n        seed = System.currentTimeMillis();\n        random = new Random(seed);\n    }\n\n\n    /**\n     * Function to generate array of double values, with predefined size.\n     *\n     * @param size result array size\n     * @return array of Double values, randomly generated, each element is between [0, 1)\n     */\n    public static Double[] generateArray(int size) {\n        Double[] arr = new Double[size];\n        for (int i = 0; i < size; i++)\n            arr[i] = generateDouble();\n        return arr;\n    }\n\n    /**\n     * Function to generate Double value.\n     *\n     * @return Double value [0, 1)\n     */\n    public static Double generateDouble() {\n        return random.nextDouble();\n    }\n\n    /**\n     * Function to generate int value.\n     *\n     * @return int value [0, n)\n     */\n    public static int generateInt(int n) {\n        return random.nextInt(n);\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\npublic class SortUtilsRandomGenerator {\n\n    private static final Random random;\n    private static final long seed;\n\n    static {\n        seed = System.currentTimeMillis();\n        random = new Random(seed);\n    }\n\n    /**\n     * Function to generate array of double values, with predefined size.\n     *\n     * @param size result array size\n     * @return array of Double values, randomly generated, each element is between [0, 1)\n     */\n    public static Double[] generateArray(int size) {\n        Double[] arr = new Double[size];\n        for (int i = 0; i < size; i++) arr[i] = generateDouble();\n        return arr;\n    }\n\n    /**\n     * Function to generate Double value.\n     *\n     * @return Double value [0, 1)\n     */\n    public static Double generateDouble() {\n        return random.nextDouble();\n    }\n\n    /**\n     * Function to generate int value.\n     *\n     * @return int value [0, n)\n     */\n    public static int generateInt(int n) {\n        return random.nextInt(n);\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass SortUtilsRandomGeneratorTest {\n\n    @RepeatedTest(1000)\n    void generateArray() {\n        int size = 1_000;\n        Double[] doubles = SortUtilsRandomGenerator.generateArray(size);\n        assertThat(doubles).hasSize(size);\n        assertThat(doubles).doesNotContainNull();\n    }\n\n    @Test\n    void generateArrayEmpty() {\n        int size = 0;\n        Double[] doubles = SortUtilsRandomGenerator.generateArray(size);\n        assertThat(doubles).hasSize(size);\n    }\n\n    @RepeatedTest(1000)\n    void generateDouble() {\n        Double randomDouble = SortUtilsRandomGenerator.generateDouble();\n        assertThat(randomDouble).isBetween(0.0, 1.0);\n        assertThat(randomDouble).isNotEqualTo(1.0);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\n\nclass SortUtilsRandomGeneratorTest {\n\n    @RepeatedTest(1000)\n    void generateArray() {\n        int size = 1_000;\n        Double[] doubles = SortUtilsRandomGenerator.generateArray(size);\n        assertThat(doubles).hasSize(size);\n        assertThat(doubles).doesNotContainNull();\n    }\n\n    @Test\n    void generateArrayEmpty() {\n        int size = 0;\n        Double[] doubles = SortUtilsRandomGenerator.generateArray(size);\n        assertThat(doubles).hasSize(size);\n    }\n\n    @RepeatedTest(1000)\n    void generateDouble() {\n        Double randomDouble = SortUtilsRandomGenerator.generateDouble();\n        assertThat(randomDouble).isBetween(0.0, 1.0);\n        assertThat(randomDouble).isNotEqualTo(1.0);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/StrandSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/StrandSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class StrandSort {\n\n    // note: the input list is destroyed\n    public static <E extends Comparable<? super E>> LinkedList<E> strandSort(\n        LinkedList<E> list\n    ) {\n        if (list.size() <= 1) return list;\n\n        LinkedList<E> result = new LinkedList<E>();\n        while (list.size() > 0) {\n            LinkedList<E> sorted = new LinkedList<E>();\n            sorted.add(list.removeFirst()); //same as remove() or remove(0)\n            for (Iterator<E> it = list.iterator(); it.hasNext();) {\n                E elem = it.next();\n                if (sorted.peekLast().compareTo(elem) <= 0) {\n                    sorted.addLast(elem); //same as add(elem) or add(0, elem)\n                    it.remove();\n                }\n            }\n            result = merge(sorted, result);\n        }\n        return result;\n    }\n\n    private static <E extends Comparable<? super E>> LinkedList<E> merge(\n        LinkedList<E> left,\n        LinkedList<E> right\n    ) {\n        LinkedList<E> result = new LinkedList<E>();\n        while (!left.isEmpty() && !right.isEmpty()) {\n            //change the direction of this comparison to change the direction of the sort\n            if (left.peek().compareTo(right.peek()) <= 0) result.add(\n                left.remove()\n            ); else result.add(right.remove());\n        }\n        result.addAll(left);\n        result.addAll(right);\n        return result;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class StrandSort {\n\n    // note: the input list is destroyed\n    public static <E extends Comparable<? super E>> LinkedList<E> strandSort(LinkedList<E> list) {\n        if (list.size() <= 1) return list;\n\n        LinkedList<E> result = new LinkedList<E>();\n        while (list.size() > 0) {\n            LinkedList<E> sorted = new LinkedList<E>();\n            sorted.add(list.removeFirst()); // same as remove() or remove(0)\n            for (Iterator<E> it = list.iterator(); it.hasNext();) {\n                E elem = it.next();\n                if (sorted.peekLast().compareTo(elem) <= 0) {\n                    sorted.addLast(elem); // same as add(elem) or add(0, elem)\n                    it.remove();\n                }\n            }\n            result = merge(sorted, result);\n        }\n        return result;\n    }\n\n    private static <E extends Comparable<? super E>> LinkedList<E> merge(\n        LinkedList<E> left, LinkedList<E> right) {\n        LinkedList<E> result = new LinkedList<E>();\n        while (!left.isEmpty() && !right.isEmpty()) {\n            // change the direction of this comparison to change the direction of the sort\n            if (left.peek().compareTo(right.peek()) <= 0)\n                result.add(left.remove());\n            else\n                result.add(right.remove());\n        }\n        result.addAll(left);\n        result.addAll(right);\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass StrandSortTest {\n\n    @Test\n    // valid test case\n    public void StrandSortNonDuplicateTest() {\n        int[] expectedArray = { 1, 2, 3, 4, 5 };\n        LinkedList<Integer> actualList = StrandSort.strandSort(\n            new LinkedList<Integer>(Arrays.asList(3, 1, 2, 4, 5))\n        );\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortDuplicateTest() {\n        int[] expectedArray = { 2, 2, 2, 5, 7 };\n        LinkedList<Integer> actualList = StrandSort.strandSort(\n            new LinkedList<Integer>(Arrays.asList(7, 2, 2, 2, 5))\n        );\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass StrandSortTest {\n\n    @Test\n    // valid test case\n    public void StrandSortNonDuplicateTest() {\n        int[] expectedArray = {1, 2, 3, 4, 5};\n        LinkedList<Integer> actualList\n            = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(3, 1, 2, 4, 5)));\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortDuplicateTest() {\n        int[] expectedArray = {2, 2, 2, 5, 7};\n        LinkedList<Integer> actualList\n            = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(7, 2, 2, 2, 5)));\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/TimSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/TimSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\n\n/**\n * This is simplified TimSort algorithm implementation. The original one is more complicated.\n * <p>\n * For more details @see <a href=\"https://en.wikipedia.org/wiki/Timsort\">TimSort Algorithm</a>\n */\nclass TimSort implements SortAlgorithm {\n    private static final int SUB_ARRAY_SIZE = 32;\n    @SuppressWarnings(\"rawtypes\")\n    private static Comparable[] aux;\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] a) {\n        int n = a.length;\n\n        InsertionSort insertionSort = new InsertionSort();\n        for (int i = 0; i < n; i += SUB_ARRAY_SIZE) {\n            insertionSort.sort(a, i, Math.min(i + SUB_ARRAY_SIZE, n));\n        }\n\n        aux = new Comparable[n];\n        for (int sz = SUB_ARRAY_SIZE; sz < n; sz = sz + sz) {\n            for (int lo = 0; lo < n - sz; lo += sz + sz) {\n                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, n - 1));\n            }\n        }\n\n        return a;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends Comparable<T>> void merge(T[] a, int lo, int mid, int hi) {\n        int i = lo, j = mid + 1;\n        System.arraycopy(a, lo, aux, lo, hi + 1 - lo);\n\n        for (int k = lo; k <= hi; k++) {\n            if (j > hi) {\n                a[k] = (T) aux[i++];\n            } else if (i > mid) {\n                a[k] = (T) aux[j++];\n            } else if (less(aux[j], aux[i])) {\n                a[k] = (T) aux[j++];\n            } else {\n                a[k] = (T) aux[i++];\n            }\n        }\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\n\n/**\n * This is simplified TimSort algorithm implementation. The original one is more complicated.\n * <p>\n * For more details @see <a href=\"https://en.wikipedia.org/wiki/Timsort\">TimSort Algorithm</a>\n */\nclass TimSort implements SortAlgorithm {\n    private static final int SUB_ARRAY_SIZE = 32;\n    @SuppressWarnings(\"rawtypes\") private static Comparable[] aux;\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] a) {\n        int n = a.length;\n\n        InsertionSort insertionSort = new InsertionSort();\n        for (int i = 0; i < n; i += SUB_ARRAY_SIZE) {\n            insertionSort.sort(a, i, Math.min(i + SUB_ARRAY_SIZE, n));\n        }\n\n        aux = new Comparable[n];\n        for (int sz = SUB_ARRAY_SIZE; sz < n; sz = sz + sz) {\n            for (int lo = 0; lo < n - sz; lo += sz + sz) {\n                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, n - 1));\n            }\n        }\n\n        return a;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends Comparable<T>> void merge(T[] a, int lo, int mid, int hi) {\n        int i = lo, j = mid + 1;\n        System.arraycopy(a, lo, aux, lo, hi + 1 - lo);\n\n        for (int k = lo; k <= hi; k++) {\n            if (j > hi) {\n                a[k] = (T) aux[i++];\n            } else if (i > mid) {\n                a[k] = (T) aux[j++];\n            } else if (less(aux[j], aux[i])) {\n                a[k] = (T) aux[j++];\n            } else {\n                a[k] = (T) aux[i++];\n            }\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass TimSortTest extends SortingAlgorithmTest {\n    @Override\n    SortAlgorithm getSortAlgorithm() {\n        return new TimSort();\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass TimSortTest extends SortingAlgorithmTest {\n    @Override\n    SortAlgorithm getSortAlgorithm() {\n        return new TimSort();\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/TopologicalSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/TopologicalSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.*;\n\n/**\n * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into\n * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is\n * performed, yielding no back-edges.\n *\n * https://en.wikipedia.org/wiki/Topological_sorting\n *\n * @author Jonathan Taylor (https://github.com/Jtmonument)\n * Based on Introduction to Algorithms 3rd Edition\n */\npublic class TopologicalSort {\n\n    /*\n     * Enum to represent the colors for the depth first search\n     * */\n    private enum Color {\n        WHITE,\n        GRAY,\n        BLACK,\n    }\n\n    /*\n     * Class to represent vertices\n     * */\n    private static class Vertex {\n\n        /*\n         * Name of vertex\n         * */\n        public final String label;\n\n        /*\n         * Weight of vertex\n         * (more accurately defined as the time that a vertex has begun a visit in DFS)\n         * */\n        public int weight;\n\n        /*\n         * The time that the vertex has finished a visit in DFS\n         * */\n        public int finished;\n\n        /*\n         * \u03c0 parent of the vertex\n         * */\n        public Vertex predecessor;\n\n        /*\n         * Represents the category of visit in DFS\n         * */\n        public Color color = Color.WHITE;\n\n        /*\n         * The array of names of descendant vertices\n         * */\n        public final ArrayList<String> next = new ArrayList<>();\n\n        public Vertex(String label) {\n            this.label = label;\n        }\n    }\n\n    /*\n     * Graph class uses the adjacency list representation\n     * */\n    static class Graph {\n\n        /*\n         * Adjacency list representation\n         * */\n        private final HashMap<String, Vertex> adj = new LinkedHashMap<>();\n\n        /*\n         * Function to add an edge to the graph\n         * */\n        public void addEdge(String label, String... next) {\n            adj.put(label, new Vertex(label));\n            if (!next[0].isEmpty()) Collections.addAll(\n                adj.get(label).next,\n                next\n            );\n        }\n    }\n\n    static class BackEdgeException extends RuntimeException {\n\n        public BackEdgeException(String backEdge) {\n            super(\n                \"This graph contains a cycle. No linear ordering is possible. \" +\n                backEdge\n            );\n        }\n    }\n\n    /*\n     * Time variable in DFS\n     * */\n    private static int time;\n\n    /*\n     * Depth First Search\n     *\n     * DFS(G)\n     *   for each vertex u \u2208 G.V\n     *       u.color = WHITE\n     *       u.\u03c0 = NIL\n     *   time = 0\n     *   for each vertex u \u2208 G.V\n     *   if u.color == WHITE\n     *       DFS-VISIT(G, u)\n     *\n     * Performed in \u0398(V + E) time\n     * */\n    public static LinkedList<String> sort(Graph graph) {\n        LinkedList<String> list = new LinkedList<>();\n        graph.adj.forEach((name, vertex) -> {\n            if (vertex.color == Color.WHITE) {\n                list.addFirst(sort(graph, vertex, list));\n            }\n        });\n        return list;\n    }\n\n    /*\n     * Depth First Search Visit\n     *\n     * DFS-Visit(G, u)\n     *   time = time + 1\n     *   u.d = time\n     *   u.color = GRAY\n     *   for each v \u2208 G.Adj[u]\n     *       if v.color == WHITE\n     *           v.\u03c0 = u\n     *           DFS-Visit(G, u)\n     *   u.color = BLACK\n     *   time = time + 1\n     *   u.f = time\n     * */\n    private static String sort(Graph graph, Vertex u, LinkedList<String> list) {\n        time++;\n        u.weight = time;\n        u.color = Color.GRAY;\n        graph.adj\n            .get(u.label)\n            .next.forEach(label -> {\n                if (graph.adj.get(label).color == Color.WHITE) {\n                    graph.adj.get(label).predecessor = u;\n                    list.addFirst(sort(graph, graph.adj.get(label), list));\n                } else if (graph.adj.get(label).color == Color.GRAY) {\n                    /*\n                     * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v\n                     * in a depth first tree. If v.d \u2264 u.d < u.f \u2264 v.f\n                     *\n                     * In many cases, we will not know u.f, but v.color denotes the type of edge\n                     * */\n                    throw new BackEdgeException(\n                        \"Back edge: \" + u.label + \" -> \" + label\n                    );\n                }\n            });\n        u.color = Color.BLACK;\n        time++;\n        u.finished = time;\n        return u.label;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.*;\n\n/**\n * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into\n * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is\n * performed, yielding no back-edges.\n *\n * https://en.wikipedia.org/wiki/Topological_sorting\n *\n * @author Jonathan Taylor (https://github.com/Jtmonument)\n * Based on Introduction to Algorithms 3rd Edition\n */\npublic class TopologicalSort {\n\n    /*\n     * Enum to represent the colors for the depth first search\n     * */\n    private enum Color {\n        WHITE,\n        GRAY,\n        BLACK,\n    }\n\n    /*\n     * Class to represent vertices\n     * */\n    private static class Vertex {\n\n        /*\n         * Name of vertex\n         * */\n        public final String label;\n\n        /*\n         * Weight of vertex\n         * (more accurately defined as the time that a vertex has begun a visit in DFS)\n         * */\n        public int weight;\n\n        /*\n         * The time that the vertex has finished a visit in DFS\n         * */\n        public int finished;\n\n        /*\n         * \u03c0 parent of the vertex\n         * */\n        public Vertex predecessor;\n\n        /*\n         * Represents the category of visit in DFS\n         * */\n        public Color color = Color.WHITE;\n\n        /*\n         * The array of names of descendant vertices\n         * */\n        public final ArrayList<String> next = new ArrayList<>();\n\n        public Vertex(String label) {\n            this.label = label;\n        }\n    }\n\n    /*\n     * Graph class uses the adjacency list representation\n     * */\n    static class Graph {\n\n        /*\n         * Adjacency list representation\n         * */\n        private final HashMap<String, Vertex> adj = new LinkedHashMap<>();\n\n        /*\n         * Function to add an edge to the graph\n         * */\n        public void addEdge(String label, String... next) {\n            adj.put(label, new Vertex(label));\n            if (!next[0].isEmpty()) Collections.addAll(adj.get(label).next, next);\n        }\n    }\n\n    static class BackEdgeException extends RuntimeException {\n\n        public BackEdgeException(String backEdge) {\n            super(\"This graph contains a cycle. No linear ordering is possible. \" + backEdge);\n        }\n    }\n\n    /*\n     * Time variable in DFS\n     * */\n    private static int time;\n\n    /*\n     * Depth First Search\n     *\n     * DFS(G)\n     *   for each vertex u \u2208 G.V\n     *       u.color = WHITE\n     *       u.\u03c0 = NIL\n     *   time = 0\n     *   for each vertex u \u2208 G.V\n     *   if u.color == WHITE\n     *       DFS-VISIT(G, u)\n     *\n     * Performed in \u0398(V + E) time\n     * */\n    public static LinkedList<String> sort(Graph graph) {\n        LinkedList<String> list = new LinkedList<>();\n        graph.adj.forEach((name, vertex) -> {\n            if (vertex.color == Color.WHITE) {\n                list.addFirst(sort(graph, vertex, list));\n            }\n        });\n        return list;\n    }\n\n    /*\n     * Depth First Search Visit\n     *\n     * DFS-Visit(G, u)\n     *   time = time + 1\n     *   u.d = time\n     *   u.color = GRAY\n     *   for each v \u2208 G.Adj[u]\n     *       if v.color == WHITE\n     *           v.\u03c0 = u\n     *           DFS-Visit(G, u)\n     *   u.color = BLACK\n     *   time = time + 1\n     *   u.f = time\n     * */\n    private static String sort(Graph graph, Vertex u, LinkedList<String> list) {\n        time++;\n        u.weight = time;\n        u.color = Color.GRAY;\n        graph.adj.get(u.label).next.forEach(label -> {\n            if (graph.adj.get(label).color == Color.WHITE) {\n                graph.adj.get(label).predecessor = u;\n                list.addFirst(sort(graph, graph.adj.get(label), list));\n            } else if (graph.adj.get(label).color == Color.GRAY) {\n                /*\n                 * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v\n                 * in a depth first tree. If v.d \u2264 u.d < u.f \u2264 v.f\n                 *\n                 * In many cases, we will not know u.f, but v.color denotes the type of edge\n                 * */\n                throw new BackEdgeException(\"Back edge: \" + u.label + \" -> \" + label);\n            }\n        });\n        u.color = Color.BLACK;\n        time++;\n        u.finished = time;\n        return u.label;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.sorts.TopologicalSort.BackEdgeException;\nimport com.thealgorithms.sorts.TopologicalSort.Graph;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass TopologicalSortTest {\n\n    @Test\n    void successTest() {\n        /*\n         * Professor Bumstead example DAG. Each directed edge means that garment u must be put on\n         * before garment v.\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"shirt\", \"tie\", \"belt\");\n        graph.addEdge(\"tie\", \"jacket\");\n        graph.addEdge(\"belt\", \"jacket\");\n        graph.addEdge(\"watch\", \"\");\n        graph.addEdge(\"undershorts\", \"pants\", \"shoes\");\n        graph.addEdge(\"shoes\", \"\");\n        graph.addEdge(\"socks\", \"shoes\");\n        graph.addEdge(\"jacket\", \"\");\n        graph.addEdge(\"pants\", \"belt\", \"shoes\");\n        LinkedList<String> expected = new LinkedList<>();\n        expected.add(\"socks\");\n        expected.add(\"undershorts\");\n        expected.add(\"pants\");\n        expected.add(\"shoes\");\n        expected.add(\"watch\");\n        expected.add(\"shirt\");\n        expected.add(\"belt\");\n        expected.add(\"tie\");\n        expected.add(\"jacket\");\n        assertIterableEquals(expected, TopologicalSort.sort(graph));\n    }\n\n    @Test\n    public void failureTest() {\n        /*\n         * Graph example from Geeks For Geeks\n         * https://www.geeksforgeeks.org/tree-back-edge-and-cross-edges-in-dfs-of-graph/\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"1\", \"2\", \"3\", \"8\");\n        graph.addEdge(\"2\", \"4\");\n        graph.addEdge(\"3\", \"5\");\n        graph.addEdge(\"4\", \"6\");\n        graph.addEdge(\"5\", \"4\", \"7\", \"8\");\n        graph.addEdge(\"6\", \"2\");\n        graph.addEdge(\"7\", \"\");\n        graph.addEdge(\"8\", \"\");\n        Exception exception = assertThrows(\n            BackEdgeException.class,\n            () -> TopologicalSort.sort(graph)\n        );\n        String expected =\n            \"This graph contains a cycle. No linear ordering is possible. \" +\n            \"Back edge: 6 -> 2\";\n        assertEquals(exception.getMessage(), expected);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.sorts.TopologicalSort.BackEdgeException;\nimport com.thealgorithms.sorts.TopologicalSort.Graph;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass TopologicalSortTest {\n\n    @Test\n    void successTest() {\n        /*\n         * Professor Bumstead example DAG. Each directed edge means that garment u must be put on\n         * before garment v.\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"shirt\", \"tie\", \"belt\");\n        graph.addEdge(\"tie\", \"jacket\");\n        graph.addEdge(\"belt\", \"jacket\");\n        graph.addEdge(\"watch\", \"\");\n        graph.addEdge(\"undershorts\", \"pants\", \"shoes\");\n        graph.addEdge(\"shoes\", \"\");\n        graph.addEdge(\"socks\", \"shoes\");\n        graph.addEdge(\"jacket\", \"\");\n        graph.addEdge(\"pants\", \"belt\", \"shoes\");\n        LinkedList<String> expected = new LinkedList<>();\n        expected.add(\"socks\");\n        expected.add(\"undershorts\");\n        expected.add(\"pants\");\n        expected.add(\"shoes\");\n        expected.add(\"watch\");\n        expected.add(\"shirt\");\n        expected.add(\"belt\");\n        expected.add(\"tie\");\n        expected.add(\"jacket\");\n        assertIterableEquals(expected, TopologicalSort.sort(graph));\n    }\n\n    @Test\n    public void failureTest() {\n        /*\n         * Graph example from Geeks For Geeks\n         * https://www.geeksforgeeks.org/tree-back-edge-and-cross-edges-in-dfs-of-graph/\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"1\", \"2\", \"3\", \"8\");\n        graph.addEdge(\"2\", \"4\");\n        graph.addEdge(\"3\", \"5\");\n        graph.addEdge(\"4\", \"6\");\n        graph.addEdge(\"5\", \"4\", \"7\", \"8\");\n        graph.addEdge(\"6\", \"2\");\n        graph.addEdge(\"7\", \"\");\n        graph.addEdge(\"8\", \"\");\n        Exception exception\n            = assertThrows(BackEdgeException.class, () -> TopologicalSort.sort(graph));\n        String expected = \"This graph contains a cycle. No linear ordering is possible. \"\n            + \"Back edge: 6 -> 2\";\n        assertEquals(exception.getMessage(), expected);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/TreeSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/TreeSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nimport com.thealgorithms.datastructures.trees.BSTRecursiveGeneric;\nimport java.util.List;\n\n/**\n * <h1> Implementation of the Tree Sort algorithm</h1>\n *\n * <p>\n * Tree Sort: A sorting algorithm which constructs a Binary Search Tree using\n * the unsorted data and then outputs the data by inorder traversal of the tree.\n *\n * Reference: https://en.wikipedia.org/wiki/Tree_sort\n * </p>\n *\n * @author Madhur Panwar (https://github.com/mdrpanwar)\n */\npublic class TreeSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        return doTreeSortArray(unsortedArray);\n    }\n\n    @Override\n    public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) {\n        return doTreeSortList(unsortedList);\n    }\n\n    private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedArray) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree\n        List<T> sortedList = tree.inorderSort();\n\n        // add the elements back to the initial array\n        int i = 0;\n        for (T element : sortedList) {\n            unsortedArray[i++] = element;\n        }\n\n        // return the array\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> List<T> doTreeSortList(\n        List<T> unsortedList\n    ) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedList) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree and return it\n        return tree.inorderSort();\n    }\n\n    public static void main(String[] args) {\n        TreeSort treeSort = new TreeSort();\n\n        // ==== Integer Array =======\n        System.out.println(\"Testing for Integer Array....\");\n        Integer[] a = { 3, -7, 45, 1, 343, -5, 2, 9 };\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(a);\n        a = treeSort.sort(a);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(a);\n        System.out.println();\n\n        // ==== Integer List =======\n        System.out.println(\"Testing for Integer List....\");\n        List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9);\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(intList);\n        intList = treeSort.sort(intList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(intList);\n        System.out.println();\n\n        // ==== String Array =======\n        System.out.println(\"Testing for String Array....\");\n        String[] b = {\n            \"banana\",\n            \"berry\",\n            \"orange\",\n            \"grape\",\n            \"peach\",\n            \"cherry\",\n            \"apple\",\n            \"pineapple\",\n        };\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(b);\n        b = treeSort.sort(b);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(b);\n        System.out.println();\n\n        // ==== String List =======\n        System.out.println(\"Testing for String List....\");\n        List<String> stringList = List.of(\n            \"banana\",\n            \"berry\",\n            \"orange\",\n            \"grape\",\n            \"peach\",\n            \"cherry\",\n            \"apple\",\n            \"pineapple\"\n        );\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(stringList);\n        stringList = treeSort.sort(stringList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(stringList);\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nimport com.thealgorithms.datastructures.trees.BSTRecursiveGeneric;\nimport java.util.List;\n\n/**\n * <h1> Implementation of the Tree Sort algorithm</h1>\n *\n * <p>\n * Tree Sort: A sorting algorithm which constructs a Binary Search Tree using\n * the unsorted data and then outputs the data by inorder traversal of the tree.\n *\n * Reference: https://en.wikipedia.org/wiki/Tree_sort\n * </p>\n *\n * @author Madhur Panwar (https://github.com/mdrpanwar)\n */\npublic class TreeSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        return doTreeSortArray(unsortedArray);\n    }\n\n    @Override\n    public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) {\n        return doTreeSortList(unsortedList);\n    }\n\n    private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedArray) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree\n        List<T> sortedList = tree.inorderSort();\n\n        // add the elements back to the initial array\n        int i = 0;\n        for (T element : sortedList) {\n            unsortedArray[i++] = element;\n        }\n\n        // return the array\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> List<T> doTreeSortList(List<T> unsortedList) {\n        // create a generic BST tree\n        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();\n\n        // add all elements to the tree\n        for (T element : unsortedList) {\n            tree.add(element);\n        }\n\n        // get the sorted list by inorder traversal of the tree and return it\n        return tree.inorderSort();\n    }\n\n    public static void main(String[] args) {\n        TreeSort treeSort = new TreeSort();\n\n        // ==== Integer Array =======\n        System.out.println(\"Testing for Integer Array....\");\n        Integer[] a = {3, -7, 45, 1, 343, -5, 2, 9};\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(a);\n        a = treeSort.sort(a);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(a);\n        System.out.println();\n\n        // ==== Integer List =======\n        System.out.println(\"Testing for Integer List....\");\n        List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9);\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(intList);\n        intList = treeSort.sort(intList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(intList);\n        System.out.println();\n\n        // ==== String Array =======\n        System.out.println(\"Testing for String Array....\");\n        String[] b = {\n            \"banana\",\n            \"berry\",\n            \"orange\",\n            \"grape\",\n            \"peach\",\n            \"cherry\",\n            \"apple\",\n            \"pineapple\",\n        };\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(b);\n        b = treeSort.sort(b);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(b);\n        System.out.println();\n\n        // ==== String List =======\n        System.out.println(\"Testing for String List....\");\n        List<String> stringList = List.of(\n            \"banana\", \"berry\", \"orange\", \"grape\", \"peach\", \"cherry\", \"apple\", \"pineapple\");\n        System.out.printf(\"%-10s\", \"unsorted: \");\n        print(stringList);\n        stringList = treeSort.sort(stringList);\n        System.out.printf(\"%-10s\", \"sorted: \");\n        print(stringList);\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see TreeSort\n */\n\npublic class TreeSortTest {\n    private TreeSort treeSort = new TreeSort();\n\n    @Test \n    public void treeSortEmptyArray(){\n        Integer[] inputArray = {};\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void treeSortSingleStringElement() {\n        String[] inputArray = {\"Test\"};\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray = {\"Test\"};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortStringArray() {\n        String[] inputArray = {\n            \"F6w9\",\n            \"l1qz\",\n            \"dIxH\",\n            \"larj\",\n            \"kRzy\",\n            \"vnNH\",\n            \"3ftM\",\n            \"hc4n\",\n            \"C5Qi\",\n            \"btGF\"\n        };\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray = {\n            \"3ftM\",\n            \"C5Qi\",\n            \"F6w9\",\n            \"btGF\",\n            \"dIxH\",\n            \"hc4n\",\n            \"kRzy\",\n            \"l1qz\",\n            \"larj\",\n            \"vnNH\"\n        };\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test \n    public void treeSortIntegerArray() {\n        Integer[] inputArray = { -97, -44, -4, -85, -92, 74, 79, -26, 76, -5 };\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedArray = { -97, -92, -85, -44, -26, -5, -4, 74, 76, 79 };\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortDoubleArray() {\n        Double[] inputArray = {\n            0.8047485045,  0.4493112337,\n            0.8298433723,  0.2691406748,\n            0.2482782839,  0.5976243420,\n            0.6746235284,  0.0552623569,\n            0.3515624123,  0.0536747336\n        };\n        Double[] outputArray = treeSort.sort(inputArray);\n        Double[] expectedArray = {\n            0.0536747336,  0.0552623569,\n            0.2482782839,  0.2691406748,\n            0.3515624123,  0.4493112337,\n            0.5976243420,  0.6746235284, \n            0.8047485045,  0.8298433723\n        };\n        assertArrayEquals(outputArray, expectedArray);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Tabbygray (https://github.com/Tabbygray)\n * @see TreeSort\n */\n\npublic class TreeSortTest {\n    private TreeSort treeSort = new TreeSort();\n\n    @Test\n    public void treeSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void treeSortSingleStringElement() {\n        String[] inputArray = {\"Test\"};\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray = {\"Test\"};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortStringArray() {\n        String[] inputArray\n            = {\"F6w9\", \"l1qz\", \"dIxH\", \"larj\", \"kRzy\", \"vnNH\", \"3ftM\", \"hc4n\", \"C5Qi\", \"btGF\"};\n        String[] outputArray = treeSort.sort(inputArray);\n        String[] expectedArray\n            = {\"3ftM\", \"C5Qi\", \"F6w9\", \"btGF\", \"dIxH\", \"hc4n\", \"kRzy\", \"l1qz\", \"larj\", \"vnNH\"};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortIntegerArray() {\n        Integer[] inputArray = {-97, -44, -4, -85, -92, 74, 79, -26, 76, -5};\n        Integer[] outputArray = treeSort.sort(inputArray);\n        Integer[] expectedArray = {-97, -92, -85, -44, -26, -5, -4, 74, 76, 79};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n\n    @Test\n    public void treeSortDoubleArray() {\n        Double[] inputArray = {0.8047485045, 0.4493112337, 0.8298433723, 0.2691406748, 0.2482782839,\n            0.5976243420, 0.6746235284, 0.0552623569, 0.3515624123, 0.0536747336};\n        Double[] outputArray = treeSort.sort(inputArray);\n        Double[] expectedArray = {0.0536747336, 0.0552623569, 0.2482782839, 0.2691406748,\n            0.3515624123, 0.4493112337, 0.5976243420, 0.6746235284, 0.8047485045, 0.8298433723};\n        assertArrayEquals(outputArray, expectedArray);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/WiggleSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/WiggleSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.maths.Ceil.ceil;\nimport static com.thealgorithms.maths.Floor.floor;\nimport static com.thealgorithms.searches.QuickSelect.select;\n\nimport java.util.Arrays;\n\n/**\n * A wiggle sort implementation based on John L.s' answer in\n * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity\n * Also have a look at: https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity?noredirect=1&lq=1\n * Not all arrays are wiggle-sortable. This algorithm will find some obviously not wiggle-sortable arrays and throw an error,\n * but there are some exceptions that won't be caught, for example [1, 2, 2].\n */\npublic class WiggleSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return wiggleSort(unsorted);\n    }\n\n    private int mapIndex(int index, int n) {\n        return ((2 * index + 1) % (n | 1));\n    }\n\n    /**\n     * Modified Dutch National Flag Sort. See also: sorts/DutchNationalFlagSort\n     *\n     * @param sortThis array to sort into group \"greater\", \"equal\" and \"smaller\" than median\n     * @param median   defines the groups\n     * @param <T>      extends interface Comparable\n     */\n    private <T extends Comparable<T>> void triColorSort(\n        T[] sortThis,\n        T median\n    ) {\n        int n = sortThis.length;\n        int i = 0;\n        int j = 0;\n        int k = n - 1;\n        while (j <= k) {\n            if (0 < sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n));\n                i++;\n                j++;\n            } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n));\n                k--;\n            } else {\n                j++;\n            }\n        }\n    }\n\n    private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) {\n        // find the median using quickSelect (if the result isn't in the array, use the next greater value)\n        T median;\n\n        median =\n            select(\n                Arrays.asList(sortThis),\n                (int) floor(sortThis.length / 2.0)\n            );\n\n        int numMedians = 0;\n\n        for (T sortThi : sortThis) {\n            if (0 == sortThi.compareTo(median)) {\n                numMedians++;\n            }\n        }\n        // added condition preventing off-by-one errors for odd arrays.\n        // https://cs.stackexchange.com/questions/150886/how-to-find-wiggle-sortable-arrays-did-i-misunderstand-john-l-s-answer?noredirect=1&lq=1\n        if (\n            sortThis.length % 2 == 1 &&\n            numMedians == ceil(sortThis.length / 2.0)\n        ) {\n            T smallestValue = select(Arrays.asList(sortThis), 0);\n            if (!(0 == smallestValue.compareTo(median))) {\n                throw new IllegalArgumentException(\n                    \"For odd Arrays if the median appears ceil(n/2) times, \" +\n                    \"the median has to be the smallest values in the array.\"\n                );\n            }\n        }\n        if (numMedians > ceil(sortThis.length / 2.0)) {\n            throw new IllegalArgumentException(\n                \"No more than half the number of values may be the same.\"\n            );\n        }\n\n        triColorSort(sortThis, median);\n        return sortThis;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.maths.Ceil.ceil;\nimport static com.thealgorithms.maths.Floor.floor;\nimport static com.thealgorithms.searches.QuickSelect.select;\n\nimport java.util.Arrays;\n\n/**\n * A wiggle sort implementation based on John L.s' answer in\n * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity\n * Also have a look at:\n * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity?noredirect=1&lq=1\n * Not all arrays are wiggle-sortable. This algorithm will find some obviously not wiggle-sortable\n * arrays and throw an error, but there are some exceptions that won't be caught, for example [1, 2,\n * 2].\n */\npublic class WiggleSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return wiggleSort(unsorted);\n    }\n\n    private int mapIndex(int index, int n) {\n        return ((2 * index + 1) % (n | 1));\n    }\n\n    /**\n     * Modified Dutch National Flag Sort. See also: sorts/DutchNationalFlagSort\n     *\n     * @param sortThis array to sort into group \"greater\", \"equal\" and \"smaller\" than median\n     * @param median   defines the groups\n     * @param <T>      extends interface Comparable\n     */\n    private <T extends Comparable<T>> void triColorSort(T[] sortThis, T median) {\n        int n = sortThis.length;\n        int i = 0;\n        int j = 0;\n        int k = n - 1;\n        while (j <= k) {\n            if (0 < sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n));\n                i++;\n                j++;\n            } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n));\n                k--;\n            } else {\n                j++;\n            }\n        }\n    }\n\n    private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) {\n        // find the median using quickSelect (if the result isn't in the array, use the next greater\n        // value)\n        T median;\n\n        median = select(Arrays.asList(sortThis), (int) floor(sortThis.length / 2.0));\n\n        int numMedians = 0;\n\n        for (T sortThi : sortThis) {\n            if (0 == sortThi.compareTo(median)) {\n                numMedians++;\n            }\n        }\n        // added condition preventing off-by-one errors for odd arrays.\n        // https://cs.stackexchange.com/questions/150886/how-to-find-wiggle-sortable-arrays-did-i-misunderstand-john-l-s-answer?noredirect=1&lq=1\n        if (sortThis.length % 2 == 1 && numMedians == ceil(sortThis.length / 2.0)) {\n            T smallestValue = select(Arrays.asList(sortThis), 0);\n            if (!(0 == smallestValue.compareTo(median))) {\n                throw new IllegalArgumentException(\n                    \"For odd Arrays if the median appears ceil(n/2) times, \"\n                    + \"the median has to be the smallest values in the array.\");\n            }\n        }\n        if (numMedians > ceil(sortThis.length / 2.0)) {\n            throw new IllegalArgumentException(\n                \"No more than half the number of values may be the same.\");\n        }\n\n        triColorSort(sortThis, median);\n        return sortThis;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class WiggleSortTest {\n\n    @Test\n    void WiggleTestNumbersEven() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 2, 3, 4 };\n        Integer[] result = { 1, 4, 2, 3 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOdd() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 2, 3, 4, 5 };\n        Integer[] result = { 3, 5, 1, 4, 2 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 7, 2, 2, 2, 5 };\n        Integer[] result = { 2, 7, 2, 5, 2 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddMultipleDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 1, 2, 2, 5 };\n        Integer[] result = { 2, 5, 1, 2, 1 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenMultipleDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 1, 2, 2, 2, 5 };\n        Integer[] result = { 2, 5, 1, 2, 1, 2 };\n        wiggleSort.sort(values);\n        System.out.println(Arrays.toString(values));\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 2, 4, 4 };\n        Integer[] result = { 1, 4, 2, 4 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestStrings() {\n        WiggleSort wiggleSort = new WiggleSort();\n        String[] values = { \"a\", \"b\", \"d\", \"c\" };\n        String[] result = { \"a\", \"d\", \"b\", \"c\" };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class WiggleSortTest {\n\n    @Test\n    void WiggleTestNumbersEven() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 3, 4};\n        Integer[] result = {1, 4, 2, 3};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOdd() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 3, 4, 5};\n        Integer[] result = {3, 5, 1, 4, 2};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {7, 2, 2, 2, 5};\n        Integer[] result = {2, 7, 2, 5, 2};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddMultipleDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 1, 2, 2, 5};\n        Integer[] result = {2, 5, 1, 2, 1};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenMultipleDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 1, 2, 2, 2, 5};\n        Integer[] result = {2, 5, 1, 2, 1, 2};\n        wiggleSort.sort(values);\n        System.out.println(Arrays.toString(values));\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 4, 4};\n        Integer[] result = {1, 4, 2, 4};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestStrings() {\n        WiggleSort wiggleSort = new WiggleSort();\n        String[] values = {\"a\", \"b\", \"d\", \"c\"};\n        String[] result = {\"a\", \"d\", \"b\", \"c\"};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/HammingDistanceTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/* In information theory, the Hamming distance between two strings of equal length \nis the number of positions at which the corresponding symbols are different. \nhttps://en.wikipedia.org/wiki/Hamming_distance\n*/\npublic class HammingDistance {\n\n    /**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */\n    public static int calculateHammingDistance(String s1, String s2)\n        throws Exception {\n        if (s1.length() != s2.length()) {\n            throw new Exception(\"String lengths must be equal\");\n        }\n\n        int stringLength = s1.length();\n        int counter = 0;\n\n        for (int i = 0; i < stringLength; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/* In information theory, the Hamming distance between two strings of equal length\nis the number of positions at which the corresponding symbols are different.\nhttps://en.wikipedia.org/wiki/Hamming_distance\n*/\npublic class HammingDistance {\n\n    /**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */\n    public static int calculateHammingDistance(String s1, String s2) throws Exception {\n        if (s1.length() != s2.length()) {\n            throw new Exception(\"String lengths must be equal\");\n        }\n\n        int stringLength = s1.length();\n        int counter = 0;\n\n        for (int i = 0; i < stringLength; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    @Test\n    void testHammingDistance() throws Exception {\n        assertEquals(HammingDistance.calculateHammingDistance(\"\", \"\"), 0);\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"java\", \"java\"),\n            0\n        );\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"karolin\", \"kathrin\"),\n            3\n        );\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"kathrin\", \"kerstin\"),\n            4\n        );\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"00000\", \"11111\"),\n            5\n        );\n    }\n\n    @Test\n    void testNotEqualStringLengths() {\n        Exception exception = assertThrows(\n            Exception.class,\n            () -> HammingDistance.calculateHammingDistance(\"ab\", \"abc\")\n        );\n        assertEquals(\"String lengths must be equal\", exception.getMessage());\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    @Test\n    void testHammingDistance() throws Exception {\n        assertEquals(HammingDistance.calculateHammingDistance(\"\", \"\"), 0);\n        assertEquals(HammingDistance.calculateHammingDistance(\"java\", \"java\"), 0);\n        assertEquals(HammingDistance.calculateHammingDistance(\"karolin\", \"kathrin\"), 3);\n        assertEquals(HammingDistance.calculateHammingDistance(\"kathrin\", \"kerstin\"), 4);\n        assertEquals(HammingDistance.calculateHammingDistance(\"00000\", \"11111\"), 5);\n    }\n\n    @Test\n    void testNotEqualStringLengths() {\n        Exception exception = assertThrows(\n            Exception.class, () -> HammingDistance.calculateHammingDistance(\"ab\", \"abc\"));\n        assertEquals(\"String lengths must be equal\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/HorspoolSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/HorspoolSearchTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\n/**\n * This class is not thread safe<br>\n * <br>\n * (From wikipedia) In computer science, the Boyer\u2013Moore\u2013Horspool algorithm or\n * Horspool's algorithm is an algorithm for finding substrings in strings. It\n * was published by Nigel Horspool in 1980.\n * <br>\n * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia\n * page</a><br>\n * <br>\n *\n * <p>\n * An explanation:<br>\n *\n * <p>\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\n * that it uses only one of the two heuristic methods for increasing the number\n * of characters shifted when finding a bad match in the text. This method is\n * usually called the \"bad symbol\" or \"bad character\" shift. The bad symbol\n * shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that\n * processing a given input to a problem and altering it in a specific way will\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\n * to match the pattern and text comparing the pattern symbols to the text's\n * from right to left.<br>\n * <br>\n *\n * <p>\n * In the bad symbol shift method, a table is created prior to the search,\n * called the \"bad symbol table\". The bad symbol table contains the shift values\n * for any symbol in the text and pattern. For these symbols, the value is the\n * length of the pattern, if the symbol is not in the first (length - 1) of the\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values\n * for the ones that exist in the first (length - 1) of the pattern.<br>\n * <br>\n *\n * <p>\n * For more details on the algorithm and the more advanced Boyer-Moore I\n * recommend checking out the wikipedia page and professor Anany Levitin's book:\n * Introduction To The Design And Analysis Of Algorithms.\n */\npublic class HorspoolSearch {\n\n    private static HashMap<Character, Integer> shiftValues; // bad symbol table\n    private static Integer patternLength;\n    private static int comparisons = 0; // total comparisons in the current/last search\n\n    /**\n     * Case sensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirst(String pattern, String text) {\n        return firstOccurrence(pattern, text, true);\n    }\n\n    /**\n     * Case insensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirstInsensitive(String pattern, String text) {\n        return firstOccurrence(pattern, text, false);\n    }\n\n    /**\n     * Utility method that returns comparisons made by last run (mainly for\n     * tests)\n     *\n     * @return number of character comparisons of the last search\n     */\n    public static Integer getLastComparisons() {\n        return HorspoolSearch.comparisons;\n    }\n\n    /**\n     * Fairly standard implementation of the Horspool algorithm. Only the index\n     * of the last character of the pattern on the text is saved and shifted by\n     * the appropriate amount when a mismatch is found. The algorithm stops at\n     * the first match or when the entire text has been exhausted.\n     *\n     * @param pattern String to be matched in the text\n     * @param text text String\n     * @return index of first occurrence of the pattern in the text\n     */\n    private static int firstOccurrence(\n        String pattern,\n        String text,\n        boolean caseSensitive\n    ) {\n        shiftValues = calcShiftValues(pattern); // build the bad symbol table\n        comparisons = 0; // reset comparisons\n\n        if (pattern.length() == 0) { // return failure, if pattern empty\n            return -1;\n        }\n\n        int textIndex = pattern.length() - 1; // align pattern with text start and get index of the last character\n\n        // while pattern is not out of text bounds\n        while (textIndex < text.length()) {\n            // try to match pattern with current part of the text starting from last character\n            int i = pattern.length() - 1;\n            while (i >= 0) {\n                comparisons++;\n                char patternChar = pattern.charAt(i);\n                char textChar = text.charAt(\n                    (textIndex + i) - (pattern.length() - 1)\n                );\n                if (!charEquals(patternChar, textChar, caseSensitive)) { // bad character, shift pattern\n                    textIndex += getShiftValue(text.charAt(textIndex));\n                    break;\n                }\n                i--;\n            }\n\n            // check for full match\n            if (i == -1) {\n                return textIndex - pattern.length() + 1;\n            }\n        }\n\n        // text exhausted, return failure\n        return -1;\n    }\n\n    /**\n     * Compares the argument characters\n     *\n     * @param c1 first character\n     * @param c2 second character\n     * @param caseSensitive boolean determining case sensitivity of comparison\n     * @return truth value of the equality comparison\n     */\n    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {\n        if (caseSensitive) {\n            return c1 == c2;\n        }\n        return Character.toLowerCase(c1) == Character.toLowerCase(c2);\n    }\n\n    /**\n     * Builds the bad symbol table required to run the algorithm. The method\n     * starts from the second to last character of the pattern and moves to the\n     * left. When it meets a new character, it is by definition its rightmost\n     * occurrence and therefore puts the distance from the current index to the\n     * index of the last character into the table. If the character is already\n     * in the table, then it is not a rightmost occurrence, so it continues.\n     *\n     * @param pattern basis for the bad symbol table\n     * @return the bad symbol table\n     */\n    private static HashMap<Character, Integer> calcShiftValues(String pattern) {\n        patternLength = pattern.length();\n        HashMap<Character, Integer> table = new HashMap<>();\n\n        for (int i = pattern.length() - 2; i >= 0; i--) { // length - 2 is the index of the second to last character\n            char c = pattern.charAt(i);\n            int finalI = i;\n            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);\n        }\n\n        return table;\n    }\n\n    /**\n     * Helper function that uses the bad symbol shift table to return the\n     * appropriate shift value for a given character\n     *\n     * @param c character\n     * @return shift value that corresponds to the character argument\n     */\n    private static Integer getShiftValue(char c) {\n        if (shiftValues.get(c) != null) {\n            return shiftValues.get(c);\n        } else {\n            return patternLength;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\n/**\n * This class is not thread safe<br>\n * <br>\n * (From wikipedia) In computer science, the Boyer\u2013Moore\u2013Horspool algorithm or\n * Horspool's algorithm is an algorithm for finding substrings in strings. It\n * was published by Nigel Horspool in 1980.\n * <br>\n * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia\n * page</a><br>\n * <br>\n *\n * <p>\n * An explanation:<br>\n *\n * <p>\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\n * that it uses only one of the two heuristic methods for increasing the number\n * of characters shifted when finding a bad match in the text. This method is\n * usually called the \"bad symbol\" or \"bad character\" shift. The bad symbol\n * shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that\n * processing a given input to a problem and altering it in a specific way will\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\n * to match the pattern and text comparing the pattern symbols to the text's\n * from right to left.<br>\n * <br>\n *\n * <p>\n * In the bad symbol shift method, a table is created prior to the search,\n * called the \"bad symbol table\". The bad symbol table contains the shift values\n * for any symbol in the text and pattern. For these symbols, the value is the\n * length of the pattern, if the symbol is not in the first (length - 1) of the\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values\n * for the ones that exist in the first (length - 1) of the pattern.<br>\n * <br>\n *\n * <p>\n * For more details on the algorithm and the more advanced Boyer-Moore I\n * recommend checking out the wikipedia page and professor Anany Levitin's book:\n * Introduction To The Design And Analysis Of Algorithms.\n */\npublic class HorspoolSearch {\n\n    private static HashMap<Character, Integer> shiftValues; // bad symbol table\n    private static Integer patternLength;\n    private static int comparisons = 0; // total comparisons in the current/last search\n\n    /**\n     * Case sensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirst(String pattern, String text) {\n        return firstOccurrence(pattern, text, true);\n    }\n\n    /**\n     * Case insensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirstInsensitive(String pattern, String text) {\n        return firstOccurrence(pattern, text, false);\n    }\n\n    /**\n     * Utility method that returns comparisons made by last run (mainly for\n     * tests)\n     *\n     * @return number of character comparisons of the last search\n     */\n    public static Integer getLastComparisons() {\n        return HorspoolSearch.comparisons;\n    }\n\n    /**\n     * Fairly standard implementation of the Horspool algorithm. Only the index\n     * of the last character of the pattern on the text is saved and shifted by\n     * the appropriate amount when a mismatch is found. The algorithm stops at\n     * the first match or when the entire text has been exhausted.\n     *\n     * @param pattern String to be matched in the text\n     * @param text text String\n     * @return index of first occurrence of the pattern in the text\n     */\n    private static int firstOccurrence(String pattern, String text, boolean caseSensitive) {\n        shiftValues = calcShiftValues(pattern); // build the bad symbol table\n        comparisons = 0; // reset comparisons\n\n        if (pattern.length() == 0) { // return failure, if pattern empty\n            return -1;\n        }\n\n        int textIndex = pattern.length()\n            - 1; // align pattern with text start and get index of the last character\n\n        // while pattern is not out of text bounds\n        while (textIndex < text.length()) {\n            // try to match pattern with current part of the text starting from last character\n            int i = pattern.length() - 1;\n            while (i >= 0) {\n                comparisons++;\n                char patternChar = pattern.charAt(i);\n                char textChar = text.charAt((textIndex + i) - (pattern.length() - 1));\n                if (!charEquals(\n                        patternChar, textChar, caseSensitive)) { // bad character, shift pattern\n                    textIndex += getShiftValue(text.charAt(textIndex));\n                    break;\n                }\n                i--;\n            }\n\n            // check for full match\n            if (i == -1) {\n                return textIndex - pattern.length() + 1;\n            }\n        }\n\n        // text exhausted, return failure\n        return -1;\n    }\n\n    /**\n     * Compares the argument characters\n     *\n     * @param c1 first character\n     * @param c2 second character\n     * @param caseSensitive boolean determining case sensitivity of comparison\n     * @return truth value of the equality comparison\n     */\n    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {\n        if (caseSensitive) {\n            return c1 == c2;\n        }\n        return Character.toLowerCase(c1) == Character.toLowerCase(c2);\n    }\n\n    /**\n     * Builds the bad symbol table required to run the algorithm. The method\n     * starts from the second to last character of the pattern and moves to the\n     * left. When it meets a new character, it is by definition its rightmost\n     * occurrence and therefore puts the distance from the current index to the\n     * index of the last character into the table. If the character is already\n     * in the table, then it is not a rightmost occurrence, so it continues.\n     *\n     * @param pattern basis for the bad symbol table\n     * @return the bad symbol table\n     */\n    private static HashMap<Character, Integer> calcShiftValues(String pattern) {\n        patternLength = pattern.length();\n        HashMap<Character, Integer> table = new HashMap<>();\n\n        for (int i = pattern.length() - 2; i >= 0;\n             i--) { // length - 2 is the index of the second to last character\n            char c = pattern.charAt(i);\n            int finalI = i;\n            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);\n        }\n\n        return table;\n    }\n\n    /**\n     * Helper function that uses the bad symbol shift table to return the\n     * appropriate shift value for a given character\n     *\n     * @param c character\n     * @return shift value that corresponds to the character argument\n     */\n    private static Integer getShiftValue(char c) {\n        if (shiftValues.get(c) != null) {\n            return shiftValues.get(c);\n        } else {\n            return patternLength;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass HorspoolSearchTest {\n\n    @Test\n    void testFindFirstMatch() {\n        int index = HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstNotMatch() {\n        int index = HorspoolSearch.findFirst(\"hell\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternLongerText() {\n        int index = HorspoolSearch.findFirst(\"Hello World!!!\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"Hello\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternAndTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstSpecialCharacter() {\n        int index = HorspoolSearch.findFirst(\"$3**\", \"Hello $3**$ World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"hello\", \"Hello World\");\n        assertEquals(0, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveNotMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"helo\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testGetLastComparisons() {\n        HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(7, lastSearchNumber);\n    }\n\n    @Test\n    void testGetLastComparisonsNotMatch() {\n        HorspoolSearch.findFirst(\"Word\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(3, lastSearchNumber);\n    }\n\n    @Test\n    void testFindFirstPatternNull() {\n        assertThrows(NullPointerException.class,\n                () -> HorspoolSearch.findFirst(null, \"Hello World\"));\n    }\n\n    @Test\n    void testFindFirstTextNull() {\n        assertThrows(NullPointerException.class,\n                () -> HorspoolSearch.findFirst(\"Hello\", null));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HorspoolSearchTest {\n\n    @Test\n    void testFindFirstMatch() {\n        int index = HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstNotMatch() {\n        int index = HorspoolSearch.findFirst(\"hell\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternLongerText() {\n        int index = HorspoolSearch.findFirst(\"Hello World!!!\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"Hello\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternAndTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstSpecialCharacter() {\n        int index = HorspoolSearch.findFirst(\"$3**\", \"Hello $3**$ World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"hello\", \"Hello World\");\n        assertEquals(0, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveNotMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"helo\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testGetLastComparisons() {\n        HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(7, lastSearchNumber);\n    }\n\n    @Test\n    void testGetLastComparisonsNotMatch() {\n        HorspoolSearch.findFirst(\"Word\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(3, lastSearchNumber);\n    }\n\n    @Test\n    void testFindFirstPatternNull() {\n        assertThrows(\n            NullPointerException.class, () -> HorspoolSearch.findFirst(null, \"Hello World\"));\n    }\n\n    @Test\n    void testFindFirstTextNull() {\n        assertThrows(NullPointerException.class, () -> HorspoolSearch.findFirst(\"Hello\", null));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/LetterCombinationsOfPhoneNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/LetterCombinationsOfPhoneNumberTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.*;\n\npublic class LetterCombinationsOfPhoneNumber {\n\n    static Character[][] numberToCharMap;\n\n    protected static List<String> printWords(int[] numbers, int len, int numIndex, String s) {\n        if (len == numIndex) {\n            return new ArrayList<>(Collections.singleton(s));\n        }\n\n        List<String> stringList = new ArrayList<>();\n\n        for (int i = 0; i < numberToCharMap[numbers[numIndex]].length; i++) {\n            String sCopy = String.copyValueOf(s.toCharArray());\n            sCopy =\n                sCopy.concat(numberToCharMap[numbers[numIndex]][i].toString());\n            stringList.addAll(printWords(numbers, len, numIndex + 1, sCopy));\n        }\n        return stringList;\n    }\n\n    private static void printWords(int[] numbers) {\n        generateNumberToCharMap();\n        List<String> stringList = printWords(numbers, numbers.length, 0, \"\");\n        stringList.stream().forEach(System.out::println);\n    }\n\n    protected static void generateNumberToCharMap() {\n        numberToCharMap = new Character[10][5];\n        numberToCharMap[0] = new Character[] { '\\0' };\n        numberToCharMap[1] = new Character[] { '\\0' };\n        numberToCharMap[2] = new Character[] { 'a', 'b', 'c' };\n        numberToCharMap[3] = new Character[] { 'd', 'e', 'f' };\n        numberToCharMap[4] = new Character[] { 'g', 'h', 'i' };\n        numberToCharMap[5] = new Character[] { 'j', 'k', 'l' };\n        numberToCharMap[6] = new Character[] { 'm', 'n', 'o' };\n        numberToCharMap[7] = new Character[] { 'p', 'q', 'r', 's' };\n        numberToCharMap[8] = new Character[] { 't', 'u', 'v' };\n        numberToCharMap[9] = new Character[] { 'w', 'x', 'y', 'z' };\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int[] number = { 2, 3, 4 };\n        printWords(number);\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.*;\n\npublic class LetterCombinationsOfPhoneNumber {\n\n    static Character[][] numberToCharMap;\n\n    protected static List<String> printWords(int[] numbers, int len, int numIndex, String s) {\n        if (len == numIndex) {\n            return new ArrayList<>(Collections.singleton(s));\n        }\n\n        List<String> stringList = new ArrayList<>();\n\n        for (int i = 0; i < numberToCharMap[numbers[numIndex]].length; i++) {\n            String sCopy = String.copyValueOf(s.toCharArray());\n            sCopy = sCopy.concat(numberToCharMap[numbers[numIndex]][i].toString());\n            stringList.addAll(printWords(numbers, len, numIndex + 1, sCopy));\n        }\n        return stringList;\n    }\n\n    private static void printWords(int[] numbers) {\n        generateNumberToCharMap();\n        List<String> stringList = printWords(numbers, numbers.length, 0, \"\");\n        stringList.stream().forEach(System.out::println);\n    }\n\n    protected static void generateNumberToCharMap() {\n        numberToCharMap = new Character[10][5];\n        numberToCharMap[0] = new Character[] {'\\0'};\n        numberToCharMap[1] = new Character[] {'\\0'};\n        numberToCharMap[2] = new Character[] {'a', 'b', 'c'};\n        numberToCharMap[3] = new Character[] {'d', 'e', 'f'};\n        numberToCharMap[4] = new Character[] {'g', 'h', 'i'};\n        numberToCharMap[5] = new Character[] {'j', 'k', 'l'};\n        numberToCharMap[6] = new Character[] {'m', 'n', 'o'};\n        numberToCharMap[7] = new Character[] {'p', 'q', 'r', 's'};\n        numberToCharMap[8] = new Character[] {'t', 'u', 'v'};\n        numberToCharMap[9] = new Character[] {'w', 'x', 'y', 'z'};\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int[] number = {2, 3, 4};\n        printWords(number);\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport java.util.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class LetterCombinationsOfPhoneNumberTest {\n\n    @Test\n    public void letterCombinationsOfPhoneNumber() {\n        LetterCombinationsOfPhoneNumber ob = new LetterCombinationsOfPhoneNumber();\n        ob.generateNumberToCharMap();\n\n        // ** Test 1 **\n        // Input: digits = \"\"\n        // Output: []\n        int[] numbers1 = {};\n        List<String> output1 = Arrays.asList(\"\");\n        assertTrue(ob.printWords(numbers1, numbers1.length, 0, \"\").equals(output1));\n\n        // ** Test 2 **\n        // Input: digits = \"2\"\n        // Output: [\"a\",\"b\",\"c\"]\n        int[] numbers2 = { 2 };\n        List<String> output2 = Arrays.asList(\"a\", \"b\", \"c\");\n        assertTrue(ob.printWords(numbers2, numbers2.length, 0, \"\").equals(output2));\n\n        // ** Test 3 **\n        // Input: digits = \"23\"\n        // Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        int[] numbers3 = { 2, 3 };\n        List<String> output3 = Arrays.asList(\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\");\n        assertTrue(ob.printWords(numbers3, numbers3.length, 0, \"\").equals(output3));\n\n        // ** Test 4 **\n        // Input: digits = \"234\"\n        // Output: [\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\",\n        // \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\",\n        // \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]\n        int[] numbers4 = { 2, 3, 4 };\n        List<String> output4 = Arrays.asList(\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\",\n                \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\",\n                \"cfh\", \"cfi\");\n        assertTrue(ob.printWords(numbers4, numbers4.length, 0, \"\").equals(output4));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class LetterCombinationsOfPhoneNumberTest {\n\n    @Test\n    public void letterCombinationsOfPhoneNumber() {\n        LetterCombinationsOfPhoneNumber ob = new LetterCombinationsOfPhoneNumber();\n        ob.generateNumberToCharMap();\n\n        // ** Test 1 **\n        // Input: digits = \"\"\n        // Output: []\n        int[] numbers1 = {};\n        List<String> output1 = Arrays.asList(\"\");\n        assertTrue(ob.printWords(numbers1, numbers1.length, 0, \"\").equals(output1));\n\n        // ** Test 2 **\n        // Input: digits = \"2\"\n        // Output: [\"a\",\"b\",\"c\"]\n        int[] numbers2 = {2};\n        List<String> output2 = Arrays.asList(\"a\", \"b\", \"c\");\n        assertTrue(ob.printWords(numbers2, numbers2.length, 0, \"\").equals(output2));\n\n        // ** Test 3 **\n        // Input: digits = \"23\"\n        // Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        int[] numbers3 = {2, 3};\n        List<String> output3 = Arrays.asList(\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\");\n        assertTrue(ob.printWords(numbers3, numbers3.length, 0, \"\").equals(output3));\n\n        // ** Test 4 **\n        // Input: digits = \"234\"\n        // Output: [\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\",\n        // \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\",\n        // \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]\n        int[] numbers4 = {2, 3, 4};\n        List<String> output4 = Arrays.asList(\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\",\n            \"afi\", \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\",\n            \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\");\n        assertTrue(ob.printWords(numbers4, numbers4.length, 0, \"\").equals(output4));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Lower.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/LowerTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\npublic class Lower {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = { \"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\" };\n        for (String s : strings) {\n            assert toLowerCase(s).equals(s.toLowerCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */\n    public static String toLowerCase(String s) {\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (\n                Character.isLetter(values[i]) &&\n                Character.isUpperCase(values[i])\n            ) {\n                values[i] = Character.toLowerCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\npublic class Lower {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"};\n        for (String s : strings) {\n            assert toLowerCase(s).equals(s.toLowerCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */\n    public static String toLowerCase(String s) {\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n                values[i] = Character.toLowerCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LowerTest {\n    @Test\n    public void toLowerCase() {\n        String input1 = \"hello world\";\n        String input2 = \"HelLO WoRld\";\n        String input3 = \"HELLO WORLD\";\n        \n        assertEquals(\"hello world\", Lower.toLowerCase(input1));\n        assertEquals(\"hello world\", Lower.toLowerCase(input2));\n        assertEquals(\"hello world\", Lower.toLowerCase(input3));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LowerTest {\n    @Test\n    public void toLowerCase() {\n        String input1 = \"hello world\";\n        String input2 = \"HelLO WoRld\";\n        String input3 = \"HELLO WORLD\";\n\n        assertEquals(\"hello world\", Lower.toLowerCase(input1));\n        assertEquals(\"hello world\", Lower.toLowerCase(input2));\n        assertEquals(\"hello world\", Lower.toLowerCase(input3));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/MyAtoi.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/MyAtoiTest.java",
        "product_old_content": "// Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function). Here is my implementation\n\npackage com.thealgorithms.strings;\n\npublic class MyAtoi {\npublic static int myAtoi(String s) {\n        s = s.trim();\n        char[] char_1 = s.toCharArray();\n        String number = \"\";\n        boolean negative = false;\n        boolean zero = false;\n        boolean isDigit = false;\n\n        for (char ch : char_1) {\n            if (Character.isDigit(ch)) {\n                if (number.length() > 1 && !isDigit) {\n                    number = \"0\";\n                    break;\n                }\n                isDigit = true;\n                if (zero) {\n                    number = \"0\";\n                    break;\n                }\n                if(ch >= '0' && ch <= '9')\n                    number += ch;\n            } else if (ch == '-' && !isDigit) {\n                number += \"0\";\n                negative = true;\n            } else if (ch == '+' && !isDigit) {\n                number += \"0\";\n            } else if (ch == '.' && isDigit) {\n                break;\n            } else if (ch == '.') {\n                zero = true;\n            } else {\n                if (!isDigit) {\n                    number = \"0\";\n                }\n                break;\n            }\n        }\n    \n    if (!isDigit) {\n            return 0;\n        }\n    \n         number = number.replaceFirst(\"^0+(?!$)\", \"\");\n    \n    \n    if (number.length() > 10 && negative) {\n            return -2147483648;\n        } else if (number.length() > 10) {\n            return 2147483647;\n        } else if (number.length() == 10 && negative) {\n            double db1 = Double.parseDouble(number);\n            if (db1 >= 2147483648d) {\n                return -2147483648;\n            }\n        } else if (number.length() == 10) {\n            double db1 = Double.parseDouble(number);\n            if (db1 > (2147483647)) {\n                return 2147483647;\n            }\n        }\n\n    if(negative){\n        return Integer.parseInt(number)*-1;\n    }\n\n        return Integer.parseInt(number);\n    }\n}",
        "product_new_content": "// Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer\n// (similar to C/C++'s atoi function). Here is my implementation\n\npackage com.thealgorithms.strings;\n\npublic class MyAtoi {\n    public static int myAtoi(String s) {\n        s = s.trim();\n        char[] char_1 = s.toCharArray();\n        String number = \"\";\n        boolean negative = false;\n        boolean zero = false;\n        boolean isDigit = false;\n\n        for (char ch : char_1) {\n            if (Character.isDigit(ch)) {\n                if (number.length() > 1 && !isDigit) {\n                    number = \"0\";\n                    break;\n                }\n                isDigit = true;\n                if (zero) {\n                    number = \"0\";\n                    break;\n                }\n                if (ch >= '0' && ch <= '9') number += ch;\n            } else if (ch == '-' && !isDigit) {\n                number += \"0\";\n                negative = true;\n            } else if (ch == '+' && !isDigit) {\n                number += \"0\";\n            } else if (ch == '.' && isDigit) {\n                break;\n            } else if (ch == '.') {\n                zero = true;\n            } else {\n                if (!isDigit) {\n                    number = \"0\";\n                }\n                break;\n            }\n        }\n\n        if (!isDigit) {\n            return 0;\n        }\n\n        number = number.replaceFirst(\"^0+(?!$)\", \"\");\n\n        if (number.length() > 10 && negative) {\n            return -2147483648;\n        } else if (number.length() > 10) {\n            return 2147483647;\n        } else if (number.length() == 10 && negative) {\n            double db1 = Double.parseDouble(number);\n            if (db1 >= 2147483648d) {\n                return -2147483648;\n            }\n        } else if (number.length() == 10) {\n            double db1 = Double.parseDouble(number);\n            if (db1 > (2147483647)) {\n                return 2147483647;\n            }\n        }\n\n        if (negative) {\n            return Integer.parseInt(number) * -1;\n        }\n\n        return Integer.parseInt(number);\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MyAtoiTest {\n\t\n    @Test\n    void testOne() {\n        assertEquals(42, MyAtoi.myAtoi(\"42\"));\n    }\n  \n    @Test\n    void testTwo() {\n        assertEquals(-42, MyAtoi.myAtoi(\"   -42\"));\n    }\n  \n    @Test\n    void testThree() {\n        assertEquals(4193, MyAtoi.myAtoi(\"4193 with words\"));\n    }\n\t\n    @Test\n    void testFour() {\n        assertEquals(0, MyAtoi.myAtoi(\"0\"));\n    }\n\n    @Test\n    void testFive() {\n        assertEquals(5678, MyAtoi.myAtoi(\"5678\"));\n    }\n\n    @Test\n    void testSix() {\n        assertEquals(42, MyAtoi.myAtoi(\"+42\"));\n    }\n\n    @Test\n    void testSeven() {\n        assertEquals(0, MyAtoi.myAtoi(\"  +0   \"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MyAtoiTest {\n\n    @Test\n    void testOne() {\n        assertEquals(42, MyAtoi.myAtoi(\"42\"));\n    }\n\n    @Test\n    void testTwo() {\n        assertEquals(-42, MyAtoi.myAtoi(\"   -42\"));\n    }\n\n    @Test\n    void testThree() {\n        assertEquals(4193, MyAtoi.myAtoi(\"4193 with words\"));\n    }\n\n    @Test\n    void testFour() {\n        assertEquals(0, MyAtoi.myAtoi(\"0\"));\n    }\n\n    @Test\n    void testFive() {\n        assertEquals(5678, MyAtoi.myAtoi(\"5678\"));\n    }\n\n    @Test\n    void testSix() {\n        assertEquals(42, MyAtoi.myAtoi(\"+42\"));\n    }\n\n    @Test\n    void testSeven() {\n        assertEquals(0, MyAtoi.myAtoi(\"  +0   \"));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Palindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PalindromeTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Check if a string is palindrome string or not using String Builder\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return (\n            (s == null || s.length() <= 1) ||\n            s.equals(new StringBuilder(s).reverse().toString())\n        );\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindromeRecursion(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using two pointer technique\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeTwoPointer(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Check if a string is palindrome string or not using String Builder\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return (\n            (s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString()));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindromeRecursion(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using two pointer technique\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeTwoPointer(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n\n    @Test\n    public void palindrome() {\n\n        String[] palindromes = { null, \"\", \"aba\", \"123321\", \"kayak\" };\n        for (String s : palindromes) {\n            Assertions.assertTrue(Palindrome.isPalindrome(s) &&\n            Palindrome.isPalindromeRecursion(s) &&\n            Palindrome.isPalindromeTwoPointer(s));\n        }\n\n        String[] notPalindromes = { \"abb\", \"abc\", \"abc123\", \"kayaks\" };\n        for (String s : notPalindromes) {\n            Assertions.assertFalse(Palindrome.isPalindrome(s) ||\n            Palindrome.isPalindromeRecursion(s) ||\n            Palindrome.isPalindromeTwoPointer(s));\n        }\n        \n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n\n    @Test\n    public void palindrome() {\n\n        String[] palindromes = {null, \"\", \"aba\", \"123321\", \"kayak\"};\n        for (String s : palindromes) {\n            Assertions.assertTrue(Palindrome.isPalindrome(s) && Palindrome.isPalindromeRecursion(s)\n                && Palindrome.isPalindromeTwoPointer(s));\n        }\n\n        String[] notPalindromes = {\"abb\", \"abc\", \"abc123\", \"kayaks\"};\n        for (String s : notPalindromes) {\n            Assertions.assertFalse(Palindrome.isPalindrome(s) || Palindrome.isPalindromeRecursion(s)\n                || Palindrome.isPalindromeTwoPointer(s));\n        }\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Pangram.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PangramTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Checks if a String is Pangram or not by checking if each alhpabet is present or not\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram2(String s) {\n        if (s.length() < 26) {\n            return false;\n        }\n        s = s.toLowerCase(); // Converting s to Lower-Case\n        for (char i = 'a'; i <= 'z'; i++) {\n            if (s.indexOf(i) == -1) {\n                return false; // if any alphabet is not present, return false\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if a String is Pangram or not by checking if each alhpabet is present or not\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram2(String s) {\n        if (s.length() < 26) {\n            return false;\n        }\n        s = s.toLowerCase(); // Converting s to Lower-Case\n        for (char i = 'a'; i <= 'z'; i++) {\n            if (s.indexOf(i) == -1) {\n                return false; // if any alphabet is not present, return false\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class PangramTest {\n\n    @Test\n    public void testPangram() {\n        assertTrue(Pangram.isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n        \n        assertTrue(Pangram.isPangram2(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram2(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram2(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram2(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PangramTest {\n\n    @Test\n    public void testPangram() {\n        assertTrue(Pangram.isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(\n            Pangram.isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n\n        assertTrue(Pangram.isPangram2(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(\n            Pangram.isPangram2(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram2(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram2(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/ReverseStringRecursive.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/ReverseStringRecursiveTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Reverse String using Recursion\n */\n\npublic class ReverseStringRecursive {\n    /**\n     * @param str string to be reversed\n     * @return reversed string\n     */\n    public static String reverse(String str)\n    {\n        if(str.isEmpty()){\n            return str;\n        } else {\n            return reverse(str.substring(1))+str.charAt(0);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Reverse String using Recursion\n */\n\npublic class ReverseStringRecursive {\n    /**\n     * @param str string to be reversed\n     * @return reversed string\n     */\n    public static String reverse(String str) {\n        if (str.isEmpty()) {\n            return str;\n        } else {\n            return reverse(str.substring(1)) + str.charAt(0);\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ReverseStringRecursiveTest {\n    ReverseStringRecursive stringRecursive = new ReverseStringRecursive();\n\n    @Test\n    void shouldAcceptWhenEmptyStringIsPassed() {\n        String expected = \"\";\n        String reversed  = stringRecursive.reverse(\"\");\n\n        assertEquals(expected,reversed);\n    }\n\n    @Test\n    void shouldAcceptNotWhenWhenSingleCharacterIsPassed() {\n        String expected = \"a\";\n        String reversed  = stringRecursive.reverse(\"a\");\n\n        assertEquals(expected,reversed);\n    }\n\n    @Test\n    void shouldAcceptWhenStringIsPassed() {\n        String expected = \"dlroWolleH\";\n        String reversed  = stringRecursive.reverse(\"HelloWorld\");\n\n        assertEquals(expected,reversed);\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ReverseStringRecursiveTest {\n    ReverseStringRecursive stringRecursive = new ReverseStringRecursive();\n\n    @Test\n    void shouldAcceptWhenEmptyStringIsPassed() {\n        String expected = \"\";\n        String reversed = stringRecursive.reverse(\"\");\n\n        assertEquals(expected, reversed);\n    }\n\n    @Test\n    void shouldAcceptNotWhenWhenSingleCharacterIsPassed() {\n        String expected = \"a\";\n        String reversed = stringRecursive.reverse(\"a\");\n\n        assertEquals(expected, reversed);\n    }\n\n    @Test\n    void shouldAcceptWhenStringIsPassed() {\n        String expected = \"dlroWolleH\";\n        String reversed = stringRecursive.reverse(\"HelloWorld\");\n\n        assertEquals(expected, reversed);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/StringCompression.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/StringCompressionTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n/*  References : https://en.wikipedia.org/wiki/Run-length_encoding\n * String compression algorithm deals with encoding the string, that is, shortening the size of the string\n * @author Swarga-codes (https://github.com/Swarga-codes)\n*/\npublic class StringCompression {\n  /**\n   * Returns the compressed or encoded string\n   * \n   * @param ch character array that contains the group of characters to be encoded\n   * @return the compressed character array as string\n   */\n  public static String compress(String input) {\n    // Keeping the count as 1 since every element present will have atleast a count\n    // of 1\n    int count = 1;\n    String compressedString = \"\";\n    // Base condition to check whether the array is of size 1, if it is then we\n    // return the array\n    if (input.length() == 1) {\n      return \"\" + input.charAt(0);\n    }\n    // If the array has a length greater than 1 we move into this loop\n    for (int i = 0; i < input.length() - 1; i++) {\n      // here we check for similarity of the adjacent elements and change the count\n      // accordingly\n      if (input.charAt(i) == input.charAt(i + 1)) {\n        count = count + 1;\n      }\n      if ((i + 1) == input.length() - 1 && input.charAt(i + 1) == input.charAt(i)) {\n        compressedString = appendCount(compressedString, count, input.charAt(i));\n        break;\n      } else if (input.charAt(i) != input.charAt(i+1)) {\n        if ((i + 1) == input.length() - 1) {\n          compressedString = appendCount(compressedString, count, input.charAt(i)) + input.charAt(i+1);\n          break;\n        } else {\n          compressedString = appendCount(compressedString, count, input.charAt(i));\n          count = 1;\n        }\n      }\n    }\n    return compressedString;\n  }\n  /**\n   * @param res   the resulting string\n   * @param count current count\n   * @param ch    the character at a particular index\n   * @return the res string appended with the count\n   */\n  public static String appendCount(String res, int count, char ch) {\n    if (count > 1) {\n      res += ch + \"\" + count;\n      count = 1;\n    } else {\n      res += ch + \"\";\n    }\n    return res;\n  }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n/*  References : https://en.wikipedia.org/wiki/Run-length_encoding\n * String compression algorithm deals with encoding the string, that is, shortening the size of the\n * string\n * @author Swarga-codes (https://github.com/Swarga-codes)\n */\npublic class StringCompression {\n    /**\n     * Returns the compressed or encoded string\n     *\n     * @param ch character array that contains the group of characters to be encoded\n     * @return the compressed character array as string\n     */\n    public static String compress(String input) {\n        // Keeping the count as 1 since every element present will have atleast a count\n        // of 1\n        int count = 1;\n        String compressedString = \"\";\n        // Base condition to check whether the array is of size 1, if it is then we\n        // return the array\n        if (input.length() == 1) {\n            return \"\" + input.charAt(0);\n        }\n        // If the array has a length greater than 1 we move into this loop\n        for (int i = 0; i < input.length() - 1; i++) {\n            // here we check for similarity of the adjacent elements and change the count\n            // accordingly\n            if (input.charAt(i) == input.charAt(i + 1)) {\n                count = count + 1;\n            }\n            if ((i + 1) == input.length() - 1 && input.charAt(i + 1) == input.charAt(i)) {\n                compressedString = appendCount(compressedString, count, input.charAt(i));\n                break;\n            } else if (input.charAt(i) != input.charAt(i + 1)) {\n                if ((i + 1) == input.length() - 1) {\n                    compressedString = appendCount(compressedString, count, input.charAt(i))\n                        + input.charAt(i + 1);\n                    break;\n                } else {\n                    compressedString = appendCount(compressedString, count, input.charAt(i));\n                    count = 1;\n                }\n            }\n        }\n        return compressedString;\n    }\n    /**\n     * @param res   the resulting string\n     * @param count current count\n     * @param ch    the character at a particular index\n     * @return the res string appended with the count\n     */\n    public static String appendCount(String res, int count, char ch) {\n        if (count > 1) {\n            res += ch + \"\" + count;\n            count = 1;\n        } else {\n            res += ch + \"\";\n        }\n        return res;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\npublic class StringCompressionTest {\n    @ParameterizedTest\n    @CsvSource({\"a,a\",\"aabbb,a2b3\",\"abbbc,ab3c\",\"aabccd,a2bc2d\"})\n    void stringCompressionTest(String input,String expectedOutput){\n        String output=StringCompression.compress(input);\n        assertEquals(expectedOutput, output);\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\npublic class StringCompressionTest {\n    @ParameterizedTest\n    @CsvSource({\"a,a\", \"aabbb,a2b3\", \"abbbc,ab3c\", \"aabccd,a2bc2d\"})\n    void stringCompressionTest(String input, String expectedOutput) {\n        String output = StringCompression.compress(input);\n        assertEquals(expectedOutput, output);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/ValidParentheses.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/ValidParenthesesTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n//        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n//        An input string is valid if:\n//        Open brackets must be closed by the same type of brackets.\n//        Open brackets must be closed in the correct order.\n//        Every close bracket has a corresponding open bracket of the same type.\n\n\npublic class ValidParentheses {\n\tpublic static boolean isValid(String s) {\n\t\tchar[] stack = new char[s.length()];\n\t\tint head = 0;\n\t\tfor(char c : s.toCharArray()) {\n\t\t\tswitch(c) {\n\t\t\t\tcase '{':\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstack[head++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif(head == 0 || stack[--head] != '{') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tif(head == 0 || stack[--head] != '(') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tif(head == 0 || stack[--head] != '[') return false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn head == 0;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.strings;\n//        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine\n//        if the input string is valid. An input string is valid if: Open brackets must be closed by\n//        the same type of brackets. Open brackets must be closed in the correct order. Every close\n//        bracket has a corresponding open bracket of the same type.\n\npublic class ValidParentheses {\n    public static boolean isValid(String s) {\n        char[] stack = new char[s.length()];\n        int head = 0;\n        for (char c : s.toCharArray()) {\n            switch (c) {\n            case '{':\n            case '[':\n            case '(':\n                stack[head++] = c;\n                break;\n            case '}':\n                if (head == 0 || stack[--head] != '{') return false;\n                break;\n            case ')':\n                if (head == 0 || stack[--head] != '(') return false;\n                break;\n            case ']':\n                if (head == 0 || stack[--head] != '[') return false;\n                break;\n            }\n        }\n        return head == 0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ValidParenthesesTest {\n\t\n    @Test\n    void testOne() {\n        assertEquals(true, ValidParentheses.isValid(\"()\"));\n    }\n  \n    @Test\n    void testTwo() {\n        assertEquals(true, ValidParentheses.isValid(\"()[]{}\"));\n    }\n  \n  \n    @Test\n    void testThree() {\n        assertEquals(false, ValidParentheses.isValid(\"(]\"));\n    }\n\t\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ValidParenthesesTest {\n\n    @Test\n    void testOne() {\n        assertEquals(true, ValidParentheses.isValid(\"()\"));\n    }\n\n    @Test\n    void testTwo() {\n        assertEquals(true, ValidParentheses.isValid(\"()[]{}\"));\n    }\n\n    @Test\n    void testThree() {\n        assertEquals(false, ValidParentheses.isValid(\"(]\"));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/WordLadder.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/WordLadderTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/*\n    **Problem Statement:**\n    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\n    Every adjacent pair of words differs by a single letter.\n    Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n    sk == endWord\n    Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\n    **Example 1:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    Output: 5 \n    Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n    **Example 2:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    Output: 0\n    Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n    **Constraints:**\n    1 <= beginWord.length <= 10\n    endWord.length == beginWord.length\n    1 <= wordList.length <= 5000\n    wordList[i].length == beginWord.length\n    beginWord, endWord, and wordList[i] consist of lowercase English letters.\n    beginWord != endWord\n    All the words in wordList are unique.\n */\n\nclass WordLadder {\n\n    /**\n     * This function finds the ladderLength\n     *\n     * @param beginWord: Starting word of the ladder\n     * @param endWord: Ending word of the ladder\n     * @param wordList: This list contains the words which needs to be included\n     * in ladder.\n     * @return ladderLength: This function will return the ladderLength(level)\n     * if the endword is there. Otherwise, will return the length as 0.\n     */\n    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> set = new HashSet(wordList);\n\n        if (!set.contains(endWord)) {\n            return 0;\n        }\n\n        Queue<String> queue = new LinkedList();\n        queue.offer(beginWord);\n        int level = 1;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String curr = queue.poll();\n                char[] words_chars = curr.toCharArray();\n                for (int j = 0; j < words_chars.length; j++) {\n                    char original_chars = words_chars[j];\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (words_chars[j] == c) {\n                            continue;\n                        }\n                        words_chars[j] = c;\n                        String new_word = String.valueOf(words_chars);\n                        if (new_word.equals(endWord)) {\n                            return level + 1;\n                        }\n                        if (set.contains(new_word)) {\n                            set.remove(new_word);\n                            queue.offer(new_word);\n                        }\n                    }\n                    words_chars[j] = original_chars;\n                }\n            }\n            level++;\n        }\n        return 0;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/*\n    **Problem Statement:**\n    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a\n   sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\n    Every adjacent pair of words differs by a single letter.\n    Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n    sk == endWord\n    Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in\n   the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\n    **Example 1:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    Output: 5\n    Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\",\n   which is 5 words long.\n\n    **Example 2:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    Output: 0\n    Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation\n   sequence.\n\n    **Constraints:**\n    1 <= beginWord.length <= 10\n    endWord.length == beginWord.length\n    1 <= wordList.length <= 5000\n    wordList[i].length == beginWord.length\n    beginWord, endWord, and wordList[i] consist of lowercase English letters.\n    beginWord != endWord\n    All the words in wordList are unique.\n */\n\nclass WordLadder {\n\n    /**\n     * This function finds the ladderLength\n     *\n     * @param beginWord: Starting word of the ladder\n     * @param endWord: Ending word of the ladder\n     * @param wordList: This list contains the words which needs to be included\n     * in ladder.\n     * @return ladderLength: This function will return the ladderLength(level)\n     * if the endword is there. Otherwise, will return the length as 0.\n     */\n    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> set = new HashSet(wordList);\n\n        if (!set.contains(endWord)) {\n            return 0;\n        }\n\n        Queue<String> queue = new LinkedList();\n        queue.offer(beginWord);\n        int level = 1;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String curr = queue.poll();\n                char[] words_chars = curr.toCharArray();\n                for (int j = 0; j < words_chars.length; j++) {\n                    char original_chars = words_chars[j];\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (words_chars[j] == c) {\n                            continue;\n                        }\n                        words_chars[j] = c;\n                        String new_word = String.valueOf(words_chars);\n                        if (new_word.equals(endWord)) {\n                            return level + 1;\n                        }\n                        if (set.contains(new_word)) {\n                            set.remove(new_word);\n                            queue.offer(new_word);\n                        }\n                    }\n                    words_chars[j] = original_chars;\n                }\n            }\n            level++;\n        }\n        return 0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.util.*;\n\npublic class WordLadderTest {\n\n    @Test\n    public void testWordLadder() {\n       \n        /**\n         * Test 1:\n         * Input: beginWord = \"hit\", endWord = \"cog\", wordList =\n         * [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n         * Output: 5\n         * Explanation: One shortest transformation sequence is\n         * \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\"\n         * which is 5 words long.\n         */\n\n        List<String> wordList1 = Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\");\n        assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList1), 5);\n\n        /**\n         * Test 2:\n         * Input: beginWord = \"hit\", endWord = \"cog\", wordList =\n         * [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n         * Output: 0\n         * Explanation: The endWord \"cog\" is not in wordList,\n         * therefore there is no valid transformation sequence.\n         */\n\n        List<String> wordList2 = Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\");\n        assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList2), 0);\n\n     }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class WordLadderTest {\n\n    @Test\n    public void testWordLadder() {\n\n        /**\n         * Test 1:\n         * Input: beginWord = \"hit\", endWord = \"cog\", wordList =\n         * [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n         * Output: 5\n         * Explanation: One shortest transformation sequence is\n         * \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\"\n         * which is 5 words long.\n         */\n\n        List<String> wordList1 = Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\");\n        assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList1), 5);\n\n        /**\n         * Test 2:\n         * Input: beginWord = \"hit\", endWord = \"cog\", wordList =\n         * [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n         * Output: 0\n         * Explanation: The endWord \"cog\" is not in wordList,\n         * therefore there is no valid transformation sequence.\n         */\n\n        List<String> wordList2 = Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\");\n        assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList2), 0);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/longestNonRepeativeSubstring.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/longestNonRepeativeSubstringTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\nclass longestNonRepeativeSubstring {\n\n    public static int lengthOfLongestSubstring(String s) {\n        int max = 0, start = 0, i = 0;\n        HashMap<Character, Integer> map = new HashMap<>();\n\n        while (i < s.length()) {\n            char temp = s.charAt(i);\n\n            // adding key to map if not present\n            if (!map.containsKey(temp)) map.put(temp, 0);\n            // checking if the first value is the dublicate value\n            else if (s.charAt(start) == temp) start++;\n            // checking if the previous value is dublicate value\n            else if (s.charAt(i - 1) == temp) {\n                if (max < map.size()) max = map.size();\n                map = new HashMap<>();\n                start = i;\n                i--;\n            }\n            // last possible place where dublicate value can be is between start and i\n            else {\n                if (max < map.size()) max = map.size();\n                while (s.charAt(start) != temp) {\n                    map.remove(s.charAt(start));\n                    start++;\n                }\n                start++;\n            }\n\n            i++;\n        }\n        if (max < map.size()) max = map.size();\n        return max;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\nclass longestNonRepeativeSubstring {\n\n    public static int lengthOfLongestSubstring(String s) {\n        int max = 0, start = 0, i = 0;\n        HashMap<Character, Integer> map = new HashMap<>();\n\n        while (i < s.length()) {\n            char temp = s.charAt(i);\n\n            // adding key to map if not present\n            if (!map.containsKey(temp)) map.put(temp, 0);\n            // checking if the first value is the dublicate value\n            else if (s.charAt(start) == temp)\n                start++;\n            // checking if the previous value is dublicate value\n            else if (s.charAt(i - 1) == temp) {\n                if (max < map.size()) max = map.size();\n                map = new HashMap<>();\n                start = i;\n                i--;\n            }\n            // last possible place where dublicate value can be is between start and i\n            else {\n                if (max < map.size()) max = map.size();\n                while (s.charAt(start) != temp) {\n                    map.remove(s.charAt(start));\n                    start++;\n                }\n                start++;\n            }\n\n            i++;\n        }\n        if (max < map.size()) max = map.size();\n        return max;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class longestNonRepeativeSubstringTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorld\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals(\n            longestNonRepeativeSubstring.lengthOfLongestSubstring(input1),\n            5\n        );\n        Assertions.assertEquals(\n            longestNonRepeativeSubstring.lengthOfLongestSubstring(input2),\n            9\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class longestNonRepeativeSubstringTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorld\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals(longestNonRepeativeSubstring.lengthOfLongestSubstring(input1), 5);\n        Assertions.assertEquals(longestNonRepeativeSubstring.lengthOfLongestSubstring(input2), 9);\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/strings/zigZagPattern/zigZagPattern.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/zigZagPattern/zigZagPatternTest.java",
        "product_old_content": "package com.thealgorithms.strings.zigZagPattern;\n\nclass zigZagPattern {\n\n    public static String encode(String s, int numRows) {\n        if (numRows < 2 || s.length() < numRows) return s;\n        int start = 0, index = 0, height = 1, depth = numRows;\n        char[] zigZagedArray = new char[s.length()];\n        while (depth != 0) {\n            int pointer = start, height_space =\n                2 + ((height - 2) * 2), depth_space = 2 + ((depth - 2) * 2);\n            boolean bool = true;\n            while (pointer < s.length()) {\n                zigZagedArray[index++] = s.charAt(pointer);\n                if (height_space == 0) pointer += depth_space; else if (\n                    depth_space == 0\n                ) pointer += height_space; else if (bool) {\n                    pointer += depth_space;\n                    bool = false;\n                } else {\n                    pointer += height_space;\n                    bool = true;\n                }\n            }\n            height++;\n            depth--;\n            start++;\n        }\n        return new String(zigZagedArray);\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings.zigZagPattern;\n\nclass zigZagPattern {\n\n    public static String encode(String s, int numRows) {\n        if (numRows < 2 || s.length() < numRows) return s;\n        int start = 0, index = 0, height = 1, depth = numRows;\n        char[] zigZagedArray = new char[s.length()];\n        while (depth != 0) {\n            int pointer = start, height_space = 2 + ((height - 2) * 2),\n                depth_space = 2 + ((depth - 2) * 2);\n            boolean bool = true;\n            while (pointer < s.length()) {\n                zigZagedArray[index++] = s.charAt(pointer);\n                if (height_space == 0)\n                    pointer += depth_space;\n                else if (depth_space == 0)\n                    pointer += height_space;\n                else if (bool) {\n                    pointer += depth_space;\n                    bool = false;\n                } else {\n                    pointer += height_space;\n                    bool = true;\n                }\n            }\n            height++;\n            depth--;\n            start++;\n        }\n        return new String(zigZagedArray);\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings.zigZagPattern;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class zigZagPatternTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorldFromJava\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals(\n            zigZagPattern.encode(input1, 4),\n            \"HooeWrrmalolFJvlda\"\n        );\n        Assertions.assertEquals(\n            zigZagPattern.encode(input2, 4),\n            \"jAaLgasPrmgaaevIrgmnnuaoig\"\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings.zigZagPattern;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class zigZagPatternTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorldFromJava\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals(zigZagPattern.encode(input1, 4), \"HooeWrrmalolFJvlda\");\n        Assertions.assertEquals(zigZagPattern.encode(input2, 4), \"jAaLgasPrmgaaevIrgmnnuaoig\");\n    }\n}"
    },
    {
        "product_commit": "ad03086f547854a4c00b1e3a85dde5d315f119b6",
        "test_commit": "ad03086f547854a4c00b1e3a85dde5d315f119b6",
        "product_file_path": "src/main/java/com/thealgorithms/others/CountWords.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/CountWordsTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\n\n/**\n * You enter a string into this program, and it will return how many words were\n * in that particular string\n *\n * @author Marcus\n */\npublic class CountWords {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Enter your text: \");\n        String str = input.nextLine();\n\n        System.out.println(\"Your text has \" + wordCount(str) + \" word(s)\");\n        System.out.println(\n            \"Your text has \" + secondaryWordCount(str) + \" word(s)\"\n        );\n        input.close();\n    }\n\n    private static int wordCount(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        return s.trim().split(\"[\\\\s]+\").length;\n    }\n\n    /**\n     * counts the number of words in a sentence but ignores all potential\n     * non-alphanumeric characters that do not represent a word. runs in O(n)\n     * where n is the length of s\n     *\n     * @param s String: sentence with word(s)\n     * @return int: number of words\n     */\n    private static int secondaryWordCount(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c) || Character.isDigit(c)) {\n                sb.append(c);\n            }\n        }\n        s = sb.toString();\n        return s.trim().split(\"[\\\\s]+\").length;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\n\n/**\n * @author Marcus\n */\nfinal public class CountWords {\n    private CountWords() {\n    }\n\n    /**\n     * @brief counts the number of words in the input string\n     * @param s the input string\n     * @return the number of words in the input string\n     */\n    public static int wordCount(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        return s.trim().split(\"[\\\\s]+\").length;\n    }\n\n    private static String removeSpecialCharacters(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetterOrDigit(c) || Character.isWhitespace(c)) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * counts the number of words in a sentence but ignores all potential\n     * non-alphanumeric characters that do not represent a word. runs in O(n)\n     * where n is the length of s\n     *\n     * @param s String: sentence with word(s)\n     * @return int: number of words\n     */\n    public static int secondaryWordCount(String s) {\n        if (s == null) {\n            return 0;\n        }\n        return wordCount(removeSpecialCharacters(s));\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\n\nclass CountWordsTest {\n    @Test\n    public void testWordCount() {\n        HashMap<String, Integer> testCases = new HashMap<>();\n        testCases.put(\"\", 0);\n        testCases.put(null, 0);\n        testCases.put(\"aaaa bbb cccc\", 3);\n        testCases.put(\"note  extra     spaces   here\", 4);\n        testCases.put(\" a  b c d  e    \", 5);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(CountWords.wordCount(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testSecondaryWordCount() {\n        HashMap<String, Integer> testCases = new HashMap<>();\n        testCases.put(\"\", 0);\n        testCases.put(null, 0);\n        testCases.put(\"aaaa bbb cccc\", 3);\n        testCases.put(\"this-is-one-word!\", 1);\n        testCases.put(\"What, about, this? Hmmm----strange\", 4);\n        testCases.put(\"word1 word-2 word-3- w?o,r.d.@!@#$&*()<>4\", 4);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(CountWords.secondaryWordCount(tc.getKey()), tc.getValue());\n        }\n    }\n}"
    },
    {
        "product_commit": "22002c9939fdeff1d7ef659a688ad7f396dd564a",
        "test_commit": "22002c9939fdeff1d7ef659a688ad7f396dd564a",
        "product_file_path": "src/main/java/com/thealgorithms/maths/NthUglyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/NthUglyNumberTest.java",
        "product_old_content": "// Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \u2026 shows the first 11 ugly numbers.\n// By convention, 1 is included.\n// A program to find the nth Ugly number\n// Algorithm :\n// Initialize three-pointers two, three, and five pointing to zero.\n// Take 3 variables nm2, nm3, and nm5 to keep track of next multiple of 2,3 and 5.\n// Make an array of size n to store the ugly numbers with 1 at 0th index.\n// Initialize a variable next which stores the value of the last element in the array.\n// Run a loop n-1 times and perform steps 6,7 and 8.\n// Update the values of nm2, nm3, nm5 as ugly[two]*2, ugly[three]*3, ugly[5]*5 respectively.\n// Select the minimum value from nm2, nm3, and nm5 and increment the pointer related to it.\n// Store the minimum value in variable next and array.\n// Return next.\npackage com.thealgorithms.maths;\n\nimport java.util.*;\n\nclass NthUglyNumber {\n\n    /* Function to get the nth ugly number*/\n    public long getNthUglyNo(int n) {\n        long[] ugly = new long[n];\n        int two = 0, three = 0, five = 0;\n        long nm2 = 2, nm3 = 3, nm5 = 5;\n        long next = 1;\n\n        ugly[0] = 1;\n\n        for (int i = 1; i < n; i++) {\n            next = Math.min(nm2, Math.min(nm3, nm5));\n\n            ugly[i] = next;\n            if (next == nm2) {\n                two = two + 1;\n                nm2 = ugly[two] * 2;\n            }\n            if (next == nm3) {\n                three = three + 1;\n                nm3 = ugly[three] * 3;\n            }\n            if (next == nm5) {\n                five = five + 1;\n                nm5 = ugly[five] * 5;\n            }\n        }\n        return next;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the value of n : \");\n        int n = sc.nextInt();\n        NthUglyNumber ob = new NthUglyNumber();\n        long ugly = ob.getNthUglyNo(n);\n        System.out.println(\"nth Ugly number is : \" + ugly);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.lang.IllegalArgumentException;\n\n\n/**\n * @brief class computing the n-th ugly number (when they are sorted)\n * @details the ugly numbers with base [2, 3, 5] are all numbers of the form 2^a*3^b^5^c,\n *   where the exponents a, b, c are non-negative integers.\n *   Some properties of ugly numbers:\n *     - base [2, 3, 5] ugly numbers are the 5-smooth numbers, cf. https://oeis.org/A051037\n *     - base [2, 3, 5, 7] ugly numbers are 7-smooth numbers, cf. https://oeis.org/A002473\n *     - base [2] ugly numbers are the non-negative powers of 2,\n *     - the base [2, 3, 5] ugly numbers are the same as base [5, 6, 2, 3, 5] ugly numbers\n */\npublic class NthUglyNumber {\n    ArrayList<Long> uglyNumbers = new ArrayList<>(Arrays.asList(1L));\n    final int[] baseNumbers;\n    HashMap<Integer, Integer> positions = new HashMap<>();\n\n    /**\n     * @brief initialized the object allowing to compute ugly numbers with given base\n     * @param baseNumbers the given base of ugly numbers\n     * @exception IllegalArgumentException baseNumber is empty\n     */\n    NthUglyNumber(int[] baseNumbers) {\n        if (baseNumbers.length == 0) {\n            throw new IllegalArgumentException(\"baseNumbers must be non-empty.\");\n        }\n\n        this.baseNumbers = baseNumbers;\n        for (final var baseNumber : baseNumbers) {\n            this.positions.put(baseNumber, 0);\n        }\n    }\n\n    /**\n     * @param n the zero-based-index of the queried ugly number\n     * @exception IllegalArgumentException n is negative\n     * @return the n-th ugly number (starting from index 0)\n     */\n    public Long get(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative.\");\n        }\n\n        while (uglyNumbers.size() <= n) {\n            addUglyNumber();\n        }\n\n        return uglyNumbers.get(n);\n    }\n\n    private void addUglyNumber() {\n        uglyNumbers.add(computeMinimalCandidate());\n        updatePositions();\n    }\n\n    private void updatePositions() {\n        final var lastUglyNumber = uglyNumbers.get(uglyNumbers.size() - 1);\n        for (final var baseNumber : baseNumbers) {\n            if (computeCandidate(baseNumber) == lastUglyNumber) {\n                positions.put(baseNumber, positions.get(baseNumber) + 1);\n            }\n        }\n    }\n\n    private long computeCandidate(int candidateBase) {\n        return candidateBase * uglyNumbers.get(positions.get(candidateBase));\n    }\n\n    private long computeMinimalCandidate() {\n        long res = Long.MAX_VALUE;\n        for (final var baseNumber : baseNumbers) {\n            res = Math.min(res, computeCandidate(baseNumber));\n        }\n        return res;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\n\nimport org.junit.jupiter.api.Test;\n\npublic class NthUglyNumberTest {\n    @Test\n    public void testGetWithNewObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(9, 12L);\n        testCases.put(19, 36L);\n        testCases.put(52, 270L);\n        testCases.put(1078, 84934656L);\n        testCases.put(1963, 6973568802L);\n\n        for (final var tc : testCases.entrySet()) {\n            var uglyNumbers = new NthUglyNumber(new int[] {2, 3, 5});\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n\n            var otherUglyNumbers = new NthUglyNumber(new int[] {5, 25, 6, 2, 3, 5});\n            assertEquals(otherUglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testGetWithSameObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(6, 7L);\n        testCases.put(1499, 1984500L);\n        testCases.put(1572, 2449440L);\n        testCases.put(1658, 3072000L);\n        testCases.put(6625, 4300800000L);\n\n        var uglyNumbers = new NthUglyNumber(new int[] {7, 2, 5, 3});\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n        \n        assertEquals(uglyNumbers.get(999), 385875);\n    }\n\n    @Test\n    public void testGetWithBase1() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1});\n        assertEquals(uglyNumbers.get(10), 1);\n    }\n\n    @Test\n    public void testGetWithBase2() {\n        var uglyNumbers = new NthUglyNumber(new int[] {2});\n        assertEquals(uglyNumbers.get(5), 32);\n    }\n\n\n    @Test\n    public void testGetThrowsAnErrorForNegativeInput() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1, 2});\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> uglyNumbers.get(-1)\n        );\n    }\n\n    @Test\n    public void testConstructorThrowsAnErrorForEmptyInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> new NthUglyNumber(new int[] {})\n        );\n    }\n}"
    },
    {
        "product_commit": "4bbc4bd69f2a68963ba733df744c6ea356aba109",
        "test_commit": "4bbc4bd69f2a68963ba733df744c6ea356aba109",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ReverseNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ReverseNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.lang.IllegalStateException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class ReverseNumber {\n\n    public static void main(String[] args) {\n        int number;\n        int reverse = 0;\n\n        try (Scanner sc = new Scanner(System.in)) {\n            System.out.println(\"Enter a number:\");\n            number = sc.nextInt();\n        } catch (NoSuchElementException | IllegalStateException e) {\n            System.out.println(\"ERROR: Invalid input\");\n            return;\n        }\n\n        while (number != 0) {\n            int remainder = number % 10;\n\n            reverse = reverse * 10 + remainder;\n            number = number / 10;\n        }\n\n        System.out.println(\"The reverse of the given number is: \" + reverse);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.lang.IllegalArgumentException;\n\n/**\n * @brief utility class reversing numbers\n */\nfinal public class ReverseNumber {\n    private ReverseNumber() {\n    }\n\n    /**\n     * @brief reverses the input number\n     * @param number the input number\n     * @exception IllegalArgumentException number is negative\n     * @return the number created by reversing the order of digits of the input number\n     */\n    public static int reverseNumber(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"number must be nonnegative.\");\n        }\n\n        int result = 0;\n        while (number > 0) {\n            result *= 10;\n            result += number % 10;\n            number /= 10;\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ReverseNumberTest {\n\n    @Test\n    public void testReverseNumber() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 0);\n        testCases.put(1, 1);\n        testCases.put(10, 1);\n        testCases.put(123, 321);\n        testCases.put(7890, 987);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(ReverseNumber.reverseNumber(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testReverseNumberThrowsExceptionForNegativeInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> ReverseNumber.reverseNumber(-1)\n        );\n    }\n}"
    },
    {
        "product_commit": "b6e78a45ac007570df4da7574b111a05000204d3",
        "test_commit": "b6e78a45ac007570df4da7574b111a05000204d3",
        "product_file_path": "src/main/java/com/thealgorithms/conversions/OctalToBinary.java",
        "test_file_path": "src/test/java/com/thealgorithms/conversions/OctalToBinaryTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.conversions;\nimport java.util.Scanner;\n\n/**\n * Converts any Octal Number to a Binary Number\n *\n * @author Bama Charan Chhandogi\n */\n\npublic class OctalToBinary {\n    public static long convertOctalToBinary(int octalNumber) {\n        long binaryNumber = 0;\n        int digitPosition = 1;\n\n        while (octalNumber != 0) {\n            int octalDigit = octalNumber % 10;\n            long binaryDigit = convertOctalDigitToBinary(octalDigit);\n\n            binaryNumber += binaryDigit * digitPosition;\n\n            octalNumber /= 10;\n            digitPosition *= 1000; // Move to the next group of 3 binary digits\n        }\n\n        return binaryNumber;\n    }\n\n    public static long convertOctalDigitToBinary(int octalDigit) {\n        long binaryDigit = 0;\n        int binaryMultiplier = 1;\n\n        while (octalDigit != 0) {\n            int octalDigitRemainder = octalDigit % 2;\n            binaryDigit += octalDigitRemainder * binaryMultiplier;\n\n            octalDigit /= 2;\n            binaryMultiplier *= 10;\n        }\n\n        return binaryDigit;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.conversions;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class OctalToBinaryTest {\n    @Test\n    public void testConvertOctalToBinary() {\n        assertEquals(101, OctalToBinary.convertOctalToBinary(5));\n        assertEquals(1001, OctalToBinary.convertOctalToBinary(11));\n        assertEquals(101010, OctalToBinary.convertOctalToBinary(52));\n        assertEquals(110, OctalToBinary.convertOctalToBinary(6));\n    }\n}"
    },
    {
        "product_commit": "5d7a59654fc4394162b69ee220c6c079c71a039b",
        "test_commit": "5d7a59654fc4394162b69ee220c6c079c71a039b",
        "product_file_path": "src/main/java/com/thealgorithms/others/LowestBasePalindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/LowestBasePalindromeTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\n/**\n * Class for finding the lowest base in which a given integer is a palindrome.\n * Includes auxiliary methods for converting between bases and reversing\n * strings.\n *\n * <p>\n * NOTE: There is potential for error, see note at line 63.\n *\n * @author RollandMichael\n * @version 2017.09.28\n */\npublic class LowestBasePalindrome {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = 0;\n        while (true) {\n            try {\n                System.out.print(\"Enter number: \");\n                n = in.nextInt();\n                break;\n            } catch (InputMismatchException e) {\n                System.out.println(\"Invalid input!\");\n                in.next();\n            }\n        }\n        System.out.println(\n            n + \" is a palindrome in base \" + lowestBasePalindrome(n)\n        );\n        System.out.println(\n            base2base(Integer.toString(n), 10, lowestBasePalindrome(n))\n        );\n        in.close();\n    }\n\n    /**\n     * Given a number in base 10, returns the lowest base in which the number is\n     * represented by a palindrome (read the same left-to-right and\n     * right-to-left).\n     *\n     * @param num A number in base 10.\n     * @return The lowest base in which num is a palindrome.\n     */\n    public static int lowestBasePalindrome(int num) {\n        int base, num2 = num;\n        int digit;\n        char digitC;\n        boolean foundBase = false;\n        String newNum = \"\";\n        String digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n        while (!foundBase) {\n            // Try from bases 2 to num-1\n            for (base = 2; base < num2; base++) {\n                newNum = \"\";\n                while (num > 0) {\n                    // Obtain the first digit of n in the current base,\n                    // which is equivalent to the integer remainder of (n/base).\n                    // The next digit is obtained by dividing n by the base and\n                    // continuing the process of getting the remainder. This is done\n                    // until n is <=0 and the number in the new base is obtained.\n                    digit = (num % base);\n                    num /= base;\n                    // If the digit isn't in the set of [0-9][A-Z] (beyond base 36), its character\n                    // form is just its value in ASCII.\n\n                    // NOTE: This may cause problems, as the capital letters are ASCII values\n                    // 65-90. It may cause false positives when one digit is, for instance 10 and assigned\n                    // 'A' from the character array and the other is 65 and also assigned 'A'.\n                    // Regardless, the character is added to the representation of n\n                    // in the current base.\n                    if (digit >= digits.length()) {\n                        digitC = (char) (digit);\n                        newNum += digitC;\n                        continue;\n                    }\n                    newNum += digits.charAt(digit);\n                }\n                // Num is assigned back its original value for the next iteration.\n                num = num2;\n                // Auxiliary method reverses the number.\n                String reverse = reverse(newNum);\n                // If the number is read the same as its reverse, then it is a palindrome.\n                // The current base is returned.\n                if (reverse.equals(newNum)) {\n                    foundBase = true;\n                    return base;\n                }\n            }\n        }\n        // If all else fails, n is always a palindrome in base n-1. (\"11\")\n        return num - 1;\n    }\n\n    private static String reverse(String str) {\n        String reverse = \"\";\n        for (int i = str.length() - 1; i >= 0; i--) {\n            reverse += str.charAt(i);\n        }\n        return reverse;\n    }\n\n    private static String base2base(String n, int b1, int b2) {\n        // Declare variables: decimal value of n,\n        // character of base b1, character of base b2,\n        // and the string that will be returned.\n        int decimalValue = 0, charB2;\n        char charB1;\n        String output = \"\";\n        // Go through every character of n\n        for (int i = 0; i < n.length(); i++) {\n            // store the character in charB1\n            charB1 = n.charAt(i);\n            // if it is a non-number, convert it to a decimal value >9 and store it in charB2\n            if (charB1 >= 'A' && charB1 <= 'Z') {\n                charB2 = 10 + (charB1 - 'A');\n            } // Else, store the integer value in charB2\n            else {\n                charB2 = charB1 - '0';\n            }\n            // Convert the digit to decimal and add it to the\n            // decimalValue of n\n            decimalValue = decimalValue * b1 + charB2;\n        }\n\n        // Converting the decimal value to base b2:\n        // A number is converted from decimal to another base\n        // by continuously dividing by the base and recording\n        // the remainder until the quotient is zero. The number in the\n        // new base is the remainders, with the last remainder\n        // being the left-most digit.\n        // While the quotient is NOT zero:\n        while (decimalValue != 0) {\n            // If the remainder is a digit < 10, simply add it to\n            // the left side of the new number.\n            if (decimalValue % b2 < 10) {\n                output = decimalValue % b2 + output;\n            } // If the remainder is >= 10, add a character with the\n            // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)\n            else {\n                output = (char) ((decimalValue % b2) + 55) + output;\n            }\n            // Divide by the new base again\n            decimalValue /= b2;\n        }\n        return output;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @brief Class for finding the lowest base in which a given integer is a palindrome.\n     cf. https://oeis.org/A016026\n */\nfinal public class LowestBasePalindrome {\n    private LowestBasePalindrome() {\n    }\n\n    private static void checkBase(int base) {\n        if (base <= 1) {\n            throw new IllegalArgumentException(\"base must be greater than 1.\");\n        }\n    }\n\n    private static void checkNumber(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"number must be nonnegative.\");\n        }\n    }\n\n    /**\n     * @brief computes the representation of the input number in given base\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return the list containing the digits of the input number in the given base, the most significant digit is at the end of the array\n     */\n    public static ArrayList<Integer> computeDigitsInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n        var result = new ArrayList<Integer>();\n        while (number > 0) {\n            result.add(number % base);\n            number /= base;\n        }\n        return result;\n    }\n\n    /**\n     * @brief checks if the input array is a palindrome\n     * @brief list the input array\n     * @return true, if the input array is a palindrome, false otherwise\n     */\n    public static boolean isPalindromic(ArrayList<Integer> list) {\n        for (int pos = 0; pos < list.size()/2; ++pos) {\n            if(list.get(pos) != list.get(list.size()-1-pos)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @brief checks if representation of the input number in given base is a palindrome\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return true, if the input number represented in the given base is a palindrome, false otherwise\n     */\n    public static boolean isPalindromicInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n\n        if (number <= 1) {\n            return true;\n        }\n\n        if (number % base == 0) {\n            // the last digit of number written in base is 0\n            return false;\n        }\n\n        return isPalindromic(computeDigitsInBase(number, base));\n    }\n\n    /**\n     * @brief finds the smallest base for which the representation of the input number is a palindrome\n     * @param number the input number\n     * @exception IllegalArgumentException number is negative\n     * @return the smallest base for which the representation of the input number is a palindrome\n     */\n    public static int lowestBasePalindrome(int number) {\n        int base = 2;\n        while(!isPalindromicInBase(number, base)) {\n            ++base;\n        }\n        return base;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LowestBasePalindromeTest {\n    @Test\n    public void testIsPalindromicPositive() {\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>()));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 2, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2))));\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicInBasePositive() {\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(1, 190));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(0, 11));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(10101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(23, 22));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(1010, 10));\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(123, 10));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForNegativeNumbers() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> LowestBasePalindrome.isPalindromicInBase(-1, 5)\n        );\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForWrongBases() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> LowestBasePalindrome.isPalindromicInBase(10, 1)\n        );\n    }\n\n    @Test\n    public void testLowestBasePalindrome() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 2);\n        testCases.put(1, 2);\n        testCases.put(2, 3);\n        testCases.put(3, 2);\n        testCases.put(10, 3);\n        testCases.put(11, 10);\n        testCases.put(15, 2);\n        testCases.put(39, 12);\n        testCases.put(44, 10);\n        testCases.put(58, 28);\n        testCases.put(69, 22);\n        testCases.put(79, 78);\n        testCases.put(87, 28);\n        testCases.put(90, 14);\n        testCases.put(5591, 37);\n        testCases.put(5895, 130);\n        testCases.put(9950, 198);\n        testCases.put(9974, 4986);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(LowestBasePalindrome.lowestBasePalindrome(tc.getKey()), tc.getValue());\n        }\n    }\n}"
    },
    {
        "product_commit": "96c1a96647c947f8f0c531ade3bc18967359e0ea",
        "test_commit": "96c1a96647c947f8f0c531ade3bc18967359e0ea",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * find max of array\n     *\n     * @param array the array contains element\n     * @return max value of given array\n     */\n    public static int findMax(int[] array) {\n        int max = array[0];\n        for (int i = 1; i < array.length; ++i) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = Integer.MIN_VALUE;\n        for (final var value : array) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMaxTest {\n\n    @Test\n    public void testFindMaxValue() {\n        assertEquals(\n            10,\n            FindMax.findMax(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMaxTest {\n\n    @Test\n    public void testFindMax0() {\n        assertEquals(\n            10,\n            FindMax.findMax(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })\n        );\n    }\n\n    @Test\n    public void testFindMax1() {\n        assertEquals(\n            7,\n            FindMax.findMax(new int[] { 6, 3, 5, 1, 7, 4, 1 })\n        );\n    }\n\n    @Test\n    public void testFindMax2() {\n        assertEquals(\n            10,\n            FindMax.findMax(new int[] { 10, 0 })\n        );\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> FindMax.findMax(new int[]{})\n        );\n    }\n}"
    },
    {
        "product_commit": "4f1514980495c4daaae2eb060228a87e14cbae11",
        "test_commit": "4f1514980495c4daaae2eb060228a87e14cbae11",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * Find the minimum number of an array of numbers.\n     *\n     * @param array the array contains element\n     * @return min value\n     */\n    public static int findMin(int[] array) {\n        int min = array[0];\n        for (int i = 1; i < array.length; ++i) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = Integer.MAX_VALUE;\n        for (final var value : array) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMinTest {\n\n    @Test\n    public void testFindMinValue() {\n        assertEquals(\n            1,\n            FindMin.findMin(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })\n        );\n    }\n\n    @Test\n    public void test1() {\n        assertEquals(1, FindMin.findMin(new int[] { 1, 3, 5, 7, 9 }));\n    }\n\n    @Test\n    public void test2() {\n        assertEquals(0, FindMin.findMin(new int[] { 0, 192, 384, 576 }));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMinTest {\n\n    @Test\n    public void testFindMinValue() {\n        assertEquals(\n            1,\n            FindMin.findMin(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })\n        );\n    }\n\n    @Test\n    public void test1() {\n        assertEquals(1, FindMin.findMin(new int[] { 1, 3, 5, 7, 9 }));\n    }\n\n    @Test\n    public void test2() {\n        assertEquals(0, FindMin.findMin(new int[] { 0, 192, 384, 576 }));\n    }\n\n    @Test\n    public void test3() {\n        assertEquals(0, FindMin.findMin(new int[] { 10, 10, 0, 10 }));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> FindMin.findMin(new int[]{})\n        );\n    }\n}"
    },
    {
        "product_commit": "e14b30b88c0de95186fe1937f795b7d8fd3fa8aa",
        "test_commit": "e14b30b88c0de95186fe1937f795b7d8fd3fa8aa",
        "product_file_path": "src/main/java/com/thealgorithms/maths/GCD.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GCDTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * get greatest common divisor in array\n     *\n     * @param number contains number\n     * @return gcd\n     */\n    public static int gcd(int[] number) {\n        int result = number[0];\n        for (int i = 1; i < number.length; i++) { // call gcd function (input two value)\n            result = gcd(result, number[i]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * @brief computes gcd of an array of numbers\n     *\n     * @param numbers the input array\n     * @return gcd of all of the numbers in the input array\n     */\n    public static int gcd(int[] numbers) {\n        int result = 0;\n        for (final var number : numbers) {\n            result = gcd(result, number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-1, 0)\n        );\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(10, -2)\n        );\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-5, -3)\n        );\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-1, 0)\n        );\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(10, -2)\n        );\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-5, -3)\n        );\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n    \n    @Test\n    void testArrayGcd1() {\n        Assertions.assertEquals(GCD.gcd(new int[]{9, 6}), 3);\n    }\n\n    @Test\n    void testArrayGcd2() {\n        Assertions.assertEquals(GCD.gcd(new int[]{2*3*5*7, 2*5*5*5, 2*5*11, 5*5*5*13}), 5);\n    }\n    \n    @Test\n    void testArrayGcdForEmptyInput() {\n        Assertions.assertEquals(GCD.gcd(new int[]{}), 0);\n    }    \n}"
    },
    {
        "product_commit": "deef2ae4456c24a21c56d4cc9d5680c0f76dbdad",
        "test_commit": "deef2ae4456c24a21c56d4cc9d5680c0f76dbdad",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CreateBinaryTreeFromInorderPreorder.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CreateBinaryTreeFromInorderPreorderTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Approach: Naive Solution: Create root node from first value present in\n * preorder traversal. Look for the index of root node's value in inorder\n * traversal. That will tell total nodes present in left subtree and right\n * subtree. Based on that index create left and right subtree. Complexity: Time:\n * O(n^2) for each node there is iteration to find index in inorder array Space:\n * Stack size = O(height) = O(lg(n))\n *\n * Optimized Solution: Instead of iterating over inorder array to find index of\n * root value, create a hashmap and find out the index of root value.\n * Complexity: Time: O(n) hashmap reduced iteration to find index in inorder\n * array Space: O(n) space taken by hashmap\n *\n */\npublic class CreateBinaryTreeFromInorderPreorder {\n\n    public static void main(String[] args) {\n        test(new Integer[] {}, new Integer[] {}); // empty tree\n        test(new Integer[] { 1 }, new Integer[] { 1 }); // single node tree\n        test(new Integer[] { 1, 2, 3, 4 }, new Integer[] { 1, 2, 3, 4 }); // right skewed tree\n        test(new Integer[] { 1, 2, 3, 4 }, new Integer[] { 4, 3, 2, 1 }); // left skewed tree\n        test(\n            new Integer[] { 3, 9, 20, 15, 7 },\n            new Integer[] { 9, 3, 15, 20, 7 }\n        ); // normal tree\n    }\n\n    private static void test(\n        final Integer[] preorder,\n        final Integer[] inorder\n    ) {\n        System.out.println(\n            \"\\n====================================================\"\n        );\n        System.out.println(\"Naive Solution...\");\n        BinaryTree root = new BinaryTree(\n            createTree(preorder, inorder, 0, 0, inorder.length)\n        );\n        System.out.println(\"Preorder Traversal: \");\n        root.preOrder(root.getRoot());\n        System.out.println(\"\\nInorder Traversal: \");\n        root.inOrder(root.getRoot());\n        System.out.println(\"\\nPostOrder Traversal: \");\n        root.postOrder(root.getRoot());\n\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            map.put(inorder[i], i);\n        }\n        BinaryTree optimizedRoot = new BinaryTree(\n            createTreeOptimized(preorder, inorder, 0, 0, inorder.length, map)\n        );\n        System.out.println(\"\\n\\nOptimized solution...\");\n        System.out.println(\"Preorder Traversal: \");\n        optimizedRoot.preOrder(root.getRoot());\n        System.out.println(\"\\nInorder Traversal: \");\n        optimizedRoot.inOrder(root.getRoot());\n        System.out.println(\"\\nPostOrder Traversal: \");\n        optimizedRoot.postOrder(root.getRoot());\n    }\n\n    private static Node createTree(\n        final Integer[] preorder,\n        final Integer[] inorder,\n        final int preStart,\n        final int inStart,\n        final int size\n    ) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inStart;\n        while (preorder[preStart] != inorder[i]) {\n            i++;\n        }\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left =\n            createTree(\n                preorder,\n                inorder,\n                preStart + 1,\n                inStart,\n                leftNodesCount\n            );\n        root.right =\n            createTree(\n                preorder,\n                inorder,\n                preStart + leftNodesCount + 1,\n                i + 1,\n                rightNodesCount\n            );\n        return root;\n    }\n\n    private static Node createTreeOptimized(\n        final Integer[] preorder,\n        final Integer[] inorder,\n        final int preStart,\n        final int inStart,\n        final int size,\n        final Map<Integer, Integer> inorderMap\n    ) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inorderMap.get(preorder[preStart]);\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left =\n            createTreeOptimized(\n                preorder,\n                inorder,\n                preStart + 1,\n                inStart,\n                leftNodesCount,\n                inorderMap\n            );\n        root.right =\n            createTreeOptimized(\n                preorder,\n                inorder,\n                preStart + leftNodesCount + 1,\n                i + 1,\n                rightNodesCount,\n                inorderMap\n            );\n        return root;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Approach: Naive Solution: Create root node from first value present in\n * preorder traversal. Look for the index of root node's value in inorder\n * traversal. That will tell total nodes present in left subtree and right\n * subtree. Based on that index create left and right subtree. Complexity: Time:\n * O(n^2) for each node there is iteration to find index in inorder array Space:\n * Stack size = O(height) = O(lg(n))\n * <p>\n * Optimized Solution: Instead of iterating over inorder array to find index of\n * root value, create a hashmap and find out the index of root value.\n * Complexity: Time: O(n) hashmap reduced iteration to find index in inorder\n * array Space: O(n) space taken by hashmap\n */\npublic class CreateBinaryTreeFromInorderPreorder {\n    public static Node createTree(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        return createTree(preorder, inorder, 0, 0, inorder.length);\n    }\n\n    public static Node createTreeOptimized(final Integer[] preorder, final Integer[] inorder) {\n        if (preorder == null || inorder == null) {\n            return null;\n        }\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        return createTreeOptimized(preorder, inorderMap, 0, 0, inorder.length);\n    }\n\n    private static Node createTree(\n            final Integer[] preorder,\n            final Integer[] inorder,\n            final int preStart,\n            final int inStart,\n            final int size\n    ) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inStart;\n        while (!preorder[preStart].equals(inorder[i])) {\n            i++;\n        }\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left =\n                createTree(\n                        preorder,\n                        inorder,\n                        preStart + 1,\n                        inStart,\n                        leftNodesCount\n                );\n        root.right =\n                createTree(\n                        preorder,\n                        inorder,\n                        preStart + leftNodesCount + 1,\n                        i + 1,\n                        rightNodesCount\n                );\n        return root;\n    }\n\n    private static Node createTreeOptimized(\n            final Integer[] preorder,\n            final Map<Integer, Integer> inorderMap,\n            final int preStart,\n            final int inStart,\n            final int size\n    ) {\n        if (size == 0) {\n            return null;\n        }\n\n        Node root = new Node(preorder[preStart]);\n        int i = inorderMap.get(preorder[preStart]);\n        int leftNodesCount = i - inStart;\n        int rightNodesCount = size - leftNodesCount - 1;\n        root.left =\n                createTreeOptimized(\n                        preorder,\n                        inorderMap,\n                        preStart + 1,\n                        inStart,\n                        leftNodesCount\n                );\n        root.right =\n                createTreeOptimized(\n                        preorder,\n                        inorderMap,\n                        preStart + leftNodesCount + 1,\n                        i + 1,\n                        rightNodesCount\n                );\n        return root;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\n\n/**\n * @author Albina Gimaletdinova on 14/05/2023\n */\npublic class CreateBinaryTreeFromInorderPreorderTest {\n    @Test\n    public void testOnNullArraysShouldReturnNullTree() {\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(null, null);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(null, null);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnEmptyArraysShouldCreateNullTree() {\n        // given\n        Integer[] preorder = {};\n        Integer[] inorder = {};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        Assertions.assertNull(root);\n        Assertions.assertNull(rootOpt);\n    }\n\n    @Test\n    public void testOnSingleNodeTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1};\n        Integer[] inorder = {1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnRightSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {1, 2, 3, 4};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnLeftSkewedTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {1, 2, 3, 4};\n        Integer[] inorder = {4, 3, 2, 1};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    @Test\n    public void testOnNormalTreeShouldCreateCorrectTree() {\n        // given\n        Integer[] preorder = {3, 9, 20, 15, 7};\n        Integer[] inorder = {9, 3, 15, 20, 7};\n\n        // when\n        BinaryTree.Node root = CreateBinaryTreeFromInorderPreorder.createTree(preorder, inorder);\n        BinaryTree.Node rootOpt = CreateBinaryTreeFromInorderPreorder.createTreeOptimized(preorder, inorder);\n\n        // then\n        checkTree(preorder, inorder, root);\n        checkTree(preorder, inorder, rootOpt);\n    }\n\n    private static void checkTree(Integer[] preorder, Integer[] inorder, BinaryTree.Node root) {\n        Assertions.assertNotNull(root);\n        Assertions.assertEquals(PreOrderTraversal.iterativePreOrder(root), Arrays.asList(preorder));\n        Assertions.assertEquals(InorderTraversal.iterativeInorder(root), Arrays.asList(inorder));\n    }\n}"
    },
    {
        "product_commit": "02557053884690f407ae2b8308f23ce445ac9f64",
        "test_commit": "02557053884690f407ae2b8308f23ce445ac9f64",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/WordSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/WordSearchTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.backtracking;\n\n\n/*\nWord Search Problem (https://en.wikipedia.org/wiki/Word_search)\n\nGiven an m x n grid of characters board and a string word, return true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or\nvertically neighboring. The same letter cell may not be used more than once.\n\nFor example,\nGiven board =\n\n[\n ['A','B','C','E'],\n ['S','F','C','S'],\n ['A','D','E','E']\n]\nword = \"ABCCED\", -> returns true,\nword = \"SEE\", -> returns true,\nword = \"ABCB\", -> returns false.\n*/\n\n/*\n   Solution\n   Depth First Search in matrix (as multiple sources possible) with backtracking\n   like finding cycle in a directed graph. Maintain a record of path\n\n   Tx = O(m * n * 3^L): for each cell, we look at 3 options (not 4 as that one will be visited), we do it L times\n   Sx = O(L) : stack size is max L\n*/\n\npublic class WordSearch {\n    private final int[] dx = {0, 0, 1, -1};\n    private final int[] dy = {1, -1, 0, 0};\n    private boolean[][] visited;\n    private char[][] board;\n    private String word;\n\n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < board.length && y >= 0 && y < board[0].length;\n    }\n\n    private boolean doDFS(int x, int y, int nextIdx) {\n        visited[x][y] = true;\n        if (nextIdx == word.length()) {\n            return true;\n        }\n        for (int i = 0; i < 4; ++i) {\n            int xi = x + dx[i];\n            int yi = y + dy[i];\n            if (isValid(xi, yi) && board[xi][yi] == word.charAt(nextIdx) && !visited[xi][yi]) {\n                boolean exists = doDFS(xi, yi, nextIdx + 1);\n                if (exists)\n                    return true;\n            }\n        }\n        visited[x][y] = false;\n        return false;\n    }\n\n    public boolean exist(char[][] board, String word) {\n        this.board = board;\n        this.word = word;\n        for (int i = 0; i < board.length; ++i) {\n            for (int j = 0; j < board[0].length; ++j) {\n                if (board[i][j] == word.charAt(0)) {\n                    visited = new boolean[board.length][board[0].length];\n                    boolean exists = doDFS(i, j, 1);\n                    if (exists)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class WordSearchTest {\n    @Test\n    void test1() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word = \"ABCCED\";\n        assertTrue(ws.exist(board, word));\n    }\n\n    @Test\n    void test2() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word = \"SEE\";\n        assertTrue(ws.exist(board, word));\n    }\n\n    @Test\n    void test3() {\n        WordSearch ws = new WordSearch();\n        char[][] board = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};\n        String word = \"ABCB\";\n        Assertions.assertFalse(ws.exist(board, word));\n    }\n}"
    },
    {
        "product_commit": "122f5e5556fa33853d8c73a4aecc1e0f3cda53ca",
        "test_commit": "122f5e5556fa33853d8c73a4aecc1e0f3cda53ca",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/RRScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/RRSchedulingTest.java",
        "product_old_content": null,
        "product_new_content": "/**\n * @author Md Asif Joardar\n */\n\npackage com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/**\n * The Round-robin scheduling algorithm is a kind of preemptive First come, First Serve CPU Scheduling algorithm.\n * This can be understood here - https://www.scaler.com/topics/round-robin-scheduling-in-os/\n */\n\npublic class RRScheduling {\n    private List<ProcessDetails> processes;\n    private int quantumTime;\n\n    RRScheduling(final List<ProcessDetails> processes, int quantumTime) {\n        this.processes = processes;\n        this.quantumTime = quantumTime;\n    }\n\n    public void scheduleProcesses() {\n        evaluateTurnAroundTime();\n        evaluateWaitingTime();\n    }\n\n    private void evaluateTurnAroundTime() {\n        int processesNumber = processes.size();\n\n        if(processesNumber == 0) {\n            return;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        int currentTime = 0; // keep track of the time\n        int completed = 0;\n        int[] mark = new int[processesNumber];\n        Arrays.fill(mark, 0);\n        mark[0] = 1;\n\n        // a copy of burst time to store the remaining burst time\n        int[] remainingBurstTime = new int[processesNumber];\n        for (int i = 0; i < processesNumber; i++) {\n            remainingBurstTime[i] = processes.get(i).getBurstTime();\n        }\n\n        while (completed != processesNumber){\n            int index = queue.poll();\n\n            if(remainingBurstTime[index] == processes.get(index).getBurstTime()){\n                currentTime = Math.max(currentTime, processes.get(index).getArrivalTime());\n            }\n\n            if(remainingBurstTime[index] - quantumTime > 0){\n                remainingBurstTime[index] -= quantumTime;\n                currentTime += quantumTime;\n            } else {\n                currentTime += remainingBurstTime[index];\n                processes.get(index).setTurnAroundTimeTime(currentTime - processes.get(index).getArrivalTime());\n                completed++;\n                remainingBurstTime[index]=0;\n            }\n\n            // If some process has arrived when this process was executing, insert them into the queue.\n            for (int i=1; i < processesNumber; i++){\n                if(remainingBurstTime[i] > 0 && processes.get(i).getArrivalTime() <= currentTime && mark[i] == 0){\n                    mark[i]=1;\n                    queue.add(i);\n                }\n            }\n\n            // If the current process has burst time remaining, push the process into the queue again.\n            if(remainingBurstTime[index] > 0) queue.add(index);\n\n            // If the queue is empty, pick the first process from the list that is not completed.\n            if(queue.isEmpty()){\n                for (int i=1; i<processesNumber; i++){\n                    if (remainingBurstTime[i] > 0){\n                        mark[i] = 1;\n                        queue.add(i);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    private void evaluateWaitingTime() {\n        for (int i = 0; i < processes.size(); i++)\n            processes.get(i).setWaitingTime(processes.get(i).getTurnAroundTimeTime() - processes.get(i).getBurstTime());\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass RRSchedulingTest {\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForRR();\n        final RRScheduling rrScheduling = new RRScheduling(processes, 4); // for sending to RR with quantum value 4\n\n        rrScheduling.scheduleProcesses();\n\n        assertEquals(6, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(12, processes.get(0).getWaitingTime());\n        assertEquals(17, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(16, processes.get(1).getWaitingTime());\n        assertEquals(22, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(6, processes.get(2).getWaitingTime());\n        assertEquals(9, processes.get(2).getTurnAroundTimeTime());\n\n        assertEquals(\"P4\", processes.get(3).getProcessId());\n        assertEquals(8, processes.get(3).getWaitingTime());\n        assertEquals(9, processes.get(3).getTurnAroundTimeTime());\n\n        assertEquals(\"P5\", processes.get(4).getProcessId());\n        assertEquals(15, processes.get(4).getWaitingTime());\n        assertEquals(20, processes.get(4).getTurnAroundTimeTime());\n\n        assertEquals(\"P6\", processes.get(5).getProcessId());\n        assertEquals(11, processes.get(5).getWaitingTime());\n        assertEquals(15, processes.get(5).getTurnAroundTimeTime());\n\n    }\n\n    private List<ProcessDetails> addProcessesForRR() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 5);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 6);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 3);\n        final ProcessDetails process4 = new ProcessDetails(\"P4\", 3, 1);\n        final ProcessDetails process5 = new ProcessDetails(\"P5\", 4, 5);\n        final ProcessDetails process6 = new ProcessDetails(\"P6\", 6, 4);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n        processDetails.add(process4);\n        processDetails.add(process5);\n        processDetails.add(process6);\n\n        return processDetails;\n    }\n}"
    },
    {
        "product_commit": "3109c11c599e4139e431f3b0f00051e017abf6d6",
        "test_commit": "3109c11c599e4139e431f3b0f00051e017abf6d6",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/PartitionProblem.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/PartitionProblemTest.java",
        "product_old_content": null,
        "product_new_content": "/**\n * @author Md Asif Joardar\n *\n * Description: The partition problem is a classic problem in computer science\n * that asks whether a given set can be partitioned into two subsets such that\n * the sum of elements in each subset is the same.\n *\n * Example:\n * Consider nums = {1, 2, 3}\n * We can split the array \"nums\" into two partitions, where each having a sum of 3.\n * nums1 = {1, 2}\n * nums2 = {3}\n *\n * The time complexity of the solution is O(n \u00d7 sum) and requires O(n \u00d7 sum) space\n */\n\npackage com.thealgorithms.dynamicprogramming;\n\nimport java.util.Arrays;\n\npublic class PartitionProblem {\n\n    /**\n     * Test if a set of integers can be partitioned into two subsets such that the sum of elements\n     * in each subset is the same.\n     *\n     * @param nums the array contains integers.\n     * @return {@code true} if two subset exists, otherwise {@code false}.\n     */\n    public static boolean partition(int[] nums)\n    {\n        // calculate the sum of all the elements in the array\n        int sum = Arrays.stream(nums).sum();\n\n        // it will return true if the sum is even and the array can be divided into two subarrays/subset with equal sum.\n        // and here i reuse the SubsetSum class from dynamic programming section to check if there is exists a\n        // subsetsum into nums[] array same as the given sum\n        return (sum & 1) == 0 && SubsetSum.subsetSum(nums, sum/2);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PartitionProblemTest {\n    @Test\n    public void testIfSumOfTheArrayIsOdd(){\n        assertFalse(PartitionProblem.partition(new int[]{1, 2, 2}));\n    }\n    @Test\n    public void testIfSizeOfTheArrayIsOne(){\n        assertFalse(PartitionProblem.partition(new int[]{2}));\n    }\n    @Test\n    public void testIfSumOfTheArrayIsEven1(){\n        assertTrue(PartitionProblem.partition(new int[]{1, 2, 3, 6}));\n    }\n    @Test\n    public void testIfSumOfTheArrayIsEven2(){\n        assertFalse(PartitionProblem.partition(new int[]{1, 2, 3, 8}));\n    }\n}"
    },
    {
        "product_commit": "3a593d5d3c5dc7099ec5e5a6d26f5fc9fd59b34a",
        "test_commit": "3a593d5d3c5dc7099ec5e5a6d26f5fc9fd59b34a",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/BSTRecursive.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/BSTRecursiveTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n *\n *\n * <h1>Binary Search Tree (Recursive)</h1>\n *\n * An implementation of BST recursively. In recursive implementation the checks\n * are down the tree First root is checked if not found then its childs are\n * checked Binary Search Tree is a binary tree which satisfies three properties:\n * left child is less than root node, right child is grater than root node, both\n * left and right childs must themselves be a BST.\n *\n * <p>\n * I have made public functions as methods and to actually implement recursive\n * approach I have used private methods\n *\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\npublic class BSTRecursive {\n\n    /**\n     * only data member is root of BST\n     */\n    private Node root;\n\n    /**\n     * Constructor use to initialize node as null\n     */\n    BSTRecursive() {\n        root = null;\n    }\n\n    /**\n     * main function for tests\n     */\n    public static void main(String[] args) {\n        BSTRecursive tree = new BSTRecursive();\n        tree.add(5);\n        tree.add(10);\n        tree.add(9);\n        assert !tree.find(4) : \"4 is not yet present in BST\";\n        assert tree.find(10) : \"10 should be present in BST\";\n        tree.remove(9);\n        assert !tree.find(9) : \"9 was just deleted from BST\";\n        tree.remove(1);\n        assert !tree.find(\n            1\n        ) : \"Since 1 was not present so find deleting would do no change\";\n        tree.add(20);\n        tree.add(70);\n        assert tree.find(70) : \"70 was inserted but not found\";\n        /*\n     Will print in following order\n     5 10 20 70\n         */\n        tree.inorder();\n    }\n\n    /**\n     * Recursive method to delete a data if present in BST.\n     *\n     * @param node the current node to search for data\n     * @param data the value to be deleted\n     * @return Node the updated value of root parameter after delete operation\n     */\n    private Node delete(Node node, int data) {\n        if (node == null) {\n            System.out.println(\"No such data present in BST.\");\n        } else if (node.data > data) {\n            node.left = delete(node.left, data);\n        } else if (node.data < data) {\n            node.right = delete(node.right, data);\n        } else {\n            if (node.right == null && node.left == null) { // If it is leaf node\n                node = null;\n            } else if (node.left == null) { // If only right node is present\n                Node temp = node.right;\n                node.right = null;\n                node = temp;\n            } else if (node.right == null) { // Only left node is present\n                Node temp = node.left;\n                node.left = null;\n                node = temp;\n            } else { // both child are present\n                Node temp = node.right;\n                // Find leftmost child of right subtree\n                while (temp.left != null) {\n                    temp = temp.left;\n                }\n                node.data = temp.data;\n                node.right = delete(node.right, temp.data);\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Recursive insertion of value in BST.\n     *\n     * @param node to check if the data can be inserted in current node or its\n     * subtree\n     * @param data the value to be inserted\n     * @return the modified value of the root parameter after insertion\n     */\n    private Node insert(Node node, int data) {\n        if (node == null) {\n            node = new Node(data);\n        } else if (node.data > data) {\n            node.left = insert(node.left, data);\n        } else if (node.data < data) {\n            node.right = insert(node.right, data);\n        }\n        return node;\n    }\n\n    /**\n     * Recursively print Preorder traversal of the BST\n     *\n     * @param node the root node\n     */\n    private void preOrder(Node node) {\n        if (node == null) {\n            return;\n        }\n        System.out.print(node.data + \" \");\n        if (node.left != null) {\n            preOrder(node.left);\n        }\n        if (node.right != null) {\n            preOrder(node.right);\n        }\n    }\n\n    /**\n     * Recursively print Postorder travesal of BST.\n     *\n     * @param node the root node\n     */\n    private void postOrder(Node node) {\n        if (node == null) {\n            return;\n        }\n        if (node.left != null) {\n            postOrder(node.left);\n        }\n        if (node.right != null) {\n            postOrder(node.right);\n        }\n        System.out.print(node.data + \" \");\n    }\n\n    /**\n     * Recursively print Inorder traversal of BST.\n     *\n     * @param node the root node\n     */\n    private void inOrder(Node node) {\n        if (node == null) {\n            return;\n        }\n        if (node.left != null) {\n            inOrder(node.left);\n        }\n        System.out.print(node.data + \" \");\n        if (node.right != null) {\n            inOrder(node.right);\n        }\n    }\n\n    /**\n     * Serach recursively if the given value is present in BST or not.\n     *\n     * @param node the current node to check\n     * @param data the value to be checked\n     * @return boolean if data is present or not\n     */\n    private boolean search(Node node, int data) {\n        if (node == null) {\n            return false;\n        } else if (node.data == data) {\n            return true;\n        } else if (node.data > data) {\n            return search(node.left, data);\n        } else {\n            return search(node.right, data);\n        }\n    }\n\n    /**\n     * add in BST. if the value is not already present it is inserted or else no\n     * change takes place.\n     *\n     * @param data the value to be inserted\n     */\n    public void add(int data) {\n        this.root = insert(this.root, data);\n    }\n\n    /**\n     * If data is present in BST delete it else do nothing.\n     *\n     * @param data the value to be removed\n     */\n    public void remove(int data) {\n        this.root = delete(this.root, data);\n    }\n\n    /**\n     * To call inorder traversal on tree\n     */\n    public void inorder() {\n        System.out.println(\"Inorder traversal of this tree is:\");\n        inOrder(this.root);\n        System.out.println(); // for next line\n    }\n\n    /**\n     * To call postorder traversal on tree\n     */\n    public void postorder() {\n        System.out.println(\"Postorder traversal of this tree is:\");\n        postOrder(this.root);\n        System.out.println(); // for next li\n    }\n\n    /**\n     * To call preorder traversal on tree.\n     */\n    public void preorder() {\n        System.out.println(\"Preorder traversal of this tree is:\");\n        preOrder(this.root);\n        System.out.println(); // for next li\n    }\n\n    /**\n     * To check if given value is present in tree or not.\n     *\n     * @param data the data to be found for\n     */\n    public boolean find(int data) {\n        if (search(this.root, data)) {\n            System.out.println(data + \" is present in given BST.\");\n            return true;\n        }\n        System.out.println(data + \" not found.\");\n        return false;\n    }\n\n    /**\n     * The Node class used for building binary search tree\n     */\n    private static class Node {\n\n        int data;\n        Node left;\n        Node right;\n\n        /**\n         * Constructor with data as parameter\n         */\n        Node(int d) {\n            data = d;\n            left = null;\n            right = null;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\n/**\n *\n *\n * <h1>Binary Search Tree (Recursive)</h1>\n *\n * An implementation of BST recursively. In recursive implementation the checks\n * are down the tree First root is checked if not found then its children are\n * checked Binary Search Tree is a binary tree which satisfies three properties:\n * left child is less than root node, right child is grater than root node, both\n * left and right children must themselves be a BST.\n *\n * <p>\n * I have made public functions as methods and to actually implement recursive\n * approach I have used private methods\n *\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\npublic class BSTRecursive {\n\n    /**\n     * only data member is root of BST\n     */\n    private Node root;\n\n    /**\n     * Constructor use to initialize node as null\n     */\n    BSTRecursive() {\n        root = null;\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Recursive method to delete a data if present in BST.\n     *\n     * @param node the current node to search for data\n     * @param data the value to be deleted\n     * @return Node the updated value of root parameter after delete operation\n     */\n    private Node delete(Node node, int data) {\n        if (node == null) {\n            System.out.println(\"No such data present in BST.\");\n        } else if (node.data > data) {\n            node.left = delete(node.left, data);\n        } else if (node.data < data) {\n            node.right = delete(node.right, data);\n        } else {\n            if (node.right == null && node.left == null) { // If it is leaf node\n                node = null;\n            } else if (node.left == null) { // If only right node is present\n                Node temp = node.right;\n                node.right = null;\n                node = temp;\n            } else if (node.right == null) { // Only left node is present\n                Node temp = node.left;\n                node.left = null;\n                node = temp;\n            } else { // both children are present\n                Node temp = node.right;\n                // Find leftmost child of right subtree\n                while (temp.left != null) {\n                    temp = temp.left;\n                }\n                node.data = temp.data;\n                node.right = delete(node.right, temp.data);\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Recursive insertion of value in BST.\n     *\n     * @param node to check if the data can be inserted in current node or its\n     * subtree\n     * @param data the value to be inserted\n     * @return the modified value of the root parameter after insertion\n     */\n    private Node insert(Node node, int data) {\n        if (node == null) {\n            node = new Node(data);\n        } else if (node.data > data) {\n            node.left = insert(node.left, data);\n        } else if (node.data < data) {\n            node.right = insert(node.right, data);\n        }\n        return node;\n    }\n\n    /**\n     * Serach recursively if the given value is present in BST or not.\n     *\n     * @param node the current node to check\n     * @param data the value to be checked\n     * @return boolean if data is present or not\n     */\n    private boolean search(Node node, int data) {\n        if (node == null) {\n            return false;\n        } else if (node.data == data) {\n            return true;\n        } else if (node.data > data) {\n            return search(node.left, data);\n        } else {\n            return search(node.right, data);\n        }\n    }\n\n    /**\n     * add in BST. if the value is not already present it is inserted or else no\n     * change takes place.\n     *\n     * @param data the value to be inserted\n     */\n    public void add(int data) {\n        this.root = insert(this.root, data);\n    }\n\n    /**\n     * If data is present in BST delete it else do nothing.\n     *\n     * @param data the value to be removed\n     */\n    public void remove(int data) {\n        this.root = delete(this.root, data);\n    }\n\n    /**\n     * To check if given value is present in tree or not.\n     *\n     * @param data the data to be found for\n     */\n    public boolean find(int data) {\n        if (search(this.root, data)) {\n            System.out.println(data + \" is present in given BST.\");\n            return true;\n        }\n        System.out.println(data + \" not found.\");\n        return false;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 06/05/2023\n */\npublic class BSTRecursiveTest {\n    @Test\n    public void testBSTIsCorrectlyConstructedFromOneNode() {\n        BSTRecursive tree = new BSTRecursive();\n        tree.add(6);\n\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(tree.getRoot()));\n    }\n\n    @Test\n    public void testBSTIsCorrectlyCleanedAndEmpty() {\n        BSTRecursive tree = new BSTRecursive();\n\n        tree.add(6);\n        tree.remove(6);\n\n        tree.add(12);\n        tree.add(1);\n        tree.add(2);\n\n        tree.remove(1);\n        tree.remove(2);\n        tree.remove(12);\n\n        Assertions.assertNull(tree.getRoot());\n    }\n\n    @Test\n    public void testBSTIsCorrectlyCleanedAndNonEmpty() {\n        BSTRecursive tree = new BSTRecursive();\n\n        tree.add(6);\n        tree.remove(6);\n\n        tree.add(12);\n        tree.add(1);\n        tree.add(2);\n\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(tree.getRoot()));\n    }\n\n    @Test\n    public void testBSTIsCorrectlyConstructedFromMultipleNodes() {\n        BSTRecursive tree = new BSTRecursive();\n        tree.add(7);\n        tree.add(1);\n        tree.add(5);\n        tree.add(100);\n        tree.add(50);\n\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(tree.getRoot()));\n    }\n}"
    },
    {
        "product_commit": "89b7ee42e6010323e4b4c0556c3005620f1d9845",
        "test_commit": "89b7ee42e6010323e4b4c0556c3005620f1d9845",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Anagrams.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/AnagramsTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase,\n * typically using all the original letters exactly once.[1]\n * For example, the word anagram itself can be rearranged into nag a ram,\n * also the word binary into brainy and the word adobe into abode.\n * Reference from https://en.wikipedia.org/wiki/Anagram\n */\npublic class Anagrams {\n\n    // 4 approaches are provided for anagram checking. approach 2 and approach 3 are similar but differ in running time.\n    public static void main(String[] args) {\n        String first = \"deal\";\n        String second = \"lead\";\n        // All the below methods takes input but doesn't return any output to the main method.\n        Anagrams nm = new Anagrams();\n        System.out.println(\n            nm.approach2(first, second)\n        );/* To activate methods for different approaches*/\n        System.out.println(\n            nm.approach1(first, second)\n        );/* To activate methods for different approaches*/\n        System.out.println(\n            nm.approach3(first, second)\n        );/* To activate methods for different approaches*/\n        System.out.println(\n            nm.approach4(first, second)\n        );/* To activate methods for different approaches*/\n        /**\n         * OUTPUT :\n         * first string =\"deal\" second string =\"lead\"\n         * Output: Anagram\n         * Input and output is constant for all four approaches\n         * 1st approach Time Complexity : O(n logn)\n         * Auxiliary Space Complexity : O(1)\n         * 2nd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 3rd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 4th approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(n)\n         */\n    }\n\n    boolean approach1(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        } else {\n            char[] c = s.toCharArray();\n            char[] d = t.toCharArray();\n            Arrays.sort(c);\n            Arrays.sort(\n                d\n            );/* In this approach the strings are stored in the character arrays and both the arrays are sorted. After that both the arrays are compared for checking anangram */\n\n            return Arrays.equals(c, d);\n        }\n    }\n\n    boolean approach2(String a, String b) {\n        if (a.length() != b.length()) {\n            return false;\n        } else {\n            int[] m = new int[26];\n            int[] n = new int[26];\n            for (char c : a.toCharArray()) {\n                m[c - 'a']++;\n            }\n            // In this approach the frequency of both the strings are stored and after that the frequencies are iterated from 0 to 26(from 'a' to 'z' ). If the frequencies match then anagram message is displayed in the form of boolean format\n            // Running time and space complexity of this algo is less as compared to others\n            for (char c : b.toCharArray()) {\n                n[c - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (m[i] != n[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    boolean approach3(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        // this is similar to approach number 2 but here the string is not converted to character array\n        else {\n            int[] a = new int[26];\n            int[] b = new int[26];\n            int k = s.length();\n            for (int i = 0; i < k; i++) {\n                a[s.charAt(i) - 'a']++;\n                b[t.charAt(i) - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (a[i] != b[i]) return false;\n            }\n            return true;\n        }\n    }\n\n    boolean approach4(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        // This approach is done using hashmap where frequencies are stored and checked iteratively and if all the frequencies of first string match with the second string then anagram message is displayed in boolean format\n        else {\n            HashMap<Character, Integer> nm = new HashMap<>();\n            HashMap<Character, Integer> kk = new HashMap<>();\n            for (char c : s.toCharArray()) {\n                nm.put(c, nm.getOrDefault(c, 0) + 1);\n            }\n            for (char c : t.toCharArray()) {\n                kk.put(c, kk.getOrDefault(c, 0) + 1);\n            }\n            // It checks for equal frequencies by comparing key-value pairs of two hashmaps\n            return nm.equals(kk);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n/**\n * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase,\n * typically using all the original letters exactly once.[1]\n * For example, the word anagram itself can be rearranged into nag a ram,\n * also the word binary into brainy and the word adobe into abode.\n * Reference from https://en.wikipedia.org/wiki/Anagram\n */\npublic class Anagrams {\n\n    // 4 approaches are provided for anagram checking. approach 2 and approach 3 are similar but differ in running time.\n    public static void main(String[] args) {\n        String first = \"deal\";\n        String second = \"lead\";\n        // All the below methods takes input but doesn't return any output to the main method.\n        Anagrams nm = new Anagrams();\n        System.out.println(\n            nm.approach2(first, second)\n        );/* To activate methods for different approaches*/\n        System.out.println(\n            nm.approach1(first, second)\n        );/* To activate methods for different approaches*/\n        System.out.println(\n            nm.approach3(first, second)\n        );/* To activate methods for different approaches*/\n        System.out.println(\n            nm.approach4(first, second)\n        );/* To activate methods for different approaches*/\n        /**\n         * OUTPUT :\n         * first string =\"deal\" second string =\"lead\"\n         * Output: Anagram\n         * Input and output is constant for all four approaches\n         * 1st approach Time Complexity : O(n logn)\n         * Auxiliary Space Complexity : O(1)\n         * 2nd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 3rd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 4th approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(n)\n         * 5th approach Time Complexity: O(n)\n         * Auxiliary Space Complexity: O(1)\n         */\n    }\n\n    boolean approach1(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        } else {\n            char[] c = s.toCharArray();\n            char[] d = t.toCharArray();\n            Arrays.sort(c);\n            Arrays.sort(\n                d\n            );/* In this approach the strings are stored in the character arrays and both the arrays are sorted. After that both the arrays are compared for checking anangram */\n\n            return Arrays.equals(c, d);\n        }\n    }\n\n    boolean approach2(String a, String b) {\n        if (a.length() != b.length()) {\n            return false;\n        } else {\n            int[] m = new int[26];\n            int[] n = new int[26];\n            for (char c : a.toCharArray()) {\n                m[c - 'a']++;\n            }\n            // In this approach the frequency of both the strings are stored and after that the frequencies are iterated from 0 to 26(from 'a' to 'z' ). If the frequencies match then anagram message is displayed in the form of boolean format\n            // Running time and space complexity of this algo is less as compared to others\n            for (char c : b.toCharArray()) {\n                n[c - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (m[i] != n[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    boolean approach3(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        // this is similar to approach number 2 but here the string is not converted to character array\n        else {\n            int[] a = new int[26];\n            int[] b = new int[26];\n            int k = s.length();\n            for (int i = 0; i < k; i++) {\n                a[s.charAt(i) - 'a']++;\n                b[t.charAt(i) - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (a[i] != b[i]) return false;\n            }\n            return true;\n        }\n    }\n\n    boolean approach4(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        // This approach is done using hashmap where frequencies are stored and checked iteratively and if all the frequencies of first string match with the second string then anagram message is displayed in boolean format\n        else {\n            HashMap<Character, Integer> nm = new HashMap<>();\n            HashMap<Character, Integer> kk = new HashMap<>();\n            for (char c : s.toCharArray()) {\n                nm.put(c, nm.getOrDefault(c, 0) + 1);\n            }\n            for (char c : t.toCharArray()) {\n                kk.put(c, kk.getOrDefault(c, 0) + 1);\n            }\n            // It checks for equal frequencies by comparing key-value pairs of two hashmaps\n            return nm.equals(kk);\n        }\n    }\n\n    boolean approach5(String s, String t) {\n        if(s.length() != t.length()){\n            return false;\n        }\n        // Approach is different from above 4 aproaches. \n        // Here we initialize an array of size 26 where each element corresponds to the frequency of a character. \n        int[] freq = new int[26];\n        // iterate through both strings, incrementing the frequency of each character in the first string and decrementing the frequency of each character in the second string. \n        for(int i=0; i<s.length(); i++){\n            int pos1 = s.charAt(i) - 'a';\n\t\t\tint pos2 = s.charAt(i) - 'a';\n            freq[pos1]++;\n            freq[pos2]--;\n        }\n        // iterate through the frequency array and check if all the elements are zero, if so return true else false\n        for(int i=0; i<26; i++){\n            if(freq[i] != 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AnagramsTest {\n\n    @Test\n    public void isAlphabetical() {\n        String input1 = \"late\";\n        Anagrams anagrams = new Anagrams();\n        assertTrue(anagrams.approach1(input1, \"tale\"));\n        assertTrue(anagrams.approach1(input1, \"teal\"));\n        assertTrue(anagrams.approach2(input1, \"tale\"));\n        assertTrue(anagrams.approach2(input1, \"teal\"));\n        assertTrue(anagrams.approach3(input1, \"tale\"));\n        assertTrue(anagrams.approach3(input1, \"teal\"));\n        assertTrue(anagrams.approach4(input1, \"tale\"));\n        assertTrue(anagrams.approach4(input1, \"teal\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AnagramsTest {\n\n    @Test\n    public void isAlphabetical() {\n        String input1 = \"late\";\n        Anagrams anagrams = new Anagrams();\n        assertTrue(anagrams.approach1(input1, \"tale\"));\n        assertTrue(anagrams.approach1(input1, \"teal\"));\n        assertTrue(anagrams.approach2(input1, \"tale\"));\n        assertTrue(anagrams.approach2(input1, \"teal\"));\n        assertTrue(anagrams.approach3(input1, \"tale\"));\n        assertTrue(anagrams.approach3(input1, \"teal\"));\n        assertTrue(anagrams.approach4(input1, \"tale\"));\n        assertTrue(anagrams.approach4(input1, \"teal\"));\n        assertTrue(anagrams.approach5(input1, \"teal\"));\n    }\n}"
    },
    {
        "product_commit": "bb830e9559648659697f17f449c51c6dc0661275",
        "test_commit": "bb830e9559648659697f17f449c51c6dc0661275",
        "product_file_path": "src/main/java/com/thealgorithms/others/TwoPointers.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/TwoPointersTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * The two pointer technique is a useful tool to utilize when searching for\n * pairs in a sorted array.\n *\n * <p>\n * link: https://www.geeksforgeeks.org/two-pointers-technique/\n */\nclass TwoPointers {\n\n    public static void main(String[] args) {\n        int[] arr = { 10, 20, 35, 50, 75, 80 };\n        int key = 70;\n        assert isPairedSum(arr, key);\n        /* 20 + 60 == 70 */\n\n        arr = new int[] { 1, 2, 3, 4, 5, 6, 7 };\n        key = 13;\n        assert isPairedSum(arr, key);\n        /* 6 + 7 == 13 */\n\n        key = 14;\n        assert !isPairedSum(arr, key);\n    }\n\n    /**\n     * Given a sorted array arr (sorted in ascending order). Find if there\n     * exists any pair of elements such that their sum is equal to key.\n     *\n     * @param arr the array contains elements\n     * @param key the number to search\n     * @return {@code true} if there exists a pair of elements, {@code false}\n     * otherwise.\n     */\n    private static boolean isPairedSum(int[] arr, int key) {\n        /* array sorting is necessary for this algorithm to function correctly */\n        Arrays.sort(arr);\n        int i = 0;\n        /* index of first element */\n        int j = arr.length - 1;\n        /* index of last element */\n\n        while (i < j) {\n            if (arr[i] + arr[j] == key) {\n                return true;\n            } else if (arr[i] + arr[j] < key) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n        return false;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * The two pointer technique is a useful tool to utilize when searching for\n * pairs in a sorted array.\n *\n * <p>\n * link: https://www.geeksforgeeks.org/two-pointers-technique/\n */\nclass TwoPointers {\n\n    /**\n     * Given a sorted array arr (sorted in ascending order). Find if there\n     * exists any pair of elements such that their sum is equal to key.\n     *\n     * @param arr the array contains elements\n     * @param key the number to search\n     * @return {@code true} if there exists a pair of elements, {@code false}\n     * otherwise.\n     */\n    public static boolean isPairedSum(int[] arr, int key) {\n        /* array sorting is necessary for this algorithm to function correctly */\n        Arrays.sort(arr);\n        int i = 0;\n        /* index of first element */\n        int j = arr.length - 1;\n        /* index of last element */\n\n        while (i < j) {\n            if (arr[i] + arr[j] == key) {\n                return true;\n            } else if (arr[i] + arr[j] < key) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n        return false;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\npublic class TwoPointersTest {\n\n\n    @Test\n    void twoPointersFirstTestCase(){\n        int[] arr = {2,6,9,22,121};\n        int key = 28;\n        assertEquals(true, TwoPointers.isPairedSum(arr,key));\n    }\n\n    @Test\n    void twoPointersSecondTestCase(){\n        int[] arr = {-1,-12,12,0,8};\n        int key = 0;\n        assertEquals(true, TwoPointers.isPairedSum(arr,key));\n    }\n\n    @Test\n    void twoPointersThirdTestCase(){\n        int[] arr = {12,35,12,152,0};\n        int key = 13;\n        assertEquals(false, TwoPointers.isPairedSum(arr,key));\n    }\n\n    @Test\n    void twoPointersFourthTestCase(){\n        int[] arr = {-2,5,-1,52,31};\n        int key = -3;\n        assertEquals(true, TwoPointers.isPairedSum(arr,key));\n    }\n\n    @Test\n    void twoPointersFiftiethTestCase(){\n        int[] arr = {25,1,0,61,21};\n        int key = 12;\n        assertEquals(false, TwoPointers.isPairedSum(arr,key));\n    }\n}"
    },
    {
        "product_commit": "fb18c27905ce136967da707cf014a1f07ba64ab9",
        "test_commit": "19bd2408ff50a8bcc835d51eff576a70a228e37f",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/DES.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/DESTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/**\n * This class is build to demonstrate the application of the DES-algorithm on a\n * plain English message. The supplied key must be in form of a 64 bit binary String.\n */\npublic class DES {\n\n    private String key;\n    private String subKeys[];\n\n    private void sanitize(String key) {\n        int length = key.length();\n        if (length != 64) {\n            throw new IllegalArgumentException(\"DES key must be supplied as a 64 character binary string\");\n        }\n    }\n\n    DES(String key) {\n        sanitize(key);\n        this.key = key;\n        subKeys = getSubkeys(key);\n    }\n\n    public String getKey() {\n        return this.key;\n    }\n\n    public void setKey(String key) {\n        sanitize(key);\n        this.key = key;\n    }\n\t\n    //Permutation table to convert initial 64 bit key to 56 bit key\n\tprivate static int[] PC1 = \n\t{  \n\t\t57, 49, 41, 33, 25, 17,  9,\n        1, 58, 50, 42, 34, 26, 18,\n        10,  2, 59, 51, 43, 35, 27,\n        19, 11,  3, 60, 52, 44, 36,\n        63, 55, 47, 39, 31, 23, 15,\n        7, 62, 54, 46, 38, 30, 22,\n        14,  6, 61, 53, 45, 37, 29,\n        21, 13,  5, 28, 20, 12,  4\n\t};\n\n    //Lookup table used to shift the initial key, in order to generate the subkeys\n    private static int[] KEY_SHIFTS = \n\t{\n\t\t1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1\n\t};\n\n    //Table to convert the 56 bit subkeys to 48 bit subkeys\n    private static int[] PC2 = \n\t{\n\t\t14, 17, 11, 24,  1,  5,\n        3, 28, 15,  6, 21, 10,\n        23, 19, 12,  4, 26,  8,\n        16,  7, 27, 20, 13,  2,\n        41, 52, 31, 37, 47, 55,\n        30, 40, 51, 45, 33, 48,\n        44, 49, 39, 56, 34, 53,\n        46, 42, 50, 36, 29, 32\n\t};\n\n    //Initial permutatation of each 64 but message block\n    private static int[] IP = \n\t{\n\t\t 58, 50, 42, 34, 26, 18, 10 , 2,\n         60, 52, 44, 36, 28, 20, 12, 4,\n         62, 54, 46, 38, 30, 22, 14, 6,\n         64, 56, 48, 40, 32, 24, 16, 8,\n         57, 49, 41, 33, 25, 17, 9, 1,\n         59, 51, 43, 35, 27, 19, 11, 3,\n         61, 53, 45, 37, 29, 21, 13, 5,\n         63, 55, 47, 39, 31, 23, 15, 7\n\t};\n\n    //Expansion table to convert right half of message blocks from 32 bits to 48 bits\n    private static int[] expansion = \n\t{\n\t\t32,  1,  2,  3,  4,  5,\n\t\t4,  5,  6,  7,  8,  9, \n\t\t8,  9, 10, 11, 12, 13, \n\t\t12, 13, 14, 15, 16, 17,\n\t\t16, 17, 18, 19, 20, 21, \n\t\t20, 21, 22, 23, 24, 25, \n\t\t24, 25, 26, 27, 28, 29, \n\t\t28, 29, 30, 31, 32,  1\n\t};\n \n    //The eight substitution boxes are defined below\n    private static int[][] s1 = {\n\t\t{14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},\n\t\t{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11,  9,  5,  3,  8},\n\t\t{4, 1, 14,  8, 13,  6, 2, 11, 15, 12,  9,  7,  3, 10,  5,  0},\n\t\t{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}\n\t };\n\n\tprivate static int[][] s2 = {\n\t\t\t{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},\n\t\t\t{3, 13,  4, 7, 15,  2,  8, 14, 12,  0, 1, 10,  6,  9, 11,  5},\n\t\t\t{0, 14, 7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},\n\t\t\t{13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14,  9}\n\t\t };\n\t\n\tprivate static int[][] s3 = {\n\t\t\t{10, 0, 9, 14, 6, 3, 15, 5,  1, 13, 12, 7, 11, 4, 2,  8},\n\t\t\t{13, 7, 0, 9, 3,  4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},\n\t\t\t{13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14,  7},\n\t\t\t{1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}\n\t\t };\n\t\n\tprivate static int[][] s4 = {\n\t\t\t{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},\n\t\t\t{13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,  9},\n\t\t\t{10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},\n\t\t\t{3, 15, 0, 6, 10, 1, 13, 8, 9,  4, 5, 11, 12, 7, 2, 14}\n\t\t };\n\t\n\tprivate static int[][] s5 = {\n\t\t\t{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},\n\t\t\t{14, 11, 2, 12,  4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},\n\t\t\t{4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},\n\t\t\t{11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}\n\t\t  };\n\t\n\tprivate static int[][] s6 = {\n\t\t\t{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},\n\t\t\t{10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},\n\t\t\t{9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},\n\t\t\t{4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}\n\t\t  };\n\t\n\tprivate static int[][] s7 = {\n\t\t\t{4, 11, 2, 14, 15,  0, 8, 13 , 3, 12, 9 , 7,  5, 10, 6, 1},\n\t\t\t{13 , 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},\n\t\t\t{1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},\n\t\t\t{6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}\n\t\t  };\n\t\n\tprivate static int[][] s8 = {\n\t\t\t{13, 2, 8,  4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},\n\t\t\t{1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6 ,11, 0, 14, 9, 2},\n\t\t\t{7, 11, 4, 1, 9, 12, 14, 2,  0, 6, 10 ,13, 15, 3, 5, 8},\n\t\t\t{2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6 ,11}\n\t\t};\n\t\n\tprivate static int[][][] s = {s1, s2, s3, s4, s5, s6, s7, s8};\n\n    //Permutation table, used in the feistel function post s-box usage\n    static int[] permutation = \n\t{\n\t\t16,  7, 20, 21, \n\t\t29, 12, 28, 17, \n\t\t 1, 15, 23, 26, \n\t\t 5, 18, 31, 10, \n\t\t 2,  8, 24, 14, \n\t\t32, 27,  3,  9, \n\t\t19, 13, 30,  6, \n\t\t22, 11,  4, 25\n\t};\n\n    //Table used for final inversion of the message box after 16 rounds of Feistel Function\n    static int[] IPinverse = \n\t{\n\t\t40, 8, 48, 16, 56, 24, 64, 32,\n\t    39, 7, 47, 15, 55, 23, 63, 31,\n\t    38, 6, 46, 14, 54, 22, 62, 30,\n\t    37, 5, 45, 13, 53, 21, 61, 29,\n\t    36, 4, 44, 12, 52, 20, 60, 28,\n\t    35, 3, 43 ,11, 51, 19, 59, 27,\n\t    34, 2, 42, 10, 50, 18, 58, 26,\n\t    33, 1, 41, 9, 49, 17, 57, 25\n\t};\n\n    private String[] getSubkeys(String originalKey) {\n        StringBuilder permutedKey = new StringBuilder(); //Initial permutation of keys via PC1\n        int i, j;\n        for (i = 0; i < 56; i++) {\n            permutedKey.append(originalKey.charAt(PC1[i] - 1)); \n        }\n        String subKeys[] = new String[16];\n        String initialPermutedKey = permutedKey.toString();\n        String C0 = initialPermutedKey.substring(0, 28), D0 = initialPermutedKey.substring(28);\n        \n        //We will now operate on the left and right halves of the permutedKey\n        for (i = 0; i < 16; i++) {\n            String Cn = C0.substring(KEY_SHIFTS[i]) + C0.substring(0, KEY_SHIFTS[i]);\n            String Dn = D0.substring(KEY_SHIFTS[i]) + D0.substring(0, KEY_SHIFTS[i]);\n            subKeys[i] = Cn + Dn;\n            C0 = Cn; //Re-assign the values to create running permutation\n            D0 = Dn;\n        }\n\n        //Let us shrink the keys to 48 bits (well, characters here) using PC2\n        for (i = 0; i < 16; i++) {\n            String key = subKeys[i];\n            permutedKey.setLength(0);\n            for (j = 0; j < 48; j++) {\n                permutedKey.append(key.charAt(PC2[j] - 1));\n            }\n            subKeys[i] = permutedKey.toString();\n        }\n\n        return subKeys;\n    }\n\n    private String XOR(String a, String b) {\n        int i, l = a.length();\n        StringBuilder xor = new StringBuilder();\n        for (i = 0; i < l; i++) {\n            int firstBit = a.charAt(i) - 48; // 48 is '0' in ascii\n            int secondBit = b.charAt(i) - 48;\n            xor.append((firstBit ^ secondBit));\n        }\n        return xor.toString();\n    }\n\n    private String createPaddedString(String s, int desiredLength, char pad) {\n        int i, l = s.length();\n        StringBuilder paddedString = new StringBuilder();\n        int diff = desiredLength - l;\n        for (i = 0; i < diff; i++) {\n            paddedString.append(pad);\n        }\n        return paddedString.toString();\n    }\n\n    private String pad(String s, int desiredLength) {\n        return createPaddedString(s, desiredLength, '0') + s;\n    }\n\n    private String padLast(String s, int desiredLength) {\n        return s + createPaddedString(s, desiredLength, '\\u0000');\n    }\n\n    private String feistel(String messageBlock, String key) {\n        int i;\n        StringBuilder expandedKey = new StringBuilder();\n        for (i = 0; i < 48; i++) {\n            expandedKey.append(messageBlock.charAt(expansion[i] - 1));\n        }\n        String mixedKey = XOR(expandedKey.toString(), key);\n        StringBuilder substitutedString = new StringBuilder();\n\n        //Let us now use the s-boxes to transform each 6 bit (length here) block to 4 bits\n        for (i = 0; i < 48; i += 6) {\n            String block = mixedKey.substring(i, i + 6);\n            int row = (block.charAt(0) - 48) * 2 + (block.charAt(5) - 48);\n            int col = (block.charAt(1) - 48) * 8 + (block.charAt(2) - 48) * 4 + (block.charAt(3) - 48) * 2 + (block.charAt(4) - 48);\n            String substitutedBlock = pad(Integer.toBinaryString(s[i / 6][row][col]), 4);\n            substitutedString.append(substitutedBlock);\n        }\n\n        StringBuilder permutedString = new StringBuilder(); \n        for (i = 0; i < 32; i++) {\n            permutedString.append(substitutedString.charAt(permutation[i] - 1));\n        }\n\n        return permutedString.toString();\n    }\n\n    private String encryptBlock(String message, String keys[]) {\n        StringBuilder permutedMessage = new StringBuilder();\n        int i;\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(message.charAt(IP[i] - 1));\n        }\n        String L0 = permutedMessage.substring(0, 32), R0 = permutedMessage.substring(32);\n\n        //Iterate 16 times\n        for (i = 0; i < 16; i++) {\n            String Ln = R0; // Previous Right block\n            String Rn = XOR(L0, feistel(R0, keys[i]));\n            L0 = Ln;\n            R0 = Rn;\n        }\n\n        String combinedBlock = R0 + L0; //Reverse the 16th block\n        permutedMessage.setLength(0);\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(combinedBlock.charAt(IPinverse[i] - 1));\n        }\n        return permutedMessage.toString();\n    }\n\n    //To decode, we follow the same process as encoding, but with reversed keys\n    private String decryptBlock(String message, String keys[]) {\n        String reversedKeys[] = new String[keys.length];\n        for (int i = 0; i < keys.length; i++) {\n            reversedKeys[i] = keys[keys.length - i - 1];\n        }\n        return encryptBlock(message, reversedKeys);\n    }\n\n    /**\n     * @param message Message to be encrypted\n     * @return The encrypted message, as a binary string\n     */\n    public String encrypt(String message) {\n        StringBuilder encryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 8 != 0) {\n            int desiredLength = (l / 8 + 1) * 8;\n            l = desiredLength;\n            message = padLast(message, desiredLength);\n        }\n\n        for (i = 0; i < l; i+= 8) {\n            String block = message.substring(i, i + 8);\n            StringBuilder bitBlock = new StringBuilder();\n            byte[] bytes = block.getBytes();\n            for (j = 0; j < 8; j++) {\n                bitBlock.append(pad(Integer.toBinaryString(bytes[j]), 8));\n            }\n            encryptedMessage.append(encryptBlock(bitBlock.toString(), subKeys));\n        }\n        return encryptedMessage.toString();\n    }\n\n    /**\n     * @param message The encrypted string. Expects it to be a multiple of 64 bits, in binary format\n     * @return The decrypted String, in plain English\n     */\n    public String decrypt(String message) {\n        StringBuilder decryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 64 != 0) {\n            throw new IllegalArgumentException(\"Encrypted message should be a multiple of 64 characters in length\");\n        }\n        for (i = 0; i < l; i+= 64) {\n            String block = message.substring(i, i + 64);\n            String result = decryptBlock(block.toString(), subKeys);\n            byte res[] = new byte[8];\n            for (j = 0; j < 64; j+=8) {\n                res[j / 8] = (byte)Integer.parseInt(result.substring(j, j + 8), 2);\n            }\n            decryptedMessage.append(new String(res));\n        }\n        return decryptedMessage.toString().replace(\"\\0\", \"\"); // Get rid of the null bytes used for padding\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * This class is build to demonstrate the application of the DES-algorithm (https://en.wikipedia.org/wiki/Data_Encryption_Standard) on a\n * plain English message. The supplied key must be in form of a 64 bit binary String.\n */\npublic class DES {\n\n    private String key;\n    private String subKeys[];\n\n    private void sanitize(String key) {\n        int length = key.length();\n        if (length != 64) {\n            throw new IllegalArgumentException(\"DES key must be supplied as a 64 character binary string\");\n        }\n    }\n\n    DES(String key) {\n        sanitize(key);\n        this.key = key;\n        subKeys = getSubkeys(key);\n    }\n\n    public String getKey() {\n        return this.key;\n    }\n\n    public void setKey(String key) {\n        sanitize(key);\n        this.key = key;\n    }\n\t\n    //Permutation table to convert initial 64 bit key to 56 bit key\n\tprivate static int[] PC1 = \n\t{  \n\t\t57, 49, 41, 33, 25, 17,  9,\n        1, 58, 50, 42, 34, 26, 18,\n        10,  2, 59, 51, 43, 35, 27,\n        19, 11,  3, 60, 52, 44, 36,\n        63, 55, 47, 39, 31, 23, 15,\n        7, 62, 54, 46, 38, 30, 22,\n        14,  6, 61, 53, 45, 37, 29,\n        21, 13,  5, 28, 20, 12,  4\n\t};\n\n    //Lookup table used to shift the initial key, in order to generate the subkeys\n    private static int[] KEY_SHIFTS = \n\t{\n\t\t1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1\n\t};\n\n    //Table to convert the 56 bit subkeys to 48 bit subkeys\n    private static int[] PC2 = \n\t{\n\t\t14, 17, 11, 24,  1,  5,\n        3, 28, 15,  6, 21, 10,\n        23, 19, 12,  4, 26,  8,\n        16,  7, 27, 20, 13,  2,\n        41, 52, 31, 37, 47, 55,\n        30, 40, 51, 45, 33, 48,\n        44, 49, 39, 56, 34, 53,\n        46, 42, 50, 36, 29, 32\n\t};\n\n    //Initial permutatation of each 64 but message block\n    private static int[] IP = \n\t{\n\t\t 58, 50, 42, 34, 26, 18, 10 , 2,\n         60, 52, 44, 36, 28, 20, 12, 4,\n         62, 54, 46, 38, 30, 22, 14, 6,\n         64, 56, 48, 40, 32, 24, 16, 8,\n         57, 49, 41, 33, 25, 17, 9, 1,\n         59, 51, 43, 35, 27, 19, 11, 3,\n         61, 53, 45, 37, 29, 21, 13, 5,\n         63, 55, 47, 39, 31, 23, 15, 7\n\t};\n\n    //Expansion table to convert right half of message blocks from 32 bits to 48 bits\n    private static int[] expansion = \n\t{\n\t\t32,  1,  2,  3,  4,  5,\n\t\t4,  5,  6,  7,  8,  9, \n\t\t8,  9, 10, 11, 12, 13, \n\t\t12, 13, 14, 15, 16, 17,\n\t\t16, 17, 18, 19, 20, 21, \n\t\t20, 21, 22, 23, 24, 25, \n\t\t24, 25, 26, 27, 28, 29, \n\t\t28, 29, 30, 31, 32,  1\n\t};\n \n    //The eight substitution boxes are defined below\n    private static int[][] s1 = {\n\t\t{14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},\n\t\t{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11,  9,  5,  3,  8},\n\t\t{4, 1, 14,  8, 13,  6, 2, 11, 15, 12,  9,  7,  3, 10,  5,  0},\n\t\t{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}\n\t };\n\n\tprivate static int[][] s2 = {\n\t\t\t{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},\n\t\t\t{3, 13,  4, 7, 15,  2,  8, 14, 12,  0, 1, 10,  6,  9, 11,  5},\n\t\t\t{0, 14, 7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},\n\t\t\t{13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14,  9}\n\t\t };\n\t\n\tprivate static int[][] s3 = {\n\t\t\t{10, 0, 9, 14, 6, 3, 15, 5,  1, 13, 12, 7, 11, 4, 2,  8},\n\t\t\t{13, 7, 0, 9, 3,  4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},\n\t\t\t{13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14,  7},\n\t\t\t{1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}\n\t\t };\n\t\n\tprivate static int[][] s4 = {\n\t\t\t{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},\n\t\t\t{13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,  9},\n\t\t\t{10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},\n\t\t\t{3, 15, 0, 6, 10, 1, 13, 8, 9,  4, 5, 11, 12, 7, 2, 14}\n\t\t };\n\t\n\tprivate static int[][] s5 = {\n\t\t\t{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},\n\t\t\t{14, 11, 2, 12,  4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},\n\t\t\t{4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},\n\t\t\t{11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}\n\t\t  };\n\t\n\tprivate static int[][] s6 = {\n\t\t\t{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},\n\t\t\t{10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},\n\t\t\t{9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},\n\t\t\t{4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}\n\t\t  };\n\t\n\tprivate static int[][] s7 = {\n\t\t\t{4, 11, 2, 14, 15,  0, 8, 13 , 3, 12, 9 , 7,  5, 10, 6, 1},\n\t\t\t{13 , 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},\n\t\t\t{1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},\n\t\t\t{6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}\n\t\t  };\n\t\n\tprivate static int[][] s8 = {\n\t\t\t{13, 2, 8,  4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},\n\t\t\t{1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6 ,11, 0, 14, 9, 2},\n\t\t\t{7, 11, 4, 1, 9, 12, 14, 2,  0, 6, 10 ,13, 15, 3, 5, 8},\n\t\t\t{2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6 ,11}\n\t\t};\n\t\n\tprivate static int[][][] s = {s1, s2, s3, s4, s5, s6, s7, s8};\n\n    //Permutation table, used in the feistel function post s-box usage\n    static int[] permutation = \n\t{\n\t\t16,  7, 20, 21, \n\t\t29, 12, 28, 17, \n\t\t 1, 15, 23, 26, \n\t\t 5, 18, 31, 10, \n\t\t 2,  8, 24, 14, \n\t\t32, 27,  3,  9, \n\t\t19, 13, 30,  6, \n\t\t22, 11,  4, 25\n\t};\n\n    //Table used for final inversion of the message box after 16 rounds of Feistel Function\n    static int[] IPinverse = \n\t{\n\t\t40, 8, 48, 16, 56, 24, 64, 32,\n\t    39, 7, 47, 15, 55, 23, 63, 31,\n\t    38, 6, 46, 14, 54, 22, 62, 30,\n\t    37, 5, 45, 13, 53, 21, 61, 29,\n\t    36, 4, 44, 12, 52, 20, 60, 28,\n\t    35, 3, 43 ,11, 51, 19, 59, 27,\n\t    34, 2, 42, 10, 50, 18, 58, 26,\n\t    33, 1, 41, 9, 49, 17, 57, 25\n\t};\n\n    private String[] getSubkeys(String originalKey) {\n        StringBuilder permutedKey = new StringBuilder(); //Initial permutation of keys via PC1\n        int i, j;\n        for (i = 0; i < 56; i++) {\n            permutedKey.append(originalKey.charAt(PC1[i] - 1)); \n        }\n        String subKeys[] = new String[16];\n        String initialPermutedKey = permutedKey.toString();\n        String C0 = initialPermutedKey.substring(0, 28), D0 = initialPermutedKey.substring(28);\n        \n        //We will now operate on the left and right halves of the permutedKey\n        for (i = 0; i < 16; i++) {\n            String Cn = C0.substring(KEY_SHIFTS[i]) + C0.substring(0, KEY_SHIFTS[i]);\n            String Dn = D0.substring(KEY_SHIFTS[i]) + D0.substring(0, KEY_SHIFTS[i]);\n            subKeys[i] = Cn + Dn;\n            C0 = Cn; //Re-assign the values to create running permutation\n            D0 = Dn;\n        }\n\n        //Let us shrink the keys to 48 bits (well, characters here) using PC2\n        for (i = 0; i < 16; i++) {\n            String key = subKeys[i];\n            permutedKey.setLength(0);\n            for (j = 0; j < 48; j++) {\n                permutedKey.append(key.charAt(PC2[j] - 1));\n            }\n            subKeys[i] = permutedKey.toString();\n        }\n\n        return subKeys;\n    }\n\n    private String XOR(String a, String b) {\n        int i, l = a.length();\n        StringBuilder xor = new StringBuilder();\n        for (i = 0; i < l; i++) {\n            int firstBit = a.charAt(i) - 48; // 48 is '0' in ascii\n            int secondBit = b.charAt(i) - 48;\n            xor.append((firstBit ^ secondBit));\n        }\n        return xor.toString();\n    }\n\n    private String createPaddedString(String s, int desiredLength, char pad) {\n        int i, l = s.length();\n        StringBuilder paddedString = new StringBuilder();\n        int diff = desiredLength - l;\n        for (i = 0; i < diff; i++) {\n            paddedString.append(pad);\n        }\n        return paddedString.toString();\n    }\n\n    private String pad(String s, int desiredLength) {\n        return createPaddedString(s, desiredLength, '0') + s;\n    }\n\n    private String padLast(String s, int desiredLength) {\n        return s + createPaddedString(s, desiredLength, '\\u0000');\n    }\n\n    private String feistel(String messageBlock, String key) {\n        int i;\n        StringBuilder expandedKey = new StringBuilder();\n        for (i = 0; i < 48; i++) {\n            expandedKey.append(messageBlock.charAt(expansion[i] - 1));\n        }\n        String mixedKey = XOR(expandedKey.toString(), key);\n        StringBuilder substitutedString = new StringBuilder();\n\n        //Let us now use the s-boxes to transform each 6 bit (length here) block to 4 bits\n        for (i = 0; i < 48; i += 6) {\n            String block = mixedKey.substring(i, i + 6);\n            int row = (block.charAt(0) - 48) * 2 + (block.charAt(5) - 48);\n            int col = (block.charAt(1) - 48) * 8 + (block.charAt(2) - 48) * 4 + (block.charAt(3) - 48) * 2 + (block.charAt(4) - 48);\n            String substitutedBlock = pad(Integer.toBinaryString(s[i / 6][row][col]), 4);\n            substitutedString.append(substitutedBlock);\n        }\n\n        StringBuilder permutedString = new StringBuilder(); \n        for (i = 0; i < 32; i++) {\n            permutedString.append(substitutedString.charAt(permutation[i] - 1));\n        }\n\n        return permutedString.toString();\n    }\n\n    private String encryptBlock(String message, String keys[]) {\n        StringBuilder permutedMessage = new StringBuilder();\n        int i;\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(message.charAt(IP[i] - 1));\n        }\n        String L0 = permutedMessage.substring(0, 32), R0 = permutedMessage.substring(32);\n\n        //Iterate 16 times\n        for (i = 0; i < 16; i++) {\n            String Ln = R0; // Previous Right block\n            String Rn = XOR(L0, feistel(R0, keys[i]));\n            L0 = Ln;\n            R0 = Rn;\n        }\n\n        String combinedBlock = R0 + L0; //Reverse the 16th block\n        permutedMessage.setLength(0);\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(combinedBlock.charAt(IPinverse[i] - 1));\n        }\n        return permutedMessage.toString();\n    }\n\n    //To decode, we follow the same process as encoding, but with reversed keys\n    private String decryptBlock(String message, String keys[]) {\n        String reversedKeys[] = new String[keys.length];\n        for (int i = 0; i < keys.length; i++) {\n            reversedKeys[i] = keys[keys.length - i - 1];\n        }\n        return encryptBlock(message, reversedKeys);\n    }\n\n    /**\n     * @param message Message to be encrypted\n     * @return The encrypted message, as a binary string\n     */\n    public String encrypt(String message) {\n        StringBuilder encryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 8 != 0) {\n            int desiredLength = (l / 8 + 1) * 8;\n            l = desiredLength;\n            message = padLast(message, desiredLength);\n        }\n\n        for (i = 0; i < l; i+= 8) {\n            String block = message.substring(i, i + 8);\n            StringBuilder bitBlock = new StringBuilder();\n            byte[] bytes = block.getBytes();\n            for (j = 0; j < 8; j++) {\n                bitBlock.append(pad(Integer.toBinaryString(bytes[j]), 8));\n            }\n            encryptedMessage.append(encryptBlock(bitBlock.toString(), subKeys));\n        }\n        return encryptedMessage.toString();\n    }\n\n    /**\n     * @param message The encrypted string. Expects it to be a multiple of 64 bits, in binary format\n     * @return The decrypted String, in plain English\n     */\n    public String decrypt(String message) {\n        StringBuilder decryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 64 != 0) {\n            throw new IllegalArgumentException(\"Encrypted message should be a multiple of 64 characters in length\");\n        }\n        for (i = 0; i < l; i+= 64) {\n            String block = message.substring(i, i + 64);\n            String result = decryptBlock(block.toString(), subKeys);\n            byte res[] = new byte[8];\n            for (j = 0; j < 64; j+=8) {\n                res[j / 8] = (byte)Integer.parseInt(result.substring(j, j + 8), 2);\n            }\n            decryptedMessage.append(new String(res));\n        }\n        return decryptedMessage.toString().replace(\"\\0\", \"\"); // Get rid of the null bytes used for padding\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n//Test example taken from https://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm\npublic class DESTest {\n\n    DES des;\n\n    @BeforeEach\n    public void setUp() {\n        des = new DES(\"0000111000110010100100100011001011101010011011010000110101110011\");\n    }\n\n    @Test\n    void testEncrypt() {\n        //given\n        String plainText = \"Your lips are smoother than vaseline\\r\\n\";\n        //This is equal to c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in hexadecimal\n        String expectedOutput = \"11000000100110011001111111011101111000110111100011010111111\" +\n        \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\" +\n        \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\" +\n        \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n\n        //when\n        String cipherText = des.encrypt(plainText);\n\n        //then\n        assertEquals(expectedOutput, cipherText);\n    }\n\n    @Test\n    void testDecrypt() {\n        //given\n       //This is equal to c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in hexadecimal\n       String cipherText = \"11000000100110011001111111011101111000110111100011010111111\" +\n       \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\" +\n       \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\" +\n       \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n        String expectedOutput = \"Your lips are smoother than vaseline\\r\\n\";;\n\n        //when\n        String plainText = des.decrypt(cipherText);\n\n        //then\n        assertEquals(expectedOutput, plainText);\n    }\n}"
    },
    {
        "product_commit": "19bd2408ff50a8bcc835d51eff576a70a228e37f",
        "test_commit": "19bd2408ff50a8bcc835d51eff576a70a228e37f",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/DES.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/DESTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * This class is build to demonstrate the application of the DES-algorithm on a\n * plain English message. The supplied key must be in form of a 64 bit binary String.\n */\npublic class DES {\n\n    private String key;\n    private String subKeys[];\n\n    private void sanitize(String key) {\n        int length = key.length();\n        if (length != 64) {\n            throw new IllegalArgumentException(\"DES key must be supplied as a 64 character binary string\");\n        }\n    }\n\n    DES(String key) {\n        sanitize(key);\n        this.key = key;\n        subKeys = getSubkeys(key);\n    }\n\n    public String getKey() {\n        return this.key;\n    }\n\n    public void setKey(String key) {\n        sanitize(key);\n        this.key = key;\n    }\n\t\n    //Permutation table to convert initial 64 bit key to 56 bit key\n\tprivate static int[] PC1 = \n\t{  \n\t\t57, 49, 41, 33, 25, 17,  9,\n        1, 58, 50, 42, 34, 26, 18,\n        10,  2, 59, 51, 43, 35, 27,\n        19, 11,  3, 60, 52, 44, 36,\n        63, 55, 47, 39, 31, 23, 15,\n        7, 62, 54, 46, 38, 30, 22,\n        14,  6, 61, 53, 45, 37, 29,\n        21, 13,  5, 28, 20, 12,  4\n\t};\n\n    //Lookup table used to shift the initial key, in order to generate the subkeys\n    private static int[] KEY_SHIFTS = \n\t{\n\t\t1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1\n\t};\n\n    //Table to convert the 56 bit subkeys to 48 bit subkeys\n    private static int[] PC2 = \n\t{\n\t\t14, 17, 11, 24,  1,  5,\n        3, 28, 15,  6, 21, 10,\n        23, 19, 12,  4, 26,  8,\n        16,  7, 27, 20, 13,  2,\n        41, 52, 31, 37, 47, 55,\n        30, 40, 51, 45, 33, 48,\n        44, 49, 39, 56, 34, 53,\n        46, 42, 50, 36, 29, 32\n\t};\n\n    //Initial permutatation of each 64 but message block\n    private static int[] IP = \n\t{\n\t\t 58, 50, 42, 34, 26, 18, 10 , 2,\n         60, 52, 44, 36, 28, 20, 12, 4,\n         62, 54, 46, 38, 30, 22, 14, 6,\n         64, 56, 48, 40, 32, 24, 16, 8,\n         57, 49, 41, 33, 25, 17, 9, 1,\n         59, 51, 43, 35, 27, 19, 11, 3,\n         61, 53, 45, 37, 29, 21, 13, 5,\n         63, 55, 47, 39, 31, 23, 15, 7\n\t};\n\n    //Expansion table to convert right half of message blocks from 32 bits to 48 bits\n    private static int[] expansion = \n\t{\n\t\t32,  1,  2,  3,  4,  5,\n\t\t4,  5,  6,  7,  8,  9, \n\t\t8,  9, 10, 11, 12, 13, \n\t\t12, 13, 14, 15, 16, 17,\n\t\t16, 17, 18, 19, 20, 21, \n\t\t20, 21, 22, 23, 24, 25, \n\t\t24, 25, 26, 27, 28, 29, \n\t\t28, 29, 30, 31, 32,  1\n\t};\n \n    //The eight substitution boxes are defined below\n    private static int[][] s1 = {\n\t\t{14, 4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7},\n\t\t{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11,  9,  5,  3,  8},\n\t\t{4, 1, 14,  8, 13,  6, 2, 11, 15, 12,  9,  7,  3, 10,  5,  0},\n\t\t{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}\n\t };\n\n\tprivate static int[][] s2 = {\n\t\t\t{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},\n\t\t\t{3, 13,  4, 7, 15,  2,  8, 14, 12,  0, 1, 10,  6,  9, 11,  5},\n\t\t\t{0, 14, 7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15},\n\t\t\t{13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14,  9}\n\t\t };\n\t\n\tprivate static int[][] s3 = {\n\t\t\t{10, 0, 9, 14, 6, 3, 15, 5,  1, 13, 12, 7, 11, 4, 2,  8},\n\t\t\t{13, 7, 0, 9, 3,  4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},\n\t\t\t{13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14,  7},\n\t\t\t{1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}\n\t\t };\n\t\n\tprivate static int[][] s4 = {\n\t\t\t{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},\n\t\t\t{13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14,  9},\n\t\t\t{10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},\n\t\t\t{3, 15, 0, 6, 10, 1, 13, 8, 9,  4, 5, 11, 12, 7, 2, 14}\n\t\t };\n\t\n\tprivate static int[][] s5 = {\n\t\t\t{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},\n\t\t\t{14, 11, 2, 12,  4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},\n\t\t\t{4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},\n\t\t\t{11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}\n\t\t  };\n\t\n\tprivate static int[][] s6 = {\n\t\t\t{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},\n\t\t\t{10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},\n\t\t\t{9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},\n\t\t\t{4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}\n\t\t  };\n\t\n\tprivate static int[][] s7 = {\n\t\t\t{4, 11, 2, 14, 15,  0, 8, 13 , 3, 12, 9 , 7,  5, 10, 6, 1},\n\t\t\t{13 , 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},\n\t\t\t{1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},\n\t\t\t{6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}\n\t\t  };\n\t\n\tprivate static int[][] s8 = {\n\t\t\t{13, 2, 8,  4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},\n\t\t\t{1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6 ,11, 0, 14, 9, 2},\n\t\t\t{7, 11, 4, 1, 9, 12, 14, 2,  0, 6, 10 ,13, 15, 3, 5, 8},\n\t\t\t{2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6 ,11}\n\t\t};\n\t\n\tprivate static int[][][] s = {s1, s2, s3, s4, s5, s6, s7, s8};\n\n    //Permutation table, used in the feistel function post s-box usage\n    static int[] permutation = \n\t{\n\t\t16,  7, 20, 21, \n\t\t29, 12, 28, 17, \n\t\t 1, 15, 23, 26, \n\t\t 5, 18, 31, 10, \n\t\t 2,  8, 24, 14, \n\t\t32, 27,  3,  9, \n\t\t19, 13, 30,  6, \n\t\t22, 11,  4, 25\n\t};\n\n    //Table used for final inversion of the message box after 16 rounds of Feistel Function\n    static int[] IPinverse = \n\t{\n\t\t40, 8, 48, 16, 56, 24, 64, 32,\n\t    39, 7, 47, 15, 55, 23, 63, 31,\n\t    38, 6, 46, 14, 54, 22, 62, 30,\n\t    37, 5, 45, 13, 53, 21, 61, 29,\n\t    36, 4, 44, 12, 52, 20, 60, 28,\n\t    35, 3, 43 ,11, 51, 19, 59, 27,\n\t    34, 2, 42, 10, 50, 18, 58, 26,\n\t    33, 1, 41, 9, 49, 17, 57, 25\n\t};\n\n    private String[] getSubkeys(String originalKey) {\n        StringBuilder permutedKey = new StringBuilder(); //Initial permutation of keys via PC1\n        int i, j;\n        for (i = 0; i < 56; i++) {\n            permutedKey.append(originalKey.charAt(PC1[i] - 1)); \n        }\n        String subKeys[] = new String[16];\n        String initialPermutedKey = permutedKey.toString();\n        String C0 = initialPermutedKey.substring(0, 28), D0 = initialPermutedKey.substring(28);\n        \n        //We will now operate on the left and right halves of the permutedKey\n        for (i = 0; i < 16; i++) {\n            String Cn = C0.substring(KEY_SHIFTS[i]) + C0.substring(0, KEY_SHIFTS[i]);\n            String Dn = D0.substring(KEY_SHIFTS[i]) + D0.substring(0, KEY_SHIFTS[i]);\n            subKeys[i] = Cn + Dn;\n            C0 = Cn; //Re-assign the values to create running permutation\n            D0 = Dn;\n        }\n\n        //Let us shrink the keys to 48 bits (well, characters here) using PC2\n        for (i = 0; i < 16; i++) {\n            String key = subKeys[i];\n            permutedKey.setLength(0);\n            for (j = 0; j < 48; j++) {\n                permutedKey.append(key.charAt(PC2[j] - 1));\n            }\n            subKeys[i] = permutedKey.toString();\n        }\n\n        return subKeys;\n    }\n\n    private String XOR(String a, String b) {\n        int i, l = a.length();\n        StringBuilder xor = new StringBuilder();\n        for (i = 0; i < l; i++) {\n            int firstBit = a.charAt(i) - 48; // 48 is '0' in ascii\n            int secondBit = b.charAt(i) - 48;\n            xor.append((firstBit ^ secondBit));\n        }\n        return xor.toString();\n    }\n\n    private String createPaddedString(String s, int desiredLength, char pad) {\n        int i, l = s.length();\n        StringBuilder paddedString = new StringBuilder();\n        int diff = desiredLength - l;\n        for (i = 0; i < diff; i++) {\n            paddedString.append(pad);\n        }\n        return paddedString.toString();\n    }\n\n    private String pad(String s, int desiredLength) {\n        return createPaddedString(s, desiredLength, '0') + s;\n    }\n\n    private String padLast(String s, int desiredLength) {\n        return s + createPaddedString(s, desiredLength, '\\u0000');\n    }\n\n    private String feistel(String messageBlock, String key) {\n        int i;\n        StringBuilder expandedKey = new StringBuilder();\n        for (i = 0; i < 48; i++) {\n            expandedKey.append(messageBlock.charAt(expansion[i] - 1));\n        }\n        String mixedKey = XOR(expandedKey.toString(), key);\n        StringBuilder substitutedString = new StringBuilder();\n\n        //Let us now use the s-boxes to transform each 6 bit (length here) block to 4 bits\n        for (i = 0; i < 48; i += 6) {\n            String block = mixedKey.substring(i, i + 6);\n            int row = (block.charAt(0) - 48) * 2 + (block.charAt(5) - 48);\n            int col = (block.charAt(1) - 48) * 8 + (block.charAt(2) - 48) * 4 + (block.charAt(3) - 48) * 2 + (block.charAt(4) - 48);\n            String substitutedBlock = pad(Integer.toBinaryString(s[i / 6][row][col]), 4);\n            substitutedString.append(substitutedBlock);\n        }\n\n        StringBuilder permutedString = new StringBuilder(); \n        for (i = 0; i < 32; i++) {\n            permutedString.append(substitutedString.charAt(permutation[i] - 1));\n        }\n\n        return permutedString.toString();\n    }\n\n    private String encryptBlock(String message, String keys[]) {\n        StringBuilder permutedMessage = new StringBuilder();\n        int i;\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(message.charAt(IP[i] - 1));\n        }\n        String L0 = permutedMessage.substring(0, 32), R0 = permutedMessage.substring(32);\n\n        //Iterate 16 times\n        for (i = 0; i < 16; i++) {\n            String Ln = R0; // Previous Right block\n            String Rn = XOR(L0, feistel(R0, keys[i]));\n            L0 = Ln;\n            R0 = Rn;\n        }\n\n        String combinedBlock = R0 + L0; //Reverse the 16th block\n        permutedMessage.setLength(0);\n        for (i = 0; i < 64; i++) {\n            permutedMessage.append(combinedBlock.charAt(IPinverse[i] - 1));\n        }\n        return permutedMessage.toString();\n    }\n\n    //To decode, we follow the same process as encoding, but with reversed keys\n    private String decryptBlock(String message, String keys[]) {\n        String reversedKeys[] = new String[keys.length];\n        for (int i = 0; i < keys.length; i++) {\n            reversedKeys[i] = keys[keys.length - i - 1];\n        }\n        return encryptBlock(message, reversedKeys);\n    }\n\n    /**\n     * @param message Message to be encrypted\n     * @return The encrypted message, as a binary string\n     */\n    public String encrypt(String message) {\n        StringBuilder encryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 8 != 0) {\n            int desiredLength = (l / 8 + 1) * 8;\n            l = desiredLength;\n            message = padLast(message, desiredLength);\n        }\n\n        for (i = 0; i < l; i+= 8) {\n            String block = message.substring(i, i + 8);\n            StringBuilder bitBlock = new StringBuilder();\n            byte[] bytes = block.getBytes();\n            for (j = 0; j < 8; j++) {\n                bitBlock.append(pad(Integer.toBinaryString(bytes[j]), 8));\n            }\n            encryptedMessage.append(encryptBlock(bitBlock.toString(), subKeys));\n        }\n        return encryptedMessage.toString();\n    }\n\n    /**\n     * @param message The encrypted string. Expects it to be a multiple of 64 bits, in binary format\n     * @return The decrypted String, in plain English\n     */\n    public String decrypt(String message) {\n        StringBuilder decryptedMessage = new StringBuilder();\n        int l = message.length(), i, j;\n        if (l % 64 != 0) {\n            throw new IllegalArgumentException(\"Encrypted message should be a multiple of 64 characters in length\");\n        }\n        for (i = 0; i < l; i+= 64) {\n            String block = message.substring(i, i + 64);\n            String result = decryptBlock(block.toString(), subKeys);\n            byte res[] = new byte[8];\n            for (j = 0; j < 64; j+=8) {\n                res[j / 8] = (byte)Integer.parseInt(result.substring(j, j + 8), 2);\n            }\n            decryptedMessage.append(new String(res));\n        }\n        return decryptedMessage.toString().replace(\"\\0\", \"\"); // Get rid of the null bytes used for padding\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n//Test example taken from https://page.math.tu-berlin.de/~kant/teaching/hess/krypto-ws2006/des.htm\npublic class DESTest {\n\n    DES des;\n\n    @BeforeEach\n    public void setUp() {\n        des = new DES(\"0000111000110010100100100011001011101010011011010000110101110011\");\n    }\n\n    @Test\n    void testEncrypt() {\n        //given\n        String plainText = \"Your lips are smoother than vaseline\\r\\n\";\n        //This is equal to c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in hexadecimal\n        String expectedOutput = \"11000000100110011001111111011101111000110111100011010111111\" +\n        \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\" +\n        \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\" +\n        \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n\n        //when\n        String cipherText = des.encrypt(plainText);\n\n        //then\n        assertEquals(expectedOutput, cipherText);\n    }\n\n    @Test\n    void testDecrypt() {\n        //given\n       //This is equal to c0999fdde378d7ed727da00bca5a84ee47f269a4d6438190d9d52f78f5358499828ac9b453e0e653 in hexadecimal\n       String cipherText = \"11000000100110011001111111011101111000110111100011010111111\" +\n       \"011010111001001111101101000000000101111001010010110101000010011101110010001111111001\" +\n       \"001101001101001001101011001000011100000011001000011011001110101010010111101111000111\" +\n       \"101010011010110000100100110011000001010001010110010011011010001010011111000001110011001010011\";\n        String expectedOutput = \"Your lips are smoother than vaseline\\r\\n\";;\n\n        //when\n        String plainText = des.decrypt(cipherText);\n\n        //then\n        assertEquals(expectedOutput, plainText);\n    }\n}"
    },
    {
        "product_commit": "b55fc972ace3007c17c7e16d1ad899f57aecf640",
        "test_commit": "b55fc972ace3007c17c7e16d1ad899f57aecf640",
        "product_file_path": "src/main/java/com/thealgorithms/strings/HorspoolSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/HorspoolSearchTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\n/**\n * This class is not thread safe<br>\n * <br>\n * (From wikipedia) In computer science, the Boyer\u2013Moore\u2013Horspool algorithm or\n * Horspool's algorithm is an algorithm for finding substrings in strings. It\n * was published by Nigel Horspool in 1980.\n * <br>\n * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia\n * page</a><br>\n * <br>\n *\n * <p>\n * An explanation:<br>\n *\n * <p>\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\n * that it uses only one of the two heuristic methods for increasing the number\n * of characters shifted when finding a bad match in the text. This method is\n * usually called the \"bad symbol\" or \"bad character\" shift. The bad symbol\n * shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that\n * processing a given input to a problem and altering it in a specific way will\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\n * to match the pattern and text comparing the pattern symbols to the text's\n * from right to left.<br>\n * <br>\n *\n * <p>\n * In the bad symbol shift method, a table is created prior to the search,\n * called the \"bad symbol table\". The bad symbol table contains the shift values\n * for any symbol in the text and pattern. For these symbols, the value is the\n * length of the pattern, if the symbol is not in the first (length - 1) of the\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values\n * for the ones that exist in the first (length - 1) of the pattern.<br>\n * <br>\n *\n * <p>\n * For more details on the algorithm and the more advanced Boyer-Moore I\n * recommend checking out the wikipedia page and professor Anany Levitin's book:\n * Introduction To The Design And Analysis Of Algorithms.\n */\npublic class HorspoolSearch {\n\n    private static HashMap<Character, Integer> shiftValues; // bad symbol table\n    private static Integer patternLength;\n    private static int comparisons = 0; // total comparisons in the current/last search\n\n    /**\n     * Case sensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirst(String pattern, String text) {\n        return firstOccurrence(pattern, text, true);\n    }\n\n    /**\n     * Case insensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirstInsensitive(String pattern, String text) {\n        return firstOccurrence(pattern, text, false);\n    }\n\n    /**\n     * Utility method that returns comparisons made by last run (mainly for\n     * tests)\n     *\n     * @return number of character comparisons of the last search\n     */\n    public static Integer getLastComparisons() {\n        return HorspoolSearch.comparisons;\n    }\n\n    /**\n     * Fairly standard implementation of the Horspool algorithm. Only the index\n     * of the last character of the pattern on the text is saved and shifted by\n     * the appropriate amount when a mismatch is found. The algorithm stops at\n     * the first match or when the entire text has been exhausted.\n     *\n     * @param pattern String to be matched in the text\n     * @param text text String\n     * @return index of first occurrence of the pattern in the text\n     */\n    private static int firstOccurrence(\n        String pattern,\n        String text,\n        boolean caseSensitive\n    ) {\n        shiftValues = calcShiftValues(pattern); // build the bad symbol table\n        comparisons = 0; // reset comparisons\n\n        int textIndex = pattern.length() - 1; // align pattern with text start and get index of the last character\n\n        // while pattern is not out of text bounds\n        while (textIndex < text.length()) {\n            // try to match pattern with current part of the text starting from last character\n            int i = pattern.length() - 1;\n            while (i >= 0) {\n                comparisons++;\n                char patternChar = pattern.charAt(i);\n                char textChar = text.charAt(\n                    (textIndex + i) - (pattern.length() - 1)\n                );\n                if (!charEquals(patternChar, textChar, caseSensitive)) { // bad character, shift pattern\n                    textIndex += getShiftValue(text.charAt(textIndex));\n                    break;\n                }\n                i--;\n            }\n\n            // check for full match\n            if (i == -1) {\n                return textIndex - pattern.length() + 1;\n            }\n        }\n\n        // text exhausted, return failure\n        return -1;\n    }\n\n    /**\n     * Compares the argument characters\n     *\n     * @param c1 first character\n     * @param c2 second character\n     * @param caseSensitive boolean determining case sensitivity of comparison\n     * @return truth value of the equality comparison\n     */\n    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {\n        if (caseSensitive) {\n            return c1 == c2;\n        }\n        return Character.toLowerCase(c1) == Character.toLowerCase(c2);\n    }\n\n    /**\n     * Builds the bad symbol table required to run the algorithm. The method\n     * starts from the second to last character of the pattern and moves to the\n     * left. When it meets a new character, it is by definition its rightmost\n     * occurrence and therefore puts the distance from the current index to the\n     * index of the last character into the table. If the character is already\n     * in the table, then it is not a rightmost occurrence, so it continues.\n     *\n     * @param pattern basis for the bad symbol table\n     * @return the bad symbol table\n     */\n    private static HashMap<Character, Integer> calcShiftValues(String pattern) {\n        patternLength = pattern.length();\n        HashMap<Character, Integer> table = new HashMap<>();\n\n        for (int i = pattern.length() - 2; i >= 0; i--) { // length - 2 is the index of the second to last character\n            char c = pattern.charAt(i);\n            int finalI = i;\n            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);\n        }\n\n        return table;\n    }\n\n    /**\n     * Helper function that uses the bad symbol shift table to return the\n     * appropriate shift value for a given character\n     *\n     * @param c character\n     * @return shift value that corresponds to the character argument\n     */\n    private static Integer getShiftValue(char c) {\n        if (shiftValues.get(c) != null) {\n            return shiftValues.get(c);\n        } else {\n            return patternLength;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\n/**\n * This class is not thread safe<br>\n * <br>\n * (From wikipedia) In computer science, the Boyer\u2013Moore\u2013Horspool algorithm or\n * Horspool's algorithm is an algorithm for finding substrings in strings. It\n * was published by Nigel Horspool in 1980.\n * <br>\n * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia\n * page</a><br>\n * <br>\n *\n * <p>\n * An explanation:<br>\n *\n * <p>\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\n * that it uses only one of the two heuristic methods for increasing the number\n * of characters shifted when finding a bad match in the text. This method is\n * usually called the \"bad symbol\" or \"bad character\" shift. The bad symbol\n * shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that\n * processing a given input to a problem and altering it in a specific way will\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\n * to match the pattern and text comparing the pattern symbols to the text's\n * from right to left.<br>\n * <br>\n *\n * <p>\n * In the bad symbol shift method, a table is created prior to the search,\n * called the \"bad symbol table\". The bad symbol table contains the shift values\n * for any symbol in the text and pattern. For these symbols, the value is the\n * length of the pattern, if the symbol is not in the first (length - 1) of the\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values\n * for the ones that exist in the first (length - 1) of the pattern.<br>\n * <br>\n *\n * <p>\n * For more details on the algorithm and the more advanced Boyer-Moore I\n * recommend checking out the wikipedia page and professor Anany Levitin's book:\n * Introduction To The Design And Analysis Of Algorithms.\n */\npublic class HorspoolSearch {\n\n    private static HashMap<Character, Integer> shiftValues; // bad symbol table\n    private static Integer patternLength;\n    private static int comparisons = 0; // total comparisons in the current/last search\n\n    /**\n     * Case sensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirst(String pattern, String text) {\n        return firstOccurrence(pattern, text, true);\n    }\n\n    /**\n     * Case insensitive version version of the algorithm\n     *\n     * @param pattern the pattern to be searched for (needle)\n     * @param text the text being searched in (haystack)\n     * @return -1 if not found or first index of the pattern in the text\n     */\n    public static int findFirstInsensitive(String pattern, String text) {\n        return firstOccurrence(pattern, text, false);\n    }\n\n    /**\n     * Utility method that returns comparisons made by last run (mainly for\n     * tests)\n     *\n     * @return number of character comparisons of the last search\n     */\n    public static Integer getLastComparisons() {\n        return HorspoolSearch.comparisons;\n    }\n\n    /**\n     * Fairly standard implementation of the Horspool algorithm. Only the index\n     * of the last character of the pattern on the text is saved and shifted by\n     * the appropriate amount when a mismatch is found. The algorithm stops at\n     * the first match or when the entire text has been exhausted.\n     *\n     * @param pattern String to be matched in the text\n     * @param text text String\n     * @return index of first occurrence of the pattern in the text\n     */\n    private static int firstOccurrence(\n        String pattern,\n        String text,\n        boolean caseSensitive\n    ) {\n        shiftValues = calcShiftValues(pattern); // build the bad symbol table\n        comparisons = 0; // reset comparisons\n\n        if (pattern.length() == 0) { // return failure, if pattern empty\n            return -1;\n        }\n\n        int textIndex = pattern.length() - 1; // align pattern with text start and get index of the last character\n\n        // while pattern is not out of text bounds\n        while (textIndex < text.length()) {\n            // try to match pattern with current part of the text starting from last character\n            int i = pattern.length() - 1;\n            while (i >= 0) {\n                comparisons++;\n                char patternChar = pattern.charAt(i);\n                char textChar = text.charAt(\n                    (textIndex + i) - (pattern.length() - 1)\n                );\n                if (!charEquals(patternChar, textChar, caseSensitive)) { // bad character, shift pattern\n                    textIndex += getShiftValue(text.charAt(textIndex));\n                    break;\n                }\n                i--;\n            }\n\n            // check for full match\n            if (i == -1) {\n                return textIndex - pattern.length() + 1;\n            }\n        }\n\n        // text exhausted, return failure\n        return -1;\n    }\n\n    /**\n     * Compares the argument characters\n     *\n     * @param c1 first character\n     * @param c2 second character\n     * @param caseSensitive boolean determining case sensitivity of comparison\n     * @return truth value of the equality comparison\n     */\n    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {\n        if (caseSensitive) {\n            return c1 == c2;\n        }\n        return Character.toLowerCase(c1) == Character.toLowerCase(c2);\n    }\n\n    /**\n     * Builds the bad symbol table required to run the algorithm. The method\n     * starts from the second to last character of the pattern and moves to the\n     * left. When it meets a new character, it is by definition its rightmost\n     * occurrence and therefore puts the distance from the current index to the\n     * index of the last character into the table. If the character is already\n     * in the table, then it is not a rightmost occurrence, so it continues.\n     *\n     * @param pattern basis for the bad symbol table\n     * @return the bad symbol table\n     */\n    private static HashMap<Character, Integer> calcShiftValues(String pattern) {\n        patternLength = pattern.length();\n        HashMap<Character, Integer> table = new HashMap<>();\n\n        for (int i = pattern.length() - 2; i >= 0; i--) { // length - 2 is the index of the second to last character\n            char c = pattern.charAt(i);\n            int finalI = i;\n            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);\n        }\n\n        return table;\n    }\n\n    /**\n     * Helper function that uses the bad symbol shift table to return the\n     * appropriate shift value for a given character\n     *\n     * @param c character\n     * @return shift value that corresponds to the character argument\n     */\n    private static Integer getShiftValue(char c) {\n        if (shiftValues.get(c) != null) {\n            return shiftValues.get(c);\n        } else {\n            return patternLength;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass HorspoolSearchTest {\n\n    @Test\n    void testFindFirstMatch() {\n        int index = HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstNotMatch() {\n        int index = HorspoolSearch.findFirst(\"hell\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternLongerText() {\n        int index = HorspoolSearch.findFirst(\"Hello World!!!\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"Hello\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstPatternAndTextEmpty() {\n        int index = HorspoolSearch.findFirst(\"\", \"\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testFindFirstSpecialCharacter() {\n        int index = HorspoolSearch.findFirst(\"$3**\", \"Hello $3**$ World\");\n        assertEquals(6, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"hello\", \"Hello World\");\n        assertEquals(0, index);\n    }\n\n    @Test\n    void testFindFirstInsensitiveNotMatch() {\n        int index = HorspoolSearch.findFirstInsensitive(\"helo\", \"Hello World\");\n        assertEquals(-1, index);\n    }\n\n    @Test\n    void testGetLastComparisons() {\n        HorspoolSearch.findFirst(\"World\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(7, lastSearchNumber);\n    }\n\n    @Test\n    void testGetLastComparisonsNotMatch() {\n        HorspoolSearch.findFirst(\"Word\", \"Hello World\");\n        int lastSearchNumber = HorspoolSearch.getLastComparisons();\n        assertEquals(3, lastSearchNumber);\n    }\n\n    @Test\n    void testFindFirstPatternNull() {\n        assertThrows(NullPointerException.class,\n                () -> HorspoolSearch.findFirst(null, \"Hello World\"));\n    }\n\n    @Test\n    void testFindFirstTextNull() {\n        assertThrows(NullPointerException.class,\n                () -> HorspoolSearch.findFirst(\"Hello\", null));\n    }\n}"
    },
    {
        "product_commit": "f69cd7cfa211f0847b9b4d67f04c37499bff31c4",
        "test_commit": "f69cd7cfa211f0847b9b4d67f04c37499bff31c4",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/BSTIterative.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/BSTIterativeTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n *\n *\n * <h1>Binary Search Tree (Iterative)</h1>\n *\n * <p>\n * An implementation of BST iteratively. Binary Search Tree is a binary tree\n * which satisfies three properties: left child is less than root node, right\n * child is grater than root node, both left and right childs must themselves be\n * a BST.\n *\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\nimport java.util.Stack;\n\npublic class BSTIterative {\n\n    /**\n     * Reference for the node of BST.\n     */\n    private Node root;\n\n    /**\n     * Default Constructor Initializes the root of BST with null.\n     */\n    BSTIterative() {\n        root = null;\n    }\n\n    /**\n     * main function for tests\n     */\n    public static void main(String[] args) {\n        BSTIterative tree = new BSTIterative();\n        tree.add(3);\n        tree.add(2);\n        tree.add(9);\n        assert !tree.find(4) : \"4 is not yet present in BST\";\n        assert tree.find(2) : \"2 should be present in BST\";\n        tree.remove(2);\n        assert !tree.find(2) : \"2 was just deleted from BST\";\n        tree.remove(1);\n        assert !tree.find(\n            1\n        ) : \"Since 1 was not present so find deleting would do no change\";\n        tree.add(30);\n        tree.add(40);\n        assert tree.find(40) : \"40 was inserted but not found\";\n        /*\n       Will print following order\n       3 9 30 40\n         */\n        tree.inorder();\n    }\n\n    /**\n     * A method to insert a new value in BST. If the given value is already\n     * present in BST the insertion is ignored.\n     *\n     * @param data the value to be inserted\n     */\n    public void add(int data) {\n        Node parent = null;\n        Node temp = this.root;\n        int rightOrLeft = -1;\n        /* Finds the proper place this node can\n         * be placed in according to rules of BST.\n         */\n        while (temp != null) {\n            if (temp.data > data) {\n                parent = temp;\n                temp = parent.left;\n                rightOrLeft = 0;\n            } else if (temp.data < data) {\n                parent = temp;\n                temp = parent.right;\n                rightOrLeft = 1;\n            } else {\n                System.out.println(data + \" is already present in BST.\");\n                return; // if data already present we ignore insertion\n            }\n        }\n        /* Creates a newNode with the value passed\n         * Since this data doesn't already exists\n         */\n        Node newNode = new Node(data);\n        /* If the parent node is null\n         * then the insertion is to be done in\n         * root itself.\n         */\n        if (parent == null) {\n            this.root = newNode;\n        } else {\n            /* Check if insertion is to be made in\n             * left or right subtree.\n             */\n            if (rightOrLeft == 0) {\n                parent.left = newNode;\n            } else {\n                parent.right = newNode;\n            }\n        }\n    }\n\n    /**\n     * A method to delete the node in BST. If node is present it will be deleted\n     *\n     * @param data the value that needs to be deleted\n     */\n    public void remove(int data) {\n        Node parent = null;\n        Node temp = this.root;\n        int rightOrLeft = -1;\n        /* Find the parent of the node and node itself\n         * That is to be deleted.\n         * parent variable store parent\n         * temp stores node itself.\n         * rightOrLeft use to keep track weather child\n         * is left or right subtree\n         */\n        while (temp != null) {\n            if (temp.data == data) {\n                break;\n            } else if (temp.data > data) {\n                parent = temp;\n                temp = parent.left;\n                rightOrLeft = 0;\n            } else {\n                parent = temp;\n                temp = parent.right;\n                rightOrLeft = 1;\n            }\n        }\n        /* If temp is null than node with given value is not\n         * present in our tree.\n         */\n        if (temp != null) {\n            Node replacement; // used to store the new values for replacing nodes\n            if (temp.right == null && temp.left == null) { // Leaf node Case\n                replacement = null;\n            } else if (temp.right == null) { // Node with only right child\n                replacement = temp.left;\n                temp.left = null;\n            } else if (temp.left == null) { // Node with only left child\n                replacement = temp.right;\n                temp.right = null;\n            } else {\n                /* If both left and right child are present\n                 * we replace this nodes data with\n                 * leftmost node's data in its right subtree\n                 * to maintain the balance of BST.\n                 * And then delete that node\n                 */\n                if (temp.right.left == null) {\n                    temp.data = temp.right.data;\n                    replacement = temp;\n                    temp.right = temp.right.right;\n                } else {\n                    Node parent2 = temp.right;\n                    Node child = temp.right.left;\n                    while (child.left != null) {\n                        parent2 = child;\n                        child = parent2.left;\n                    }\n                    temp.data = child.data;\n                    parent2.left = child.right;\n                    replacement = temp;\n                }\n            }\n            /* Change references of parent after\n             * deleting the child.\n             */\n            if (parent == null) {\n                this.root = replacement;\n            } else {\n                if (rightOrLeft == 0) {\n                    parent.left = replacement;\n                } else {\n                    parent.right = replacement;\n                }\n            }\n        }\n    }\n\n    /**\n     * A method for inorder traversal of BST.\n     */\n    public void inorder() {\n        if (this.root == null) {\n            System.out.println(\"This BST is empty.\");\n            return;\n        }\n        System.out.println(\"Inorder traversal of this tree is:\");\n        Stack<Node> st = new Stack<Node>();\n        Node cur = this.root;\n        while (cur != null || !st.empty()) {\n            while (cur != null) {\n                st.push(cur);\n                cur = cur.left;\n            }\n            cur = st.pop();\n            System.out.print(cur.data + \" \");\n            cur = cur.right;\n        }\n        System.out.println(); // for next line\n    }\n\n    /**\n     * A method used to print postorder traversal of BST.\n     */\n    public void postorder() {\n        if (this.root == null) {\n            System.out.println(\"This BST is empty.\");\n            return;\n        }\n        System.out.println(\"Postorder traversal of this tree is:\");\n        Stack<Node> st = new Stack<Node>();\n        Node cur = this.root, temp2;\n        while (cur != null || !st.empty()) {\n            if (cur != null) {\n                st.push(cur);\n                cur = cur.left;\n            } else {\n                temp2 = st.peek();\n                if (temp2.right != null) {\n                    cur = temp2.right;\n                } else {\n                    st.pop();\n                    while (!st.empty() && st.peek().right == temp2) {\n                        System.out.print(temp2.data + \" \");\n                        temp2 = st.pop();\n                    }\n                    System.out.print(temp2.data + \" \");\n                }\n            }\n        }\n        System.out.println(); // for next line\n    }\n\n    /**\n     * Method used to display preorder traversal of BST.\n     */\n    public void preorder() {\n        if (this.root == null) {\n            System.out.println(\"This BST is empty.\");\n            return;\n        }\n        System.out.println(\"Preorder traversal of this tree is:\");\n        Stack<Node> st = new Stack<Node>();\n        st.push(this.root);\n        Node temp;\n        while (!st.empty()) {\n            temp = st.pop();\n            System.out.print(temp.data + \" \");\n            if (temp.right != null) {\n                st.push(temp.right);\n            }\n            if (temp.left != null) {\n                st.push(temp.left);\n            }\n        }\n        System.out.println(); // for next line\n    }\n\n    /**\n     * A method to check if given data exists in out Binary Search Tree.\n     *\n     * @param data the value that needs to be searched for\n     * @return boolean representing if the value was find\n     */\n    public boolean find(int data) {\n        Node temp = this.root;\n        /* Check if node exists\n         */\n        while (temp != null) {\n            if (temp.data > data) {\n                temp = temp.left;\n            } else if (temp.data < data) {\n                temp = temp.right;\n            } else {\n                /* If found return true\n                 */\n                System.out.println(data + \" is present in the BST.\");\n                return true;\n            }\n        }\n        System.out.println(data + \" not found.\");\n        return false;\n    }\n\n    /**\n     * The Node class used for building binary search tree\n     */\n    private static class Node {\n\n        int data;\n        Node left;\n        Node right;\n\n        /**\n         * Constructor with data as parameter\n         */\n        Node(int d) {\n            data = d;\n            left = null;\n            right = null;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\n/**\n *\n *\n * <h1>Binary Search Tree (Iterative)</h1>\n *\n * <p>\n * An implementation of BST iteratively. Binary Search Tree is a binary tree\n * which satisfies three properties: left child is less than root node, right\n * child is grater than root node, both left and right childs must themselves be\n * a BST.\n *\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\n\npublic class BSTIterative {\n\n    /**\n     * Reference for the node of BST.\n     */\n    private Node root;\n\n    /**\n     * Default Constructor Initializes the root of BST with null.\n     */\n    BSTIterative() {\n        root = null;\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * A method to insert a new value in BST. If the given value is already\n     * present in BST the insertion is ignored.\n     *\n     * @param data the value to be inserted\n     */\n    public void add(int data) {\n        Node parent = null;\n        Node temp = this.root;\n        int rightOrLeft = -1;\n        /* Finds the proper place this node can\n         * be placed in according to rules of BST.\n         */\n        while (temp != null) {\n            if (temp.data > data) {\n                parent = temp;\n                temp = parent.left;\n                rightOrLeft = 0;\n            } else if (temp.data < data) {\n                parent = temp;\n                temp = parent.right;\n                rightOrLeft = 1;\n            } else {\n                System.out.println(data + \" is already present in BST.\");\n                return; // if data already present we ignore insertion\n            }\n        }\n        /* Creates a newNode with the value passed\n         * Since this data doesn't already exists\n         */\n        Node newNode = new Node(data);\n        /* If the parent node is null\n         * then the insertion is to be done in\n         * root itself.\n         */\n        if (parent == null) {\n            this.root = newNode;\n        } else {\n            /* Check if insertion is to be made in\n             * left or right subtree.\n             */\n            if (rightOrLeft == 0) {\n                parent.left = newNode;\n            } else {\n                parent.right = newNode;\n            }\n        }\n    }\n\n    /**\n     * A method to delete the node in BST. If node is present it will be deleted\n     *\n     * @param data the value that needs to be deleted\n     */\n    public void remove(int data) {\n        Node parent = null;\n        Node temp = this.root;\n        int rightOrLeft = -1;\n        /* Find the parent of the node and node itself\n         * That is to be deleted.\n         * parent variable store parent\n         * temp stores node itself.\n         * rightOrLeft use to keep track weather child\n         * is left or right subtree\n         */\n        while (temp != null) {\n            if (temp.data == data) {\n                break;\n            } else if (temp.data > data) {\n                parent = temp;\n                temp = parent.left;\n                rightOrLeft = 0;\n            } else {\n                parent = temp;\n                temp = parent.right;\n                rightOrLeft = 1;\n            }\n        }\n        /* If temp is null than node with given value is not\n         * present in our tree.\n         */\n        if (temp != null) {\n            Node replacement; // used to store the new values for replacing nodes\n            if (temp.right == null && temp.left == null) { // Leaf node Case\n                replacement = null;\n            } else if (temp.right == null) { // Node with only right child\n                replacement = temp.left;\n                temp.left = null;\n            } else if (temp.left == null) { // Node with only left child\n                replacement = temp.right;\n                temp.right = null;\n            } else {\n                /* If both left and right child are present\n                 * we replace this nodes data with\n                 * leftmost node's data in its right subtree\n                 * to maintain the balance of BST.\n                 * And then delete that node\n                 */\n                if (temp.right.left == null) {\n                    temp.data = temp.right.data;\n                    replacement = temp;\n                    temp.right = temp.right.right;\n                } else {\n                    Node parent2 = temp.right;\n                    Node child = temp.right.left;\n                    while (child.left != null) {\n                        parent2 = child;\n                        child = parent2.left;\n                    }\n                    temp.data = child.data;\n                    parent2.left = child.right;\n                    replacement = temp;\n                }\n            }\n            /* Change references of parent after\n             * deleting the child.\n             */\n            if (parent == null) {\n                this.root = replacement;\n            } else {\n                if (rightOrLeft == 0) {\n                    parent.left = replacement;\n                } else {\n                    parent.right = replacement;\n                }\n            }\n        }\n    }\n\n    /**\n     * A method to check if given data exists in out Binary Search Tree.\n     *\n     * @param data the value that needs to be searched for\n     * @return boolean representing if the value was find\n     */\n    public boolean find(int data) {\n        Node temp = this.root;\n        /* Check if node exists\n         */\n        while (temp != null) {\n            if (temp.data > data) {\n                temp = temp.left;\n            } else if (temp.data < data) {\n                temp = temp.right;\n            } else {\n                /* If found return true\n                 */\n                System.out.println(data + \" is present in the BST.\");\n                return true;\n            }\n        }\n        System.out.println(data + \" not found.\");\n        return false;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 23/04/2023\n */\npublic class BSTIterativeTest {\n    @Test\n    public void testBSTIsCorrectlyConstructedFromOneNode() {\n        BSTIterative tree = new BSTIterative();\n        tree.add(6);\n\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(tree.getRoot()));\n    }\n\n    @Test\n    public void testBSTIsCorrectlyCleanedAndEmpty() {\n        BSTIterative tree = new BSTIterative();\n\n        tree.add(6);\n        tree.remove(6);\n\n        tree.add(12);\n        tree.add(1);\n        tree.add(2);\n\n        tree.remove(1);\n        tree.remove(2);\n        tree.remove(12);\n\n        Assertions.assertNull(tree.getRoot());\n    }\n\n    @Test\n    public void testBSTIsCorrectlyCleanedAndNonEmpty() {\n        BSTIterative tree = new BSTIterative();\n\n        tree.add(6);\n        tree.remove(6);\n\n        tree.add(12);\n        tree.add(1);\n        tree.add(2);\n\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(tree.getRoot()));\n    }\n\n    @Test\n    public void testBSTIsCorrectlyConstructedFromMultipleNodes() {\n        BSTIterative tree = new BSTIterative();\n        tree.add(7);\n        tree.add(1);\n        tree.add(5);\n        tree.add(100);\n        tree.add(50);\n\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(tree.getRoot()));\n    }\n}"
    },
    {
        "product_commit": "4c18e60671adebb2b8236024ad50f14367455e2a",
        "test_commit": "4c18e60671adebb2b8236024ad50f14367455e2a",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/BSTFromSortedArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/BSTFromSortedArrayTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\n/**\n * Given a sorted array. Create a balanced binary search tree from it.\n *\n * Steps: 1. Find the middle element of array. This will act as root 2. Use the\n * left half recursively to create left subtree 3. Use the right half\n * recursively to create right subtree\n */\npublic class BSTFromSortedArray {\n    public static Node createBST(int[] array) {\n        if (array == null || array.length == 0) {\n            return null;\n        }\n        return createBST(array, 0, array.length - 1);\n    }\n\n    private static Node createBST(int[] array, int startIdx, int endIdx) {\n        // No element left.\n        if (startIdx > endIdx) {\n            return null;\n        }\n        int mid = startIdx + (endIdx - startIdx) / 2;\n\n        // middle element will be the root\n        Node root = new Node(array[mid]);\n        root.left = createBST(array, startIdx, mid - 1);\n        root.right = createBST(array, mid + 1, endIdx);\n        return root;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Albina Gimaletdinova on 20/04/2023\n */\npublic class BSTFromSortedArrayTest {\n    @Test\n    public void testNullArray() {\n        BinaryTree.Node actualBST = BSTFromSortedArray.createBST(null);\n        Assertions.assertNull(actualBST);\n    }\n\n    @Test\n    public void testEmptyArray() {\n        BinaryTree.Node actualBST = BSTFromSortedArray.createBST(new int[]{});\n        Assertions.assertNull(actualBST);\n    }\n\n    @Test\n    public void testSingleElementArray() {\n        BinaryTree.Node actualBST = BSTFromSortedArray.createBST(new int[]{Integer.MIN_VALUE});\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(actualBST));\n    }\n\n    @Test\n    public void testCreateBSTFromSmallArray() {\n        BinaryTree.Node actualBST = BSTFromSortedArray.createBST(new int[]{1, 2, 3});\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(actualBST));\n    }\n\n    @Test\n    public void testCreateBSTFromLongerArray() {\n        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        BinaryTree.Node actualBST = BSTFromSortedArray.createBST(array);\n        Assertions.assertTrue(CheckBinaryTreeIsValidBST.isBST(actualBST));\n    }\n\n    @Test\n    public void testShouldNotCreateBSTFromNonSortedArray() {\n        int[] array = {10, 2, 3, 4, 5, 6, 7, 8, 9, 1};\n        BinaryTree.Node actualBST = BSTFromSortedArray.createBST(array);\n        Assertions.assertFalse(CheckBinaryTreeIsValidBST.isBST(actualBST));\n    }\n}"
    },
    {
        "product_commit": "4c18e60671adebb2b8236024ad50f14367455e2a",
        "test_commit": "4c18e60671adebb2b8236024ad50f14367455e2a",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CheckBinaryTreeIsValidBST.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckBinaryTreeIsValidBSTTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n * This code recursively validates whether given Binary Search Tree (BST) is balanced or not.\n * Trees with only distinct values are supported.\n * Key points:\n * 1. According to the definition of a BST, each node in a tree must be in range [min, max],\n *    where 'min' and 'max' values represent the child nodes (left, right).\n * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE.\n */\npublic class CheckBinaryTreeIsValidBST {\n    public static boolean isBST(BinaryTree.Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) {\n        // empty tree is a BST\n        if (node == null) {\n            return true;\n        }\n\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        return (\n            isBSTUtil(node.left, min, node.data - 1) &&\n            isBSTUtil(node.right, node.data + 1, max)\n        );\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class CheckBinaryTreeIsValidBSTTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{Integer.MIN_VALUE});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 13});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 12});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n}"
    },
    {
        "product_commit": "4c18e60671adebb2b8236024ad50f14367455e2a",
        "test_commit": "4c18e60671adebb2b8236024ad50f14367455e2a",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/ValidBSTOrNot.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/ValidBSTOrNotTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n * This code recursively validates whether given Binary Search Tree (BST) is balanced or not.\n * Trees with only distinct values are supported.\n * Key points:\n * 1. According to the definition of a BST, each node in a tree must be in range [min, max],\n *    where 'min' and 'max' values represent the child nodes (left, right).\n * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE.\n */\npublic class ValidBSTOrNot {\n    public static boolean isBST(BinaryTree.Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) {\n        // empty tree is a BST\n        if (node == null) {\n            return true;\n        }\n\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        return (\n            isBSTUtil(node.left, min, node.data - 1) &&\n            isBSTUtil(node.right, node.data + 1, max)\n        );\n    }\n}",
        "product_new_content": null,
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class ValidBSTOrNotTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(ValidBSTOrNot.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{Integer.MIN_VALUE});\n        assertTrue(ValidBSTOrNot.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 20});\n        assertTrue(ValidBSTOrNot.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 13});\n        assertFalse(ValidBSTOrNot.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 12});\n        assertFalse(ValidBSTOrNot.isBST(root));\n    }\n}",
        "test_new_content": null
    },
    {
        "product_commit": "1551b8f50ba485b5a7d34fe9ed1fbf650134fb9f",
        "test_commit": "1551b8f50ba485b5a7d34fe9ed1fbf650134fb9f",
        "product_file_path": "src/main/java/com/thealgorithms/others/LineSweep.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/LineSweepTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/* Line Sweep algorithm can be used to solve range problems by first sorting the list of ranges\n * by the start value of the range in non-decreasing order and doing a \"sweep\" through the number\n * line(x-axis) by incrementing the start point by 1 and decrementing the end point+1 by 1 on the\n * number line.\n * An overlapping range is defined as (StartA <= EndB) AND (EndA >= StartB)\n * References\n * https://en.wikipedia.org/wiki/Sweep_line_algorithm\n * https://en.wikipedia.org/wiki/De_Morgan%27s_laws>\n */\npublic class LineSweep {\n\n    /**  Find Maximum end point\n     *   param = ranges : Array of range[start,end]\n     *   return Maximum Endpoint\n     */\n    public static int FindMaximumEndPoint (int[][]ranges){\n         Arrays.sort(ranges, Comparator.comparingInt(a->a[1]));\n         return ranges[ranges.length-1][1];\n     }\n\n    /**  Find if any ranges overlap\n     *   param = ranges : Array of range[start,end]\n     *   return true if overlap exists false otherwise.\n     */\n    public static boolean isOverlap(int[][] ranges) {\n\n        int maximumEndPoint = FindMaximumEndPoint(ranges);\n        Arrays.sort(ranges, Comparator.comparingInt(a->a[0]));\n        int[] numberLine = new int[maximumEndPoint+2];\n        for (int[] range : ranges) {\n\n            int start = range[0];\n            int end = range[1];\n\n            numberLine[start] += 1;\n            numberLine[end+1] -= 1;\n        }\n\n        int current = 0;\n        int overlaps = 0;\n        for (int num : numberLine) {\n            current += num;\n            overlaps = Math.max(overlaps, current);\n        }\n        return overlaps >1 ;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\npublic class LineSweepTest {\n\n\n    @Test\n    void testForOverlap(){\n        int[][]arr = {{0,10},{7,20},{15,24}};\n        assertTrue(LineSweep.isOverlap(arr));\n    }\n\n    @Test\n    void testForNoOverlap(){\n        int[][]arr = {{0,10},{11,20},{21,24}};\n        assertFalse(LineSweep.isOverlap(arr));\n    }\n    @Test\n    void testForOverlapWhenEndAEqualsStartBAndViceVersa(){\n        int[][]arr = {{0,10},{10,20},{21,24}};\n        assertTrue(LineSweep.isOverlap(arr));\n    }\n    @Test\n    void testForMaximumEndPoint(){\n        int[][]arr = {{10,20},{1,100},{14,16},{1,8}};\n        assertEquals(100,LineSweep.FindMaximumEndPoint(arr));\n    }\n\n}"
    },
    {
        "product_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "test_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/AllPathsFromSourceToTarget.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java",
        "product_old_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm=new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices)\n    {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList()\n    {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v)\n    {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n\n    public void storeAllPaths(int s, int d)\n    {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path \n    private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList)\n    {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n        \n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int a[][], int source, int destination)\n    {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for(int i=0 ; i<a.length ; i++)\n        {\n            g.addEdge(a[i][0], a[i][1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "product_new_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm=new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices)\n    {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList()\n    {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v)\n    {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n\n    public void storeAllPaths(int s, int d)\n    {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path \n    private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList)\n    {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n        \n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int[][] a, int source, int destination)\n    {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for(int i=0 ; i<a.length ; i++)\n        {\n            g.addEdge(a[i][0], a[i][1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int a[][] = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3),List.of(2, 0, 3),List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int a[][] = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3},{1,4},{3,4},{2,4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4),List.of(0, 1, 4),List.of(0, 2, 1, 3, 4),List.of(0, 2, 1, 4),List.of(0, 2, 4),List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int a[][] = {{1,0},{2,3},{0,4},{1,5},{4,3},{0,2},{0,3},{1,2},{0,5},{3,4},{2,5},{2,4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5),List.of(1, 0, 5),List.of(1, 5),List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int a[][] = {{0,1},{0,2},{1,2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2),List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int[][] a = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3),List.of(2, 0, 3),List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int[][] a = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3},{1,4},{3,4},{2,4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4),List.of(0, 1, 4),List.of(0, 2, 1, 3, 4),List.of(0, 2, 1, 4),List.of(0, 2, 4),List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int[][] a = {{1,0},{2,3},{0,4},{1,5},{4,3},{0,2},{0,3},{1,2},{0,5},{3,4},{2,5},{2,4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5),List.of(1, 0, 5),List.of(1, 5),List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int[][] a = {{0,1},{0,2},{1,2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2),List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n}"
    },
    {
        "product_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "test_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n        T array[],\n        T key,\n        int left,\n        int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.printf(\n                \"Should be found: %d. Found %d at index %d. An array length %d%n\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.printf(\"Found by system method at an index: %d. Is equal: %b%n\", toCheck, toCheck == atIndex);\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n            T[] array,\n            T key,\n            int left,\n            int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.printf(\n                \"Should be found: %d. Found %d at index %d. An array length %d%n\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.printf(\"Found by system method at an index: %d. Is equal: %b%n\", toCheck, toCheck == atIndex);\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int arr[] = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int arr[] = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int[] arr = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int[] arr = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}"
    },
    {
        "product_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "test_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "product_file_path": "src/main/java/com/thealgorithms/searches/OrderAgnosticBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\n//URL: https://www.geeksforgeeks.org/order-agnostic-binary-search/\n\n/* Order Agnostic Binary Search is an algorithm where we do not know whether the given\n   sorted array is ascending or descending order.\n   We declare a boolean variable to find whether the array is ascending order.\n   In the while loop, we use the two pointer method (start and end) to get the middle element.\n   if the middle element is equal to our target element, then that is the answer.\n   If not, then we check if the array is ascending or descending order.\n   Depending upon the condition, respective statements will be executed and we will get our answer.\n */\n\n public class OrderAgnosticBinarySearch {\n\n     static int BinSearchAlgo(int arr[], int start, int end, int target) {\n\n         // Checking whether the given array is ascending order\n         boolean AscOrd = arr[start] < arr[end];\n\n         while (start <= end) {\n             int middle = start + (end - start) / 2;\n\n             // Check if the desired element is present at the middle position\n             if (arr[middle] == target)\n                 return middle;       // returns the index of the middle element\n\n             // Ascending order\n             if (AscOrd) {\n                 if (arr[middle] < target)\n                     start = middle + 1;\n                 else\n                     end = middle - 1;\n             }\n\n             // Descending order\n             else {\n                 if (arr[middle] > target)\n                     start = middle + 1;\n                 else\n                     end = middle - 1;\n             }\n         }\n         // Element is not present\n         return -1;\n     }\n }",
        "product_new_content": "package com.thealgorithms.searches;\n\n//URL: https://www.geeksforgeeks.org/order-agnostic-binary-search/\n\n/* Order Agnostic Binary Search is an algorithm where we do not know whether the given\n   sorted array is ascending or descending order.\n   We declare a boolean variable to find whether the array is ascending order.\n   In the while loop, we use the two pointer method (start and end) to get the middle element.\n   if the middle element is equal to our target element, then that is the answer.\n   If not, then we check if the array is ascending or descending order.\n   Depending upon the condition, respective statements will be executed and we will get our answer.\n */\n\n public class OrderAgnosticBinarySearch {\n\n     static int BinSearchAlgo(int[] arr, int start, int end, int target) {\n\n         // Checking whether the given array is ascending order\n         boolean AscOrd = arr[start] < arr[end];\n\n         while (start <= end) {\n             int middle = start + (end - start) / 2;\n\n             // Check if the desired element is present at the middle position\n             if (arr[middle] == target)\n                 return middle;       // returns the index of the middle element\n\n             // Ascending order\n             if (AscOrd) {\n                 if (arr[middle] < target)\n                     start = middle + 1;\n                 else\n                     end = middle - 1;\n             }\n\n             // Descending order\n             else {\n                 if (arr[middle] > target)\n                     start = middle + 1;\n                 else\n                     end = middle - 1;\n             }\n         }\n         // Element is not present\n         return -1;\n     }\n }",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int arr[] = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int arr[] = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int[] arr = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int[] arr = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}"
    },
    {
        "product_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "test_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "product_file_path": "src/main/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\nimport java.util.*;\npublic class sortOrderAgnosticBinarySearch {\n    public static int find(int arr[],int key){\n        int start = 0;\n        int end = arr.length-1;\n        boolean arrDescending = arr[start]>arr[end];  //checking for Array is in ascending order or descending order.\n        while(start<=end){\n            int mid = end-start/2;\n            if (arr[mid]==key){\n                return mid;\n            }\n            if(arrDescending){       // boolean is true then our array is in descending order \n                if(key<arr[mid]){\n                    start=mid+1;\n                }\n                else{\n                    end=mid-1;\n                }\n            }\n            else {         // otherwise our array is in ascending order \n                if(key>arr[mid]){\n                   start=mid+1;\n               }\n               else{\n                   end=mid-1;\n               }\n            }\n        }\n        return -1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\nimport java.util.*;\npublic class sortOrderAgnosticBinarySearch {\n    public static int find(int[] arr, int key){\n        int start = 0;\n        int end = arr.length-1;\n        boolean arrDescending = arr[start]>arr[end];  //checking for Array is in ascending order or descending order.\n        while(start<=end){\n            int mid = end-start/2;\n            if (arr[mid]==key){\n                return mid;\n            }\n            if(arrDescending){       // boolean is true then our array is in descending order \n                if(key<arr[mid]){\n                    start=mid+1;\n                }\n                else{\n                    end=mid-1;\n                }\n            }\n            else {         // otherwise our array is in ascending order \n                if(key>arr[mid]){\n                   start=mid+1;\n               }\n               else{\n                   end=mid-1;\n               }\n            }\n        }\n        return -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int arr[] = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int arr[] = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int[] arr = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int[] arr = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}"
    },
    {
        "product_commit": "1ce907625b65abe27fef450df9c645b5d71c383d",
        "test_commit": "1ce907625b65abe27fef450df9c645b5d71c383d",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    Node reverseList(Node node) {\n        Node prevNode = head;\n        while (prevNode.next != node) {\n            prevNode = prevNode.next;\n        }\n        Node prev = null, curr = node, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        prevNode.next = prev;\n        return head;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (\n                    newHead.next != null && newHead.value == newHead.next.value\n                ) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) &&\n        list.search(5) &&\n        list.search(1) &&\n        !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 &&\n        list.getNth(2) == 5 &&\n        list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(\n            0,\n            new Node(2, new Node(3, new Node(3, new Node(4))))\n        );\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {}\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    public Node reverseList(Node node) {\n        Node prev = null;\n        Node curr = node;\n        \n        while (curr != null && curr.next != null) {\n            Node next=curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        //when curr.next==null, the current element is left without pointing it to its prev,so \n        if(curr != null){\n            curr.next = prev;\n            prev=curr;\n        }\n        //prev will be pointing to the last element in the Linkedlist, it will be the new head of the reversed linkedlist\n        return prev;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (\n                    newHead.next != null && newHead.value == newHead.next.value\n                ) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) &&\n        list.search(5) &&\n        list.search(1) &&\n        !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 &&\n        list.getNth(2) == 5 &&\n        list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(\n            0,\n            new Node(2, new Node(3, new Node(3, new Node(4))))\n        );\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {}\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i+1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        //List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode/2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode/2, list.middle().value);\n\n        //return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        //return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1,5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); //Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i+1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        //List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode/2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode/2, list.middle().value);\n\n        //return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        //return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1,5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); //Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    //Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList(){\n\n        //Creating a new LinkedList of size:4\n        //The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n          \n        //Reversing the LinkedList using reverseList() method and storing the head of the reversed linkedlist in a head node\n        //The reversed linkedlist will be 4->3->2->1->null\n        Node head=list.reverseList(list.getHead());\n\n        //Recording the Nodes after reversing the LinkedList\n        Node firstNode = head;              //4\n        Node secondNode = firstNode.next;   //3\n        Node thirdNode = secondNode.next;   //2\n        Node fourthNode = thirdNode.next;   //1\n        \n        //Checking whether the LinkedList is reversed or not by comparing the original list and reversed list nodes\n        assertEquals(1,fourthNode.value);\n        assertEquals(2,thirdNode.value);\n        assertEquals(3,secondNode.value);\n        assertEquals(4,firstNode.value);\n    }\n    \n    //Test to check whether implemented reverseList() method handles NullPointer Exception for TestCase where head==null\n    @Test\n    void reverseListNullPointer(){\n        //Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list=new SinglyLinkedList();\n        Node first=list.getHead();\n        \n        //Reversing the linkedlist\n        Node head=list.reverseList(first);\n\n        //checking whether the method works fine if the input is null\n        assertEquals(head,first);\n    }\n\n    //Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest(){\n        //Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        //Reversing the LinkedList using reverseList() method and storing the head of the reversed linkedlist in a head node\n        Node head=list.reverseList(list.getHead());\n        \n        //Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp=head;\n\n        int i=20; //This is for the comparison of values of nodes of the reversed linkedlist\n        //Checking whether the reverseList() method performed its task\n        while(temp!=null && i>0){\n             assertEquals(i,temp.value);\n             temp=temp.next;\n             i--;\n        }\n    }\n\n}"
    },
    {
        "product_commit": "8259f0e9cf086fd8632b86eb3417a3753727712d",
        "test_commit": "8259f0e9cf086fd8632b86eb3417a3753727712d",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElement.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/hashmap/hashing/MajorityElementTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\n/*\nThis class finds the majority element(s) in an array of integers.\nA majority element is an element that appears more than or equal to n/2 times, where n is the length of the array.\n*/\npublic class MajorityElement {\n      /*\n     This method returns the majority element(s) in the given array of integers.\n     @param nums: an array of integers\n     @return a list of majority elements\n     */\n    public static List<Integer> majority(int[] nums){\n        HashMap<Integer,Integer> numToCount  = new HashMap<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (numToCount.containsKey(nums[i])){\n                numToCount.put(nums[i],numToCount.get(nums[i])+1);\n            } else {\n                numToCount.put(nums[i],1);\n            }\n        }\n        List<Integer> majorityElements = new ArrayList<>();\n        for (int key: numToCount.keySet()) {\n            if (numToCount.get(key) >= n/2){\n                majorityElements.add(key);\n            }\n        }\n        return majorityElements;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport com.thealgorithms.datastructures.hashmap.hashing.MajorityElement;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport java.util.ArrayList;\n\npublic class MajorityElementTest{\n    @Test\n    void testMajorityWithSingleMajorityElement() {\n        int[] nums = {1, 2, 3, 9, 9, 6, 7, 8, 9, 9, 9, 9};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(9);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithMultipleMajorityElements() {\n        int[] nums = {1, 2, 3, 3, 4, 4, 4, 4};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(4);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithNoMajorityElement() {\n        int[] nums = {1, 2, 4, 4, 5, 4};\n        List<Integer> expected = new ArrayList<>();\n        expected.add(4);\n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testMajorityWithEmptyArray() {\n        int[] nums = {};\n        List<Integer> expected = Collections.emptyList(); \n        List<Integer> actual = MajorityElement.majority(nums);\n        assertEquals(expected, actual);\n    }\n}"
    },
    {
        "product_commit": "7779c18ef612f50b8389382e9e43ff7e159dc21e",
        "test_commit": "7779c18ef612f50b8389382e9e43ff7e159dc21e",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LeonardoNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LeonardoNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class LeonardoNumber {\n\n    public static int leonardoNumber(int n) {\n        if (n < 0) {\n            return 0;\n        }\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);\n    }\n\n    public static void main(String args[]) {\n        for (int i = 0; i < 20; i++) {\n            System.out.print(leonardoNumber(i) + \" \");\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n /**\n  * https://en.wikipedia.org/wiki/Leonardo_number\n  */\npublic class LeonardoNumber {\n\n    /**\n     * Calculate nth Leonardo Number (1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, ...)\n     *\n     * @param n the index of Leonardo Number to calculate\n     * @return nth number of Leonardo sequences\n     */\n    public static int leonardoNumber(int n) {\n        if (n < 0) {\n            throw new ArithmeticException();\n        }\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class LeonardoNumberTest {\n    @Test\n    void leonardoNumberNegative() {\n        assertThrows(ArithmeticException.class, ()-> LeonardoNumber.leonardoNumber(-1));\n    }\n    @Test\n    void leonardoNumberZero() {\n        assertEquals(1, LeonardoNumber.leonardoNumber(0));\n    }\n    @Test\n    void leonardoNumberOne() {\n        assertEquals(1, LeonardoNumber.leonardoNumber(1));\n    }\n    @Test\n    void leonardoNumberFive() {\n        assertEquals(15, LeonardoNumber.leonardoNumber(5));\n    }\n    @Test\n    void leonardoNumberTwenty() {\n        assertEquals(21891 , LeonardoNumber.leonardoNumber(20));\n    }\n}"
    },
    {
        "product_commit": "7779c18ef612f50b8389382e9e43ff7e159dc21e",
        "test_commit": "7779c18ef612f50b8389382e9e43ff7e159dc21e",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LucasSeries.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LucasSeriesTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Lucas_number\n */\npublic class LucasSeries {\n\n    public static void main(String[] args) {\n        assert lucasSeries(1) == 2 && lucasSeriesIteration(1) == 2;\n        assert lucasSeries(2) == 1 && lucasSeriesIteration(2) == 1;\n        assert lucasSeries(3) == 3 && lucasSeriesIteration(3) == 3;\n        assert lucasSeries(4) == 4 && lucasSeriesIteration(4) == 4;\n        assert lucasSeries(5) == 7 && lucasSeriesIteration(5) == 7;\n        assert lucasSeries(6) == 11 && lucasSeriesIteration(6) == 11;\n        assert lucasSeries(11) == 123 && lucasSeriesIteration(11) == 123;\n    }\n\n    /**\n     * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using recursion\n     *\n     * @param n nth\n     * @return nth number of lucas series\n     */\n    public static int lucasSeries(int n) {\n        return n == 1\n            ? 2\n            : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);\n    }\n\n    /**\n     * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using iteration\n     *\n     * @param n nth\n     * @return nth number of lucas series\n     */\n    public static int lucasSeriesIteration(int n) {\n        int previous = 2;\n        int current = 1;\n        for (int i = 1; i < n; i++) {\n            int next = previous + current;\n            previous = current;\n            current = next;\n        }\n        return previous;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Lucas_number\n */\npublic class LucasSeries {\n\n    /**\n     * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using recursion\n     *\n     * @param n nth\n     * @return nth number of Lucas Series\n     */\n    public static int lucasSeries(int n) {\n        return n == 1\n            ? 2\n            : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);\n    }\n\n    /**\n     * Calculate nth number of Lucas Series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,\n     * 123, ....) using iteration\n     *\n     * @param n nth\n     * @return nth number of lucas series\n     */\n    public static int lucasSeriesIteration(int n) {\n        int previous = 2;\n        int current = 1;\n        for (int i = 1; i < n; i++) {\n            int next = previous + current;\n            previous = current;\n            current = next;\n        }\n        return previous;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class LucasSeriesTest {\n    @Test\n    void lucasSeriesTwo() {\n        assertEquals(2, LucasSeries.lucasSeries(1));\n        assertEquals(2, LucasSeries.lucasSeriesIteration(1));\n    }\n    @Test\n    void lucasSeriesOne() {\n        assertEquals(1, LucasSeries.lucasSeries(2));\n        assertEquals(1, LucasSeries.lucasSeriesIteration(2));\n    }\n    @Test\n    void lucasSeriesSeven() {\n        assertEquals(7, LucasSeries.lucasSeries(5));\n        assertEquals(7, LucasSeries.lucasSeriesIteration(5));\n    }\n    @Test\n    void lucasSeriesEleven() {\n        assertEquals(123, LucasSeries.lucasSeries(11));\n        assertEquals(123, LucasSeries.lucasSeriesIteration(11));\n    }\n}"
    },
    {
        "product_commit": "7779c18ef612f50b8389382e9e43ff7e159dc21e",
        "test_commit": "7779c18ef612f50b8389382e9e43ff7e159dc21e",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Median.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MedianTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Median\n */\npublic class Median {\n\n    public static void main(String[] args) {\n        assert median(new int[] { 0 }) == 0;\n        assert median(new int[] { 1, 2 }) == 1.5;\n        assert median(new int[] { 4, 1, 3, 2 }) == 2.5;\n        assert median(new int[] { 1, 3, 3, 6, 7, 8, 9 }) == 6;\n        assert median(new int[] { 1, 2, 3, 4, 5, 6, 8, 9 }) == 4.5;\n    }\n\n    /**\n     * Calculate average median\n     *\n     * @param values number series\n     * @return median of given {@code values}\n     */\n    public static double median(int[] values) {\n        Arrays.sort(values);\n        int length = values.length;\n        return length % 2 == 0\n            ? (values[length / 2] + values[length / 2 - 1]) / 2.0\n            : values[length / 2];\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Median\n */\npublic class Median {\n\n    /**\n     * Calculate average median\n     * @param values sorted numbers to find median of\n     * @return median of given {@code values}\n     */\n    public static double median(int[] values) {\n        Arrays.sort(values);\n        int length = values.length;\n        return length % 2 == 0\n            ? (values[length / 2] + values[length / 2 - 1]) / 2.0\n            : values[length / 2];\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class MedianTest {\n    @Test\n    void medianSingleValue() {\n        int[] arr = {0};\n        assertEquals(0, Median.median(arr));\n    }\n\n    @Test\n    void medianTwoValues() {\n        int[] arr = {1, 2};\n        assertEquals(1.5, Median.median(arr));\n    }\n\n    @Test\n    void medianThreeValues() {\n        int[] arr = {1, 2, 3};\n        assertEquals(2, Median.median(arr));\n    }\n\n    @Test\n    void medianDecimalValueReturn() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 8, 9};\n        assertEquals(4.5, Median.median(arr));\n    }\n\n    @Test\n    void medianNegativeValues() {\n        int[] arr = {-27, -16, -7, -4, -2, -1};\n        assertEquals(-5.5, Median.median(arr));\n    }\n}"
    },
    {
        "product_commit": "8798e042a899223ee29bae3acd20253e836fcd94",
        "test_commit": "8798e042a899223ee29bae3acd20253e836fcd94",
        "product_file_path": "src/main/java/com/thealgorithms/conversions/BinaryToDecimal.java",
        "test_file_path": "src/test/java/com/thealgorithms/conversions/BinaryToDecimalTest.java",
        "product_old_content": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\n/**\n * This class converts a Binary number to a Decimal number\n */\nclass BinaryToDecimal {\n\n    public static int binaryToDecimal(int binNum) {\n        int binCopy, d, s = 0, power = 0;\n        binCopy = binNum;\n        while (binCopy != 0) {\n            d = binCopy % 10;\n            s += d * (int) Math.pow(2, power++);\n            binCopy /= 10;\n        }\n        return s;\n    }\n\n    /**\n     * Main Method\n     *\n     * @param args Command line arguments\n     */\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Binary number: \");\n        System.out.println(\"Decimal equivalent:\" + binaryToDecimal(sc.nextInt()));\n        sc.close();\n    }\n}",
        "product_new_content": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\n/**\n * This class converts a Binary number to a Decimal number\n */\nclass BinaryToDecimal {\n\n    public static long binaryToDecimal(long binNum) {\n        long binCopy, d, s = 0, power = 0;\n        binCopy = binNum;\n        while (binCopy != 0) {\n            d = binCopy % 10;\n            s += d * (long) Math.pow(2, power++);\n            binCopy /= 10;\n        }\n        return s;\n    }\n\n    /**\n     * Main Method\n     *\n     * @param args Command line arguments\n     */\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Binary number: \");\n        System.out.println(\"Decimal equivalent:\" + binaryToDecimal(sc.nextLong()));\n        sc.close();\n    }\n}",
        "test_old_content": "package com.thealgorithms.conversions;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BinaryToDecimalTest {\n\n    @Test\n    public void testBinaryToDecimal() {\n        //zeros at the starting should be removed\n        assertEquals(0, BinaryToDecimal.binaryToDecimal(0));\n        assertEquals(1, BinaryToDecimal.binaryToDecimal(1));\n        assertEquals(5, BinaryToDecimal.binaryToDecimal(101));\n        assertEquals(63, BinaryToDecimal.binaryToDecimal(111111));\n        assertEquals(512, BinaryToDecimal.binaryToDecimal(1000000000));\n    }\n}",
        "test_new_content": "package com.thealgorithms.conversions;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BinaryToDecimalTest {\n\n    @Test\n    // Test converting binary to decimal\n    public void testBinaryToDecimal() {\n        // zeros at the starting should be removed\n        assertEquals(0, BinaryToDecimal.binaryToDecimal(0));\n        assertEquals(1, BinaryToDecimal.binaryToDecimal(1));\n        assertEquals(5, BinaryToDecimal.binaryToDecimal(101));\n        assertEquals(63, BinaryToDecimal.binaryToDecimal(111111));\n        assertEquals(512, BinaryToDecimal.binaryToDecimal(1000000000));\n    }\n\n    @Test\n    // Test converting negative binary numbers\n    public void testNegativeBinaryToDecimal() {\n        assertEquals(-1, BinaryToDecimal.binaryToDecimal(-1));\n        assertEquals(-42, BinaryToDecimal.binaryToDecimal(-101010));\n    }\n\n    @Test\n    // Test converting binary numbers with large values\n    public void testLargeBinaryToDecimal() {\n        assertEquals(262144L, BinaryToDecimal.binaryToDecimal(1000000000000000000L));\n        assertEquals(524287L, BinaryToDecimal.binaryToDecimal(1111111111111111111L));\n    }\n}"
    },
    {
        "product_commit": "d1601560032b75f347adf987417eda0fdc2d95f4",
        "test_commit": "d1601560032b75f347adf987417eda0fdc2d95f4",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMax {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute max value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute max value\n     */\n    public static int getMaxValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMaxWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays\n            .stream(numbers)\n            .skip(1)\n            .filter(number -> Math.abs(number) > Math.abs(absMaxWrapper.value))\n            .forEach(number -> absMaxWrapper.value = number);\n\n        return absMaxWrapper.value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class AbsoluteMax {\n\n    /**\n     * Finds the absolute maximum value among the given numbers.\n     *\n     * @param numbers The numbers to compare.\n     * @return The absolute maximum value.\n     * @throws IllegalArgumentException If the input array is empty or null.\n     */\n    public static int getMaxValue(int... numbers) {\n        if (numbers == null || numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n        }\n        int absMax = numbers[0];\n        for (int i = 1; i < numbers.length; i++) {\n            if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n                absMax = numbers[i];\n            }\n        }\n        return absMax;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMaxTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(16, AbsoluteMax.getMaxValue(-2, 0, 16));\n        assertEquals(-10, AbsoluteMax.getMaxValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMaxValueWithNoArguments() {\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> AbsoluteMax.getMaxValue()\n        );\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMaxTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(16, AbsoluteMax.getMaxValue(-2, 0, 16));\n        assertEquals(-22, AbsoluteMax.getMaxValue(-3, -10, -22));\n        assertEquals(-888, AbsoluteMax.getMaxValue(-888));\n    }\n\n    @Test\n    void testGetMaxValueWithNoArguments() {\n        assertThrows(IllegalArgumentException.class, AbsoluteMax::getMaxValue);\n    }\n}"
    },
    {
        "product_commit": "86c93146d94e188b62696b4b429e68aa4c14416d",
        "test_commit": "86c93146d94e188b62696b4b429e68aa4c14416d",
        "product_file_path": "src/main/java/com/thealgorithms/strings/StringCompression.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/StringCompressionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings;\n/*  References : https://en.wikipedia.org/wiki/Run-length_encoding\n * String compression algorithm deals with encoding the string, that is, shortening the size of the string\n * @author Swarga-codes (https://github.com/Swarga-codes)\n*/\npublic class StringCompression {\n  /**\n   * Returns the compressed or encoded string\n   * \n   * @param ch character array that contains the group of characters to be encoded\n   * @return the compressed character array as string\n   */\n  public static String compress(String input) {\n    // Keeping the count as 1 since every element present will have atleast a count\n    // of 1\n    int count = 1;\n    String compressedString = \"\";\n    // Base condition to check whether the array is of size 1, if it is then we\n    // return the array\n    if (input.length() == 1) {\n      return \"\" + input.charAt(0);\n    }\n    // If the array has a length greater than 1 we move into this loop\n    for (int i = 0; i < input.length() - 1; i++) {\n      // here we check for similarity of the adjacent elements and change the count\n      // accordingly\n      if (input.charAt(i) == input.charAt(i + 1)) {\n        count = count + 1;\n      }\n      if ((i + 1) == input.length() - 1 && input.charAt(i + 1) == input.charAt(i)) {\n        compressedString = appendCount(compressedString, count, input.charAt(i));\n        break;\n      } else if (input.charAt(i) != input.charAt(i+1)) {\n        if ((i + 1) == input.length() - 1) {\n          compressedString = appendCount(compressedString, count, input.charAt(i)) + input.charAt(i+1);\n          break;\n        } else {\n          compressedString = appendCount(compressedString, count, input.charAt(i));\n          count = 1;\n        }\n      }\n    }\n    return compressedString;\n  }\n  /**\n   * @param res   the resulting string\n   * @param count current count\n   * @param ch    the character at a particular index\n   * @return the res string appended with the count\n   */\n  public static String appendCount(String res, int count, char ch) {\n    if (count > 1) {\n      res += ch + \"\" + count;\n      count = 1;\n    } else {\n      res += ch + \"\";\n    }\n    return res;\n  }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\npublic class StringCompressionTest {\n    @ParameterizedTest\n    @CsvSource({\"a,a\",\"aabbb,a2b3\",\"abbbc,ab3c\",\"aabccd,a2bc2d\"})\n    void stringCompressionTest(String input,String expectedOutput){\n        String output=StringCompression.compress(input);\n        assertEquals(expectedOutput, output);\n    }\n}"
    },
    {
        "product_commit": "2418604f7aa448edfdac18a258841ae3afcb462c",
        "test_commit": "2418604f7aa448edfdac18a258841ae3afcb462c",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    Node reverseList(Node node) {\n        Node prevNode = head;\n        while (prevNode.next != node) {\n            prevNode = prevNode.next;\n        }\n        Node prev = null, curr = node, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        prevNode.next = prev;\n        return head;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (\n                    newHead.next != null && newHead.value == newHead.next.value\n                ) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list.toString());\n        /* Test search function */\n        assert list.search(10) &&\n        list.search(5) &&\n        list.search(1) &&\n        !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 &&\n        list.getNth(2) == 5 &&\n        list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list.toString());\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(\n            0,\n            new Node(2, new Node(3, new Node(3, new Node(4))))\n        );\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {}\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    Node reverseList(Node node) {\n        Node prevNode = head;\n        while (prevNode.next != node) {\n            prevNode = prevNode.next;\n        }\n        Node prev = null, curr = node, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        prevNode.next = prev;\n        return head;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (\n                    newHead.next != null && newHead.value == newHead.next.value\n                ) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list.toString());\n        /* Test search function */\n        assert list.search(10) &&\n        list.search(5) &&\n        list.search(1) &&\n        !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 &&\n        list.getNth(2) == 5 &&\n        list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list.toString());\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(\n            0,\n            new Node(2, new Node(3, new Node(3, new Node(4))))\n        );\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {}\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i+1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        //List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode/2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode/2, list.middle().value);\n\n        //return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        //return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1,5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); //Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n}"
    },
    {
        "product_commit": "a7e76c57a075a677dd024be6715bd15de3785074",
        "test_commit": "a7e76c57a075a677dd024be6715bd15de3785074",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/ArrayCombination.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/ArrayCombinationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.*;\n\n/**\n * Finds all permutations of 1...n of length k\n * @author TheClerici (https://github.com/TheClerici)\n */\npublic class ArrayCombination {\n    private static int length;\n\n    /**\n     * Find all combinations of 1..n by creating an array and using backtracking in Combination.java\n     * @param n max value of the array.\n     * @param k length of combination\n     * @return a list of all combinations of length k. If k == 0, return null.\n     */\n    public static List<TreeSet<Integer>> combination(int n, int k) {\n        if (n <= 0) {\n            return null;\n        }\n        length = k;\n        Integer[] arr = new Integer[n];\n        for (int i = 1; i <= n; i++) {\n            arr[i-1] = i;\n        }\n        return Combination.combination(arr, length);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\n\npublic class ArrayCombinationTest {\n\n    @Test\n    void testNBeingZeroOrLess() {\n        List<TreeSet<Integer>> zeroResult = ArrayCombination.combination(0, 1);\n        List<TreeSet<Integer>> negativeResult = ArrayCombination.combination(-1, 1);\n        assertNull(zeroResult);\n        assertNull(negativeResult);\n    }\n\n    @Test\n    void testNoLengthElement() {\n        List<TreeSet<Integer>> result = ArrayCombination.combination(2, 0);\n        assertNull(result);\n    }\n\n    @Test\n    void testLengthOne() {\n        List<TreeSet<Integer>> result = ArrayCombination.combination(2, 1);\n        assert result != null;\n        assertEquals(1, result.get(0).iterator().next());\n        assertEquals(2, result.get(1).iterator().next());\n    }\n\n    @Test\n    void testLengthTwo() {\n        List<TreeSet<Integer>> result = ArrayCombination.combination(2, 2);\n        assert result != null;\n        Integer[] arr = result.get(0).toArray(new Integer[2]);\n        assertEquals(1, arr[0]);\n        assertEquals(2, arr[1]);\n    }\n\n    @Test\n    void testLengthFive() {\n        List<TreeSet<Integer>> result = ArrayCombination.combination(10, 5);\n        assert result != null;\n        Integer[] arr = result.get(0).toArray(new Integer[5]);\n        assertEquals(1, arr[0]);\n        assertEquals(5, arr[4]);\n    }\n}"
    },
    {
        "product_commit": "b6563cf37ae7db33e3f3c8ad513acd905353c147",
        "test_commit": "b6563cf37ae7db33e3f3c8ad513acd905353c147",
        "product_file_path": "src/main/java/com/thealgorithms/io/BufferedReader.java",
        "test_file_path": "src/test/java/com/thealgorithms/io/BufferedReaderTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.io;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Mimics the actions of the Original buffered reader\n * implements other actions, such as peek(n) to lookahead,\n * block() to read a chunk of size {BUFFER SIZE}\n * <p>\n * Author: Kumaraswamy B.G (Xoma Dev)\n */\npublic class BufferedReader {\n\n  private static final int DEFAULT_BUFFER_SIZE = 5;\n\n  /**\n   * Maximum number of bytes the buffer can hold.\n   * Value is changed when encountered Eof to not\n   * cause overflow read of 0 bytes\n   */\n\n  private int bufferSize;\n  private final byte[] buffer;\n\n  /**\n   * posRead -> indicates the next byte to read\n   */\n  private int posRead = 0, bufferPos = 0;\n\n  private boolean foundEof = false;\n\n  private InputStream input;\n\n  public BufferedReader(byte[] input) throws IOException {\n    this(new ByteArrayInputStream(input));\n  }\n\n  public BufferedReader(InputStream input) throws IOException {\n    this(input, DEFAULT_BUFFER_SIZE);\n  }\n\n  public BufferedReader(InputStream input, int bufferSize) throws IOException {\n    this.input = input;\n    if (input.available() == -1)\n      throw new IOException(\"Empty or already closed stream provided\");\n\n    this.bufferSize = bufferSize;\n    buffer = new byte[bufferSize];\n  }\n\n  /**\n   * Reads a single byte from the stream\n   */\n  public int read() throws IOException {\n    if (needsRefill()) {\n      if (foundEof)\n        return -1;\n      // the buffer is empty, or the buffer has\n      // been completely read and needs to be refilled\n      refill();\n    }\n    return buffer[posRead++] & 0xff; // read and un-sign it\n  }\n\n  /**\n   * Number of bytes not yet been read\n   */\n\n  public int available() throws IOException {\n    int available = input.available();\n    if (needsRefill())\n      // since the block is already empty,\n      // we have no responsibility yet\n      return available;\n    return bufferPos - posRead + available;\n  }\n\n  /**\n   * Returns the next character\n   */\n\n  public int peek() throws IOException {\n    return peek(1);\n  }\n\n  /**\n   * Peeks and returns a value located at next {n}\n   */\n\n  public int peek(int n) throws IOException {\n    int available = available();\n    if (n >= available)\n      throw new IOException(\"Out of range, available %d, but trying with %d\"\n              .formatted(available, n));\n    pushRefreshData();\n\n    if (n >= bufferSize)\n      throw new IllegalAccessError(\"Cannot peek %s, maximum upto %s (Buffer Limit)\"\n              .formatted(n, bufferSize));\n    return buffer[n];\n  }\n\n  /**\n   * Removes the already read bytes from the buffer\n   * in-order to make space for new bytes to be filled up.\n   * <p>\n   * This may also do the job to read first time data (whole buffer is empty)\n   */\n\n  private void pushRefreshData() throws IOException {\n    for (int i = posRead, j = 0; i < bufferSize; i++, j++)\n      buffer[j] = buffer[i];\n\n    bufferPos -= posRead;\n    posRead = 0;\n\n    // fill out the spaces that we've\n    // emptied\n    justRefill();\n  }\n\n  /**\n   * Reads one complete block of size {bufferSize}\n   * if found eof, the total length of array will\n   * be that of what's available\n   *\n   * @return a completed block\n   */\n  public byte[] readBlock() throws IOException {\n    pushRefreshData();\n\n    byte[] cloned = new byte[bufferSize];\n    // arraycopy() function is better than clone()\n    if (bufferPos >= 0)\n      System.arraycopy(buffer,\n              0,\n              cloned,\n              0,\n              // important to note that, bufferSize does not stay constant\n              // once the class is defined. See justRefill() function\n              bufferSize);\n    // we assume that already a chunk\n    // has been read\n    refill();\n    return cloned;\n  }\n\n  private boolean needsRefill() {\n    return bufferPos == 0 || posRead == bufferSize;\n  }\n\n  private void refill() throws IOException {\n    posRead = 0;\n    bufferPos = 0;\n    justRefill();\n  }\n\n  private void justRefill() throws IOException {\n    assertStreamOpen();\n\n    // try to fill in the maximum we can until\n    // we reach EOF\n    while (bufferPos < bufferSize) {\n      int read = input.read();\n      if (read == -1) {\n        // reached end-of-file, no more data left\n        // to be read\n        foundEof = true;\n        // rewrite the BUFFER_SIZE, to know that we've reached\n        // EOF when requested refill\n        bufferSize = bufferPos;\n      }\n      buffer[bufferPos++] = (byte) read;\n    }\n  }\n\n  private void assertStreamOpen() {\n    if (input == null)\n      throw new IllegalStateException(\"Input Stream already closed!\");\n  }\n\n  public void close() throws IOException {\n    if (input != null) {\n      try {\n        input.close();\n      } finally {\n        input = null;\n      }\n    }\n  }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.io;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BufferedReaderTest {\n  @Test\n  public void testPeeks() throws IOException {\n    String text = \"Hello!\\nWorld!\";\n    int len = text.length();\n    byte[] bytes = text.getBytes();\n\n    ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n    BufferedReader reader = new BufferedReader(input);\n\n    // read the first letter\n    assertEquals(reader.read(), 'H');\n    len--;\n    assertEquals(reader.available(), len);\n\n    // position: H[e]llo!\\nWorld!\n    // reader.read() will be == 'e'\n    assertEquals(reader.peek(1), 'l');\n    assertEquals(reader.peek(2), 'l'); // second l\n    assertEquals(reader.peek(3), 'o');\n  }\n\n  @Test\n  public void testMixes() throws IOException {\n    String text = \"Hello!\\nWorld!\";\n    int len = text.length();\n    byte[] bytes = text.getBytes();\n\n    ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n    BufferedReader reader = new BufferedReader(input);\n\n    // read the first letter\n    assertEquals(reader.read(), 'H'); // first letter\n    len--;\n\n    assertEquals(reader.peek(1), 'l'); // third later (second letter after 'H')\n    assertEquals(reader.read(), 'e'); // second letter\n    len--;\n    assertEquals(reader.available(), len);\n\n    // position: H[e]llo!\\nWorld!\n    assertEquals(reader.peek(2), 'o'); // second l\n    assertEquals(reader.peek(3), '!');\n    assertEquals(reader.peek(4), '\\n');\n\n    assertEquals(reader.read(), 'l'); // third letter\n    assertEquals(reader.peek(1), 'o'); // fourth letter\n\n    for (int i = 0; i < 6; i++)\n      reader.read();\n    try {\n      System.out.println((char) reader.peek(4));\n    } catch (Exception ignored) {\n      System.out.println(\"[cached intentional error]\");\n      // intentional, for testing purpose\n    }\n  }\n\n  @Test\n  public void testBlockPractical() throws IOException {\n    String text = \"!Hello\\nWorld!\";\n    byte[] bytes = text.getBytes();\n    int len = bytes.length;\n\n    ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n    BufferedReader reader = new BufferedReader(input);\n\n\n    assertEquals(reader.peek(), 'H');\n    assertEquals(reader.read(), '!'); // read the first letter\n    len--;\n\n    // this only reads the next 5 bytes (Hello) because\n    // the default buffer size = 5\n    assertEquals(new String(reader.readBlock()), \"Hello\");\n    len -= 5;\n    assertEquals(reader.available(), len);\n\n    // maybe kind of a practical demonstration / use case\n    if (reader.read() == '\\n') {\n      assertEquals(reader.read(), 'W');\n      assertEquals(reader.read(), 'o');\n\n      // the rest of the blocks\n      assertEquals(new String(reader.readBlock()), \"rld!\");\n    } else {\n      // should not reach\n      throw new IOException(\"Something not right\");\n    }\n  }\n\n  @Test\n  public void randomTest() throws IOException {\n    Random random = new Random();\n\n    int len = random.nextInt(9999);\n    int bound = 256;\n\n    ByteArrayOutputStream stream = new ByteArrayOutputStream(len);\n    while (len-- > 0)\n      stream.write(random.nextInt(bound));\n\n    byte[] bytes = stream.toByteArray();\n    ByteArrayInputStream comparer = new ByteArrayInputStream(bytes);\n\n    int blockSize = random.nextInt(7) + 5;\n    BufferedReader reader = new BufferedReader(\n            new ByteArrayInputStream(bytes), blockSize);\n\n    for (int i = 0; i < 50; i++) {\n      if ((i & 1) == 0) {\n        assertEquals(comparer.read(), reader.read());\n        continue;\n      }\n      byte[] block = new byte[blockSize];\n      comparer.read(block);\n      byte[] read = reader.readBlock();\n\n      assertArrayEquals(block, read);\n    }\n  }\n}"
    },
    {
        "product_commit": "3e9dd776e5cc91c84e8206779ace3874c8d7491f",
        "test_commit": "3e9dd776e5cc91c84e8206779ace3874c8d7491f",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/queues/LinkedQueue.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/queues/LinkedQueueTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.queues;\n\nimport java.util.NoSuchElementException;\n\npublic class LinkedQueue {\n\n    class Node {\n\n        int data;\n        Node next;\n\n        public Node() {\n            this(0);\n        }\n\n        public Node(int data) {\n            this(data, null);\n        }\n\n        public Node(int data, Node next) {\n            this.data = data;\n            this.next = next;\n        }\n    }\n\n    /**\n     * Front of Queue\n     */\n    private Node front;\n\n    /**\n     * Rear of Queue\n     */\n    private Node rear;\n\n    /**\n     * Size of Queue\n     */\n    private int size;\n\n    /**\n     * Init LinkedQueue\n     */\n    public LinkedQueue() {\n        front = rear = new Node();\n    }\n\n    /**\n     * Check if queue is empty\n     *\n     * @return true if queue is empty, otherwise false\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Add element to rear of queue\n     *\n     * @param data insert value\n     * @return true if add successfully\n     */\n    public boolean enqueue(int data) {\n        Node newNode = new Node(data);\n        rear.next = newNode;\n        rear = newNode;\n        /* make rear point at last node */\n        size++;\n        return true;\n    }\n\n    /**\n     * Remove element at the front of queue\n     *\n     * @return element at the front of queue\n     */\n    public int dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        Node destroy = front.next;\n        int retValue = destroy.data;\n        front.next = front.next.next;\n        destroy = null;\n        /* clear let GC do it's work */\n        size--;\n\n        if (isEmpty()) {\n            front = rear;\n        }\n\n        return retValue;\n    }\n\n    /**\n     * Peek element at the front of queue without removing\n     *\n     * @return element at the front\n     */\n    public int peekFront() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return front.next.data;\n    }\n\n    /**\n     * Peek element at the rear of queue without removing\n     *\n     * @return element at the front\n     */\n    public int peekRear() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return rear.data;\n    }\n\n    /**\n     * Return size of queue\n     *\n     * @return size of queue\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Clear all nodes in queue\n     */\n    public void clear() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"[]\";\n        }\n        StringBuilder builder = new StringBuilder();\n        Node cur = front.next;\n        builder.append(\"[\");\n        while (cur != null) {\n            builder.append(cur.data).append(\", \");\n            cur = cur.next;\n        }\n        builder.replace(builder.length() - 2, builder.length(), \"]\");\n        return builder.toString();\n    }\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        LinkedQueue queue = new LinkedQueue();\n        assert queue.isEmpty();\n\n        queue.enqueue(1);\n        /* 1 */\n        queue.enqueue(2);\n        /* 1 2 */\n        queue.enqueue(3);\n        /* 1 2 3 */\n        System.out.println(queue);\n        /* [1, 2, 3] */\n\n        assert queue.size() == 3;\n        assert queue.dequeue() == 1;\n        assert queue.peekFront() == 2;\n        assert queue.peekRear() == 3;\n\n        queue.clear();\n        assert queue.isEmpty();\n\n        System.out.println(queue);\n        /* [] */\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.queues;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.StringJoiner;\n\npublic class LinkedQueue<T> implements Iterable<T> {\n\n    static class Node<T> {\n\n        T data;\n        Node<T> next;\n\n        public Node() {\n            this(null);\n        }\n\n        public Node(T data) {\n            this(data, null);\n        }\n\n        public Node(T data, Node<T> next) {\n            this.data = data;\n            this.next = next;\n        }\n    }\n\n    /**\n     * Front of Queue\n     */\n    private Node<T> front;\n\n    /**\n     * Rear of Queue\n     */\n    private Node<T> rear;\n\n    /**\n     * Size of Queue\n     */\n    private int size;\n\n    /**\n     * Init LinkedQueue\n     */\n    public LinkedQueue() {\n        front = rear = new Node<>();\n    }\n\n    /**\n     * Check if queue is empty\n     *\n     * @return true if queue is empty, otherwise false\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Add element to rear of queue\n     *\n     * @param data insert value\n     */\n    public void enqueue(T data) {\n        Node<T> newNode = new Node<>(data);\n\n        rear.next = newNode;\n        rear = newNode;\n        /* make rear point at last node */\n        size++;\n    }\n\n    /**\n     * Remove element at the front of queue\n     *\n     * @return element at the front of queue\n     */\n    public T dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        Node<T> destroy = front.next;\n        T retValue = destroy.data;\n        front.next = front.next.next;\n        /* clear let GC do it's work */\n        size--;\n\n        if (isEmpty()) {\n            front = rear;\n        }\n\n        return retValue;\n    }\n\n    /**\n     * Peek element at the front of queue without removing\n     *\n     * @return element at the front\n     */\n    public T peekFront() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return front.next.data;\n    }\n\n    /**\n     * Peek element at the rear of queue without removing\n     *\n     * @return element at the front\n     */\n    public T peekRear() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return rear.data;\n    }\n\n    /**\n     * Peeks the element at the index and\n     *          returns the value\n     * @param pos at which to peek\n     */\n\n    public T peek(int pos) {\n        if (pos > size)\n            throw new IndexOutOfBoundsException(\n                    \"Position %s out of range!\".formatted(pos));\n        Node<T> node = front;\n        while (pos-- > 0)\n            node = node.next;\n        return node.data;\n    }\n\n    /**\n     * Node iterator, allows to travel through\n     * the nodes using for() loop or forEach(Consumer)\n     */\n\n    @Override\n    public Iterator<T> iterator() {\n        return new Iterator<>() {\n\n            Node<T> node = front;\n\n            @Override\n            public boolean hasNext() {\n                return node.next != null;\n            }\n\n            @Override\n            public T next() {\n                return (node = node.next).data;\n            }\n        };\n    }\n\n    /**\n     * Return size of queue\n     *\n     * @return size of queue\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Clear all nodes in queue\n     */\n    public void clear() {\n        while (size > 0)\n            dequeue();\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner join = new StringJoiner(\", \"); // separator of ', '\n        Node<T> travel = front;\n        while ((travel = travel.next) != null)\n            join.add(String.valueOf(travel.data));\n        return '[' + join.toString() + ']';\n    }\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        LinkedQueue<Integer> queue = new LinkedQueue<>();\n        assert queue.isEmpty();\n\n        queue.enqueue(1);\n        /* 1 */\n        queue.enqueue(2);\n        /* 1 2 */\n        queue.enqueue(3);\n        /* 1 2 3 */\n        System.out.println(queue);\n        /* [1, 2, 3] */\n\n        assert queue.size() == 3;\n        assert queue.dequeue() == 1;\n        assert queue.peekFront() == 2;\n        assert queue.peekRear() == 3;\n\n        queue.clear();\n        assert queue.isEmpty();\n\n        System.out.println(queue);\n        /* [] */\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.queues;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\nclass LinkedQueueTest {\n  @Test\n  public void testQue() {\n    LinkedQueue<Integer> queue = new LinkedQueue<>();\n    for (int i = 1; i < 5; i++)\n      queue.enqueue(i);\n\n    assertEquals(queue.peekRear(), 4);\n    assertEquals(queue.peek(2), 2);\n\n    assertEquals(queue.peek(4), 4);\n\n    final int[] element = { 1 };\n\n    // iterates over all the elements present\n    // as in the form of nodes\n    queue.forEach(integer -> {\n      if (element[0]++ != integer)\n        throw new AssertionError();\n    });\n  }\n}"
    },
    {
        "product_commit": "dd949e9b5dc92f306c5c5eb345ce28e257a75d82",
        "test_commit": "dd949e9b5dc92f306c5c5eb345ce28e257a75d82",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LongDivision.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LongDivisionTest.java",
        "product_old_content": "//        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n//\n//        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, \n//        and -2.7335 would be truncated to -2.\n//        My method used Long Division, here is the source \"https://en.wikipedia.org/wiki/Long_division\"\n\npackage com.thealgorithms.maths;\n\npublic class LongDivision {\npublic static int divide(int dividend, int divisor) {\n        long new_dividend_1 = dividend;\n        long new_divisor_1 = divisor;\n\n        if (dividend < 0) {\n            new_dividend_1 = new_dividend_1 * -1;\n        }\n        if (divisor < 0) {\n            new_divisor_1 = new_divisor_1 * -1;\n        }\n\n        if (dividend == 0 || new_dividend_1 < new_divisor_1) {\n            return 0;\n        }\n\n        StringBuilder answer = new StringBuilder();\n\n        String dividend_string = \"\" + new_dividend_1;\n        int last_index = 0;\n\n        String remainder = \"\";\n\n\n        for (int i = 0; i < dividend_string.length(); i++) {\n            String part_v1 = remainder + \"\" + dividend_string.substring(last_index, i + 1);\n            long part_1 = Long.parseLong(part_v1);\n            if (part_1 > new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == 0) {\n                answer.append(0);\n            } else if (part_1 < new_divisor_1) {\n                answer.append(0);\n            }\n            if (!(part_1 == 0)) {\n                remainder = String.valueOf(part_1);\n            }else{\n                remainder = \"\";\n            }\n\n            last_index++;\n        }\n\n        if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {\n            try {\n                return Integer.parseInt(answer.toString()) * (-1);\n            } catch (NumberFormatException e) {\n                return -2147483648;\n            }\n        }\n        try {\n            return Integer.parseInt(answer.toString());\n        } catch (NumberFormatException e) {\n            return 2147483647;\n        }\n\n    }\n}",
        "product_new_content": "//        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n//\n//        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, \n//        and -2.7335 would be truncated to -2.\n//        My method used Long Division, here is the source \"https://en.wikipedia.org/wiki/Long_division\"\n\npackage com.thealgorithms.maths;\n\npublic class LongDivision {\npublic static int divide(int dividend, int divisor) {\n        long new_dividend_1 = dividend;\n        long new_divisor_1 = divisor;\n\n        if(divisor == 0){\n            return 0;\n        }\n        if (dividend < 0) {\n            new_dividend_1 = new_dividend_1 * -1;\n        }\n        if (divisor < 0) {\n            new_divisor_1 = new_divisor_1 * -1;\n        }\n\n        if (dividend == 0 || new_dividend_1 < new_divisor_1) {\n            return 0;\n        }\n\n        StringBuilder answer = new StringBuilder();\n\n        String dividend_string = \"\" + new_dividend_1;\n        int last_index = 0;\n\n        String remainder = \"\";\n\n\n        for (int i = 0; i < dividend_string.length(); i++) {\n            String part_v1 = remainder + \"\" + dividend_string.substring(last_index, i + 1);\n            long part_1 = Long.parseLong(part_v1);\n            if (part_1 > new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == 0) {\n                answer.append(0);\n            } else if (part_1 < new_divisor_1) {\n                answer.append(0);\n            }\n            if (!(part_1 == 0)) {\n                remainder = String.valueOf(part_1);\n            }else{\n                remainder = \"\";\n            }\n\n            last_index++;\n        }\n\n        if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {\n            try {\n                return Integer.parseInt(answer.toString()) * (-1);\n            } catch (NumberFormatException e) {\n                return -2147483648;\n            }\n        }\n        try {\n            return Integer.parseInt(answer.toString());\n        } catch (NumberFormatException e) {\n            return 2147483647;\n        }\n\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LongDivisionTest {\n\t\n    @Test\n    void testOne() {\n        assertEquals(3, LongDivision.divide(10,3));\n    }\n  \n      @Test\n    void testTwo() {\n        assertEquals(-2, LongDivision.divide(7,-3));\n    }\n  \n  \n      @Test\n    void testThree() {\n        assertEquals(10, LongDivision.divide(105,10));\n    }\n\t\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LongDivisionTest {\n\n    // Requirement: Dividend (positive) is  greater than divisor (positive), returns correct integer after division\n    @Test\n    void testOne() {\n        assertEquals(3, LongDivision.divide(10,3));\n    }\n\n    // Requirement: Dividend (positive) is  greater than divisor (negative), returns correct integer after division\n    @Test\n    void testTwo() {\n        assertEquals(-2, LongDivision.divide(7,-3));\n    }\n  \n    // Requirement: Dividend (positive) is  greater than divisor (negative), returns correct integer after division\n    // Basically the same as in the first test\n    @Test\n    void testThree() {\n        assertEquals(10, LongDivision.divide(105,10));\n    }\n\n    // Requirement: Dividend (negative), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is less than 0.\n    @Test\n    void testNegativeDividend() {\n        assertEquals(-1, LongDivision.divide(-5,3));\n    }\n\t\n    // Requirement: Dividend (positive), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is less than the divisor. The test should return 0 in this case. \n    @Test\n    void testDividendLessThanDivisor() {\n        assertEquals(0, LongDivision.divide(3,5));\n    }\n\n    // Requirement: Dividend (neither), divisor (positive), returns correct integer after division\n    // Tests the case where the dividend is 0. This should return a 0.\n    @Test\n    void testDividendIsZero() {\n        assertEquals(0, LongDivision.divide(0,5));\n    }\n\n    // Requirement: Dividend (positive), divisor (neither), returns correct integer after division\n    // Tests the case where the divisor is 0. This should return a 0.\n    @Test\n    void testDivisionByZero() {\n        assertEquals(0, LongDivision.divide(5,0));  \n    }\n}"
    },
    {
        "product_commit": "87f9ebcb29bed03306cf300af242103615aeace1",
        "test_commit": "87f9ebcb29bed03306cf300af242103615aeace1",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FrizzyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FrizzyNumberTest.java",
        "product_old_content": null,
        "product_new_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find the FrizzyNumber*/\n\n\npackage com.thealgorithms.maths;\n\npublic class FrizzyNumber {\n\n    /**\n     * Returns the n-th number that is a sum of powers\n     * of the given base.\n     * Example: base = 3 and n = 4\n     * Ascending order of sums of powers of 3 =\n     * 3^0 = 1, 3^1 = 3, 3^1 + 3^0 = 4, 3^2 + 3^0 = 9\n     * Ans = 9\n     * \n     * @param base The base whose n-th sum of powers is required\n     * @param n    Index from ascending order of sum of powers of base\n     * @return n-th sum of powers of base\n     */\n    public static double getNthFrizzy(int base, int n) {\n        double final1 = 0.0;\n        int i = 0;\n        do\n        {\n            final1 += Math.pow(base, i++) * (n % 2);\n        } while ((n /= 2) > 0);\n        return final1;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class FrizzyNumberTest {\n    @Test\n    public void testFrizziesForBase2() {\n        assertEquals(\n                1,\n                FrizzyNumber.getNthFrizzy(2, 1));\n        assertEquals(\n                3,\n                FrizzyNumber.getNthFrizzy(2, 3));\n        assertEquals(\n                1000,\n                FrizzyNumber.getNthFrizzy(2, 1000));\n    }\n\n    @Test\n    public void testFrizziesForBase3() {\n        assertEquals(\n                1,\n                FrizzyNumber.getNthFrizzy(3, 1));\n        assertEquals(\n                3,\n                FrizzyNumber.getNthFrizzy(3, 2));\n        assertEquals(\n                29430,\n                FrizzyNumber.getNthFrizzy(3, 1000));\n    }\n\n    @Test\n    public void testFrizziesForBase69() {\n        assertEquals(\n                1,\n                FrizzyNumber.getNthFrizzy(69, 1));\n        assertEquals(\n                69,\n                FrizzyNumber.getNthFrizzy(69, 2));\n        assertEquals(\n                328510,\n                FrizzyNumber.getNthFrizzy(69, 9));\n        assertEquals(\n                333340,\n                FrizzyNumber.getNthFrizzy(69, 15));\n    }\n}"
    },
    {
        "product_commit": "f3613382aab6b15e50560a759c9b6e41038a6515",
        "test_commit": "f3613382aab6b15e50560a759c9b6e41038a6515",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/AllPathsFromSourceToTarget.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java",
        "product_old_content": null,
        "product_new_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find all possible paths from source to destination*/\n\n/**Wikipedia link -> https://en.wikipedia.org/wiki/Shortest_path_problem */\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\npublic class AllPathsFromSourceToTarget {\n\n    // No. of vertices in graph\n    private int v;\n\n    // To store the paths from source to destination\n    static List<List<Integer>> nm=new ArrayList<>();\n    // adjacency list\n    private ArrayList<Integer>[] adjList;\n\n    // Constructor\n    public AllPathsFromSourceToTarget(int vertices)\n    {\n\n        // initialise vertex count\n        this.v = vertices;\n\n        // initialise adjacency list\n        initAdjList();\n    }\n\n    // utility method to initialise adjacency list\n    private void initAdjList()\n    {\n        adjList = new ArrayList[v];\n\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n\n    // add edge from u to v\n    public void addEdge(int u, int v)\n    {\n        // Add v to u's list.\n        adjList[u].add(v);\n    }\n\n\n    public void storeAllPaths(int s, int d)\n    {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n\n        // add source to path[]\n        pathList.add(s);\n        // Call recursive utility\n        storeAllPathsUtil(s, d, isVisited, pathList);\n    }\n\n    // A recursive function to print all paths from 'u' to 'd'.\n    // isVisited[] keeps track of vertices in current path.\n    // localPathList<> stores actual vertices in the current path \n    private void storeAllPathsUtil(Integer u, Integer d, boolean[] isVisited, List<Integer> localPathList)\n    {\n\n        if (u.equals(d)) {\n            nm.add(new ArrayList<>(localPathList));\n            return;\n        }\n\n        // Mark the current node\n        isVisited[u] = true;\n\n        // Recursion for all the vertices adjacent to current vertex\n        \n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // store current node in path[]\n                localPathList.add(i);\n                storeAllPathsUtil(i, d, isVisited, localPathList);\n\n                // remove current node in path[]\n                localPathList.remove(i);\n            }\n        }\n\n        // Mark the current node\n        isVisited[u] = false;\n    }\n\n    // Driver program\n    public static List<List<Integer>> allPathsFromSourceToTarget(int vertices, int a[][], int source, int destination)\n    {\n        // Create a sample graph\n        AllPathsFromSourceToTarget g = new AllPathsFromSourceToTarget(vertices);\n        for(int i=0 ; i<a.length ; i++)\n        {\n            g.addEdge(a[i][0], a[i][1]);\n            // edges are added\n        }\n        g.storeAllPaths(source, destination);\n        // method call to store all possible paths\n        return nm;\n        // returns all possible paths from source to destination\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AllPathsFromSourceToTargetTest {\n\n    @Test\n    void testForFirstCase() {\n        int vertices = 4;\n        int a[][] = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3}};\n        int source = 2;\n        int destination = 3;\n        List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3),List.of(2, 0, 3),List.of(2, 1, 3));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForSecondCase() {\n        int vertices = 5;\n        int a[][] = {{0,1},{0,2},{0,3},{2,0},{2,1},{1,3},{1,4},{3,4},{2,4}};\n        int source = 0;\n        int destination = 4;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4),List.of(0, 1, 4),List.of(0, 2, 1, 3, 4),List.of(0, 2, 1, 4),List.of(0, 2, 4),List.of(0, 3, 4));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForThirdCase() {\n        int vertices = 6;\n        int a[][] = {{1,0},{2,3},{0,4},{1,5},{4,3},{0,2},{0,3},{1,2},{0,5},{3,4},{2,5},{2,4}};\n        int source = 1;\n        int destination = 5;\n        List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5),List.of(1, 0, 5),List.of(1, 5),List.of(1, 2, 5));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n\n    @Test\n    void testForFourthcase() {\n        int vertices = 3;\n        int a[][] = {{0,1},{0,2},{1,2}};\n        int source = 0;\n        int destination = 2;\n        List<List<Integer>> list2 = List.of(List.of(0, 1, 2),List.of(0, 2));\n        List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices,a,source,destination);\n        list2=list1;\n        assertIterableEquals(list1, list2);\n    }\n}"
    },
    {
        "product_commit": "3499c1bee6659db08f40abebc4e72d9bdfeec8f4",
        "test_commit": "3499c1bee6659db08f40abebc4e72d9bdfeec8f4",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/PostOrderTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/PostOrderTraversalTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.*;\n\n/**\n * Given tree is traversed in a 'post-order' way: LEFT -> RIGHT -> ROOT.\n * Below are given the recursive and iterative implementations.\n * <p>\n * Complexities:\n * Recursive: O(n) - time, O(n) - space, where 'n' is the number of nodes in a tree.\n * <p>\n * Iterative: O(n) - time, O(h) - space, where 'n' is the number of nodes in a tree\n * and 'h' is the height of a binary tree.\n * In the worst case 'h' can be O(n) if tree is completely unbalanced, for instance:\n * 5\n *  \\\n *   6\n *    \\\n *     7\n *      \\\n *       8\n *\n * @author Albina Gimaletdinova on 21/02/2023\n */\npublic class PostOrderTraversal {\n    public static List<Integer> recursivePostOrder(BinaryTree.Node root) {\n        List<Integer> result = new ArrayList<>();\n        recursivePostOrder(root, result);\n        return result;\n    }\n\n    public static List<Integer> iterativePostOrder(BinaryTree.Node root) {\n        LinkedList<Integer> result = new LinkedList<>();\n        if (root == null) {\n            return result;\n        }\n\n        Deque<BinaryTree.Node> stack = new ArrayDeque<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            BinaryTree.Node node = stack.pop();\n            result.addFirst(node.data);\n            if (node.left != null) {\n                stack.push(node.left);\n            }\n            if (node.right != null) {\n                stack.push(node.right);\n            }\n        }\n\n        return result;\n    }\n\n    private static void recursivePostOrder(BinaryTree.Node root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        recursivePostOrder(root.left, result);\n        recursivePostOrder(root.right, result);\n        result.add(root.data);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * Given tree is traversed in a 'post-order' way: LEFT -> RIGHT -> ROOT.\n *\n * @author Albina Gimaletdinova on 21/02/2023\n */\npublic class PostOrderTraversalTest {\n    @Test\n    public void testNullRoot() {\n        assertEquals(Collections.emptyList(), PostOrderTraversal.recursivePostOrder(null));\n        assertEquals(Collections.emptyList(), PostOrderTraversal.iterativePostOrder(null));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testPostOrder() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        List<Integer> expected = List.of(4, 5, 2, 6, 7, 3, 1);\n\n        assertEquals(expected, PostOrderTraversal.recursivePostOrder(root));\n        assertEquals(expected, PostOrderTraversal.iterativePostOrder(root));\n    }\n\n    /*\n         5\n          \\\n           6\n            \\\n             7\n              \\\n               8\n    */\n    @Test\n    public void testPostOrderNonBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{5, null, 6, null, 7, null, 8});\n        List<Integer> expected = List.of(8, 7, 6, 5);\n\n        assertEquals(expected, PostOrderTraversal.recursivePostOrder(root));\n        assertEquals(expected, PostOrderTraversal.iterativePostOrder(root));\n    }\n}"
    },
    {
        "product_commit": "b98dc2c5b5e9ba46017d4f6fd3a2458087903ea9",
        "test_commit": "b98dc2c5b5e9ba46017d4f6fd3a2458087903ea9",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMap.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/hashmap/hashing/LinearProbingHashMapTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport java.util.ArrayList;\n\n/***\n * This class is an implementation of a hash table using linear probing.\n * @see <a href=\"https://en.wikipedia.org/wiki/Linear_probing\">Linear Probing Hash Table</a>\n *\n * @param <Key> keys type.\n * @param <Value> values type.\n */\npublic class LinearProbingHashMap<Key extends Comparable<Key>, Value> extends Map<Key, Value> {\n    private int hsize; // size of the hash table\n    private Key[] keys;\n    private Value[] values;\n    private int size; // amount of elements in the hash table\n\n    public LinearProbingHashMap() {\n        this(16);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public LinearProbingHashMap(int size) {\n        this.hsize = size;\n        keys = (Key[]) new Comparable[size];\n        values = (Value[]) new Object[size];\n    }\n\n    @Override\n    public boolean put(Key key, Value value) {\n        if (key == null) {\n            return false;\n        }\n\n        if (size > hsize / 2) {\n            resize(2 * hsize);\n        }\n\n        int keyIndex = hash(key, hsize);\n        for (; keys[keyIndex] != null; keyIndex = increment(keyIndex)) {\n            if (key.equals(keys[keyIndex])) {\n                values[keyIndex] = value;\n                return true;\n            }\n        }\n\n        keys[keyIndex] = key;\n        values[keyIndex] = value;\n        size++;\n        return true;\n    }\n\n    @Override\n    public Value get(Key key) {\n        if (key == null) {\n            return null;\n        }\n\n        for (int i = hash(key, hsize); keys[i] != null; i = increment(i)) {\n            if (key.equals(keys[i])) {\n                return values[i];\n            }\n        }\n\n        return null;\n    }\n\n    @Override\n    public boolean delete(Key key) {\n        if (key == null || !contains(key)) {\n            return false;\n        }\n\n        int i = hash(key, hsize);\n        while (!key.equals(keys[i])) {\n            i = increment(i);\n        }\n\n        keys[i] = null;\n        values[i] = null;\n\n        i = increment(i);\n        while (keys[i] != null) {\n            // delete keys[i] an vals[i] and reinsert\n            Key keyToRehash = keys[i];\n            Value valToRehash = values[i];\n            keys[i] = null;\n            values[i] = null;\n            size--;\n            put(keyToRehash, valToRehash);\n            i = increment(i);\n        }\n\n        size--;\n        if (size > 0 && size <= hsize / 8) {\n            resize(hsize / 2);\n        }\n\n        return true;\n    }\n\n    @Override\n    public boolean contains(Key key) {\n        return get(key) != null;\n    }\n\n    @Override\n    int size() {\n        return size;\n    }\n\n    @Override\n    Iterable<Key> keys() {\n        ArrayList<Key> listOfKeys = new ArrayList<>(size);\n        for (int i = 0; i < hsize; i++) {\n            if (keys[i] != null) {\n                listOfKeys.add(keys[i]);\n            }\n        }\n\n        listOfKeys.sort(Comparable::compareTo);\n        return listOfKeys;\n    }\n\n    private int increment(int i) {\n        return (i + 1) % hsize;\n    }\n\n    private void resize(int newSize) {\n        LinearProbingHashMap<Key, Value> tmp = new LinearProbingHashMap<>(newSize);\n        for (int i = 0; i < hsize; i++) {\n            if (keys[i] != null) {\n                tmp.put(keys[i], values[i]);\n            }\n        }\n\n        this.keys = tmp.keys;\n        this.values = tmp.values;\n        this.hsize = newSize;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nclass LinearProbingHashMapTest extends MapTest {\n    @Override\n    <Key extends Comparable<Key>, Value> Map<Key, Value> getMap() {\n        return new LinearProbingHashMap<>();\n    }\n}"
    },
    {
        "product_commit": "45923d68726e111fd1663ca7975c09b764cdbd34",
        "test_commit": "45923d68726e111fd1663ca7975c09b764cdbd34",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/InorderTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/InorderTraversalTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\n/**\n * Given tree is traversed in an 'inorder' way: LEFT -> ROOT -> RIGHT.\n * Below are given the recursive and iterative implementations.\n *\n * Complexities:\n * Recursive: O(n) - time, O(n) - space, where 'n' is the number of nodes in a tree.\n *\n * Iterative: O(n) - time, O(h) - space, where 'n' is the number of nodes in a tree\n * and 'h' is the height of a binary tree.\n * In the worst case 'h' can be O(n) if tree is completely unbalanced, for instance:\n * 5\n *  \\\n *   6\n *    \\\n *     7\n *      \\\n *       8\n *\n * @author Albina Gimaletdinova on 21/02/2023\n */\npublic class InorderTraversal {\n    public static List<Integer> recursiveInorder(BinaryTree.Node root) {\n        List<Integer> result = new ArrayList<>();\n        recursiveInorder(root, result);\n        return result;\n    }\n\n    public static List<Integer> iterativeInorder(BinaryTree.Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Deque<BinaryTree.Node> stack = new ArrayDeque<>();\n        while (!stack.isEmpty() || root != null) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            result.add(root.data);\n            root = root.right;\n        }\n        return result;\n    }\n\n    private static void recursiveInorder(BinaryTree.Node root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        recursiveInorder(root.left, result);\n        result.add(root.data);\n        recursiveInorder(root.right, result);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 21/02/2023\n */\npublic class InorderTraversalTest {\n    @Test\n    public void testNullRoot() {\n        assertEquals(Collections.emptyList(), InorderTraversal.recursiveInorder(null));\n        assertEquals(Collections.emptyList(), InorderTraversal.iterativeInorder(null));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testRecursiveInorder() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        List<Integer> expected = List.of(4, 2, 5, 1, 6, 3, 7);\n\n        assertEquals(expected, InorderTraversal.recursiveInorder(root));\n        assertEquals(expected, InorderTraversal.iterativeInorder(root));\n    }\n\n    /*\n         5\n          \\\n           6\n            \\\n             7\n              \\\n               8\n    */\n    @Test\n    public void testRecursiveInorderNonBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{5, null, 6, null, 7, null, 8});\n        List<Integer> expected = List.of(5, 6, 7, 8);\n\n        assertEquals(expected, InorderTraversal.recursiveInorder(root));\n        assertEquals(expected, InorderTraversal.iterativeInorder(root));\n    }\n}"
    },
    {
        "product_commit": "6d13d95e416e2dfb4c08d3e5b823e26c9f10266d",
        "test_commit": "6d13d95e416e2dfb4c08d3e5b823e26c9f10266d",
        "product_file_path": "src/main/java/com/thealgorithms/geometry/GrahamScan.java",
        "test_file_path": "src/test/java/com/thealgorithms/geometry/GrahamScanTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.geometry;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Stack;\n\n/*\n * A Java program that computes the convex hull using the Graham Scan algorithm\n * In the best case, time complexity is O(n), while in the worst case, it is log(n).\n * O(n) space complexity\n *\n * This algorithm is only applicable to integral coordinates.\n *\n * Reference:\n * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_algorithm.cpp\n * https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/graham_scan_functions.hpp\n * https://algs4.cs.princeton.edu/99hull/GrahamScan.java.html\n */\npublic class GrahamScan {\n    private final Stack<Point> hull = new Stack<>();\n\n    public GrahamScan(Point[] points) {\n\n        /*\n         * pre-process the points by sorting them with respect to the bottom-most point, then we'll push the\n         * first point in the array to be our first extreme point.\n         */\n        Arrays.sort(points);\n        Arrays.sort(points, 1, points.length, points[0].polarOrder());\n        hull.push(points[0]);\n\n        // find index of first point not equal to a[0] (indexPoint1) and the first point that's not\n        // collinear with either (indexPoint2).\n        int indexPoint1;\n        for (indexPoint1 = 1; indexPoint1 < points.length; indexPoint1++)\n            if (!points[0].equals(points[indexPoint1])) break;\n        if (indexPoint1 == points.length) return;\n\n        int indexPoint2;\n        for (indexPoint2 = indexPoint1+1; indexPoint2 < points.length; indexPoint2++)\n            if (Point.orientation(points[0], points[indexPoint1], points[indexPoint2]) != 0) break;\n        hull.push(points[indexPoint2-1]);\n\n        // Now we simply add the point to the stack based on the orientation.\n        for (int i = indexPoint2; i < points.length; i++) {\n            Point top = hull.pop();\n            while (Point.orientation(hull.peek(), top, points[i]) <= 0) {\n                top = hull.pop();\n            }\n            hull.push(top);\n            hull.push(points[i]);\n        }\n    }\n\n    /**\n     * @return A stack of points representing the convex hull.\n     */\n    public Iterable<Point> hull() {\n        Stack<Point> s = new Stack<>();\n        for (Point p : hull) s.push(p);\n        return s;\n    }\n\n    public record Point(int x, int y) implements Comparable<Point> {\n\n        /**\n         * Default constructor\n         * @param x x-coordinate\n         * @param y y-coordinate\n         */\n        public Point { }\n\n            /**\n             * @return the x-coordinate\n             */\n            @Override\n            public int x() {\n                return x;\n            }\n\n            /**\n             * @return the y-coordinate\n             */\n            @Override\n            public int y() { return y; }\n\n            /**\n             * Finds the orientation of ordered triplet.\n             *\n             * @param a Co-ordinates of point a <int, int>\n             * @param b Co-ordinates of point a <int, int>\n             * @param c Co-ordinates of point a <int, int>\n             * @return { -1, 0, +1 } if a -\u2192 b -\u2192 c is a { clockwise, collinear; counterclockwise } turn.\n             */\n            public static int orientation(Point a, Point b, Point c) {\n                int val = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n                if (val == 0) {\n                    return 0;\n                }\n                return (val > 0) ? +1 : -1;\n            }\n\n            /**\n             * @param p2 Co-ordinate of point to compare to.\n             * This function will compare the points and will return a positive integer it the\n             * point is greater than the argument point and a negative integer if the point is\n             * less than the argument point.\n             */\n            public int compareTo(Point p2) {\n                if (this.y < p2.y) return -1;\n                if (this.y > p2.y) return +1;\n                if (this.x < p2.x) return -1;\n                if (this.x > p2.x) return +1;\n                return 0;\n            }\n\n            /**\n             * A helper function that will let us sort points by their polar order\n             * This function will compare the angle between 2 polar Co-ordinates\n             *\n             * @return the comparator\n             */\n            public Comparator<Point> polarOrder() {\n                return new PolarOrder();\n            }\n\n            private class PolarOrder implements Comparator<Point> {\n                public int compare(Point p1, Point p2) {\n                    int dx1 = p1.x - x;\n                    int dy1 = p1.y - y;\n                    int dx2 = p2.x - x;\n                    int dy2 = p2.y - y;\n\n                    if (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below\n                    else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above\n                    else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal\n                        if (dx1 >= 0 && dx2 < 0) return -1;\n                        else if (dx2 >= 0 && dx1 < 0) return +1;\n                        else return 0;\n                    } else return -orientation(Point.this, p1, p2);     // both above or below\n                }\n            }\n\n            /**\n             * Override of the toString method, necessary to compute the difference\n             * between the expected result and the derived result\n             *\n             * @return a string representation of any given 2D point in the format (x, y)\n             */\n            @Override\n            public String toString() {\n                return \"(\" + x + \", \" + y + \")\";\n            }\n        }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.geometry;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class GrahamScanTest {\n    @Test\n    void testGrahamScan() {\n        GrahamScan.Point[] points = {new GrahamScan.Point(0, 3), new GrahamScan.Point(1, 1),\n                new GrahamScan.Point(2, 2), new GrahamScan.Point(4, 4),\n                new GrahamScan.Point(0, 0), new GrahamScan.Point(1, 2),\n                new GrahamScan.Point(3, 1), new GrahamScan.Point(3, 3)};\n        String expectedResult = \"[(0, 0), (3, 1), (4, 4), (0, 3)]\";\n\n        GrahamScan graham = new GrahamScan(points);\n        assertEquals(expectedResult, graham.hull().toString());\n    }\n}"
    },
    {
        "product_commit": "6b9eb1b9c1eddd1615a1d00d99d3e1c7f77fdbac",
        "test_commit": "6b9eb1b9c1eddd1615a1d00d99d3e1c7f77fdbac",
        "product_file_path": "src/main/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearchTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\nimport java.util.*;\npublic class sortOrderAgnosticBinarySearch {\n    public static int find(int arr[],int key){\n        int start = 0;\n        int end = arr.length-1;\n        boolean arrDescending = arr[start]>arr[end];  //checking for Array is in ascending order or descending order.\n        while(start<=end){\n            int mid = end-start/2;\n            if (arr[mid]==key){\n                return mid;\n            }\n            if(arrDescending){       // boolean is true then our array is in descending order \n                if(key<arr[mid]){\n                    start=mid+1;\n                }\n                else{\n                    end=mid-1;\n                }\n            }\n            else {         // otherwise our array is in ascending order \n                if(key>arr[mid]){\n                   start=mid+1;\n               }\n               else{\n                   end=mid-1;\n               }\n            }\n        }\n        return -1;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int arr[] = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int arr[] = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}"
    },
    {
        "product_commit": "3c0d94292cdb94c1719bf8d93398233f2797df03",
        "test_commit": "3c0d94292cdb94c1719bf8d93398233f2797df03",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/IntrospectiveSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/IntrospectiveSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * Introspective Sort Algorithm Implementation\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Introsort\">IntroSort Algorithm</a>\n */\npublic class IntrospectiveSort implements SortAlgorithm {\n\n    private static final int INSERTION_SORT_THRESHOLD = 16;\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] a) {\n        int n = a.length;\n        introSort(a, 0, n - 1, 2 * (int) (Math.log(n) / Math.log(2)));\n        return a;\n    }\n\n    private static <T extends Comparable<T>> void swap(T[] a, int i, int j) {\n        T temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    private static <T extends Comparable<T>> void introSort(T[] a, int low, int high, int depth) {\n        while (high - low > INSERTION_SORT_THRESHOLD) {\n            if (depth == 0) {\n                heapSort(a, low, high);\n                return;\n            }\n            int pivotIndex = partition(a, low, high);\n            introSort(a, pivotIndex + 1, high, depth - 1);\n            high = pivotIndex - 1;\n        }\n        insertionSort(a, low, high);\n    }\n\n    private static <T extends Comparable<T>> int partition(T[] a, int low, int high) {\n        int pivotIndex = low + (int) (Math.random() * (high - low + 1));\n        swap(a, pivotIndex, high);\n        T pivot = a[high];\n        int i = low - 1;\n        for (int j = low; j <= high - 1; j++) {\n            if (a[j].compareTo(pivot) <= 0) {\n                i++;\n                swap(a, i, j);\n            }\n        }\n        swap(a, i + 1, high);\n        return i + 1;\n    }\n\n    private static <T extends Comparable<T>> void insertionSort(T[] a, int low, int high) {\n        for (int i = low + 1; i <= high; i++) {\n            T key = a[i];\n            int j = i - 1;\n            while (j >= low && a[j].compareTo(key) > 0) {\n                a[j + 1] = a[j];\n                j--;\n            }\n            a[j + 1] = key;\n        }\n    }\n\n    private static <T extends Comparable<T>> void heapSort(T[] a, int low, int high) {\n        for (int i = (high + low - 1) / 2; i >= low; i--) {\n            heapify(a, i, high - low + 1, low);\n        }\n        for (int i = high; i > low; i--) {\n            swap(a, low, i);\n            heapify(a, low, i - low, low);\n        }\n    }\n\n    private static <T extends Comparable<T>> void heapify(T[] a, int i, int n, int low) {\n        int left = 2 * i - low + 1;\n        int right = 2 * i - low + 2;\n        int largest = i;\n        if (left < n && a[left].compareTo(a[largest]) > 0) {\n            largest = left;\n        }\n        if (right < n && a[right].compareTo(a[largest]) > 0) {\n            largest = right;\n        }\n        if (largest != i) {\n            swap(a, i, largest);\n            heapify(a, largest, n, low);\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class IntrospectiveSortTest {\n    @Test\n    // valid test case\n    public void StrandSortNonDuplicateTest() {\n        Integer[] expectedArray = {1, 2, 3, 4, 5};\n        Integer[] actualList = new IntrospectiveSort().sort(expectedArray);\n        assertArrayEquals(expectedArray, actualList);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortDuplicateTest() {\n        Integer[] expectedArray = {2, 2, 2, 5, 7};\n        Integer[] actualList = new IntrospectiveSort().sort(expectedArray);\n        assertArrayEquals(expectedArray, actualList);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortEmptyTest() {\n        Integer[] expectedArray = {};\n        Integer[] actualList = new IntrospectiveSort().sort(expectedArray);\n        assertArrayEquals(expectedArray, actualList);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortNullTest() {\n        Integer[] expectedArray = null;\n        assertThrows(NullPointerException.class, () -> {\n            new IntrospectiveSort().sort(expectedArray);\n        });\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortNegativeTest() {\n        Integer[] expectedArray = {-1, -2, -3, -4, -5};\n        Integer[] actualList = new IntrospectiveSort().sort(expectedArray);\n        assertArrayEquals(expectedArray, actualList);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortNegativeAndPositiveTest() {\n        Integer[] expectedArray = {-1, -2, -3, 4, 5};\n        Integer[] actualList = new IntrospectiveSort().sort(expectedArray);\n        assertArrayEquals(expectedArray, actualList);\n    }\n\n    @Test\n    // valid test case\n    public void allSameTest() {\n        Integer[] expectedArray = {1, 1, 1, 1, 1};\n        Integer[] actualList = new IntrospectiveSort().sort(expectedArray);\n        assertArrayEquals(expectedArray, actualList);\n    }\n}"
    },
    {
        "product_commit": "541f490d1eef4a1b9ff5e269116c77324f4ce098",
        "test_commit": "541f490d1eef4a1b9ff5e269116c77324f4ce098",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/ValidBSTOrNot.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/ValidBSTOrNotTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\npublic class ValidBSTOrNot {\n\n    class Node {\n\n        int data;\n        Node left, right;\n\n        public Node(int item) {\n            data = item;\n            left = right = null;\n        }\n    }\n\n    // Root of the Binary Tree\n\n    /* can give min and max value according to your code or\n  can write a function to find min and max value of tree. */\n\n    /* returns true if given search tree is binary\n  search tree (efficient version) */\n    boolean isBST(Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    /* Returns true if the given tree is a BST and its\n  values are >= min and <= max. */\n    boolean isBSTUtil(Node node, int min, int max) {\n        /* an empty tree is BST */\n        if (node == null) {\n            return true;\n        }\n\n        /* false if this node violates the min/max constraints */\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        /* otherwise check the subtrees recursively\n    tightening the min/max constraints */\n        // Allow only distinct values\n        return (\n            isBSTUtil(node.left, min, node.data - 1) &&\n            isBSTUtil(node.right, node.data + 1, max)\n        );\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\n/**\n * This code recursively validates whether given Binary Search Tree (BST) is balanced or not.\n * Trees with only distinct values are supported.\n * Key points:\n * 1. According to the definition of a BST, each node in a tree must be in range [min, max],\n *    where 'min' and 'max' values represent the child nodes (left, right).\n * 2. The smallest possible node value is Integer.MIN_VALUE, the biggest - Integer.MAX_VALUE.\n */\npublic class ValidBSTOrNot {\n    public static boolean isBST(BinaryTree.Node root) {\n        return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private static boolean isBSTUtil(BinaryTree.Node node, int min, int max) {\n        // empty tree is a BST\n        if (node == null) {\n            return true;\n        }\n\n        if (node.data < min || node.data > max) {\n            return false;\n        }\n\n        return (\n            isBSTUtil(node.left, min, node.data - 1) &&\n            isBSTUtil(node.right, node.data + 1, max)\n        );\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class ValidBSTOrNotTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(ValidBSTOrNot.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{Integer.MIN_VALUE});\n        assertTrue(ValidBSTOrNot.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 20});\n        assertTrue(ValidBSTOrNot.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 13});\n        assertFalse(ValidBSTOrNot.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 12});\n        assertFalse(ValidBSTOrNot.isBST(root));\n    }\n}"
    },
    {
        "product_commit": "d565edc69abbd5ac44e80cabed36f7d4f2a158d5",
        "test_commit": "d565edc69abbd5ac44e80cabed36f7d4f2a158d5",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/PreOrderTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/PreOrderTraversalTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Given tree is traversed in a 'pre-order' way: ROOT -> LEFT -> RIGHT.\n * Below are given the recursive and iterative implementations.\n *\n * Complexities:\n * Recursive: O(n) - time, O(n) - space, where 'n' is the number of nodes in a tree.\n *\n * Iterative: O(n) - time, O(h) - space, where 'n' is the number of nodes in a tree\n * and 'h' is the height of a binary tree.\n * In the worst case 'h' can be O(n) if tree is completely unbalanced, for instance:\n * 5\n *  \\\n *   6\n *    \\\n *     7\n *      \\\n *       8\n *\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class PreOrderTraversal {\n    public static List<Integer> recursivePreOrder(BinaryTree.Node root) {\n        List<Integer> result = new ArrayList<>();\n        recursivePreOrder(root, result);\n        return result;\n    }\n\n    public static List<Integer> iterativePreOrder(BinaryTree.Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Deque<BinaryTree.Node> stack = new LinkedList<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            BinaryTree.Node node = stack.pop();\n            result.add(node.data);\n            if (node.right != null) stack.push(node.right);\n            if (node.left != null) stack.push(node.left);\n        }\n\n        return result;\n    }\n\n    private static void recursivePreOrder(BinaryTree.Node root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        result.add(root.data);\n        recursivePreOrder(root.left, result);\n        recursivePreOrder(root.right, result);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class PreOrderTraversalTest {\n    @Test\n    public void testNullRoot() {\n        assertEquals(Collections.emptyList(), PreOrderTraversal.recursivePreOrder(null));\n        assertEquals(Collections.emptyList(), PreOrderTraversal.iterativePreOrder(null));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testRecursivePreOrder() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(1, 2, 4, 5, 3, 6, 7), PreOrderTraversal.recursivePreOrder(root));\n        assertEquals(List.of(1, 2, 4, 5, 3, 6, 7), PreOrderTraversal.iterativePreOrder(root));\n    }\n\n    /*\n         5\n          \\\n           6\n            \\\n             7\n              \\\n               8\n    */\n    @Test\n    public void testRecursivePreOrderNonBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{5, null, 6, null, 7, null, 8});\n        assertEquals(List.of(5, 6, 7, 8), PreOrderTraversal.recursivePreOrder(root));\n        assertEquals(List.of(5, 6, 7, 8), PreOrderTraversal.iterativePreOrder(root));\n    }\n}"
    },
    {
        "product_commit": "e0b1235befa3f1b846c6b1c52f9f9fcced96020f",
        "test_commit": "e0b1235befa3f1b846c6b1c52f9f9fcced96020f",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/LevenshteinDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/LevenshteinDistanceTests.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * @author Kshitij VERMA (github.com/kv19971) LEVENSHTEIN DISTANCE dyamic\n * programming implementation to show the difference between two strings\n * (https://en.wikipedia.org/wiki/Levenshtein_distance)\n */\npublic class LevenshteinDistance {\n\n    private static int minimum(int a, int b, int c) {\n        if (a < b && a < c) {\n            return a;\n        } else if (b < a && b < c) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n\n    private static int calculate_distance(String a, String b) {\n        int len_a = a.length() + 1;\n        int len_b = b.length() + 1;\n        int[][] distance_mat = new int[len_a][len_b];\n        for (int i = 0; i < len_a; i++) {\n            distance_mat[i][0] = i;\n        }\n        for (int j = 0; j < len_b; j++) {\n            distance_mat[0][j] = j;\n        }\n        for (int i = 0; i < len_a; i++) {\n            for (int j = 0; j < len_b; j++) {\n                int cost;\n                if (a.charAt(i) == b.charAt(j)) {\n                    cost = 0;\n                } else {\n                    cost = 1;\n                }\n                distance_mat[i][j] =\n                    minimum(\n                        distance_mat[i - 1][j],\n                        distance_mat[i - 1][j - 1],\n                        distance_mat[i][j - 1]\n                    ) +\n                    cost;\n            }\n        }\n        return distance_mat[len_a - 1][len_b - 1];\n    }\n\n    public static void main(String[] args) {\n        String a = \"\"; // enter your string here\n        String b = \"\"; // enter your string here\n\n        System.out.print(\n            \"Levenshtein distance between \" + a + \" and \" + b + \" is: \"\n        );\n        System.out.println(calculate_distance(a, b));\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * @author Kshitij VERMA (github.com/kv19971) LEVENSHTEIN DISTANCE dyamic\n * programming implementation to show the difference between two strings\n * (https://en.wikipedia.org/wiki/Levenshtein_distance)\n */\npublic class LevenshteinDistance {\n\n    private static int minimum(int a, int b, int c) {\n        if (a < b && a < c) {\n            return a;\n        } else if (b < a && b < c) {\n            return b;\n        } else {\n            return c;\n        }\n    }\n\n    public static int calculateLevenshteinDistance(String str1, String str2) {\n        int len1 = str1.length() + 1;\n        int len2 = str2.length() + 1;\n        int[][] distanceMat = new int[len1][len2];\n        for (int i = 0; i < len1; i++) {\n            distanceMat[i][0] = i;\n        }\n        for (int j = 0; j < len2; j++) {\n            distanceMat[0][j] = j;\n        }\n        for (int i = 1; i < len1; i++) {\n            for (int j = 1; j < len2; j++) {\n                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    distanceMat[i][j] = distanceMat[i - 1][j - 1];\n                } else {\n                    distanceMat[i][j] =\n                            1 + minimum(\n                                    distanceMat[i - 1][j],\n                                    distanceMat[i - 1][j - 1],\n                                    distanceMat[i][j - 1]\n                            );\n                }\n            }\n        }\n        return distanceMat[len1 - 1][len2 - 1];\n    }\n\n    public static void main(String[] args) {\n        String str1 = \"\"; // enter your string here\n        String str2 = \"\"; // enter your string here\n\n        System.out.print(\n                \"Levenshtein distance between \" + str1 + \" and \" + str2 + \" is: \"\n        );\n        System.out.println(calculateLevenshteinDistance(str1, str2));\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class LevenshteinDistanceTests {\n\n    @ParameterizedTest\n    @CsvSource({\"dog,cat,3\", \"sunday,saturday,3\", \"cat,cats,1\", \"rain,train,1\"})\n    void levenshteinDistanceTest(String str1, String str2, int distance) {\n        int result = LevenshteinDistance.calculateLevenshteinDistance(str1, str2);\n        assertEquals(distance, result);\n    }\n\n}"
    },
    {
        "product_commit": "69a428470cad55a484efa078c49efc49d412bccd",
        "test_commit": "69a428470cad55a484efa078c49efc49d412bccd",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithm.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/TarjansAlgorithmTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * Java program that implements Tarjan's Algorithm.\n * @author Shivanagouda S A (https://github.com/shivu2002a)\n * \n */\n\n/**\n * Tarjan's algorithm is a linear time algorithm to find the strongly connected components of a \n   directed graph, which, from here onwards will be referred as SCC. \n    \n * A graph is said to be strongly connected if every vertex is reachable from every other vertex. \n   The SCCs of a directed graph form a partition into subgraphs that are themselves strongly connected.\n   Single node is always a SCC.\n\n * Example:\n    0 --------> 1 -------> 3 --------> 4\n    ^          /\n    |         /\n    |        /\n    |       /\n    |      /\n    |     /\n    |    /\n    |   /\n    |  /\n    | /\n    |V\n    2\n\n    For the above graph, the SCC list goes as follows:\n    1, 2, 0\n    3\n    4\n    \n    We can also see that order of the nodes in an SCC doesn't matter since they are in cycle.\n\n {@summary}\n    Tarjan's Algorithm: \n    * DFS search produces a DFS tree \n    * Strongly Connected Components form subtrees of the DFS tree. \n    * If we can find the head of these subtrees, we can get all the nodes in that subtree (including the head)\n      and that will be one SCC. \n    * There is no back edge from one SCC to another (here can be cross edges, but they will not be used).\n\n    * Kosaraju Algorithm aims at doing the same but uses two DFS traversalse whereas Tarjan\u2019s algorithm does \n      the same in a single DFS, which leads to much lower constant factors in the latter.\n\n */\npublic class TarjansAlgorithm {\n\n    //Timer for tracking lowtime and insertion time\n    private int Time;\n\n    private List<List<Integer>> SCClist = new ArrayList<List<Integer>>();\n\n    public List<List<Integer>> stronglyConnectedComponents(int V, List<List<Integer>> graph) {\n\n        // Initially all vertices as unvisited, insertion and low time are undefined\n\n        // insertionTime:Time when a node is visited 1st time while DFS traversal\n\n        // lowTime: indicates the earliest visited vertex (the vertex with minimum insertion time) that can \n        // be reached from a subtree rooted with a particular node.\n        int lowTime[] = new int[V];\n        int insertionTime[] = new int[V];\n        for (int i = 0; i < V; i++) {\n            insertionTime[i] = -1;\n            lowTime[i] = -1;\n        }\n        \n        // To check if element is present in stack\n        boolean isInStack[] = new boolean[V];\n\n        // Store nodes during DFS\n        Stack<Integer> st = new Stack<Integer>();\n\n        for (int i = 0; i < V; i++) {\n            if (insertionTime[i] == -1)\n                stronglyConnCompsUtil(i, lowTime, insertionTime, isInStack, st, graph);\n        }\n\n        return SCClist;\n    }\n\n    private void stronglyConnCompsUtil(int u, int lowTime[], int insertionTime[],\n            boolean isInStack[], Stack<Integer> st, List<List<Integer>> graph) {\n\n        // Initialize insertion time and lowTime value of current node\n        insertionTime[u] = Time;\n        lowTime[u] = Time;\n        Time += 1;\n\n        //Push current node into stack\n        isInStack[u] = true;\n        st.push(u);\n\n        int n;\n\n        // Go through all vertices adjacent to this\n        Iterator<Integer> i = graph.get(u).iterator();\n\n        while (i.hasNext()) {\n            n = i.next();\n\n            //If the adjacent node is unvisited, do DFS\n            if (insertionTime[n] == -1) {\n                stronglyConnCompsUtil(n, lowTime, insertionTime, isInStack, st, graph);\n                //update lowTime for the current node comparing lowtime of adj node\n                lowTime[u] = Math.min(lowTime[u], lowTime[n]);\n            } else if (isInStack[n] == true) {\n                //If adj node is in stack, update low \n                lowTime[u] = Math.min(lowTime[u], insertionTime[n]);\n            }\n        }\n        //If lowtime and insertion time are same, current node is the head of an SCC\n        // head node found, get all the nodes in this SCC\n        if (lowTime[u] == insertionTime[u]) {\n            int w = -1;\n            var scc = new ArrayList<Integer>();\n\n            //Stack has all the nodes of the current SCC\n            while (w != u) {\n                w = st.pop();\n                scc.add(w);\n                isInStack[w] = false;\n            }\n            SCClist.add(scc);\n        }\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class TarjansAlgorithmTest {\n    \n    TarjansAlgorithm tarjansAlgo = new TarjansAlgorithm();\n\n    @Test\n    public void findStronglyConnectedComps(){\n        var v = 5;\n        var graph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < v; i++) {\n            graph.add(new ArrayList<>());\n        }\n        graph.get(0).add(1);\n        graph.get(1).add(2);\n        graph.get(2).add(0);\n        graph.get(1).add(3);\n        graph.get(3).add(4);\n\n        var actualResult = tarjansAlgo.stronglyConnectedComponents(v, graph);\n        /*\n            Expected result: \n            0, 1, 2\n            3\n            4 \n        */\n        List<List<Integer>> expectedResult = new ArrayList<>();\n\n        expectedResult.add(Arrays.asList(4));\n        expectedResult.add(Arrays.asList(3));\n        expectedResult.add(Arrays.asList(2, 1, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n    @Test\n    public void findStronglyConnectedCompsShouldGetSingleNodes() {\n        //Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(5).add(6);\n        adjList.get(6).add(7);\n        adjList.get(7).add(0);\n\n        List<List<Integer>> actualResult = tarjansAlgo.stronglyConnectedComponents(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result: \n            7, 6, 5, 4, 3, 2, 1, 0\n        */\n        expectedResult.add(Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n    \n}"
    },
    {
        "product_commit": "a584ca248cd4433796910cbb1f531896dee4d54e",
        "test_commit": "a584ca248cd4433796910cbb1f531896dee4d54e",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/LevelOrderTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/LevelOrderTraversalTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\npublic class LevelOrderTraversal {\n\n    class Node {\n\n        int data;\n        Node left, right;\n\n        public Node(int item) {\n            data = item;\n            left = right = null;\n        }\n    }\n\n    // Root of the Binary Tree\n    Node root;\n\n    public LevelOrderTraversal(Node root) {\n        this.root = root;\n    }\n\n    /* function to print level order traversal of tree*/\n    void printLevelOrder() {\n        int h = height(root);\n        int i;\n        for (i = 1; i <= h; i++) {\n            printGivenLevel(root, i);\n        }\n    }\n\n    /* Compute the \"height\" of a tree -- the number of\n  nodes along the longest path from the root node\n  down to the farthest leaf node.*/\n    int height(Node root) {\n        if (root == null) {\n            return 0;\n        } else {\n            /**\n             * Return the height of larger subtree\n             */\n            return Math.max(height(root.left), height(root.right)) + 1;\n        }\n    }\n\n    /* Print nodes at the given level */\n    void printGivenLevel(Node root, int level) {\n        if (root == null) {\n            return;\n        }\n        if (level == 1) {\n            System.out.print(root.data + \" \");\n        } else if (level > 1) {\n            printGivenLevel(root.left, level - 1);\n            printGivenLevel(root.right, level - 1);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class LevelOrderTraversal {\n\n    static List<List<Integer>> traverse(BinaryTree.Node root) {\n        if (root == null) {\n            return List.of();\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        Queue<BinaryTree.Node> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            int nodesOnLevel = q.size();\n            List<Integer> level = new LinkedList<>();\n            for (int i = 0; i < nodesOnLevel; i++) {\n                BinaryTree.Node tempNode = q.poll();\n                level.add(tempNode.data);\n\n                if (tempNode.left != null) {\n                    q.add(tempNode.left);\n                }\n\n                if (tempNode.right != null) {\n                    q.add(tempNode.right);\n                }\n            }\n            result.add(level);\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 08/02/2023\n */\npublic class LevelOrderTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), LevelOrderTraversal.traverse(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{50});\n        assertEquals(List.of(List.of(50)), LevelOrderTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testLevelOrderTraversalCompleteTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(List.of(1), List.of(2, 3), List.of(4, 5, 6, 7)), LevelOrderTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n        /  \\\n       8    9\n    */\n    @Test\n    public void testLevelOrderTraversalDifferentHeight() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(\n                new Integer[]{1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9});\n        assertEquals(List.of(List.of(1), List.of(2, 3), List.of(4, 5, 6, 7), List.of(8, 9)),\n                LevelOrderTraversal.traverse(root));\n    }\n}"
    },
    {
        "product_commit": "a584ca248cd4433796910cbb1f531896dee4d54e",
        "test_commit": "a584ca248cd4433796910cbb1f531896dee4d54e",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/ZigzagTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/ZigzagTraversalTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.*;\n\n/**\n * Given a binary tree.\n * This code returns the zigzag level order traversal of its nodes' values.\n * Binary tree:\n *                               7\n *                   /                         \\\n *                6                           3\n *         /                \\             /             \\\n *      2                    4         10                19\n * Zigzag traversal:\n * [[7], [3, 6], [2, 4, 10, 19]]\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm using a queue.\n * 1. The algorithm starts with a root node. This node is added to a queue.\n * 2. While the queue is not empty:\n *  - each time we enter the while-loop we get queue size. Queue size refers to the number of nodes at the current level.\n *  - we traverse all the level nodes in 2 ways: from left to right OR from right to left\n *    (this state is stored on `prevLevelFromLeftToRight` variable)\n *  - if the current node has children we add them to a queue\n *  - add level with nodes to a result.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree\n * O(N) - space, where N is the number of nodes in a binary tree\n *\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversal {\n    public static List<List<Integer>> traverse(BinaryTree.Node root) {\n        if (root == null) {\n            return new ArrayList<>();\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        // create a queue\n        Deque<BinaryTree.Node> q = new ArrayDeque<>();\n        q.offer(root);\n        // start with writing nodes from left to right\n        boolean prevLevelFromLeftToRight = false;\n\n        while (!q.isEmpty()) {\n            int nodesOnLevel = q.size();\n            List<Integer> level = new LinkedList<>();\n            // traverse all the level nodes\n            for (int i = 0; i < nodesOnLevel; i++) {\n                BinaryTree.Node node = q.poll();\n                if (prevLevelFromLeftToRight) {\n                    level.add(0, node.data);\n                } else {\n                    level.add(node.data);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            // the next level node traversal will be from the other side\n            prevLevelFromLeftToRight = !prevLevelFromLeftToRight;\n            result.add(level);\n        }\n        return result;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.*;\n\n/**\n * Given a binary tree.\n * This code returns the zigzag level order traversal of its nodes' values.\n * Binary tree:\n *                               7\n *                   /                         \\\n *                6                           3\n *         /                \\             /             \\\n *      2                    4         10                19\n * Zigzag traversal:\n * [[7], [3, 6], [2, 4, 10, 19]]\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm using a queue.\n * 1. The algorithm starts with a root node. This node is added to a queue.\n * 2. While the queue is not empty:\n *  - each time we enter the while-loop we get queue size. Queue size refers to the number of nodes at the current level.\n *  - we traverse all the level nodes in 2 ways: from left to right OR from right to left\n *    (this state is stored on `prevLevelFromLeftToRight` variable)\n *  - if the current node has children we add them to a queue\n *  - add level with nodes to a result.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree\n * O(N) - space, where N is the number of nodes in a binary tree\n *\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversal {\n    public static List<List<Integer>> traverse(BinaryTree.Node root) {\n        if (root == null) {\n            return List.of();\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        // create a queue\n        Deque<BinaryTree.Node> q = new ArrayDeque<>();\n        q.offer(root);\n        // start with writing nodes from left to right\n        boolean prevLevelFromLeftToRight = false;\n\n        while (!q.isEmpty()) {\n            int nodesOnLevel = q.size();\n            List<Integer> level = new LinkedList<>();\n            // traverse all the level nodes\n            for (int i = 0; i < nodesOnLevel; i++) {\n                BinaryTree.Node node = q.poll();\n                if (prevLevelFromLeftToRight) {\n                    level.add(0, node.data);\n                } else {\n                    level.add(node.data);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            // the next level node traversal will be from the other side\n            prevLevelFromLeftToRight = !prevLevelFromLeftToRight;\n            result.add(level);\n        }\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), ZigzagTraversal.traverse(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{50});\n        assertEquals(List.of(List.of(50)), ZigzagTraversal.traverse(root));\n    }\n\n    @Test\n    public void testZigzagTraversal() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{7, 6, 14, 2, 80, 100});\n        assertEquals(List.of(List.of(7), List.of(14, 6), List.of(2, 80, 100)), ZigzagTraversal.traverse(root));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), ZigzagTraversal.traverse(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{50});\n        assertEquals(List.of(List.of(50)), ZigzagTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testZigzagTraversalCompleteTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7)), ZigzagTraversal.traverse(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n        /  \\\n       8    9\n    */\n    @Test\n    public void testZigzagTraversalDifferentHeight() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(\n                new Integer[]{1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9});\n        assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7), List.of(9, 8)),\n                ZigzagTraversal.traverse(root));\n    }\n}"
    },
    {
        "product_commit": "c0fec8dfe2c91d4cc9dec3f7f67d0a6fc7826085",
        "test_commit": "c0fec8dfe2c91d4cc9dec3f7f67d0a6fc7826085",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/OptimalJobScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/OptimalJobSchedulingTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * This class refers to the Optimal Job Scheduling problem with the following constrains:\n *  - precedence relation between the processes\n *  - machine pair dependent transportation delays\n *\n * https://en.wikipedia.org/wiki/Optimal_job_scheduling\n *\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobScheduling {\n\n    private final int numberProcesses;\n    private final int numberMachines;\n    private final int[][] Run;\n    private final int[][] Transfer;\n    private final int[][] Cost;\n\n    /**\n     * Constructor of the class.\n     * @param numberProcesses ,refers to the number of precedent processes(N)\n     * @param numberMachines ,refers to the number of different machines in our disposal(M)\n     * @param Run , N*M matrix refers to the cost of running each process to each machine\n     * @param Transfer ,M*M symmetric matrix refers to the transportation delay for each pair of machines\n     */\n    public OptimalJobScheduling(int numberProcesses, int numberMachines, int[][] Run, int[][] Transfer) {\n        this.numberProcesses = numberProcesses;\n        this.numberMachines = numberMachines;\n        this.Run = Run;\n        this.Transfer = Transfer;\n        this.Cost = new int[numberProcesses][numberMachines];\n    }\n\n    /**\n     * Function which computes the cost of process scheduling to a number of VMs.\n     */\n    public void execute(){\n        this.calculateCost();\n        this.showResults();\n    }\n\n    /**\n     * Function which computes the cost of running each Process to each and every Machine\n     */\n    private void calculateCost(){\n\n        for (int i=0; i < numberProcesses; i++){           //for each Process\n\n            for (int j=0; j < numberMachines; j++) {       //for each Machine\n\n                Cost[i][j] = runningCost(i, j);\n            }\n        }\n    }\n\n    /**\n     * Function which returns the minimum cost of running a certain Process to a certain Machine.In order for the Machine to execute the Process ,he requires the output\n     * of the previously executed Process, which may have been executed to the same Machine or some other.If the previous Process has been executed to another Machine,we\n     * have to transfer her result, which means extra cost for transferring the data from one Machine to another(if the previous Process has been executed to the same\n     * Machine, there is no transport cost).\n     *\n     * @param process ,refers to the Process\n     * @param machine ,refers to the Machine\n     * @return the minimum cost of executing the process to the certain machine.\n     */\n    private int runningCost(int process, int machine) {\n\n        if (process==0)                         //refers to the first process,which does not require for a previous one to have been executed\n            return Run[process][machine];\n        else {\n\n            int[] runningCosts = new int[numberMachines];     //stores the costs of executing our Process depending on the Machine the previous one was executed\n\n            for (int k=0; k < numberMachines; k++)                                                     //computes the cost of executing the previous process to each and every Machine\n                runningCosts[k] = Cost[process-1][k] + Transfer[k][machine] + Run[process][machine];   //transferring the result to our Machine and executing the Process to our Machine\n\n            return findMin(runningCosts);                     //returns the minimum running cost\n        }\n    }\n\n    /**\n     * Function used in order to return the minimum Cost.\n     * @param cost ,an Array of size M which refers to the costs of executing a Process to each Machine\n     * @return the minimum cost\n     */\n    private int findMin(int[] cost) {\n\n        int min=0;\n\n        for (int i=1;i<cost.length;i++){\n\n            if (cost[i]<cost[min])\n                min=i;\n        }\n        return cost[min];\n    }\n\n    /**\n     * Method used in order to present the overall costs.\n     */\n    private void showResults(){\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++) {\n                System.out.print(Cost[i][j]);\n                System.out.print(\" \");\n            }\n\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    /**\n     * Getter for the running Cost of i process on j machine.\n     */\n    public int getCost(int process,int machine) {\n        return Cost[process][machine];\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author georgioct@csd.auth.gr\n */\npublic class OptimalJobSchedulingTest {\n\n    @Test\n    public void testOptimalJobScheduling1(){\n\n        int numberProcesses = 5;\n        int numberMachines = 4;\n\n        int[][] Run = {\n                {5, 1, 3, 2},\n                {4, 2, 1, 3},\n                {1, 5, 2, 1},\n                {2, 3, 4, 2},\n                {1, 1, 3, 1}};\n\n        int[][] Transfer = {\n                {0, 1, 2, 4},\n                {1, 0, 2, 3},\n                {2, 2, 0, 1},\n                {4, 3, 1, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses,numberMachines,Run,Transfer);\n\n        opt.execute();\n\n\n        int[][] costs = {\n                {5, 1, 3, 2},\n                {6, 3, 4, 5},\n                {5, 8, 6, 6},\n                {7, 9, 10, 8},\n                {8, 9, 12, 9}};\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++){\n\n                assertEquals(costs[i][j],opt.getCost(i,j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling2(){\n\n        int numberProcesses = 3;\n        int numberMachines = 3;\n\n        int[][] Run = {\n                {5, 1, 3},\n                {4, 2, 1},\n                {1, 5, 2}};\n\n        int[][] Transfer = {\n                {0, 1, 2},\n                {1, 0, 2},\n                {2, 2, 0}};\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses,numberMachines,Run,Transfer);\n\n        opt.execute();\n\n        int[][] costs = {\n                {5, 1, 3},\n                {6, 3, 4},\n                {5, 8, 6}};\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++){\n\n                assertEquals(costs[i][j],opt.getCost(i,j));\n            }\n        }\n    }\n\n    @Test\n    public void testOptimalJobScheduling3(){\n\n        int numberProcesses = 6;\n        int numberMachines = 4;\n\n        int[][] Run = {\n                {5, 1, 3, 2},\n                {4, 2, 1, 1},\n                {1, 5, 2, 6},\n                {1, 1, 2, 3},\n                {2, 1, 4, 6},\n                {3, 2, 2, 3},\n        };\n\n        int[][] Transfer = {\n                {0, 1, 2, 1},\n                {1, 0, 2, 3},\n                {2, 2, 0, 2},\n                {1, 3, 2, 0},\n        };\n\n        OptimalJobScheduling opt = new OptimalJobScheduling(numberProcesses,numberMachines,Run,Transfer);\n\n        opt.execute();\n\n        int[][] costs = {\n                {5, 1, 3, 2},\n                {6, 3, 4, 3},\n                {5, 8, 6, 9},\n                {6, 7, 8, 9},\n                {8, 8, 12, 13},\n                {11, 10, 12, 12}};\n\n        for (int i=0; i < numberProcesses; i++){\n\n            for (int j=0; j < numberMachines; j++){\n\n                assertEquals(costs[i][j],opt.getCost(i,j));\n            }\n        }\n    }\n}"
    },
    {
        "product_commit": "39df47b5f2e1b5d996fa790447130722c760a21c",
        "test_commit": "39df47b5f2e1b5d996fa790447130722c760a21c",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/Kosaraju.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/KosarajuTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * Java program that implements Kosaraju Algorithm.\n * @author Shivanagouda S A (https://github.com/shivu2002a)\n * \n */\n\n/**\n * Kosaraju algorithm is a linear time algorithm to find the strongly connected components of a \n   directed graph, which, from here onwards will be referred by SCC. It leverages the fact that the transpose\n   graph (same graph with all the edges reversed) has exactly the same SCCs as the original graph.\n    \n * A graph is said to be strongly connected if every vertex is reachable from every other vertex. \n   The SCCs of a directed graph form a partition into subgraphs that are themselves strongly connected.\n   Single node is always a SCC.\n\n * Example:\n\n    0 <--- 2 -------> 3 -------- > 4 ---- > 7\n    |     ^                      | ^       ^\n    |    /                       |  \\     /\n    |   /                        |   \\   /\n    v  /                         v    \\ /\n    1                            5 --> 6 \n\n    For the above graph, the SCC list goes as follows:\n    0, 1, 2 \n    3\n    4, 5, 6\n    7\n    \n    We can also see that order of the nodes in an SCC doesn't matter since they are in cycle.\n\n {@summary}\n * Kosaraju Algorithm: \n    1. Perform DFS traversal of the graph. Push node to stack before returning. This gives edges sorted by lowest finish time.\n    2. Find the transpose graph by reversing the edges.\n    3. Pop nodes one by one from the stack and again to DFS on the modified graph.\n\n    The transpose graph of the above graph:\n     0 ---> 2 <------- 3 <------- 4 <------ 7\n    ^     /                      ^ \\       /\n    |    /                       |  \\     /\n    |   /                        |   \\   /\n    |  v                         |    v v\n    1                            5 <--- 6 \n\n    We can observe that this graph has the same SCC as that of original graph.\n\n */\n\npublic class Kosaraju {\n\n    // Sort edges according to lowest finish time\n    Stack<Integer> stack = new Stack<Integer>();\n\n    //Store each component\n    private List<Integer> scc = new ArrayList<>();\n\n    //All the strongly connected components\n    private List<List<Integer>> sccsList = new ArrayList<>();\n\n    /**\n     * \n     * @param v Node count\n     * @param list Adjacency list of graph\n     * @return List of SCCs\n     */\n    public List<List<Integer>> kosaraju(int v, List<List<Integer>> list){\n        \n        sortEdgesByLowestFinishTime(v, list);\n        \n        List<List<Integer>> transposeGraph = createTransposeMatrix(v, list);\n\n        findStronglyConnectedComponents(v, transposeGraph);\n        \n        return sccsList;\n    }\n\n    private void sortEdgesByLowestFinishTime(int v, List<List<Integer>> list){\n        int vis[] = new int[v];\n        for (int i = 0; i < v; i++) {\n            if(vis[i] == 0){\n                dfs(i, vis, list);\n            }\n        }\n    }\n\n    private List<List<Integer>> createTransposeMatrix(int v, List<List<Integer>> list) {\n        var transposeGraph = new ArrayList<List<Integer>>(v);\n        for (int i = 0; i < v; i++) {\n            transposeGraph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < v; i++) {\n            for (Integer neigh : list.get(i)) {\n                transposeGraph.get(neigh).add(i);\n            }\n        }\n        return transposeGraph;\n    }\n\n    /**\n     * \n     * @param v Node count\n     * @param transposeGraph Transpose of the given adjacency list\n     */\n    public void findStronglyConnectedComponents(int v, List<List<Integer>> transposeGraph){\n        int vis[] = new int[v];\n        while (!stack.isEmpty()) {\n            var node = stack.pop();\n            if(vis[node] == 0){\n                dfs2(node, vis, transposeGraph);\n                sccsList.add(scc);\n                scc = new ArrayList<>();\n            }\n        }\n    }\n\n    //Dfs to store the nodes in order of lowest finish time\n    private void dfs(int node, int vis[], List<List<Integer>> list){\n        vis[node] = 1;\n        for(Integer neighbour : list.get(node)){\n            if(vis[neighbour] == 0)\n                dfs(neighbour, vis, list);\n        }\n        stack.push(node);\n    }\n\n    //Dfs to find all the nodes of each strongly connected component\n    private void dfs2(int node, int vis[], List<List<Integer>> list){\n        vis[node] = 1;\n        for(Integer neighbour : list.get(node)){\n            if(vis[neighbour] == 0)\n                dfs2(neighbour, vis, list);\n        }\n        scc.add(node);\n    }\n    \n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KosarajuTest {\n\n    private Kosaraju kosaraju = new Kosaraju();\n\n    @Test\n    public void findStronglyConnectedComps() {\n        //Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(0);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(4).add(7);\n        adjList.get(5).add(6);\n        adjList.get(6).add(4);\n        adjList.get(6).add(7);\n\n        List<List<Integer>> actualResult = kosaraju.kosaraju(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result: \n            0, 1, 2\n            3\n            5, 4, 6 \n            7\n        */\n        expectedResult.add(Arrays.asList(1, 2, 0));\n        expectedResult.add(Arrays.asList(3));\n        expectedResult.add(Arrays.asList(5, 6, 4));\n        expectedResult.add(Arrays.asList(7));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n    @Test\n    public void findStronglyConnectedCompsShouldGetSingleNodes() {\n        //Create a adjacency list of graph\n        var n = 8;\n        var adjList = new ArrayList<List<Integer>>(n);\n\n        for (int i = 0; i < n; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        adjList.get(0).add(1);\n        adjList.get(1).add(2);\n        adjList.get(2).add(3);\n        adjList.get(3).add(4);\n        adjList.get(4).add(5);\n        adjList.get(5).add(6);\n        adjList.get(6).add(7);\n        adjList.get(7).add(0);\n\n        List<List<Integer>> actualResult = kosaraju.kosaraju(n, adjList);\n        List<List<Integer>> expectedResult = new ArrayList<>();\n        /*\n            Expected result: \n            0, 1, 2, 3, 4, 5, 6, 7\n        */\n        expectedResult.add(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 0));\n        assertTrue(expectedResult.equals(actualResult));\n    }\n\n}"
    },
    {
        "product_commit": "54d6f79acd533721cb43060f476cb9d26b11c37d",
        "test_commit": "54d6f79acd533721cb43060f476cb9d26b11c37d",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/SimpleSubstitutionCipher.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/SimpleSubstitutionCipherTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n *\n * @author Hassan Elseoudy\n */\npublic class SimpleSubstitutionCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @return Encrypted message\n     */\n    public static String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @return message\n     */\n    public static String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n\n    /**\n     * TODO remove main and make JUnit Testing\n     */\n    public static void main(String[] args) {\n        String a = encode(\n            \"defend the east wall of the castle\",\n            \"phqgiumeaylnofdxjkrcvstzwb\"\n        );\n        String b = decode(a, \"phqgiumeaylnofdxjkrcvstzwb\");\n        System.out.println(b);\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n *\n * @author Hassan Elseoudy\n */\npublic class SimpleSubstitutionCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @return Encrypted message\n     */\n    public static String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @return message\n     */\n    public static String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class SimpleSubstitutionCipherTest {\n\n    @Test\n    void testEncode() {\n        // Given\n        String message = \"HELLOWORLD\";\n        String key = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // When\n        String actual = SimpleSubstitutionCipher.encode(message, key);\n\n        // Then\n        assertEquals(\"EINNDTDKNG\", actual);\n    }\n\n    @Test\n    void testDecode() {\n        // Given\n        String message = \"EINNDTDKNG\";\n        String key = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // When\n        String actual = SimpleSubstitutionCipher.decode(message, key);\n\n        // Then\n        assertEquals(\"HELLOWORLD\", actual);\n    }\n\n    @Test\n    void testIsTextTheSameAfterEncodeAndDecode() {\n        // Given\n        String text = \"HELLOWORLD\";\n        String key = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // When\n        String encodedText = SimpleSubstitutionCipher.encode(text, key);\n        String decodedText = SimpleSubstitutionCipher.decode(encodedText, key);\n\n        // Then\n        assertEquals(text, decodedText);\n    }\n}"
    },
    {
        "product_commit": "b14f55096df075bd1cf005c9d40d86e92f8b3ba5",
        "test_commit": "b14f55096df075bd1cf005c9d40d86e92f8b3ba5",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/LFUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/LFUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Java program for LFU Cache (https://en.wikipedia.org/wiki/Least_frequently_used)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class LFUCache<K, V> {\n\n    private class Node {\n\n        private K key;\n        private V value;\n        private int frequency;\n        private Node previous;\n        private Node next;\n\n        public Node(K key, V value, int frequency) {\n            this.key = key;\n            this.value = value;\n            this.frequency = frequency;\n        }\n    }\n\n    private Node head;\n    private Node tail;\n    private Map<K, Node> map = null;\n    private Integer capacity;\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public LFUCache() {\n        this.capacity = DEFAULT_CAPACITY;\n    }\n\n    public LFUCache(Integer capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>();\n    }\n\n    /**\n     * This method returns value present in the cache corresponding to the key passed as parameter\n     *\n     * @param <K> key for which value is to be retrieved\n     * @returns <V> object corresponding to the key passed as parameter, returns null if <K> key is not present in the cache\n     */\n    public V get(K key) {\n        if (this.map.get(key) == null) {\n            return null;\n        }\n\n        Node node = map.get(key);\n        removeNode(node);\n        node.frequency += 1;\n        addNodeWithUpdatedFrequency(node);\n\n        return node.value;\n    }\n\n    /**\n     * This method stores <K> key and <V> value in the cache\n     *\n     * @param <K> key which is to be stored in the cache\n     * @param <V> value which is to be stored in the cache\n     */\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            node.frequency += 1;\n            removeNode(node);\n            addNodeWithUpdatedFrequency(node);\n        } else {\n            if (map.size() >= capacity) {\n                map.remove(this.head.key);\n                removeNode(head);\n            }\n            Node node = new Node(key, value, 1);\n            addNodeWithUpdatedFrequency(node);\n            map.put(key, node);\n        }\n    }\n\n    /**\n     * This method stores the node in the cache with updated frequency\n     *\n     * @param Node node which is to be updated in the cache\n     */\n    private void addNodeWithUpdatedFrequency(Node node) {\n        if (tail != null && head != null) {\n            Node temp = this.head;\n            while (temp != null) {\n                if (temp.frequency > node.frequency) {\n                    if (temp == head) {\n                        node.next = temp;\n                        temp.previous = node;\n                        this.head = node;\n                        break;\n                    } else {\n                        node.next = temp;\n                        node.previous = temp.previous;\n                        temp.previous.next = node;\n                        node.previous = temp.previous;\n                        break;\n                    }\n                } else {\n                    temp = temp.next;\n                    if (temp == null) {\n                        tail.next = node;\n                        node.previous = tail;\n                        node.next = null;\n                        tail = node;\n                        break;\n                    }\n                }\n            }\n        } else {\n            tail = node;\n            head = tail;\n        }\n    }\n\n    /**\n     * This method removes node from the cache\n     *\n     * @param Node node which is to be removed in the cache\n     */\n    private void removeNode(Node node) {\n        if (node.previous != null) {\n            node.previous.next = node.next;\n        } else {\n            this.head = node.next;\n        }\n\n        if (node.next != null) {\n            node.next.previous = node.previous;\n        } else {\n            this.tail = node.previous;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Java program for LFU Cache (https://en.wikipedia.org/wiki/Least_frequently_used)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class LFUCache<K, V> {\n\n    private class Node {\n\n        private K key;\n        private V value;\n        private int frequency;\n        private Node previous;\n        private Node next;\n\n        public Node(K key, V value, int frequency) {\n            this.key = key;\n            this.value = value;\n            this.frequency = frequency;\n        }\n    }\n\n    private Node head;\n    private Node tail;\n    private Map<K, Node> map = null;\n    private Integer capacity;\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public LFUCache() {\n        this.capacity = DEFAULT_CAPACITY;\n    }\n\n    public LFUCache(Integer capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>();\n    }\n\n    /**\n     * This method returns value present in the cache corresponding to the key passed as parameter\n     *\n     * @param <K> key for which value is to be retrieved\n     * @returns <V> object corresponding to the key passed as parameter, returns null if <K> key is not present in the cache\n     */\n    public V get(K key) {\n        if (this.map.get(key) == null) {\n            return null;\n        }\n\n        Node node = map.get(key);\n        removeNode(node);\n        node.frequency += 1;\n        addNodeWithUpdatedFrequency(node);\n\n        return node.value;\n    }\n\n    /**\n     * This method stores <K> key and <V> value in the cache\n     *\n     * @param <K> key which is to be stored in the cache\n     * @param <V> value which is to be stored in the cache\n     */\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            node.frequency += 1;\n            removeNode(node);\n            addNodeWithUpdatedFrequency(node);\n        } else {\n            if (map.size() >= capacity) {\n                map.remove(this.head.key);\n                removeNode(head);\n            }\n            Node node = new Node(key, value, 1);\n            addNodeWithUpdatedFrequency(node);\n            map.put(key, node);\n        }\n    }\n\n    /**\n     * This method stores the node in the cache with updated frequency\n     *\n     * @param Node node which is to be updated in the cache\n     */\n    private void addNodeWithUpdatedFrequency(Node node) {\n        if (tail != null && head != null) {\n            Node temp = this.head;\n            while (temp != null) {\n                if (temp.frequency > node.frequency) {\n                    if (temp == head) {\n                        node.next = temp;\n                        temp.previous = node;\n                        this.head = node;\n                        break;\n                    } else {\n                        node.next = temp;\n                        node.previous = temp.previous;\n                        temp.previous.next = node;\n                        temp.previous = node;\n                        break;\n                    }\n                } else {\n                    temp = temp.next;\n                    if (temp == null) {\n                        tail.next = node;\n                        node.previous = tail;\n                        node.next = null;\n                        tail = node;\n                        break;\n                    }\n                }\n            }\n        } else {\n            tail = node;\n            head = tail;\n        }\n    }\n\n    /**\n     * This method removes node from the cache\n     *\n     * @param Node node which is to be removed in the cache\n     */\n    private void removeNode(Node node) {\n        if (node.previous != null) {\n            node.previous.next = node.next;\n        } else {\n            this.head = node.next;\n        }\n\n        if (node.next != null) {\n            node.next.previous = node.previous;\n        } else {\n            this.tail = node.previous;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LFUCacheTest {\n\n    @Test\n    void testLFUCacheWithIntegerValueShouldPass() {\n        LFUCache<Integer, Integer> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, 10);\n        lfuCache.put(2, 20);\n        lfuCache.put(3, 30);\n        lfuCache.put(4, 40);\n        lfuCache.put(5, 50);\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(10, lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, 60);\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return 60\n        assertEquals(60, lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, 70);\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(70, lfuCache.get(7));\n    }\n\n    @Test\n    void testLFUCacheWithStringValueShouldPass() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, \"Alpha\");\n        lfuCache.put(2, \"Beta\");\n        lfuCache.put(3, \"Gamma\");\n        lfuCache.put(4, \"Delta\");\n        lfuCache.put(5, \"Eplison\");\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(\"Alpha\", lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, \"Digamma\");\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return string Digamma\n        assertEquals(\"Digamma\", lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, \"Zeta\");\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(\"Zeta\", lfuCache.get(7));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LFUCacheTest {\n\n    @Test\n    void testLFUCacheWithIntegerValueShouldPass() {\n        LFUCache<Integer, Integer> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, 10);\n        lfuCache.put(2, 20);\n        lfuCache.put(3, 30);\n        lfuCache.put(4, 40);\n        lfuCache.put(5, 50);\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(10, lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, 60);\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return 60\n        assertEquals(60, lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, 70);\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(70, lfuCache.get(7));\n    }\n\n    @Test\n    void testLFUCacheWithStringValueShouldPass() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, \"Alpha\");\n        lfuCache.put(2, \"Beta\");\n        lfuCache.put(3, \"Gamma\");\n        lfuCache.put(4, \"Delta\");\n        lfuCache.put(5, \"Eplison\");\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(\"Alpha\", lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, \"Digamma\");\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return string Digamma\n        assertEquals(\"Digamma\", lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, \"Zeta\");\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(\"Zeta\", lfuCache.get(7));\n    }\n\n    /**\n     * test addNodeWithUpdatedFrequency method\n     * @author yuluo\n     */\n    @Test\n    void testAddNodeWithUpdatedFrequency() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(3);\n        lfuCache.put(1, \"beijing\");\n        lfuCache.put(2, \"shanghai\");\n        lfuCache.put(3, \"gansu\");\n\n        assertEquals(\"beijing\", lfuCache.get(1));\n\n        lfuCache.put(1, \"shanxi\");\n\n        assertEquals(\"shanxi\", lfuCache.get(1));\n    }\n}"
    },
    {
        "product_commit": "b6c1d250f4539db7c8b275ea162ab19b5e40ac3d",
        "test_commit": "b6c1d250f4539db7c8b275ea162ab19b5e40ac3d",
        "product_file_path": "src/main/java/com/thealgorithms/others/Conway.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/ConwayTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.*;\n\npublic class Conway {\n\n    /*\n     * This class will generate the conway sequence also known as the look and say sequence.\n     * To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n     *1 is read off as \"one 1\" or 11.\n     *11 is read off as \"two 1s\" or 21.\n     *21 is read off as \"one 2, one 1\" or 1211.\n     *1211 is read off as \"one 1, one 2, two 1s\" or 111221.\n     *111221 is read off as \"three 1s, two 2s, one 1\" or 312211.\n     * https://en.wikipedia.org/wiki/Look-and-say_sequence\n     * */\n\n    private static final StringBuilder builder = new StringBuilder();\n\n    protected static List<String> generateList(String originalString, int maxIteration) {\n        List<String> numbers = new ArrayList<>();\n        for(int i=0; i<maxIteration; i++) {\n            originalString = generateNextElement(originalString);\n            numbers.add(originalString);\n        }\n        return numbers;\n    }\n\n\n    public static String generateNextElement(String originalString) {\n        builder.setLength(0);\n        String[] stp = originalString.split(\"(?<=(.))(?!\\\\1)\");\n        Arrays.stream(stp).forEach(s -> builder.append(s.length()).append(s.charAt(0)));\n        return builder.toString();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ConwayTest {\n    @Test\n    public void testGenerateWith1(){\n        assertEquals(\"31131211131221\", Conway.generateList(\"1\", 8).get(7));\n    }\n\n    @Test\n    public void testGenerateWith123456(){\n        assertEquals(\"13211321322113311213212312311211131122211213211331121321122112133221123113112221131112212211131221121321131211132221123113112221131112311332211211131221131211132211121312211231131112311211232221143113112221131112311332111213122112311311123112112322211531131122211311123113321112131221123113111231121123222116\", Conway.generateList(\"123456\", 20).get(11));\n    }\n\n    @Test\n    public void testGenerateWith1A1Z3E1R1T3G1F1D2E1S1C(){\n        assertEquals(\"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211A311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211Z111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312113221133211322112211213322112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133112132123222113221321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211R311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211T111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312113221133211322112211213322112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133112132123222113221321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211G311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211F311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211D111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211S311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111231133221121113311211131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211C\", Conway.generateList(\"1A1Z3E1R1T3G1F1D2E1S1C\", 20).get(19));\n    }\n\n    @Test\n    public void testGenerateNextElementWith1(){\n        assertEquals(\"11\", Conway.generateNextElement(\"1\"));\n    }\n\n    @Test\n    public void testGenerateNextElementWith123456(){\n        assertEquals(\"111213141516\", Conway.generateNextElement(\"123456\"));\n    }\n\n    @Test\n    public void testGenerateNextElementWith1A1Z3E1R1T3G1F1D2E1S1C(){\n        assertEquals(\"111A111Z131E111R111T131G111F111D121E111S111C\", Conway.generateNextElement(\"1A1Z3E1R1T3G1F1D2E1S1C\"));\n    }\n}"
    },
    {
        "product_commit": "d5f140458a1c2fc95ef91a7790fd98bfbca4e141",
        "test_commit": "d5f140458a1c2fc95ef91a7790fd98bfbca4e141",
        "product_file_path": "src/main/java/com/thealgorithms/searches/SearchInARowAndColWiseSortedMatrix.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/TestSearchInARowAndColWiseSortedMatrix.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\n\nimport java.util.Arrays;\n\npublic class SearchInARowAndColWiseSortedMatrix {\n    /**\n     * Search a key in row and column wise sorted matrix\n     *\n     * @param matrix matrix to be searched\n     * @param value  Key being searched for\n     * @author Sadiul Hakim : https://github.com/sadiul-hakim\n     */\n\n    public int[] search(int[][] matrix, int value) {\n        int n = matrix.length;\n        // This variable iterates over rows\n        int i = 0;\n        // This variable iterates over columns\n        int j = n - 1;\n        int[] result = { -1, -1 };\n\n        while (i < n && j >= 0) {\n            if (matrix[i][j] == value) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n            if (value > matrix[i][j]) {\n                i++;\n            } else {\n                j--;\n            }\n\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class TestSearchInARowAndColWiseSortedMatrix {\n    @Test\n    public void searchItem() {\n        int[][] matrix = {\n                { 3, 4, 5, 6, 7 },\n                { 8, 9, 10, 11, 12 },\n                { 14, 15, 16, 17, 18 },\n                { 23, 24, 25, 26, 27 },\n                { 30, 31, 32, 33, 34 }\n        };\n\n        var test = new SearchInARowAndColWiseSortedMatrix();\n        int[] res = test.search(matrix, 16);\n        int[] expectedResult = { 2, 2 };\n        assertArrayEquals(expectedResult, res);\n    }\n\n    @Test\n    public void notFound() {\n        int[][] matrix = {\n                { 3, 4, 5, 6, 7 },\n                { 8, 9, 10, 11, 12 },\n                { 14, 15, 16, 17, 18 },\n                { 23, 24, 25, 26, 27 },\n                { 30, 31, 32, 33, 34 }\n        };\n\n        var test = new SearchInARowAndColWiseSortedMatrix();\n        int[] res = test.search(matrix, 96);\n        int[] expectedResult = { -1, -1 };\n        assertArrayEquals(expectedResult, res);\n    }\n}"
    },
    {
        "product_commit": "351e85d264432c1172cd28bb3da542cf9e1ad456",
        "test_commit": "351e85d264432c1172cd28bb3da542cf9e1ad456",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/SameTreesCheck.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/SameTreesCheckTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * Given 2 binary trees.\n * This code checks whether they are the same (structurally identical and have the same values) or not.\n * <p>\n * Example:\n * 1. Binary trees:\n *      1                 1\n *     / \\               / \\\n *    2   3             2   3\n *   /\\   /\\           /\\   /\\\n *  4  5 6  7         4  5 6  7\n * These trees are the same, so the code returns 'true'.\n * <p>\n * 2. Binary trees:\n *      1   1\n *     /     \\\n *    2       2\n * These trees are NOT the same (the structure differs), so the code returns 'false'.\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm.\n * For each tree we create a queue and iterate the trees using these queues.\n * On each step we check the nodes for equality, and if the nodes are not the same, return false.\n * Otherwise, add children nodes to the queues and continue traversing the trees.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree,\n * O(N) - space, where N is the number of nodes in a binary tree.\n *\n * @author Albina Gimaletdinova on 13/01/2023\n */\npublic class SameTreesCheck {\n    public static boolean check(BinaryTree.Node p, BinaryTree.Node q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n\n        Deque<BinaryTree.Node> q1 = new ArrayDeque<>();\n        Deque<BinaryTree.Node> q2 = new ArrayDeque<>();\n        q1.add(p);\n        q2.add(q);\n        while (!q1.isEmpty() && !q2.isEmpty()) {\n            BinaryTree.Node first = q1.poll();\n            BinaryTree.Node second = q2.poll();\n            // check that some node can be null\n            // if the check is true: both nodes are null or both nodes are not null\n            if (!equalNodes(first, second)) return false;\n\n            if (first != null) {\n                if (!equalNodes(first.left, second.left)) return false;\n                if (first.left != null) {\n                    q1.add(first.left);\n                    q2.add(second.left);\n                }\n\n                if (!equalNodes(first.right, second.right)) return false;\n                if (first.right != null) {\n                    q1.add(first.right);\n                    q2.add(second.right);\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean equalNodes(BinaryTree.Node p, BinaryTree.Node q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.data == q.data;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author Albina Gimaletdinova on 12/01/2023\n */\npublic class SameTreesCheckTest {\n    @Test\n    public void testBothRootsAreNull() {\n        assertTrue(SameTreesCheck.check(null, null));\n    }\n\n    @Test\n    public void testOneRootIsNull() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{100});\n        assertFalse(SameTreesCheck.check(root, null));\n    }\n\n    @Test\n    public void testSingleNodeTreesAreSame() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{100});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{100});\n        assertTrue(SameTreesCheck.check(p, q));\n    }\n\n    /*\n         1                 1\n        / \\               / \\\n       2   3             2   3\n      /\\   /\\           /\\   /\\\n     4  5 6  7         4  5 6  7\n     */\n    @Test\n    public void testSameTreesIsSuccessful() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertTrue(SameTreesCheck.check(p, q));\n    }\n\n\n    /*\n         1                 1\n        / \\               / \\\n       2   3             2   3\n      /\\   /\\           /\\   /\n     4  5 6  7         4  5 6\n     */\n    @Test\n    public void testSameTreesFails() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6});\n        assertFalse(SameTreesCheck.check(p, q));\n    }\n\n    /*\n       1    1\n      /      \\\n     2        2\n     */\n    @Test\n    public void testTreesWithDifferentStructure() {\n        final BinaryTree.Node p = TreeTestUtils.createTree(new Integer[]{1, 2});\n        final BinaryTree.Node q = TreeTestUtils.createTree(new Integer[]{1, null, 2});\n        assertFalse(SameTreesCheck.check(p, q));\n    }\n}"
    },
    {
        "product_commit": "44c05bf7db34c9e0458b82b82bf7b0aa69421af7",
        "test_commit": "44c05bf7db34c9e0458b82b82bf7b0aa69421af7",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/SJFScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/SJFSchedulingTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\n\nimport java.util.ArrayList;\n\n/**\n * Implementation of Shortest Job First Algorithm: The algorithm allows the waiting process with the minimal burst time to be executed first.\n * see more here: https://www.guru99.com/shortest-job-first-sjf-scheduling.html\n */\n\npublic class SJFScheduling {\n    protected ArrayList<ProcessDetails> processes;\n    protected ArrayList<String>schedule ;\n\n    /**\n     * a simple constructor\n     * @param processes a list of processes the user wants to schedule\n     *  it also sorts the processes based on the time of their arrival\n     */\n    SJFScheduling(final ArrayList<ProcessDetails> processes) {\n        this.processes = processes;\n        schedule=new ArrayList<>();\n        sortByArrivalTime();\n    }\nprotected void sortByArrivalTime() {\n        int size=processes.size(),i,j;\n        ProcessDetails temp;\n        for(i=0;i<size;i++)\n        {\n            for(j=i+1;j<size-1;j++)\n            {\n                if(processes.get(j).getArrivalTime()>processes.get(j+1).getArrivalTime())\n                {\n                    temp=processes.get(j);\n                    processes.set(j,processes.get(j+1));\n                    processes.set(j+1,temp);\n                }\n            }\n        }\n\n}\n\n    /**\n     * this functions returns the order of the executions\n     */\n\n    public void scheduleProcesses() {\n        ArrayList<ProcessDetails> ready=new ArrayList<>();\n\n        int size = processes.size(),runtime,time=0;\n        int executed=0,j,k=0;\n        ProcessDetails running;\n\n        if (size == 0) {\n            return;\n        }\n\n\n        while(executed<size)\n        {\n            while(k<size && processes.get(k).getArrivalTime()<=time)//here we find the processes that have arrived.\n            {\n                ready.add(processes.get(k));\n                k++;\n            }\n\n            running=findShortestJob(ready);\n            if(running==null)\n            {\n                  time++;\n            }\n            else {\n                  runtime = running.getBurstTime();\n                  for (j = 0; j < runtime; j++) {\n                      time++;}\n                  schedule.add(running.getProcessId());\n                  ready.remove(running);\n                  executed++;\n                  }\n        }\n\n\n    }\n\n    /**\n     * this function evaluates the shortest job of all the ready processes (based on  a process burst time)\n     * @param ReadyProcesses an array list of ready processes\n     * @return returns the process' with the shortest burst time OR NULL if there are no ready processes\n     */\n    private ProcessDetails findShortestJob(ArrayList<ProcessDetails> ReadyProcesses) {\n        if (ReadyProcesses.isEmpty()){\n            return null;\n        }\n        int i,size = ReadyProcesses.size();\n        int minBurstTime = ReadyProcesses.get(0).getBurstTime(), temp, positionOfShortestJob = 0;\n\n\n        for (i = 1; i < size; i++) {\n            temp = ReadyProcesses.get(i).getBurstTime();\n            if (minBurstTime > temp  ) {\n                minBurstTime = temp;\n                positionOfShortestJob = i;\n            }\n        }\n\n        return ReadyProcesses.get(positionOfShortestJob);\n    }\n\n\n\n\n\n    }",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SJFSchedulingTest {\n    private  ArrayList<ProcessDetails> process;\n    void initialisation0()\n    {\n\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,6));\n        process.add(new ProcessDetails(\"2\",1,2));\n    }\n    void initialisation1()\n    {\n\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,6));\n        process.add(new ProcessDetails(\"2\",1,2));\n        process.add(new ProcessDetails(\"3\",4 ,3));\n        process.add(new ProcessDetails(\"4\",3,1));\n        process.add(new ProcessDetails(\"5\",6 ,4));\n        process.add(new ProcessDetails(\"6\",5,5));\n    }\n\n    void initialisation2()\n    {\n\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,3));\n        process.add(new ProcessDetails(\"2\",1,2));\n        process.add(new ProcessDetails(\"3\",2 ,1));\n\n    }\n    void initialisation3(){\n        process=new ArrayList<>();\n        process.add(new ProcessDetails(\"1\",0 ,3));\n        process.add(new ProcessDetails(\"2\",5,2));\n        process.add(new ProcessDetails(\"3\",9 ,1));\n    }\n    @Test\n    void constructor()\n    {\n        initialisation0();\n        SJFScheduling a=new SJFScheduling(process);\n         assertEquals( 6,a.processes.get(0).getBurstTime());\n        assertEquals( 2,a.processes.get(1).getBurstTime());\n    }\n\n     @Test\n    void sort()\n    {\n        initialisation1();\n        SJFScheduling a=new SJFScheduling(process);\n        a.sortByArrivalTime();\n        assertEquals(\"1\",a.processes.get(0).getProcessId());\n        assertEquals(\"2\",a.processes.get(1).getProcessId());\n        assertEquals(\"3\",a.processes.get(3).getProcessId());\n        assertEquals(\"4\",a.processes.get(2).getProcessId());\n        assertEquals(\"5\",a.processes.get(5).getProcessId());\n        assertEquals(\"6\",a.processes.get(4).getProcessId());\n\n    }\n\n    @Test\n    void scheduling(){\n        initialisation1();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"4\"  , a.schedule.get(1));\n        assertEquals(  \"2\" , a.schedule.get(2));\n        assertEquals(  \"3\" , a.schedule.get(3));\n        assertEquals(\"5\"   , a.schedule.get(4));\n        assertEquals(   \"6\", a.schedule.get(5));\n\n\n    }\n\n    @Test\n    void schedulingOf_TwoProcesses(){\n        initialisation0();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"2\"  , a.schedule.get(1));\n    }\n\n    @Test\n    void schedulingOfA_ShortestJobArrivingLast(){\n        initialisation2();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"3\"  , a.schedule.get(1));\n        assertEquals( \"2\"  , a.schedule.get(2));\n    }\n    @Test\n    void scheduling_WithProcessesNotComingBackToBack(){\n        initialisation3();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertEquals( \"1\"  , a.schedule.get(0));\n        assertEquals( \"2\"  , a.schedule.get(1));\n        assertEquals( \"3\"  , a.schedule.get(2));\n    }\n    @Test\n    void schedulingOf_nothing(){\n        process=new ArrayList<>();\n        SJFScheduling a=new SJFScheduling(process);\n        a.scheduleProcesses();\n        assertTrue( a.schedule.isEmpty());\n\n    }\n}"
    },
    {
        "product_commit": "3b6e3edbfbcecbffeff09f7658b53b82bfbbd744",
        "test_commit": "3b6e3edbfbcecbffeff09f7658b53b82bfbbd744",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/VerticalOrderTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/VerticalOrderTraversalTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\n\n/* The following class implements a vertical order traversal\nin a tree from top to bottom and left to right, so for a tree :\n           1\n          / \\\n         2   3\n        / \\   \\\n       4   5   6\n        \\     / \\\n         7   8   10\n          \\\n           9\n the sequence will be :\n 4 2 7 1 5 9 3 8 6 10\n */\npublic class VerticalOrderTraversal {\n\n    public static void main(String[] args) {\n        BinaryTree tree = new BinaryTree();\n        tree.put(5);\n        tree.put(6);\n        tree.put(3);\n        tree.put(1);\n        tree.put(4);\n        BinaryTree.Node root = tree.getRoot();\n        ArrayList<Integer> ans = verticalTraversal(root);\n        for (int i : ans) {\n            System.out.print(i + \" \");\n        }\n    }\n\n    /*Function that receives a root Node and prints the tree \n\tin Vertical Order.*/\n    private static ArrayList<Integer> verticalTraversal(BinaryTree.Node root) {\n        /*Queue to store the Nodes.*/\n        Queue<BinaryTree.Node> queue = new LinkedList<>();\n\n        /*Queue to store the index of particular vertical \n\t\t column of a tree , with root at 0, Nodes on left \n\t\t with negative index and Nodes on right with positive\n\t\t index. */\n        Queue<Integer> index = new LinkedList<>();\n\n        /*Map of Integer and ArrayList to store all the \n\t\t elements in a particular index in a single arrayList\n\t\t that will have a key equal to the index itself. */\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\n\n        /* min and max stores leftmost and right most index to\n\t\t later print the tree in vertical fashion.*/\n        int max = 0, min = 0;\n        queue.offer(root);\n        index.offer(0);\n\n        while (!queue.isEmpty()) {\n            if (queue.peek().left != null) {\n                /*Adding the left Node if it is not null\n\t\t\t\tand its index by subtracting 1 from it's \n\t\t\t\tparent's index*/\n                queue.offer(queue.peek().left);\n                index.offer(index.peek() - 1);\n            }\n            if (queue.peek().right != null) {\n                /*Adding the right Node if it is not null\n\t\t\t\tand its index by adding 1 from it's \n\t\t\t\tparent's index*/\n                queue.offer(queue.peek().right);\n                index.offer(index.peek() + 1);\n            }\n            /*If the map does not contains the index a new\n\t\t\t ArrayList is created with the index as key.*/\n            if (!map.containsKey(index.peek())) {\n                ArrayList<Integer> a = new ArrayList<>();\n                map.put(index.peek(), a);\n            }\n            /*For a index, corresponding Node data is added\n\t\t\t to the respective ArrayList present at that\n\t\t\t index. */\n            map.get(index.peek()).add(queue.peek().data);\n            max = (int) Math.max(max, index.peek());\n            min = (int) Math.min(min, index.peek());\n            /*The Node and its index are removed \n\t\t\t from their respective queues.*/\n            index.poll();\n            queue.poll();\n        }\n        /*Finally map data is printed here which has keys\n\t\tfrom min to max. Each ArrayList represents a \n\t\tvertical column that is added in ans ArrayList.*/\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) {\n            for (int j = 0; j < map.get(i).size(); j++) {\n                ans.add(map.get(i).get(j));\n            }\n        }\n        return ans;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\n\n/* The following class implements a vertical order traversal\nin a tree from top to bottom and left to right, so for a tree :\n           1\n          / \\\n         2   3\n        / \\   \\\n       4   5   6\n        \\     / \\\n         7   8   10\n          \\\n           9\n the sequence will be :\n 4 2 7 1 5 9 3 8 6 10\n */\npublic class VerticalOrderTraversal {\n\n    /*Function that receives a root Node and prints the tree\n\tin Vertical Order.*/\n    public static ArrayList<Integer> verticalTraversal(BinaryTree.Node root) {\n        if (root == null) {\n            return new ArrayList<>();\n        }\n\n        /*Queue to store the Nodes.*/\n        Queue<BinaryTree.Node> queue = new LinkedList<>();\n\n        /*Queue to store the index of particular vertical \n\t\t column of a tree , with root at 0, Nodes on left \n\t\t with negative index and Nodes on right with positive\n\t\t index. */\n        Queue<Integer> index = new LinkedList<>();\n\n        /*Map of Integer and ArrayList to store all the \n\t\t elements in a particular index in a single arrayList\n\t\t that will have a key equal to the index itself. */\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\n\n        /* min and max stores leftmost and right most index to\n\t\t later print the tree in vertical fashion.*/\n        int max = 0, min = 0;\n        queue.offer(root);\n        index.offer(0);\n\n        while (!queue.isEmpty()) {\n            if (queue.peek().left != null) {\n                /*Adding the left Node if it is not null\n\t\t\t\tand its index by subtracting 1 from it's \n\t\t\t\tparent's index*/\n                queue.offer(queue.peek().left);\n                index.offer(index.peek() - 1);\n            }\n            if (queue.peek().right != null) {\n                /*Adding the right Node if it is not null\n\t\t\t\tand its index by adding 1 from it's \n\t\t\t\tparent's index*/\n                queue.offer(queue.peek().right);\n                index.offer(index.peek() + 1);\n            }\n            /*If the map does not contains the index a new\n\t\t\t ArrayList is created with the index as key.*/\n            if (!map.containsKey(index.peek())) {\n                ArrayList<Integer> a = new ArrayList<>();\n                map.put(index.peek(), a);\n            }\n            /*For a index, corresponding Node data is added\n\t\t\t to the respective ArrayList present at that\n\t\t\t index. */\n            map.get(index.peek()).add(queue.peek().data);\n            max = Math.max(max, index.peek());\n            min = Math.min(min, index.peek());\n            /*The Node and its index are removed\n\t\t\t from their respective queues.*/\n            index.poll();\n            queue.poll();\n        }\n        /*Finally map data is printed here which has keys\n\t\tfrom min to max. Each ArrayList represents a\n\t\tvertical column that is added in ans ArrayList.*/\n        ArrayList<Integer> ans = new ArrayList<>();\n        for (int i = min; i <= max; i++) {\n            ans.addAll(map.get(i));\n        }\n        return ans;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 13/01/2023\n */\npublic class VerticalOrderTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), VerticalOrderTraversal.verticalTraversal(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{50});\n        assertEquals(List.of(50), VerticalOrderTraversal.verticalTraversal(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testVerticalTraversalCompleteTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(4, 2, 1, 5, 6, 3, 7), VerticalOrderTraversal.verticalTraversal(root));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4   56  7\n        /  \\\n       8    9\n    */\n    @Test\n    public void testVerticalTraversalDifferentHeight() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(\n                new Integer[]{1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9});\n        assertEquals(List.of(4, 2, 8, 1, 5, 6, 3, 9, 7), VerticalOrderTraversal.verticalTraversal(root));\n    }\n}"
    },
    {
        "product_commit": "5aa417b6aee6a4d9d5392f8590079a1342003989",
        "test_commit": "5aa417b6aee6a4d9d5392f8590079a1342003989",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/ZigzagTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/ZigzagTraversalTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.*;\n\n/**\n * Given a binary tree.\n * This code returns the zigzag level order traversal of its nodes' values.\n * Binary tree:\n *                               7\n *                   /                         \\\n *                6                           3\n *         /                \\             /             \\\n *      2                    4         10                19\n * Zigzag traversal:\n * [[7], [3, 6], [2, 4, 10, 19]]\n * <p>\n * This solution implements the breadth-first search (BFS) algorithm using a queue.\n * 1. The algorithm starts with a root node. This node is added to a queue.\n * 2. While the queue is not empty:\n *  - each time we enter the while-loop we get queue size. Queue size refers to the number of nodes at the current level.\n *  - we traverse all the level nodes in 2 ways: from left to right OR from right to left\n *    (this state is stored on `prevLevelFromLeftToRight` variable)\n *  - if the current node has children we add them to a queue\n *  - add level with nodes to a result.\n * <p>\n * Complexities:\n * O(N) - time, where N is the number of nodes in a binary tree\n * O(N) - space, where N is the number of nodes in a binary tree\n *\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversal {\n    public static List<List<Integer>> traverse(BinaryTree.Node root) {\n        if (root == null) {\n            return new ArrayList<>();\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n\n        // create a queue\n        Deque<BinaryTree.Node> q = new ArrayDeque<>();\n        q.offer(root);\n        // start with writing nodes from left to right\n        boolean prevLevelFromLeftToRight = false;\n\n        while (!q.isEmpty()) {\n            int nodesOnLevel = q.size();\n            List<Integer> level = new LinkedList<>();\n            // traverse all the level nodes\n            for (int i = 0; i < nodesOnLevel; i++) {\n                BinaryTree.Node node = q.poll();\n                if (prevLevelFromLeftToRight) {\n                    level.add(0, node.data);\n                } else {\n                    level.add(node.data);\n                }\n                if (node.left != null) {\n                    q.offer(node.left);\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                }\n            }\n            // the next level node traversal will be from the other side\n            prevLevelFromLeftToRight = !prevLevelFromLeftToRight;\n            result.add(level);\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 11/01/2023\n */\npublic class ZigzagTraversalTest {\n    @Test\n    public void testRootNull() {\n        assertEquals(Collections.emptyList(), ZigzagTraversal.traverse(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{50});\n        assertEquals(List.of(List.of(50)), ZigzagTraversal.traverse(root));\n    }\n\n    @Test\n    public void testZigzagTraversal() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{7, 6, 14, 2, 80, 100});\n        assertEquals(List.of(List.of(7), List.of(14, 6), List.of(2, 80, 100)), ZigzagTraversal.traverse(root));\n    }\n}"
    },
    {
        "product_commit": "1eedaeb07387c521f02ab211f0664e500dbb2ba9",
        "test_commit": "1eedaeb07387c521f02ab211f0664e500dbb2ba9",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SortUtils.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SortUtilsTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * The class contains util methods\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nfinal class SortUtils {\n\n    /**\n     * Helper method for swapping places in array\n     *\n     * @param array The array which elements we want to swap\n     * @param idx index of the first element\n     * @param idy index of the second element\n     */\n    static <T> boolean swap(T[] array, int idx, int idy) {\n        T swap = array[idx];\n        array[idx] = array[idy];\n        array[idy] = swap;\n        return true;\n    }\n\n    /**\n     * This method checks if first element is less than the other element\n     *\n     * @param v first element\n     * @param w second element\n     * @return true if the first element is less than the second element\n     */\n    static <T extends Comparable<T>> boolean less(T v, T w) {\n        return v.compareTo(w) < 0;\n    }\n\n    /**\n     * This method checks if first element is greater than the other element\n     *\n     * @param v first element\n     * @param w second element\n     * @return true if the first element is greater than the second element\n     */\n    static <T extends Comparable<T>> boolean greater(T v, T w) {\n        return v.compareTo(w) > 0;\n    }\n\n    /**\n     * This method checks if first element is greater than or equal the other\n     * element\n     *\n     * @param v first element\n     * @param w second element\n     * @return true if the first element is greater than or equal the second\n     * element\n     */\n    static <T extends Comparable<T>> boolean greaterOrEqual(T v, T w) {\n        return v.compareTo(w) >= 0;\n    }\n\n    /**\n     * Prints a list\n     *\n     * @param toPrint - a list which should be printed\n     */\n    static void print(List<?> toPrint) {\n        toPrint\n            .stream()\n            .map(Object::toString)\n            .map(str -> str + \" \")\n            .forEach(System.out::print);\n\n        System.out.println();\n    }\n\n    /**\n     * Prints an array\n     *\n     * @param toPrint - an array which should be printed\n     */\n    static void print(Object[] toPrint) {\n        System.out.println(Arrays.toString(toPrint));\n    }\n\n    /**\n     * Swaps all position from {\n     *\n     * @param left} to @{\n     * @param right} for {\n     * @param array}\n     *\n     * @param array is an array\n     * @param left is a left flip border of the array\n     * @param right is a right flip border of the array\n     */\n    static <T extends Comparable<T>> void flip(T[] array, int left, int right) {\n        while (left <= right) {\n            swap(array, left++, right--);\n        }\n    }\n\n    /**\n     * Function to check if the array is sorted. By default, it will check if the array is sorted in ASC order.\n     *\n     * @param array - an array which to check is it sorted or not.\n     * @return true - if array sorted in ASC order, false otherwise.\n     */\n    static <T extends Comparable<T>> boolean isSorted(T[] array) {\n        for (int i = 1; i < array.length; i++)\n            if (less(array[i], array[i - 1]))\n                return false;\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * The class contains util methods\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nfinal class SortUtils {\n\n    /**\n     * Helper method for swapping places in array\n     *\n     * @param array The array which elements we want to swap\n     * @param idx index of the first element\n     * @param idy index of the second element\n     */\n    static <T> boolean swap(T[] array, int idx, int idy) {\n        T swap = array[idx];\n        array[idx] = array[idy];\n        array[idy] = swap;\n        return true;\n    }\n\n    /**\n     * This method checks if first element is less than the other element\n     *\n     * @param v first element\n     * @param w second element\n     * @return true if the first element is less than the second element\n     */\n    static <T extends Comparable<T>> boolean less(T v, T w) {\n        return v.compareTo(w) < 0;\n    }\n\n    /**\n     * This method checks if first element is greater than the other element\n     *\n     * @param v first element\n     * @param w second element\n     * @return true if the first element is greater than the second element\n     */\n    static <T extends Comparable<T>> boolean greater(T v, T w) {\n        return v.compareTo(w) > 0;\n    }\n\n    /**\n     * This method checks if first element is greater than or equal the other\n     * element\n     *\n     * @param v first element\n     * @param w second element\n     * @return true if the first element is greater than or equal the second\n     * element\n     */\n    static <T extends Comparable<T>> boolean greaterOrEqual(T v, T w) {\n        return v.compareTo(w) >= 0;\n    }\n\n    /**\n     * Prints a list\n     *\n     * @param toPrint - a list which should be printed\n     */\n    static void print(List<?> toPrint) {\n        toPrint\n            .stream()\n            .map(Object::toString)\n            .map(str -> str + \" \")\n            .forEach(System.out::print);\n\n        System.out.println();\n    }\n\n    /**\n     * Prints an array\n     *\n     * @param toPrint - an array which should be printed\n     */\n    static void print(Object[] toPrint) {\n        System.out.println(Arrays.toString(toPrint));\n    }\n\n    /**\n     * Swaps all position from {\n     *\n     * @param left} to @{\n     * @param right} for {\n     * @param array}\n     *\n     * @param array is an array\n     * @param left is a left flip border of the array\n     * @param right is a right flip border of the array\n     */\n    static <T extends Comparable<T>> void flip(T[] array, int left, int right) {\n        while (left <= right) {\n            swap(array, left++, right--);\n        }\n    }\n\n    /**\n     * Function to check if the array is sorted. By default, it will check if the array is sorted in ASC order.\n     *\n     * @param array - an array which to check is it sorted or not.\n     * @return true - if array sorted in ASC order, false otherwise.\n     */\n    static <T extends Comparable<T>> boolean isSorted(T[] array) {\n        for (int i = 1; i < array.length; i++)\n            if (less(array[i], array[i - 1]))\n                return false;\n        return true;\n    }\n\n    static <T extends Comparable<T>> boolean isSorted(List<T> list) {\n        for (int i = 1; i < list.size(); i++)\n            if (less(list.get(i), list.get(i - 1)))\n                return false;\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SortUtilsTest {\n\n    @Test\n    void isSortedEmptyArray() {\n        Double[] emptyArray = {};\n        assertTrue(SortUtils.isSorted(emptyArray));\n    }\n\n    @Test\n    void isSortedWithSingleElement() {\n        Double[] singleElementArray = {1.0};\n        assertTrue(SortUtils.isSorted(singleElementArray));\n    }\n\n    @Test\n    void isSortedTrue() {\n        Integer[] array = {1, 1, 2, 3, 5, 8, 11};\n        assertTrue(SortUtils.isSorted(array));\n\n        Integer[] identicalArray = {1, 1, 1, 1, 1};\n        assertTrue(SortUtils.isSorted(identicalArray));\n\n        Double[] doubles = {-15.123, -15.111, 0.0, 0.12, 0.15};\n        assertTrue(SortUtils.isSorted(doubles));\n    }\n\n    @Test\n    void isSortedFalse() {\n        Double[] array = {1.0, 3.0, -0.15};\n        assertFalse(SortUtils.isSorted(array));\n\n        Integer[] array2 = {14, 15, 16, 1};\n        assertFalse(SortUtils.isSorted(array2));\n\n        Integer[] array3 = {5, 4, 3, 2, 1};\n        assertFalse(SortUtils.isSorted(array3));\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SortUtilsTest {\n\n    @Test\n    void isSortedEmptyArray() {\n        Double[] emptyArray = {};\n        assertTrue(SortUtils.isSorted(emptyArray));\n    }\n\n    @Test\n    void isSortedWithSingleElement() {\n        Double[] singleElementArray = {1.0};\n        assertTrue(SortUtils.isSorted(singleElementArray));\n    }\n\n    @Test\n    void isSortedArrayTrue() {\n        Integer[] array = {1, 1, 2, 3, 5, 8, 11};\n        assertTrue(SortUtils.isSorted(array));\n\n        Integer[] identicalArray = {1, 1, 1, 1, 1};\n        assertTrue(SortUtils.isSorted(identicalArray));\n\n        Double[] doubles = {-15.123, -15.111, 0.0, 0.12, 0.15};\n        assertTrue(SortUtils.isSorted(doubles));\n    }\n\n    @Test\n    void isSortedArrayFalse() {\n        Double[] array = {1.0, 3.0, -0.15};\n        assertFalse(SortUtils.isSorted(array));\n\n        Integer[] array2 = {14, 15, 16, 1};\n        assertFalse(SortUtils.isSorted(array2));\n\n        Integer[] array3 = {5, 4, 3, 2, 1};\n        assertFalse(SortUtils.isSorted(array3));\n    }\n\n    @Test\n    void isSortedListTrue() {\n        List<Integer> list = List.of(1, 1, 2, 3, 5, 8, 11);\n        assertTrue(SortUtils.isSorted(list));\n\n        List<Integer> identicalList = List.of(1, 1, 1, 1, 1);\n        assertTrue(SortUtils.isSorted(identicalList));\n\n        List<Double> doubles = List.of(-15.123, -15.111, 0.0, 0.12, 0.15);\n        assertTrue(SortUtils.isSorted(doubles));\n    }\n\n    @Test\n    void isSortedListFalse() {\n        List<Double> list = List.of(1.0, 3.0, -0.15);\n        assertFalse(SortUtils.isSorted(list));\n\n        List<Integer> array2 = List.of(14, 15, 16, 1);\n        assertFalse(SortUtils.isSorted(array2));\n\n        List<Integer> array3 = List.of(5, 4, 3, 2, 1);\n        assertFalse(SortUtils.isSorted(array3));\n    }\n}"
    },
    {
        "product_commit": "91234747294a788a8f7cd6a918f24e7df74832f2",
        "test_commit": "91234747294a788a8f7cd6a918f24e7df74832f2",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/heaps/LeftistHeap.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/heaps/LeftistHeapTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport java.util.ArrayList;\n\n/* \n * This is a leftist heap that follows the same operations as a\n * binary min heap, but may be unbalanced at times and follows a\n * leftist property, in which the left side is more heavy on the\n * right based on the null-path length (npl) values.\n * \n * Source: https://iq.opengenus.org/leftist-heap/\n * \n */\n\npublic class LeftistHeap {\n\tprivate class Node {\n\t\tprivate int element, npl;\n\t\tprivate Node left, right;\n\n\t\t// Node constructor setting the data element and left/right pointers to null\n\t\tprivate Node(int element) {\n\t\t\tthis.element = element;\n\t\t\tleft = right = null;\n\t\t\tnpl = 0;\n\t\t}\n\t}\n\n\tprivate Node root;\n\n\t// Constructor\n\tpublic LeftistHeap() {\n\t\troot = null;\n\t}\n\n\t// Checks if heap is empty\n\tpublic boolean isEmpty() {\n\t\treturn root == null;\n\t}\n\n\t// Resets structure to initial state\n\tpublic void clear() {\n\t\t// We will put head is null\n\t\troot = null;\n\t}\n\n\t// Merge function that merges the contents of another leftist heap with the\n\t// current one\n\tpublic void merge(LeftistHeap h1) {\n\t\t// If the present function is rhs then we ignore the merge\n\t\troot = merge(root, h1.root);\n\t\th1.root = null;\n\t}\n\n\t// Function merge with two Nodes a and b\n\tpublic Node merge(Node a, Node b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\n\t\tif (b == null)\n\t\t\treturn a;\n\n\t\t// Violates leftist property, so must do a swap\n\t\tif (a.element > b.element) {\n\t\t\tNode temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t}\n\n\t\t// Now we call the function merge to merge a and b\n\t\ta.right = merge(a.right, b);\n\n\t\t// Violates leftist property so must swap here\n\t\tif (a.left == null) {\n\t\t\ta.left = a.right;\n\t\t\ta.right = null;\n\t\t} else {\n\t\t\tif (a.left.npl < a.right.npl) {\n\t\t\t\tNode temp = a.left;\n\t\t\t\ta.left = a.right;\n\t\t\t\ta.right = temp;\n\t\t\t}\n\t\t\ta.npl = a.right.npl + 1;\n\t\t}\n\t\treturn a;\n\t}\n\n\t// Function insert. Uses the merge function to add the data\n\tpublic void insert(int a) {\n\t\troot = merge(new Node(a), root);\n\t}\n\n\t// Returns and removes the minimum element in the heap\n\tpublic int extract_min() {\n\t\t// If is empty return -1\n\t\tif (isEmpty())\n\t\t\treturn -1;\n\n\t\tint min = root.element;\n\t\troot = merge(root.left, root.right);\n\t\treturn min;\n\t}\n\n\t// Function returning a list of an in order traversal of the data structure\n\tpublic ArrayList<Integer> in_order() {\n\t\tArrayList<Integer> lst = new ArrayList<>();\n\t\tin_order_aux(root, lst);\n\t\treturn new ArrayList<>(lst);\n\t}\n\n\t// Auxiliary function for in_order\n\tprivate void in_order_aux(Node n, ArrayList<Integer> lst) {\n\t\tif (n == null)\n\t\t\treturn;\n\t\tin_order_aux(n.left, lst);\n\t\tlst.add(n.element);\n\t\tin_order_aux(n.right, lst);\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeftistHeapTest {\n\t\n\t@Test\n\tvoid testLeftistHeap() {\n\t\tLeftistHeap heap = new LeftistHeap();\n\t\tAssertions.assertTrue(heap.isEmpty());\n\t\theap.insert(6);\n\t\tAssertions.assertTrue(!heap.isEmpty());\n\t\theap.insert(2);\n\t\theap.insert(3);\n\t\theap.insert(1);\n\t\theap.in_order();\n\t\tAssertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3, 1]\"));\n\t\tAssertions.assertTrue(heap.extract_min() == 1);\n\t\tAssertions.assertTrue(heap.in_order().toString().equals(\"[6, 2, 3]\"));\n\t\theap.insert(8);\n\t\theap.insert(12);\n\t\theap.insert(4);\n\t\tAssertions.assertTrue(heap.in_order().toString().equals(\"[8, 3, 12, 2, 6, 4]\"));\n\t\theap.clear();\n\t\tAssertions.assertTrue(heap.isEmpty());\n\t}\n}"
    },
    {
        "product_commit": "8ba295b1adb6c0d8f8e14731563e5521ea8469ee",
        "test_commit": "8ba295b1adb6c0d8f8e14731563e5521ea8469ee",
        "product_file_path": "src/main/java/com/thealgorithms/searches/OrderAgnosticBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/OrderAgnosticBinarySearchTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\n\n//URL: https://www.geeksforgeeks.org/order-agnostic-binary-search/\n\n/* Order Agnostic Binary Search is an algorithm where we do not know whether the given\n   sorted array is ascending or descending order.\n   We declare a boolean variable to find whether the array is ascending order.\n   In the while loop, we use the two pointer method (start and end) to get the middle element.\n   if the middle element is equal to our target element, then that is the answer.\n   If not, then we check if the array is ascending or descending order.\n   Depending upon the condition, respective statements will be executed and we will get our answer.\n */\n\n public class OrderAgnosticBinarySearch {\n\n     static int BinSearchAlgo(int arr[], int start, int end, int target) {\n\n         // Checking whether the given array is ascending order\n         boolean AscOrd = arr[start] < arr[end];\n\n         while (start <= end) {\n             int middle = start + (end - start) / 2;\n\n             // Check if the desired element is present at the middle position\n             if (arr[middle] == target)\n                 return middle;       // returns the index of the middle element\n\n             // Ascending order\n             if (AscOrd) {\n                 if (arr[middle] < target)\n                     start = middle + 1;\n                 else\n                     end = middle - 1;\n             }\n\n             // Descending order\n             else {\n                 if (arr[middle] > target)\n                     start = middle + 1;\n                 else\n                     end = middle - 1;\n             }\n         }\n         // Element is not present\n         return -1;\n     }\n }",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.searches.OrderAgnosticBinarySearch;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\npublic class OrderAgnosticBinarySearchTest {\n     @Test\n     //valid Test Case\n     public void ElementInMiddle() {\n         int[] arr = {10, 20, 30, 40, 50};\n         int answer = OrderAgnosticBinarySearch.BinSearchAlgo(arr, 0, arr.length - 1, 30);\n         System.out.println(answer);\n         int expected = 2;\n         assertEquals(expected, answer);\n     }\n\n     @Test\n     //valid Test Case\n     public void RightHalfDescOrder() {\n         int[] arr = {50, 40, 30, 20, 10};\n         int answer = OrderAgnosticBinarySearch.BinSearchAlgo(arr, 0, arr.length - 1, 10);\n         System.out.println(answer);\n         int expected = 4;\n         assertEquals(expected, answer);\n     }\n\n     @Test\n     //valid test case\n     public void LeftHalfDescOrder() {\n         int[] arr = {50, 40, 30, 20, 10};\n         int answer = OrderAgnosticBinarySearch.BinSearchAlgo(arr, 0, arr.length - 1, 50);\n         System.out.println(answer);\n         int expected = 0;\n         assertEquals(expected, answer);\n     }\n\n     @Test\n     //valid test case\n     public void RightHalfAscOrder() {\n         int[] arr = {10, 20, 30, 40, 50};\n         int answer = OrderAgnosticBinarySearch.BinSearchAlgo(arr, 0, arr.length - 1, 50);\n         System.out.println(answer);\n         int expected = 4;\n         assertEquals(expected, answer);\n     }\n\n     @Test\n     //valid test case\n     public void LeftHalfAscOrder() {\n         int[] arr = {10, 20, 30, 40, 50};\n         int answer = OrderAgnosticBinarySearch.BinSearchAlgo(arr, 0, arr.length - 1, 10);\n         System.out.println(answer);\n         int expected = 0;\n         assertEquals(expected, answer);\n     }\n\n     @Test\n     //valid test case\n     public void ElementNotFound() {\n         int[] arr = {10, 20, 30, 40, 50};\n         int answer = OrderAgnosticBinarySearch.BinSearchAlgo(arr, 0, arr.length - 1, 100);\n         System.out.println(answer);\n         int expected = -1;\n         assertEquals(expected, answer);\n     }\n }"
    },
    {
        "product_commit": "3f7e4d3f8f034aa31f3c8c74fab8320cdf87bad1",
        "test_commit": "3f7e4d3f8f034aa31f3c8c74fab8320cdf87bad1",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/TimSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/TimSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\n/**\n * @author [Hemanth Kotagiri](https://github.com/hemanth-kotagiri)\n * @see [Tim Sort](https://en.wikipedia.org/wiki/Tim_sort)\n */\nclass TimSort {\n\n    int array[];\n    int array_length;\n    int RUN = 32;\n\n    /**\n     * @brief A constructor which takes in the array specified by the user.\n     * @param array : Array given by the user.\n     */\n    public TimSort(int[] array) {\n        this.array = array;\n        this.array_length = array.length;\n    }\n\n    /**\n     * @brief A constructor which takes in an array length and randomly\n     * initializes an array.\n     * @param array_length length given by the user.\n     */\n    public TimSort(int array_length) {\n        Random rand = new Random();\n\n        this.array_length = array_length;\n        this.array = new int[this.array_length];\n\n        for (int i = 0; i < this.array_length; i++) {\n            int random_number = rand.nextInt(1000);\n            this.array[i] = random_number;\n        }\n    }\n\n    /**\n     * @brief A method to change the size of the run.\n     * @param run : Value specified by the user to change the run.\n     */\n    public void change_run(int run) {\n        this.RUN = run;\n    }\n\n    /**\n     * @brief A default constructor when no parameters are given. Initializes\n     * the array length to be 100. Generates a random number array of size 100.\n     */\n    public TimSort() {\n        this.array_length = 100;\n        this.array = new int[this.array_length];\n\n        Random rand = new Random();\n        for (int i = 0; i < this.array_length; i++) {\n            int random_number = rand.nextInt(1000);\n            this.array[i] = random_number;\n        }\n    }\n\n    /**\n     * @brief Performs Insertion Sort Algorithm on given array with bounded\n     * indices.\n     * @param array: The array on which the algorithm is to be performed.\n     * @param start_idx: The starting index from which the algorithm is to be\n     * performed.\n     * @param end_idx: The ending index at which the algorithm needs to stop\n     * sorting.\n     */\n    public void insertion_sort(int[] array, int start_idx, int end_idx) {\n        for (int i = start_idx; i <= end_idx; i++) {\n            int current_element = array[i];\n            int j = i - 1;\n            while (j >= start_idx && array[j] > current_element) {\n                array[j + 1] = array[j];\n                j--;\n            }\n            array[j + 1] = current_element;\n        }\n    }\n\n    /**\n     * @brief A method to merge two runs(chunks of array).\n     * @param array: The origin array which is to be sorted.\n     * @param start: Starting index of the first run(chunk).\n     * @param mid: The ending index of the first run(chunk).\n     * @param end: Ending index of the second run(chunk).\n     */\n    public void merge_runs(int array[], int start, int mid, int end) {\n        int first_array_size = mid - start + 1, second_array_size = end - mid;\n        int array1[] = new int[first_array_size], array2[] = new int[second_array_size];\n        int i = 0, j = 0, k = 0;\n\n        // Building the two sub arrays from the array to merge later\n        for (i = 0; i < first_array_size; i++) {\n            array1[i] = array[start + i];\n        }\n        for (i = 0; i < second_array_size; i++) {\n            array2[i] = array[mid + 1 + i];\n        }\n\n        i = 0;\n        j = 0;\n        k = start;\n\n        while (i < first_array_size && j < second_array_size) {\n            if (array1[i] <= array2[j]) {\n                array[k] = array1[i];\n                i++;\n            } else {\n                array[k] = array2[j];\n                j++;\n            }\n            k++;\n        }\n\n        while (i < first_array_size) {\n            array[k] = array1[i];\n            k++;\n            i++;\n        }\n\n        while (j < second_array_size) {\n            array[k] = array2[j];\n            k++;\n            j++;\n        }\n    }\n\n    /**\n     * @brief Tim Sort Algorithm method.\n     */\n    public void algorithm() {\n        // Before Sorting\n        System.out.println(\"Before sorting the array: \");\n        this.showArrayElements();\n        System.out.println();\n\n        // Applying insertion sort on RUNS.\n        for (int i = 0; i < this.array_length; i += this.RUN) {\n            this.insertion_sort(\n                    this.array,\n                    i,\n                    Math.min(i + this.RUN, (this.array_length - 1))\n                );\n        }\n\n        for (\n            int split = this.RUN;\n            split < this.array_length;\n            split = 2 * split\n        ) {\n            for (\n                int start_idx = 0;\n                start_idx < this.array_length;\n                start_idx += 2 * split\n            ) {\n                int mid = start_idx + split - 1;\n                int end_idx = Math.min(\n                    (start_idx + 2 * split - 1),\n                    (this.array_length - 1)\n                );\n\n                this.merge_runs(this.array, start_idx, mid, end_idx);\n            }\n        }\n        // After sorting\n        System.out.println(\"After sorting the array: \");\n        this.showArrayElements();\n        System.out.println();\n    }\n\n    /**\n     * @brief A method to show the elements inside the array.\n     */\n    public void showArrayElements() {\n        for (int i = 0; i < this.array.length; i++) {\n            System.out.print(this.array[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    /**\n     * @brief A method to test the sorting algorithm\n     */\n    static void test() {\n        int[] array = { 4, 1, 3, 17, 12, 11, 8 };\n        TimSort sorterObj1 = new TimSort();\n        TimSort sorterObj2 = new TimSort(50);\n        TimSort sorterObj3 = new TimSort(array);\n\n        sorterObj1.algorithm();\n        sorterObj2.algorithm();\n        sorterObj3.algorithm();\n\n        // Testing the first array\n        for (int i = 0; i < sorterObj1.array_length - 1; i++) {\n            assert (\n                (sorterObj1.array[i] <= sorterObj1.array[i + 1])\n            ) : \"Array is not sorted\";\n        }\n\n        // Testing the second array.\n        for (int i = 0; i < sorterObj2.array_length - 1; i++) {\n            assert (\n                (sorterObj2.array[i] <= sorterObj2.array[i + 1])\n            ) : \"Array is not sorted\";\n        }\n\n        // Testing the third array.\n        for (int i = 0; i < sorterObj3.array_length - 1; i++) {\n            assert (\n                (sorterObj3.array[i] <= sorterObj3.array[i + 1])\n            ) : \"Array is not sorted\";\n        }\n    }\n\n    public static void main(String[] args) {\n        test();\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\n\n/**\n * This is simplified TimSort algorithm implementation. The original one is more complicated.\n * <p>\n * For more details @see <a href=\"https://en.wikipedia.org/wiki/Timsort\">TimSort Algorithm</a>\n */\nclass TimSort implements SortAlgorithm {\n    private static final int SUB_ARRAY_SIZE = 32;\n    @SuppressWarnings(\"rawtypes\")\n    private static Comparable[] aux;\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] a) {\n        int n = a.length;\n\n        InsertionSort insertionSort = new InsertionSort();\n        for (int i = 0; i < n; i += SUB_ARRAY_SIZE) {\n            insertionSort.sort(a, i, Math.min(i + SUB_ARRAY_SIZE, n));\n        }\n\n        aux = new Comparable[n];\n        for (int sz = SUB_ARRAY_SIZE; sz < n; sz = sz + sz) {\n            for (int lo = 0; lo < n - sz; lo += sz + sz) {\n                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, n - 1));\n            }\n        }\n\n        return a;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends Comparable<T>> void merge(T[] a, int lo, int mid, int hi) {\n        int i = lo, j = mid + 1;\n        System.arraycopy(a, lo, aux, lo, hi + 1 - lo);\n\n        for (int k = lo; k <= hi; k++) {\n            if (j > hi) {\n                a[k] = (T) aux[i++];\n            } else if (i > mid) {\n                a[k] = (T) aux[j++];\n            } else if (less(aux[j], aux[i])) {\n                a[k] = (T) aux[j++];\n            } else {\n                a[k] = (T) aux[i++];\n            }\n        }\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass TimSortTest {\n\n    private TimSort timSort;\n\n    @BeforeEach\n    void setUp() {\n        timSort = new TimSort();\n    }\n\n    @Test\n    void shouldAcceptWhenEmptyArrayIsPassed() {\n        Integer [] array = new Integer[]{};\n        Integer [] expected = new Integer[]{};\n\n        Integer []sorted = timSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenSingleValuedArrayIsPassed() {\n        Integer [] array = new Integer[]{2};\n        Integer [] expected = new Integer[]{2};\n\n        Integer [] sorted = timSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllPositiveValuesIsPassed() {\n        Integer [] array = new Integer[]{60, 7, 55, 9, 999, 3};\n        Integer [] expected = new Integer[]{3, 7, 9, 55, 60, 999};\n\n        Integer [] sorted = timSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllNegativeValuesIsPassed() {\n        Integer [] array = new Integer[]{-60, -7, -55, -9, -999, -3};\n        Integer [] expected = new Integer[]{-999, -60, -55, -9, -7, -3};\n\n        Integer [] sorted = timSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithRealNumberValuesIsPassed() {\n        Integer [] array = new Integer[]{60, -7, 55, 9, -999, -3};\n        Integer [] expected = new Integer[]{-999, -7, -3, 9, 55, 60};\n\n        Integer [] sorted = timSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithDuplicateValueIsPassed() {\n        Integer [] array = new Integer[]{60, 7, 55, 55, 999, 3};\n        Integer [] expected = new Integer[]{3, 7, 55, 55, 60, 999};\n\n        Integer [] sorted = timSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenStringValueArrayIsPassed() {\n        String[] array = {\"z\", \"a\", \"x\", \"b\", \"y\"};\n        String[] expected = {\"a\", \"b\", \"x\", \"y\", \"z\"};\n\n        String[] sorted = timSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenRandomArrayIsPassed() {\n        int randomSize = SortUtilsRandomGenerator.generateInt(10_000);\n        Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);\n        Double[] sorted = timSort.sort(array);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n}"
    },
    {
        "product_commit": "6c9090ffed0b6b0ca85f13f04e7344160d81a572",
        "test_commit": "6c9090ffed0b6b0ca85f13f04e7344160d81a572",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BucketSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BucketSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Bucket_sort\n */\npublic class BucketSort {\n\n    public static void main(String[] args) {\n        int[] arr = new int[10];\n\n        /* generate 10 random numbers from -50 to 49 */\n        Random random = new Random();\n        for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random.nextInt(100) - 50;\n        }\n\n        bucketSort(arr);\n\n        /* check array is sorted or not */\n        for (int i = 0, limit = arr.length - 1; i < limit; ++i) {\n            assert arr[i] <= arr[i + 1];\n        }\n    }\n\n    /**\n     * BucketSort algorithms implements\n     *\n     * @param arr the array contains elements\n     */\n    private static void bucketSort(int[] arr) {\n        /* get max value of arr */\n        int max = max(arr);\n\n        /* get min value of arr */\n        int min = min(arr);\n\n        /* number of buckets */\n        int numberOfBuckets = max - min + 1;\n\n        List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);\n\n        /* init buckets */\n        for (int i = 0; i < numberOfBuckets; ++i) {\n            buckets.add(new ArrayList<>());\n        }\n\n        /* store elements to buckets */\n        for (int value : arr) {\n            int hash = hash(value, min, numberOfBuckets);\n            buckets.get(hash).add(value);\n        }\n\n        /* sort individual bucket */\n        for (List<Integer> bucket : buckets) {\n            Collections.sort(bucket);\n        }\n\n        /* concatenate buckets to origin array */\n        int index = 0;\n        for (List<Integer> bucket : buckets) {\n            for (int value : bucket) {\n                arr[index++] = value;\n            }\n        }\n    }\n\n    /**\n     * Get index of bucket which of our elements gets placed into it.\n     *\n     * @param elem the element of array to be sorted\n     * @param min min value of array\n     * @param numberOfBucket the number of bucket\n     * @return index of bucket\n     */\n    private static int hash(int elem, int min, int numberOfBucket) {\n        return (elem - min) / numberOfBucket;\n    }\n\n    /**\n     * Calculate max value of array\n     *\n     * @param arr the array contains elements\n     * @return max value of given array\n     */\n    public static int max(int[] arr) {\n        int max = arr[0];\n        for (int value : arr) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Calculate min value of array\n     *\n     * @param arr the array contains elements\n     * @return min value of given array\n     */\n    public static int min(int[] arr) {\n        int min = arr[0];\n        for (int value : arr) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Bucket_sort\n */\npublic class BucketSort {\n\n    public static void main(String[] args) {\n        int[] arr = new int[10];\n\n        /* generate 10 random numbers from -50 to 49 */\n        Random random = new Random();\n        for (int i = 0; i < arr.length; ++i) {\n            arr[i] = random.nextInt(100) - 50;\n        }\n\n        bucketSort(arr);\n\n        /* check array is sorted or not */\n        for (int i = 0, limit = arr.length - 1; i < limit; ++i) {\n            assert arr[i] <= arr[i + 1];\n        }\n    }\n\n    /**\n     * BucketSort algorithms implements\n     *\n     * @param arr the array contains elements\n     */\n    public static int[] bucketSort(int[] arr) {\n        /* get max value of arr */\n        int max = max(arr);\n\n        /* get min value of arr */\n        int min = min(arr);\n\n        /* number of buckets */\n        int numberOfBuckets = max - min + 1;\n\n        List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);\n\n        /* init buckets */\n        for (int i = 0; i < numberOfBuckets; ++i) {\n            buckets.add(new ArrayList<>());\n        }\n\n        /* store elements to buckets */\n        for (int value : arr) {\n            int hash = hash(value, min, numberOfBuckets);\n            buckets.get(hash).add(value);\n        }\n\n        /* sort individual bucket */\n        for (List<Integer> bucket : buckets) {\n            Collections.sort(bucket);\n        }\n\n        /* concatenate buckets to origin array */\n        int index = 0;\n        for (List<Integer> bucket : buckets) {\n            for (int value : bucket) {\n                arr[index++] = value;\n            }\n        }\n        \n        return arr;\n    }\n\n    /**\n     * Get index of bucket which of our elements gets placed into it.\n     *\n     * @param elem the element of array to be sorted\n     * @param min min value of array\n     * @param numberOfBucket the number of bucket\n     * @return index of bucket\n     */\n    private static int hash(int elem, int min, int numberOfBucket) {\n        return (elem - min) / numberOfBucket;\n    }\n\n    /**\n     * Calculate max value of array\n     *\n     * @param arr the array contains elements\n     * @return max value of given array\n     */\n    public static int max(int[] arr) {\n        int max = arr[0];\n        for (int value : arr) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Calculate min value of array\n     *\n     * @param arr the array contains elements\n     * @return min value of given array\n     */\n    public static int min(int[] arr) {\n        int min = arr[0];\n        for (int value : arr) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BucketSortTest {\n\n    @Test\n    public void bucketSortSingleIntegerArray() {\n        int[] inputArray = { 4 };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortNonDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 99, 27, 15, 23, 36 };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 27, 36, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 27, 15, 23, 27, 36, 23 };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 23, 27, 27, 36};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortNonDuplicateIntegerArrayWithNegativeNum() {\n        int[] inputArray = {  6, -1, 99, 27, -15, 23, -36  };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = { -36, -15, -1, 6, 23, 27, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bucketSortDuplicateIntegerArrayWithNegativeNum() {\n        int[] inputArray = { 6, -1, 27, -15, 23, 27, -36, 23  };\n        int[] outputArray = BucketSort.bucketSort(inputArray);\n        int[] expectedOutput = { -36, -15, -1, 6, 23, 23, 27, 27};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "7692e8f47dda31167ef27fc478c8617a67418d3c",
        "test_commit": "7692e8f47dda31167ef27fc478c8617a67418d3c",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/HeapSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/HeapSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Heap Sort Algorithm Implements MinHeap\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\npublic class HeapSort implements SortAlgorithm {\n\n    private static class Heap<T extends Comparable<T>> {\n\n        /**\n         * Array to store heap\n         */\n        private T[] heap;\n\n        /**\n         * Constructor\n         *\n         * @param heap array of unordered integers\n         */\n        public Heap(T[] heap) {\n            this.heap = heap;\n        }\n\n        /**\n         * Heapifies subtree from top as root to last as last child\n         *\n         * @param rootIndex index of root\n         * @param lastChild index of last child\n         */\n        private void heapSubtree(int rootIndex, int lastChild) {\n            int leftIndex = rootIndex * 2 + 1;\n            int rightIndex = rootIndex * 2 + 2;\n            T root = heap[rootIndex];\n            if (rightIndex <= lastChild) { // if has right and left children\n                T left = heap[leftIndex];\n                T right = heap[rightIndex];\n                if (less(left, right) && less(left, root)) {\n                    swap(heap, leftIndex, rootIndex);\n                    heapSubtree(leftIndex, lastChild);\n                } else if (less(right, root)) {\n                    swap(heap, rightIndex, rootIndex);\n                    heapSubtree(rightIndex, lastChild);\n                }\n            } else if (leftIndex <= lastChild) { // if no right child, but has left child\n                T left = heap[leftIndex];\n                if (less(left, root)) {\n                    swap(heap, leftIndex, rootIndex);\n                    heapSubtree(leftIndex, lastChild);\n                }\n            }\n        }\n\n        /**\n         * Makes heap with root as root\n         *\n         * @param root index of root of heap\n         */\n        private void makeMinHeap(int root) {\n            int leftIndex = root * 2 + 1;\n            int rightIndex = root * 2 + 2;\n            boolean hasLeftChild = leftIndex < heap.length;\n            boolean hasRightChild = rightIndex < heap.length;\n            if (hasRightChild) { // if has left and right\n                makeMinHeap(leftIndex);\n                makeMinHeap(rightIndex);\n                heapSubtree(root, heap.length - 1);\n            } else if (hasLeftChild) {\n                heapSubtree(root, heap.length - 1);\n            }\n        }\n\n        /**\n         * Gets the root of heap\n         *\n         * @return root of heap\n         */\n        private T getRoot(int size) {\n            swap(heap, 0, size);\n            heapSubtree(0, size - 1);\n            return heap[size]; // return old root\n        }\n    }\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return sort(Arrays.asList(unsorted)).toArray(unsorted);\n    }\n\n    @Override\n    public <T extends Comparable<T>> List<T> sort(List<T> unsorted) {\n        int size = unsorted.size();\n\n        @SuppressWarnings(\"unchecked\")\n        Heap<T> heap = new Heap<>(\n            unsorted.toArray((T[]) new Comparable[unsorted.size()])\n        );\n\n        heap.makeMinHeap(0); // make min heap using index 0 as root.\n        List<T> sorted = new ArrayList<>(size);\n        while (size > 0) {\n            T min = heap.getRoot(--size);\n            sorted.add(min);\n        }\n\n        return sorted;\n    }\n\n    /**\n     * Main method\n     *\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Integer[] heap = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        HeapSort heapSort = new HeapSort();\n        print(heapSort.sort(heap));\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * Heap Sort Algorithm Implementation\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Heapsort\">Heap Sort Algorithm</a>\n */\npublic class HeapSort implements SortAlgorithm {\n\n    /**\n     * For simplicity, we are considering the heap root index as 1 instead of 0.\n     * It simplifies future calculations. Because of that we are decreasing the\n     * provided indexes by 1 in {@link #swap(Object[], int, int)} and\n     * {@link #less(Comparable[], int, int)} functions.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        int n = unsorted.length;\n        heapify(unsorted, n);\n        while (n > 1) {\n            swap(unsorted, 1, n--);\n            siftDown(unsorted, 1, n);\n        }\n        return unsorted;\n    }\n\n    private static <T extends Comparable<T>> void heapify(T[] unsorted, int n) {\n        for (int k = n / 2; k >= 1; k--) {\n            siftDown(unsorted, k, n);\n        }\n    }\n\n    private static <T extends Comparable<T>> void siftDown(T[] unsorted, int k, int n) {\n        while (2 * k <= n) {\n            int j = 2 * k;\n            if (j < n && less(unsorted, j, j + 1)) {\n                j++;\n            }\n            if (!less(unsorted, k, j)) {\n                break;\n            }\n            swap(unsorted, k, j);\n            k = j;\n        }\n    }\n\n    private static <T> void swap(T[] array, int idx, int idy) {\n        T swap = array[idx - 1];\n        array[idx - 1] = array[idy - 1];\n        array[idy - 1] = swap;\n    }\n\n    private static <T extends Comparable<T>> boolean less(T[] array, int idx, int idy) {\n        return array[idx - 1].compareTo(array[idy - 1]) < 0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HeapSortTest {\n\t\n\tprivate HeapSort heapSort = new HeapSort();\n\t\n\t@Test\n    void testHeapSortCase1() {\n        Integer[] array = { 49, 4, 36, 9, 144, 1 };\n        Integer[] sorted = heapSort.sort(array);\n        Integer[] expected = { 1, 4, 9, 36, 49, 144 };\n        assertArrayEquals(expected, sorted);\n    }\n\t\n\t@Test\n    void testHeapSortCase2() {\n        Integer[] array = { };\n        Integer[] sorted = heapSort.sort(array);\n        Integer[] expected = { };\n        assertArrayEquals(expected, sorted);\n    }\n\t\n\t@Test\n    void testHeapSortCase3 () {\n        Integer[] array = { -3, 5, 3, 4, 3, 7, 40, -20, 30, 0 };\n        Integer[] sorted = heapSort.sort(array);\n        Integer[] expected = { -20, -3, 0, 3, 3, 4, 5, 7, 30, 40 };\n        assertArrayEquals(expected, sorted);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HeapSortTest {\n    private HeapSort heapSort;\n\n    @BeforeEach\n    void setUp() {\n        heapSort = new HeapSort();\n    }\n\n    @Test\n    void shouldAcceptWhenEmptyArrayIsPassed() {\n        Integer[] array = new Integer[]{};\n        Integer[] expected = new Integer[]{};\n\n        Integer[] sorted = heapSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenSingleValuedArrayIsPassed() {\n        Integer[] array = new Integer[]{2};\n        Integer[] expected = new Integer[]{2};\n\n        Integer[] sorted = heapSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllPositiveValuesIsPassed() {\n        Integer[] array = new Integer[]{60, 7, 55, 9, 999, 3};\n        Integer[] expected = new Integer[]{3, 7, 9, 55, 60, 999};\n\n        Integer[] sorted = heapSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllNegativeValuesIsPassed() {\n        Integer[] array = new Integer[]{-60, -7, -55, -9, -999, -3};\n        Integer[] expected = new Integer[]{-999, -60, -55, -9, -7, -3};\n\n        Integer[] sorted = heapSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithRealNumberValuesIsPassed() {\n        Integer[] array = new Integer[]{60, -7, 55, 9, -999, -3};\n        Integer[] expected = new Integer[]{-999, -7, -3, 9, 55, 60};\n\n        Integer[] sorted = heapSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithDuplicateValueIsPassed() {\n        Integer[] array = new Integer[]{60, 7, 55, 55, 999, 3};\n        Integer[] expected = new Integer[]{3, 7, 55, 55, 60, 999};\n\n        Integer[] sorted = heapSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenStringValueArrayIsPassed() {\n        String[] array = {\"z\", \"a\", \"x\", \"b\", \"y\"};\n        String[] expected = {\"a\", \"b\", \"x\", \"y\", \"z\"};\n\n        String[] sorted = heapSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenRandomArrayIsPassed() {\n        int randomSize = SortUtilsRandomGenerator.generateInt(10_000);\n        Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);\n        Double[] sorted = heapSort.sort(array);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n}"
    },
    {
        "product_commit": "72468cc707d72ff353efaeecd35b8615076f192a",
        "test_commit": "72468cc707d72ff353efaeecd35b8615076f192a",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/MergeSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/MergeSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * Generic merge sort algorithm.\n *\n * @see SortAlgorithm\n */\nclass MergeSort implements SortAlgorithm {\n\n    /**\n     * Generic merge sort algorithm implements.\n     *\n     * @param unsorted the array which should be sorted.\n     * @param <T> Comparable class.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        doSort(unsorted, 0, unsorted.length - 1);\n        return unsorted;\n    }\n\n    /**\n     * @param arr the array to be sorted.\n     * @param left the first index of the array.\n     * @param right the last index of the array.\n     */\n    private static <T extends Comparable<T>> void doSort(\n        T[] arr,\n        int left,\n        int right\n    ) {\n        if (left < right) {\n            int mid = (left + right) >>> 1;\n            doSort(arr, left, mid);\n            doSort(arr, mid + 1, right);\n            merge(arr, left, mid, right);\n        }\n    }\n\n    /**\n     * Merges two parts of an array.\n     *\n     * @param arr the array to be merged.\n     * @param left the first index of the array.\n     * @param mid the middle index of the array.\n     * @param right the last index of the array merges two parts of an array in\n     * increasing order.\n     */\n    private static <T extends Comparable<T>> void merge(\n        T[] arr,\n        int left,\n        int mid,\n        int right\n    ) {\n        int length = right - left + 1;\n        @SuppressWarnings(\"unchecked\")\n        T[] temp = (T[]) new Comparable[length];\n        int i = left;\n        int j = mid + 1;\n        int k = 0;\n\n        while (i <= mid && j <= right) {\n            if (arr[i].compareTo(arr[j]) <= 0) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n            }\n        }\n\n        while (i <= mid) {\n            temp[k++] = arr[i++];\n        }\n\n        while (j <= right) {\n            temp[k++] = arr[j++];\n        }\n\n        System.arraycopy(temp, 0, arr, left, length);\n    }\n\n    /**\n     * Driver code\n     */\n    public static void main(String[] args) {\n        MergeSort mergeSort = new MergeSort();\n\n        Integer[] arr = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        mergeSort.sort(arr);\n        for (int i = 0; i < arr.length - 1; ++i) {\n            assert arr[i] <= arr[i + 1];\n        }\n\n        String[] stringArray = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        mergeSort.sort(stringArray);\n        for (int i = 0; i < stringArray.length - 1; ++i) {\n            assert arr[i].compareTo(arr[i + 1]) <= 0;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\n\n/**\n * Generic merge sort algorithm.\n *\n * @see SortAlgorithm\n */\nclass MergeSort implements SortAlgorithm {\n\n    @SuppressWarnings(\"rawtypes\")\n    private static Comparable[] aux;\n\n    /**\n     * Generic merge sort algorithm implements.\n     *\n     * @param unsorted the array which should be sorted.\n     * @param <T> Comparable class.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        aux = new Comparable[unsorted.length];\n        doSort(unsorted, 0, unsorted.length - 1);\n        return unsorted;\n    }\n\n    /**\n     * @param arr the array to be sorted.\n     * @param left the first index of the array.\n     * @param right the last index of the array.\n     */\n    private static <T extends Comparable<T>> void doSort(T[] arr, int left, int right) {\n        if (left < right) {\n            int mid = (left + right) >>> 1;\n            doSort(arr, left, mid);\n            doSort(arr, mid + 1, right);\n            merge(arr, left, mid, right);\n        }\n    }\n\n    /**\n     * Merges two parts of an array.\n     *\n     * @param arr the array to be merged.\n     * @param left the first index of the array.\n     * @param mid the middle index of the array.\n     * @param right the last index of the array merges two parts of an array in\n     * increasing order.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) {\n        int i = left, j = mid + 1;\n        System.arraycopy(arr, left, aux, left, right + 1 - left);\n\n        for (int k = left; k <= right; k++) {\n            if (j > right) {\n                arr[k] = (T) aux[i++];\n            } else if (i > mid) {\n                arr[k] = (T) aux[j++];\n            } else if (less(aux[j], aux[i])) {\n                arr[k] = (T) aux[j++];\n            } else {\n                arr[k] = (T) aux[i++];\n            }\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\npublic class MergeSortTest {\n\n    private static MergeSort mergeSort= new MergeSort();\n\n    @Test\n    void shouldAcceptWhenEmptyArrayIsPassed() {\n        Integer [] array = new Integer[]{};\n        Integer [] expected = new Integer[]{};\n\n        Integer []sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenSingleValuedArrayIsPassed() {\n        Integer [] array = new Integer[]{2};\n        Integer [] expected = new Integer[]{2};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllPositiveValuesIsPassed() {\n        Integer [] array = new Integer[]{60, 7, 55, 9, 999, 3};\n        Integer [] expected = new Integer[]{3, 7, 9, 55, 60, 999};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllNegativeValuesIsPassed() {\n        Integer [] array = new Integer[]{-60, -7, -55, -9, -999, -3};\n        Integer [] expected = new Integer[]{-999, -60, -55, -9, -7, -3};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithRealNumberValuesIsPassed() {\n        Integer [] array = new Integer[]{60, -7, 55, 9, -999, -3};\n        Integer [] expected = new Integer[]{-999, -7, -3, 9, 55, 60};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithDuplicateValueIsPassed() {\n        Integer [] array = new Integer[]{60, 7, 55, 55, 999, 3};\n        Integer [] expected = new Integer[]{3, 7, 55, 55, 60, 999};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenStringValueArrayIsPassed() {\n        String[] array = {\"z\", \"a\", \"x\", \"b\", \"y\"};\n        String[] expected = {\"a\", \"b\", \"x\", \"y\", \"z\"};\n\n        String[] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MergeSortTest {\n\n    private MergeSort mergeSort;\n\n    @BeforeEach\n    void setUp() {\n        mergeSort = new MergeSort();\n    }\n\n    @Test\n    void shouldAcceptWhenEmptyArrayIsPassed() {\n        Integer [] array = new Integer[]{};\n        Integer [] expected = new Integer[]{};\n\n        Integer []sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenSingleValuedArrayIsPassed() {\n        Integer [] array = new Integer[]{2};\n        Integer [] expected = new Integer[]{2};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllPositiveValuesIsPassed() {\n        Integer [] array = new Integer[]{60, 7, 55, 9, 999, 3};\n        Integer [] expected = new Integer[]{3, 7, 9, 55, 60, 999};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithAllNegativeValuesIsPassed() {\n        Integer [] array = new Integer[]{-60, -7, -55, -9, -999, -3};\n        Integer [] expected = new Integer[]{-999, -60, -55, -9, -7, -3};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithRealNumberValuesIsPassed() {\n        Integer [] array = new Integer[]{60, -7, 55, 9, -999, -3};\n        Integer [] expected = new Integer[]{-999, -7, -3, 9, 55, 60};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenArrayWithDuplicateValueIsPassed() {\n        Integer [] array = new Integer[]{60, 7, 55, 55, 999, 3};\n        Integer [] expected = new Integer[]{3, 7, 55, 55, 60, 999};\n\n        Integer [] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenStringValueArrayIsPassed() {\n        String[] array = {\"z\", \"a\", \"x\", \"b\", \"y\"};\n        String[] expected = {\"a\", \"b\", \"x\", \"y\", \"z\"};\n\n        String[] sorted = mergeSort.sort(array);\n\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void shouldAcceptWhenRandomArrayIsPassed() {\n        int randomSize = SortUtilsRandomGenerator.generateInt(10_000);\n        Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);\n        Double[] sorted = mergeSort.sort(array);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n}"
    },
    {
        "product_commit": "260f1b2beec7ef09b3d08aa1241e404e7ae409fa",
        "test_commit": "260f1b2beec7ef09b3d08aa1241e404e7ae409fa",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/KnapsackMemoization.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/KnapsackMemoizationTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport java.util.Arrays;\n\n/**\n * Recursive Solution for 0-1 knapsack with memoization\n */\npublic class KnapsackMemoization {\n\n    private static int[][] t;\n\n    // Returns the maximum value that can\n    // be put in a knapsack of capacity W\n    public static int knapsack(int[] wt, int[] value, int W, int n) {\n        if (t[n][W] != -1) {\n            return t[n][W];\n        }\n        if (n == 0 || W == 0) {\n            return 0;\n        }\n        if (wt[n - 1] <= W) {\n            t[n - 1][W - wt[n - 1]] = knapsack(wt, value, W - wt[n - 1], n - 1);\n            // Include item in the bag. In that case add the value of the item and call for the remaining items\n            int tmp1 = value[n - 1] + t[n - 1][W - wt[n - 1]];\n            // Don't include the nth item in the bag anl call for remaining item without reducing the weight\n            int tmp2 = knapsack(wt, value, W, n - 1);\n            t[n - 1][W] = tmp2;\n            // include the larger one\n            int tmp = tmp1 > tmp2 ? tmp1 : tmp2;\n            t[n][W] = tmp;\n            return tmp;\n            // If Weight for the item is more than the desired weight then don't include it\n            // Call for rest of the n-1 items\n        } else if (wt[n - 1] > W) {\n            t[n][W] = knapsack(wt, value, W, n - 1);\n            return t[n][W];\n        }\n        return -1;\n    }\n\n    // Driver code\n    public static void main(String args[]) {\n        int[] wt = { 1, 3, 4, 5 };\n        int[] value = { 1, 4, 5, 7 };\n        int W = 10;\n        t = new int[wt.length + 1][W + 1];\n        Arrays.stream(t).forEach(a -> Arrays.fill(a, -1));\n        int res = knapsack(wt, value, W, wt.length);\n        System.out.println(\"Maximum knapsack value \" + res);\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * Recursive Solution for 0-1 knapsack with memoization\n * This method is basically an extension to the recursive approach so that we\n * can overcome the problem of calculating redundant cases and thus increased\n * complexity. We can solve this problem by simply creating a 2-D array that can\n * store a particular state (n, w) if we get it the first time.\n */\npublic class KnapsackMemoization {\n\n    int knapSack(int W, int wt[], int val[], int N) {\n\n        // Declare the table dynamically\n        int dp[][] = new int[N + 1][W + 1];\n\n        // Loop to initially filled the\n        // table with -1\n        for (int i = 0; i < N + 1; i++) {\n            for (int j = 0; j < W + 1; j++) {\n                dp[i][j] = -1;\n            }\n        }\n\n        return knapSackRec(W, wt, val, N, dp);\n    }\n\n    // Returns the value of maximum profit using Recursive approach\n    int knapSackRec(int W, int wt[],\n            int val[], int n,\n            int[][] dp) {\n\n        // Base condition\n        if (n == 0 || W == 0) {\n            return 0;\n        }\n\n        if (dp[n][W] != -1) {\n            return dp[n][W];\n        }\n\n        if (wt[n - 1] > W) {\n            // Store the value of function call stack in table\n            dp[n][W] = knapSackRec(W, wt, val, n - 1, dp);\n            return dp[n][W];\n        } else {\n            // Return value of table after storing\n            return dp[n][W] = Math.max((val[n - 1] + knapSackRec(W - wt[n - 1], wt, val, n - 1, dp)),\n                    knapSackRec(W, wt, val, n - 1, dp));\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KnapsackMemoizationTest {\n\n    KnapsackMemoization knapsackMemoization = new KnapsackMemoization();\n\n    @Test\n    void Test1() {\n        int[] weight = { 1, 3, 4, 5 };\n        int[] value = { 1, 4, 5, 7 };\n        int capacity = 10;\n        assertEquals(13, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test2() {\n        int[] weight = { 95, 4, 60, 32, 23, 72, 80, 62, 65, 46 };\n        int[] value = { 55, 10, 47, 5, 4, 50, 8, 61, 85, 87 };\n        int capacity = 269;\n        assertEquals(295, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n    @Test\n    void Test3() {\n        int[] weight = { 10, 20, 30 };\n        int[] value = { 60, 100, 120 };\n        int capacity = 50;\n        assertEquals(220, knapsackMemoization.knapSack(capacity, weight, value, weight.length));\n    }\n\n}"
    },
    {
        "product_commit": "f7dee0d958177f31b7de104dec6a789bc2a850d7",
        "test_commit": "f7dee0d958177f31b7de104dec6a789bc2a850d7",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/MergeSortRecursive.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/MergeSortRecursiveTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MergeSortRecursive {\n\n    List<Integer> arr;\n\n    public MergeSortRecursive(List<Integer> arr) {\n        this.arr = arr;\n    }\n\n    public void mergeSort() {\n        List<Integer> arrSorted = merge(arr);\n        System.out.println(arrSorted);\n    }\n\n    private static List<Integer> merge(List<Integer> arr) {\n        // base condition\n        if (arr.size() <= 1) {\n            return arr;\n        }\n\n        int arrLength = arr.size();\n        int half = arrLength / 2;\n        List<Integer> arrA = arr.subList(0, half);\n        List<Integer> arrB = arr.subList(half, arr.size());\n\n        // recursion\n        arrA = merge(arrA);\n        arrB = merge(arrB);\n\n        return sort(arrA, arrB);\n    }\n\n    private static List<Integer> sort(\n        List<Integer> unsortedA,\n        List<Integer> unsortedB\n    ) {\n        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {\n            return new ArrayList<>();\n        }\n        if (unsortedA.size() <= 0) {\n            return unsortedB;\n        }\n        if (unsortedB.size() <= 0) {\n            return unsortedA;\n        }\n        if (unsortedA.get(0) <= unsortedB.get(0)) {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                {\n                    add(unsortedA.get(0));\n                }\n            };\n            newAl.addAll(\n                sort(unsortedA.subList(1, unsortedA.size()), unsortedB)\n            );\n            return newAl;\n        } else {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                {\n                    add(unsortedB.get(0));\n                }\n            };\n            newAl.addAll(\n                sort(unsortedA, unsortedB.subList(1, unsortedB.size()))\n            );\n            return newAl;\n        }\n    }\n}\n\nclass App {\n\n    public static void main(String[] args) {\n        MergeSortRecursive sort = new MergeSortRecursive(\n            new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9))\n        );\n        sort.mergeSort();\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MergeSortRecursive {\n\n    List<Integer> arr;\n\n    public MergeSortRecursive(List<Integer> arr) {\n        this.arr = arr;\n    }\n\n    public List<Integer> mergeSort() {\n        List<Integer> arrSorted = merge(arr);\n        return arrSorted;\n    }\n\n    private static List<Integer> merge(List<Integer> arr) {\n        // base condition\n        if (arr.size() <= 1) {\n            return arr;\n        }\n\n        int arrLength = arr.size();\n        int half = arrLength / 2;\n        List<Integer> arrA = arr.subList(0, half);\n        List<Integer> arrB = arr.subList(half, arr.size());\n\n        // recursion\n        arrA = merge(arrA);\n        arrB = merge(arrB);\n\n        return sort(arrA, arrB);\n    }\n\n    private static List<Integer> sort(\n        List<Integer> unsortedA,\n        List<Integer> unsortedB\n    ) {\n        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {\n            return new ArrayList<>();\n        }\n        if (unsortedA.size() <= 0) {\n            return unsortedB;\n        }\n        if (unsortedB.size() <= 0) {\n            return unsortedA;\n        }\n        if (unsortedA.get(0) <= unsortedB.get(0)) {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                {\n                    add(unsortedA.get(0));\n                }\n            };\n            newAl.addAll(\n                sort(unsortedA.subList(1, unsortedA.size()), unsortedB)\n            );\n            return newAl;\n        } else {\n            List<Integer> newAl = new ArrayList<Integer>() {\n                {\n                    add(unsortedB.get(0));\n                }\n            };\n            newAl.addAll(\n                sort(unsortedA, unsortedB.subList(1, unsortedB.size()))\n            );\n            return newAl;\n        }\n    }\n}\n\nclass App {\n\n    public static void main(String[] args) {\n        MergeSortRecursive sort = new MergeSortRecursive(\n            new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9))\n        );\n        sort.mergeSort();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MergeSortRecursiveTest {\n\t\n//\tprivate MergeSortRecursive mergeSortRecursive = new MergeSortRecursive();\n\t\n\t@Test\n\tvoid testMergeSortRecursiveCase1 () {\n\t\tMergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(5, 12, 9, 3, 15, 88));\n\t\t\n\t\tList<Integer> expected = Arrays.asList(3, 5, 9, 12, 15, 88);\n\t\tList<Integer> sorted = mergeSortRecursive.mergeSort();\n\t\t\n\t\tassertEquals(expected, sorted);\n\t}\n\t\n\t@Test\n\tvoid testMergeSortRecursiveCase2 () {\n\t\tMergeSortRecursive mergeSortRecursive = new MergeSortRecursive(Arrays.asList(-3, 5, 3, 4, 3, 7, 40, -20, 30, 0));\n\t\t\n\t\tList<Integer> expected = Arrays.asList(-20, -3, 0, 3, 3, 4, 5, 7, 30, 40);\n\t\tList<Integer> sorted = mergeSortRecursive.mergeSort();\n\t\t\n\t\tassertEquals(expected, sorted);\n\t}\n\n}"
    },
    {
        "product_commit": "b294ddcb381ccbf84e8190717fa2aad8cc9ed8da",
        "test_commit": "b294ddcb381ccbf84e8190717fa2aad8cc9ed8da",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AliquotSum.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AliquotSumTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    /**\n     * Finds the aliquot sum of an integer number.\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotValue(int number) {\n        var sumWrapper = new Object() {\n            int value = 0;\n        };\n\n        IntStream\n            .iterate(1, i -> ++i)\n            .limit(number / 2)\n            .filter(i -> number % i == 0)\n            .forEach(i -> sumWrapper.value += i);\n\n        return sumWrapper.value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    /**\n     * Finds the aliquot sum of an integer number.\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotValue(int number) {\n        var sumWrapper = new Object() {\n            int value = 0;\n        };\n\n        IntStream\n            .iterate(1, i -> ++i)\n            .limit(number / 2)\n            .filter(i -> number % i == 0)\n            .forEach(i -> sumWrapper.value += i);\n\n        return sumWrapper.value;\n    }\n    \n     /**\n     * Function to calculate the aliquot sum of an integer number\n     *\n     * @param n a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotSum(int n) {\n        if (n <= 0)\n            return -1;\n        int sum = 1;\n        double root = Math.sqrt(n);\n        /*\n         * We can get the factors after the root by dividing number by its factors\n         * before the root.\n         * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n         * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n         * Now by dividing 100 by each factor before 10 we get:\n         * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n         * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n         */\n        for (int i = 2; i <= root; i++) {\n            if (n % i == 0) {\n                sum += i + n / i;\n            }\n        }\n        // if n is a perfect square then its root was added twice in above loop, so subtracting root from sum\n        if (root == (int) root)\n            sum -= root;\n        return sum;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AliquotSumTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(0, AliquotSum.getAliquotValue(1));\n        assertEquals(6, AliquotSum.getAliquotValue(6));\n        assertEquals(9, AliquotSum.getAliquotValue(15));\n        assertEquals(1, AliquotSum.getAliquotValue(19));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AliquotSumTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(0, AliquotSum.getAliquotValue(1));\n        assertEquals(6, AliquotSum.getAliquotValue(6));\n        assertEquals(9, AliquotSum.getAliquotValue(15));\n        assertEquals(1, AliquotSum.getAliquotValue(19));\n        assertEquals(0, AliquotSum.getAliquotSum(1));\n        assertEquals(6, AliquotSum.getAliquotSum(6));\n        assertEquals(9, AliquotSum.getAliquotSum(15));\n        assertEquals(1, AliquotSum.getAliquotSum(19));\n    }\n}"
    },
    {
        "product_commit": "9cde14095c5c74e122502a643655ac760843ee19",
        "test_commit": "9cde14095c5c74e122502a643655ac760843ee19",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BreadthFirstSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.searches.DepthFirstSearch.Node;\nimport java.util.ArrayDeque;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Queue;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n */\npublic class BreadthFirstSearch {\n\n    public static Optional<Node> search(final Node node, final String name) {\n        if (node.getName().equals(name)) {\n            return Optional.of(node);\n        }\n\n        Queue<Node> queue = new ArrayDeque<>(node.getSubNodes());\n\n        while (!queue.isEmpty()) {\n            final Node current = queue.poll();\n\n            if (current.getName().equals(name)) {\n                return Optional.of(current);\n            }\n\n            queue.addAll(current.getSubNodes());\n\n            queue.remove();\n        }\n\n        return Optional.empty();\n    }\n\n    public static void assertThat(final Object actual, final Object expected) {\n        if (!Objects.equals(actual, expected)) {\n            throw new AssertionError(\n                String.format(\"expected=%s but was actual=%s\", expected, actual)\n            );\n        }\n    }\n\n    public static void main(final String[] args) {\n        final Node rootNode = new Node(\n            \"A\",\n            List.of(\n                new Node(\n                    \"B\",\n                    List.of(\n                        new Node(\"D\"),\n                        new Node(\"F\", List.of(new Node(\"H\"), new Node(\"I\")))\n                    )\n                ),\n                new Node(\"C\", List.of(new Node(\"G\"))),\n                new Node(\"E\")\n            )\n        );\n\n        {\n            final String expected = \"I\";\n\n            final Node result = search(rootNode, expected)\n                .orElseThrow(() -> new AssertionError(\"Node not found!\"));\n\n            assertThat(result.getName(), expected);\n        }\n\n        {\n            final String expected = \"G\";\n\n            final Node result = search(rootNode, expected)\n                .orElseThrow(() -> new AssertionError(\"Node not found!\"));\n\n            assertThat(result.getName(), expected);\n        }\n\n        {\n            final String expected = \"E\";\n\n            final Node result = search(rootNode, expected)\n                .orElseThrow(() -> new AssertionError(\"Node not found!\"));\n\n            assertThat(result.getName(), expected);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.searches.DepthFirstSearch.Node;\nimport java.util.ArrayDeque;\nimport java.util.Optional;\nimport java.util.Queue;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n */\npublic class BreadthFirstSearch {\n    public static Optional<Node> search(final Node node, final String name) {\n        if (node.getName().equals(name)) {\n            return Optional.of(node);\n        }\n\n        Queue<Node> queue = new ArrayDeque<>(node.getSubNodes());\n\n        while (!queue.isEmpty()) {\n            final Node current = queue.poll();\n\n            if (current.getName().equals(name)) {\n                return Optional.of(current);\n            }\n\n            queue.addAll(current.getSubNodes());\n        }\n\n        return Optional.empty();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BreadthFirstSearchTest {\n\n    private static final DepthFirstSearch.Node rootNode = new DepthFirstSearch.Node(\n            \"A\",\n            List.of(\n                    new DepthFirstSearch.Node(\n                            \"B\",\n                            List.of(\n                                    new DepthFirstSearch.Node(\"D\"),\n                                    new DepthFirstSearch.Node(\"F\", List.of(new DepthFirstSearch.Node(\"H\"), new DepthFirstSearch.Node(\"I\")))\n                            )\n                    ),\n                    new DepthFirstSearch.Node(\"C\", List.of(new DepthFirstSearch.Node(\"G\"))),\n                    new DepthFirstSearch.Node(\"E\")\n            )\n    );\n\n    @Test\n    void searchI() {\n        Optional<DepthFirstSearch.Node> Inode = BreadthFirstSearch.search(rootNode, \"I\");\n        assertTrue(Inode.isPresent());\n        assertEquals(Inode.get().getName(), \"I\");\n    }\n\n    @Test\n    void searchG() {\n        Optional<DepthFirstSearch.Node> Gnode = BreadthFirstSearch.search(rootNode, \"G\");\n        assertTrue(Gnode.isPresent());\n        assertEquals(Gnode.get().getName(), \"G\");\n    }\n\n    @Test\n    void searchE() {\n        Optional<DepthFirstSearch.Node> Enode = BreadthFirstSearch.search(rootNode, \"E\");\n        assertTrue(Enode.isPresent());\n        assertEquals(Enode.get().getName(), \"E\");\n    }\n}"
    },
    {
        "product_commit": "4990f791a6bb8ab7012635f75b318dd19c3bca55",
        "test_commit": "4990f791a6bb8ab7012635f75b318dd19c3bca55",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BeadSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BeadSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\n\n//BeadSort Algorithm(wikipedia) : https://en.wikipedia.org/wiki/Bead_sort\n//BeadSort can't sort negative number, Character, String. It can sort positive number only\n\npublic class BeadSort {\n    public int[] sort(int[] unsorted) {\n    int[] sorted = new int[unsorted.length];\n    int max = 0;\n    for(int i = 0; i < unsorted.length; i++) {\n    max = Math.max(max, unsorted[i]);\n    }\n\n    char[][] grid = new char[unsorted.length][max];\n    int[] count = new int[max];\n\n    for(int i = 0; i < unsorted.length; i++) {\n        for(int j = 0; j < max; j++) {\n            grid[i][j] = '-';\n         }\n     }\n\n    for(int i = 0; i < max; i++) {\n        count[i] = 0;\n    }\n\n        for(int i = 0; i < unsorted.length; i++) {\n            int k = 0;\n            for(int j = 0; j < (int) unsorted[i] ; j++) {\n                grid[count[max - k - 1]++][k] = '*';\n                k++;\n             }\n        }\n\n        for(int i = 0; i < unsorted.length; i++) {\n            int k = 0;\n            for(int j = 0; j < max && grid[unsorted.length - 1 - i][j] == '*'; j++) {\n                k++;\n            }\n            sorted[i] = k;\n        }\n        return sorted;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BeadSortTest {\n    //BeadSort can't sort negative number, Character, String. It can sort positive number only\n    private BeadSort beadSort = new BeadSort();\n    \n    @Test\n    public void beadSortEmptyArray() {\n        int[] inputArray = {};\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void beadSortSingleIntegerArray() {\n        int[] inputArray = { 4 };\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bogoSortNonDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 99, 27, 15, 23, 36 };\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 27, 36, 99};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n    \n    @Test\n    public void bogoSortDuplicateIntegerArray() {\n        int[] inputArray = { 6, 1, 27, 15, 23, 27, 36, 23 };\n        int[] outputArray = beadSort.sort(inputArray);\n        int[] expectedOutput = {1, 6, 15, 23, 23, 27, 27, 36};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "b8d6b1a9b07d4cc3e294ec12f5f57332b6bc404e",
        "test_commit": "b8d6b1a9b07d4cc3e294ec12f5f57332b6bc404e",
        "product_file_path": "src/main/java/com/thealgorithms/others/CRC16.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/CRC16Test.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\n\n/**\n * Generates a crc16 checksum for a given string \n */\npublic class CRC16 {\n\n    public static void main(String[] args) {\n        System.out.println(crc16(\"Hello World!\"));\n    }\n\n\tpublic static String crc16(String message) {\n\t\tint crc = 0xFFFF; // initial value\n\t\tint polynomial = 0x1021; // 0001 0000 0010 0001 (0, 5, 12)\n\t\tbyte[] bytes = message.getBytes();\n\n\t\tfor (byte b : bytes) {\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tboolean bit = ((b >> (7 - i) & 1) == 1);\n\t\t\t\tboolean c15 = ((crc >> 15 & 1) == 1);\n\t\t\t\tcrc <<= 1;\n\t\t\t\tif (c15 ^ bit)\n\t\t\t\t\tcrc ^= polynomial;\n\t\t\t}\n\t\t}\n\t\tcrc &= 0xffff;\n\t\treturn Integer.toHexString(crc).toUpperCase();\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass CRC16Test {\n\n    CRC16 crc = new CRC16();\n\n    @Test\n    void testCRC16() {\n        // given\n        String textToCRC16 = \"hacktoberfest!\";\n\n        // when\n        String resultCRC16 = crc.crc16(textToCRC16); // Algorithm CRC16-CCITT-FALSE\n\n        // then\n        assertEquals(\"10FC\", resultCRC16);\n    }\n\n}"
    },
    {
        "product_commit": "b75dce17c38e73dc6dfba06ceba96619d09a46ea",
        "test_commit": "b75dce17c38e73dc6dfba06ceba96619d09a46ea",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SquareFreeInteger.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SquareFreeIntegerTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n/*\n * Java program for Square free integer\n * This class has a function which checks \n * if an integer has repeated prime factors\n * and will return false if the number has repeated prime factors.\n * true otherwise\n * Wikipedia: https://en.wikipedia.org/wiki/Square-free_integer\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class SquareFreeInteger {\n    /**\n     * This method returns whether an integer is square free\n     *\n     * @param number Integer value which is to be checked\n     * @return false when number has repeated prime factors\n     *         true when number has non repeated prime factors\n     * @throws IllegalArgumentException when number is negative or zero\n     */\n\tpublic static boolean isSquareFreeInteger(int number) {\n\t\t\n\t\tif(number <= 0) {\n\t\t\t//throw exception when number is less than or is zero\n\t\t\tthrow new IllegalArgumentException(\"Number must be greater than zero.\");\n\t\t}\n\t\t\n\t\t//Store prime factors of number which is passed as argument\n\t\t//in a list \n\t\tList<Integer> primeFactorsList = PrimeFactorization.pfactors(number);\n\t\t\n\t\t//Create set from list of prime factors of integer number\n\t\t//if size of list and set is equal then the argument passed to this method is square free\n\t\t//if size of list and set is not equal then the argument passed to this method is not square free\n\t\treturn primeFactorsList.size() == new HashSet<>(primeFactorsList).size();\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nclass SquareFreeIntegerTest {\n\n\t@Test\n\tvoid testIsSquareFreeInteger() {\n\n\t\t//given\n\t\tList<Integer> listOfSquareFreeIntegers = List.of(1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35, 37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55, 57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71, 73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89, 91, 93, 94, 95, 97, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 118, 119, 122, 123, 127, 129, 130, 131, 133, 134, 137, 138, 139, 141, 142, 143, 145, 146, 149, 151, 154, 155, 157, 158, 159, 161, 163, 165, 166, 167, 170, 173, 174, 177, 178, 179, 181, 182, 183, 185, 186, 187, 190, 191, 193, 194, 195, 197, 199, 201, 202, 203, 205, 206, 209, 210, 211, 213, 214, 215, 217, 218, 219, 221, 222, 223, 226, 227, 229, 230, 231, 233, 235, 237, 238, 239, 241, 246, 247, 249, 251, 253, 254, 255, 257, 258, 259, 262, 263, 265, 266, 267, 269, 271, 273, 274, 277, 278, 281, 282, 283, 285, 286, 287, 290, 291, 293, 295, 298, 299, 301, 302, 303, 305, 307, 309, 310, 311, 313, 314, 317, 318, 319, 321, 322, 323, 326, 327, 329, 330, 331, 334, 335, 337, 339, 341, 345, 346, 347, 349, 353, 354, 355, 357, 358, 359, 362, 365, 366, 367, 370, 371, 373, 374, 377, 379, 381, 382, 383, 385, 386, 389, 390, 391, 393, 394, 395, 397, 398, 399, 401, 402, 403, 406, 407, 409, 410, 411, 413, 415, 417, 418, 419, 421, 422, 426, 427, 429, 430, 431, 433, 434, 435, 437, 438, 439, 442, 443, 445, 446, 447, 449, 451, 453, 454, 455, 457, 458, 461, 462, 463, 465, 466, 467, 469, 470, 471, 473, 474, 478, 479, 481, 482, 483, 485, 487, 489, 491, 493, 494, 497, 498, 499, 501, 502, 503, 505, 506, 509, 510, 511, 514, 515, 517, 518, 519, 521, 523, 526, 527, 530, 533, 534, 535, 537, 538, 541, 542, 543, 545, 546, 547, 551, 553, 554, 555, 557, 559, 561, 562, 563, 565, 566, 569, 570, 571, 573, 574, 577, 579, 581, 582, 583, 586, 587, 589, 590, 591, 593, 595, 597, 598, 599, 601, 602, 606, 607, 609, 610, 611, 613, 614, 615, 617, 618, 619, 622, 623, 626, 627, 629, 631, 633, 634, 635, 638, 641, 642, 643, 645, 646, 647, 649, 651, 653, 654, 655, 658, 659, 661, 662, 663, 665, 667, 669, 670, 671, 673, 674, 677, 678, 679, 681, 682, 683, 685, 687, 689, 690, 691, 694, 695, 697, 698, 699, 701, 703, 705, 706, 707, 709, 710, 713, 714, 715, 717, 718, 719, 721, 723, 727, 730, 731, 733, 734, 737, 739, 741, 742, 743, 745, 746, 749, 751, 753, 754, 755, 757, 758, 759, 761, 762, 763, 766, 767, 769, 770, 771, 773, 777, 778, 779, 781, 782, 785, 786, 787, 789, 790, 791, 793, 794, 795, 797, 798, 799, 802, 803, 805, 806, 807, 809, 811, 813, 814, 815, 817, 818, 821, 822, 823, 826, 827, 829, 830, 831, 834, 835, 838, 839, 842, 843, 849, 851, 853, 854, 857, 858, 859, 861, 862, 863, 865, 866, 869, 870, 871, 874, 877, 878, 879, 881, 883, 885, 886, 887, 889, 890, 893, 894, 895, 897, 898, 899, 901, 902, 903, 905, 906, 907, 910, 911, 913, 914, 915, 917, 919, 921, 922, 923, 926, 929, 930, 933, 934, 935, 937, 938, 939, 941, 942, 943, 946, 947, 949, 951, 953, 955, 957, 958, 959, 962, 965, 966, 967, 969, 970, 971, 973, 974, 977, 978, 979, 982, 983, 985, 986, 987, 989, 991, 993, 994, 995, 997, 998, 1001, 1002, 1003, 1005, 1006, 1007, 1009, 1010, 1011, 1013, 1015, 1018, 1019, 1021, 1022, 1023, 1027, 1030, 1031, 1033, 1034, 1037, 1038, 1039, 1041, 1042, 1043, 1045, 1046, 1047, 1049, 1051, 1054, 1055, 1057, 1059, 1061, 1063, 1065, 1066, 1067, 1069, 1070, 1073, 1074, 1077, 1079, 1081, 1082, 1085, 1086, 1087, 1090, 1091, 1093, 1094, 1095, 1097, 1099, 1101, 1102, 1103, 1105, 1106, 1109, 1110, 1111, 1113, 1114, 1115, 1117, 1118, 1119, 1121, 1122, 1123, 1126, 1129, 1130, 1131, 1133, 1135, 1137, 1138, 1139, 1141, 1142, 1145, 1146, 1147, 1149, 1151, 1153, 1154, 1155, 1157, 1158, 1159, 1162, 1163, 1165, 1166, 1167, 1169, 1171, 1173, 1174, 1177, 1178, 1181, 1182, 1185, 1186, 1187, 1189, 1190, 1191, 1193, 1194, 1195, 1198, 1199, 1201, 1202, 1203, 1205, 1207, 1209, 1211, 1213, 1214, 1217, 1218, 1219, 1221, 1222, 1223, 1226, 1227, 1229, 1230, 1231, 1234, 1235, 1237, 1238, 1239, 1241, 1243, 1245, 1246, 1247, 1249, 1253, 1254, 1255, 1257, 1258, 1259, 1261, 1262, 1263, 1265, 1266, 1267, 1270, 1271, 1273, 1277, 1279, 1281, 1282, 1283, 1285, 1286, 1289, 1290, 1291, 1293, 1294, 1295, 1297, 1298, 1299, 1301, 1302, 1303, 1306, 1307, 1309, 1310, 1311, 1313, 1315, 1317, 1318, 1319, 1321, 1322, 1326, 1327, 1329, 1330, 1333, 1334, 1335, 1337, 1338, 1339, 1342, 1343, 1345, 1346, 1347, 1349, 1351, 1353, 1354, 1355, 1357, 1358, 1361, 1362, 1363, 1365, 1366, 1367, 1370, 1371, 1373, 1374, 1378, 1379, 1381, 1382, 1383, 1385, 1387, 1389, 1390, 1391, 1393, 1394, 1397, 1398, 1399, 1401, 1402, 1403, 1405, 1406, 1407, 1409, 1410, 1411, 1414, 1415, 1417, 1418, 1419, 1423, 1426, 1427, 1429, 1430, 1433, 1434, 1435, 1437, 1438, 1439, 1441, 1442, 1443, 1446, 1447, 1451, 1453, 1454, 1455, 1457, 1459, 1461, 1462, 1463, 1465, 1466, 1469, 1471, 1473, 1474, 1477, 1478, 1479, 1481, 1482, 1483, 1486, 1487, 1489, 1490, 1491, 1493, 1495, 1497, 1498, 1499, 1501, 1502, 1505, 1506, 1507, 1509, 1510, 1511, 1513, 1514, 1515, 1517, 1518, 1522, 1523, 1526, 1527, 1529, 1531, 1533, 1534, 1535, 1537, 1538, 1541, 1542, 1543, 1545, 1546, 1547, 1549, 1551, 1553, 1554, 1555, 1558, 1559, 1561, 1562, 1563, 1565, 1567, 1569, 1570, 1571, 1574, 1577, 1578, 1579, 1581, 1582, 1583, 1585, 1586, 1589, 1590, 1591, 1594, 1595, 1597, 1598, 1599, 1601, 1603, 1605, 1606, 1607, 1609, 1610, 1613, 1614, 1615, 1618, 1619, 1621, 1622, 1623, 1626, 1627, 1630, 1631, 1633, 1634, 1635, 1637, 1639, 1641, 1642, 1643, 1645, 1646, 1649, 1651, 1653, 1654, 1655, 1657, 1658, 1659, 1661, 1662, 1663, 1667, 1669, 1670, 1671, 1673, 1677, 1678, 1679, 1685, 1686, 1687, 1689, 1691, 1693, 1695, 1697, 1698, 1699, 1702, 1703, 1705, 1706, 1707, 1709, 1711, 1713, 1714, 1717, 1718, 1721, 1722, 1723, 1726, 1727, 1729, 1730, 1731, 1733, 1735, 1738, 1739, 1741, 1742, 1743, 1745, 1747, 1749, 1751, 1753, 1754, 1757, 1758, 1759, 1761, 1762, 1763, 1765, 1766, 1767, 1769, 1770, 1771, 1774, 1777, 1778, 1779, 1781, 1783, 1785, 1786, 1787, 1789, 1790, 1793, 1794, 1795, 1797, 1798, 1799, 1801, 1802, 1803, 1806, 1807, 1810, 1811, 1814, 1817, 1819, 1821, 1822, 1823, 1826, 1829, 1830, 1831, 1833, 1834, 1835, 1837, 1838, 1839, 1841, 1842, 1843, 1846, 1847, 1851, 1853, 1855, 1857, 1858, 1861, 1865, 1866, 1867, 1869, 1870, 1871, 1873, 1874, 1877, 1878, 1879, 1882, 1883, 1885, 1886, 1887, 1889, 1891, 1893, 1894, 1895, 1897, 1898, 1901, 1902, 1903, 1905, 1906, 1907, 1909, 1910, 1913, 1914, 1915, 1918, 1919, 1921, 1923, 1927, 1929, 1930, 1931, 1933, 1934, 1937, 1938, 1939, 1941, 1942, 1943, 1945, 1946, 1947, 1949, 1951, 1954, 1955, 1957, 1958, 1959, 1961, 1963, 1965, 1966, 1967, 1969, 1970, 1973, 1974, 1977, 1978, 1979, 1981, 1982, 1983, 1985, 1986, 1987, 1990, 1991, 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2005, 2006, 2010, 2011, 2013, 2014, 2015, 2017, 2018, 2019, 2021, 2022, 2026, 2027, 2029, 2030, 2031, 2033, 2035, 2037, 2038, 2039, 2041, 2042, 2045, 2046, 2047, 2049, 2051, 2053, 2054, 2055, 2059, 2062, 2063, 2065, 2066, 2067, 2069, 2071, 2073, 2074, 2077, 2078, 2081, 2082, 2083, 2085, 2086, 2087, 2089, 2090, 2091, 2093, 2094, 2095, 2098, 2099, 2101, 2102, 2103, 2105, 2109, 2110, 2111, 2113, 2114, 2117, 2118, 2119, 2121, 2122, 2123, 2126, 2127, 2129, 2130, 2131, 2134, 2135, 2137, 2138, 2139, 2141, 2143, 2145, 2146, 2147, 2149, 2153, 2154, 2155, 2157, 2158, 2159, 2161, 2162, 2163, 2165, 2167, 2170, 2171, 2173, 2174, 2177, 2179, 2181, 2182, 2183, 2185, 2186, 2189, 2190, 2191, 2193, 2194, 2195, 2198, 2199, 2201, 2202, 2203, 2206, 2207, 2210, 2211, 2213, 2215, 2217, 2218, 2219, 2221, 2222, 2226, 2227, 2229, 2230, 2231, 2233, 2234, 2235, 2237, 2238, 2239, 2242, 2243, 2245, 2246, 2247, 2249, 2251, 2253, 2255, 2257, 2258, 2261, 2262, 2263, 2265, 2266, 2267, 2269, 2270, 2271, 2273, 2274, 2278, 2279, 2281, 2282, 2283, 2285, 2287, 2289, 2290, 2291, 2293, 2294, 2297, 2298, 2301, 2302, 2305, 2306, 2307, 2309, 2310, 2311, 2314, 2315, 2317, 2318, 2319, 2321, 2323, 2326, 2327, 2329, 2330, 2333, 2334, 2335, 2337, 2338, 2339, 2341, 2342, 2343, 2345, 2346, 2347, 2351, 2353, 2354, 2355, 2357, 2359, 2361, 2362, 2363, 2365, 2369, 2370, 2371, 2373, 2374, 2377, 2378, 2379, 2381, 2382, 2383, 2386, 2387, 2389, 2390, 2391, 2393, 2395, 2397, 2398, 2399, 2402, 2405, 2406, 2407, 2409, 2410, 2411, 2413, 2414, 2415, 2417, 2418, 2419, 2422, 2423, 2426, 2427, 2429, 2431, 2433, 2434, 2435, 2437, 2438, 2441, 2442, 2443, 2445, 2446, 2447, 2449, 2451, 2453, 2454, 2455, 2458, 2459, 2461, 2462, 2463, 2465, 2467, 2469, 2470, 2471, 2473, 2474, 2477, 2478, 2479, 2481, 2482, 2483, 2485, 2486, 2487, 2489, 2490, 2491, 2494, 2495, 2497, 2498);\n\n\t\tfor(int i = 1; i <=2500; i++) {\n\t\t\t//when\n\t\t\tboolean isNumberSquareFree = SquareFreeInteger.isSquareFreeInteger(i);\n\t\t\tboolean isNumberPresentInList = listOfSquareFreeIntegers.contains(i);\n\n\t\t\t//then\n\t\t\tassertEquals(isNumberSquareFree,isNumberPresentInList);\n\t\t}\n\t}\n\n\t@Test\n\tvoid testIsSquareFreeIntegerThrowExceptionIfNumberIsZero() {\n\t\t//given\n\t\tint number = 0;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(\n\t\t\t\tIllegalArgumentException.class,\n\t\t\t\t() -> {\n\t\t\t\t\tSquareFreeInteger.isSquareFreeInteger(number);\n\t\t\t\t}\n\t\t\t\t);\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testIsSquareFreeIntegerMustThrowExceptionIfNumberIsNegative() {\n\t\t//given\n\t\tint number = -1;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(\n\t\t\t\tIllegalArgumentException.class,\n\t\t\t\t() -> {\n\t\t\t\t\tSquareFreeInteger.isSquareFreeInteger(number);\n\t\t\t\t}\n\t\t\t\t);\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n}"
    },
    {
        "product_commit": "58cf08f2fd1d144840f032a9c10df732a1eeb7ae",
        "test_commit": "58cf08f2fd1d144840f032a9c10df732a1eeb7ae",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/InsertionSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/InsertionSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nclass InsertionSort implements SortAlgorithm {\n\n    /**\n     * Generic insertion sort algorithm in increasing order.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1; i < array.length; i++) {\n            T insertValue = array[i];\n            int j;\n            for (j = i - 1; j >= 0 && less(insertValue, array[j]); j--) {\n                array[j + 1] = array[j];\n            }\n            if (j != i - 1) {\n                array[j + 1] = insertValue;\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Integer[] integers = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        InsertionSort sort = new InsertionSort();\n        sort.sort(integers);\n        print(integers);\n        /* [1, 4, 6, 9, 12, 23, 54, 78, 231] */\n\n        String[] strings = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        sort.sort(strings);\n        print(strings);\n        /* [a, b, c, d, e] */\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.function.Function;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\nclass InsertionSort implements SortAlgorithm {\n\n    /**\n     * Generic insertion sort algorithm in increasing order.\n     *\n     * @param array the array to be sorted.\n     * @param <T>   the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1; i < array.length; i++)\n            for (int j = i; j > 0 && less(array[j], array[j - 1]); j--)\n                swap(array, j, j - 1);\n        return array;\n    }\n\n    /**\n     * Sentinel sort is a function which on the first step finds the minimal element in the provided\n     * array and puts it to the zero position, such a trick gives us an ability to avoid redundant\n     * comparisons like `j > 0` and swaps (we can move elements on position right, until we find\n     * the right position for the chosen element) on further step.\n     *\n     * @param array the array to be sorted\n     * @param <T>   Generic type which extends Comparable interface.\n     * @return sorted array\n     */\n    public <T extends Comparable<T>> T[] sentinelSort(T[] array) {\n        int minElemIndex = 0;\n        int n = array.length;\n        if (n < 1)\n            return array;\n\n        // put the smallest element to the 0 position as a sentinel, which will allow us to avoid\n        // redundant comparisons like `j > 0` further\n        for (int i = 1; i < n; i++)\n            if (less(array[i], array[minElemIndex]))\n                minElemIndex = i;\n        swap(array, 0, minElemIndex);\n\n        for (int i = 2; i < n; i++) {\n            int j = i;\n            T currentValue = array[i];\n            while (less(currentValue, array[j - 1])) {\n                array[j] = array[j - 1];\n                j--;\n            }\n\n            array[j] = currentValue;\n        }\n\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        int size = 100_000;\n        Double[] randomArray = SortUtilsRandomGenerator.generateArray(size);\n        Double[] copyRandomArray = new Double[size];\n        System.arraycopy(randomArray, 0, copyRandomArray, 0, size);\n\n        InsertionSort insertionSort = new InsertionSort();\n        double insertionTime = measureApproxExecTime(insertionSort::sort, randomArray);\n        System.out.printf(\"Original insertion time: %5.2f  sec.\\n\", insertionTime);\n\n        double insertionSentinelTime = measureApproxExecTime(insertionSort::sentinelSort, copyRandomArray);\n        System.out.printf(\"Sentinel insertion time: %5.2f  sec.\\n\", insertionSentinelTime);\n\n        // ~ 1.5 time sentinel sort is faster, then classical Insertion sort implementation.\n        System.out.printf(\"Sentinel insertion is %f3.2 time faster than Original insertion sort\\n\",\n                insertionTime / insertionSentinelTime);\n    }\n\n    private static double measureApproxExecTime(Function<Double[], Double[]> sortAlgorithm, Double[] randomArray) {\n        long start = System.currentTimeMillis();\n        sortAlgorithm.apply(randomArray);\n        long end = System.currentTimeMillis();\n        return (end - start) / 1000.0;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.function.Function;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass InsertionSortTest {\n    private InsertionSort insertionSort;\n\n    @BeforeEach\n    void setUp() {\n        insertionSort = new InsertionSort();\n    }\n\n    @Test\n    void insertionSortSortEmptyArrayShouldPass() {\n        testEmptyArray(insertionSort::sort);\n        testEmptyArray(insertionSort::sentinelSort);\n    }\n\n    private void testEmptyArray(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalSortSingleValueArrayShouldPass() {\n        testSingleValue(insertionSort::sort);\n        testSingleValue(insertionSort::sentinelSort);\n    }\n\n    private void testSingleValue(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {7};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithIntegerArrayShouldPass() {\n        testIntegerArray(insertionSort::sort);\n        testIntegerArray(insertionSort::sentinelSort);\n    }\n\n    private void testIntegerArray(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalForArrayWithNegativeValuesShouldPass() {\n        testWithNegativeValues(insertionSort::sort);\n        testWithNegativeValues(insertionSort::sentinelSort);\n    }\n\n    private void testWithNegativeValues(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {49, -36, -144, -49, 1, 9};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {-144, -49, -36, 1, 9, 49};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalForArrayWithDuplicateValuesShouldPass() {\n        testWithDuplicates(insertionSort::sort);\n        testWithDuplicates(insertionSort::sentinelSort);\n    }\n\n    private void testWithDuplicates(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithStringArrayShouldPass() {\n        testWithStringArray(insertionSort::sort);\n        testWithStringArray(insertionSort::sentinelSort);\n    }\n\n    private void testWithStringArray(Function<String[], String[]> sortAlgorithm) {\n        String[] array = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        String[] sorted = sortAlgorithm.apply(array);\n        String[] expected = {\"a\", \"b\", \"c\", \"d\", \"e\"};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithRandomArrayPass() {\n        testWithRandomArray(insertionSort::sort);\n        testWithRandomArray(insertionSort::sentinelSort);\n    }\n\n    private void testWithRandomArray(Function<Double[], Double[]> sortAlgorithm) {\n        int randomSize = (int) (SortUtilsRandomGenerator.generateDouble() * 10_000);\n        Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);\n        Double[] sorted = sortAlgorithm.apply(array);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n}"
    },
    {
        "product_commit": "58cf08f2fd1d144840f032a9c10df732a1eeb7ae",
        "test_commit": "58cf08f2fd1d144840f032a9c10df732a1eeb7ae",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SortUtilsRandomGenerator.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SortUtilsRandomGeneratorTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Random;\n\npublic class SortUtilsRandomGenerator {\n\n    private static final Random random;\n    private static final long seed;\n\n    static {\n        seed = System.currentTimeMillis();\n        random = new Random(seed);\n    }\n\n\n    /**\n     * Function to generate array of double values, with predefined size.\n     *\n     * @param size result array size\n     * @return array of Double values, randomly generated, each element is between [0, 1)\n     */\n    public static Double[] generateArray(int size) {\n        Double[] arr = new Double[size];\n        for (int i = 0; i < size; i++)\n            arr[i] = generateDouble();\n        return arr;\n    }\n\n    /**\n     * Function to generate Double value.\n     *\n     * @return Double value [0, 1)\n     */\n    public static Double generateDouble() {\n        return random.nextDouble();\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass SortUtilsRandomGeneratorTest {\n\n    @RepeatedTest(1000)\n    void generateArray() {\n        int size = 1_000;\n        Double[] doubles = SortUtilsRandomGenerator.generateArray(size);\n        assertThat(doubles).hasSize(size);\n        assertThat(doubles).doesNotContainNull();\n    }\n\n    @Test\n    void generateArrayEmpty() {\n        int size = 0;\n        Double[] doubles = SortUtilsRandomGenerator.generateArray(size);\n        assertThat(doubles).hasSize(size);\n    }\n\n    @RepeatedTest(1000)\n    void generateDouble() {\n        Double randomDouble = SortUtilsRandomGenerator.generateDouble();\n        assertThat(randomDouble).isBetween(0.0, 1.0);\n        assertThat(randomDouble).isNotEqualTo(1.0);\n    }\n}"
    },
    {
        "product_commit": "c8ecd23183b4e19488c59877ad47ea1ede90bdd9",
        "test_commit": "c8ecd23183b4e19488c59877ad47ea1ede90bdd9",
        "product_file_path": "src/main/java/com/thealgorithms/maths/KaprekarNumbers.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/KaprekarNumbersTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n    /* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n    // Provides a list of kaprekarNumber in a range\n    public static ArrayList<Long> kaprekarNumberInRange(long start, long end)\n        throws Exception {\n        long n = end - start;\n        if (n < 0) throw new Exception(\"Invalid range\");\n        ArrayList<Long> list = new ArrayList<>();\n\n        for (long i = start; i <= end; i++) {\n            if (isKaprekarNumber(i)) list.add(i);\n        }\n\n        return list;\n    }\n\n    // Checks whether a given number is Kaprekar Number or not\n    public static boolean isKaprekarNumber(long num) {\n        String number = Long.toString(num);\n        BigInteger originalNumber = new BigInteger(number);\n        BigInteger numberSquared = originalNumber.multiply(originalNumber);\n        if (number.length() == numberSquared.toString().length()) {\n            return number.equals(numberSquared.toString());\n        } else {\n            BigInteger leftDigits1 = new BigInteger(\"0\");\n            BigInteger leftDigits2;\n            if (numberSquared.toString().contains(\"0\")) {\n                leftDigits1 =\n                    new BigInteger(\n                        numberSquared\n                            .toString()\n                            .substring(0, numberSquared.toString().indexOf(\"0\"))\n                    );\n            }\n            leftDigits2 =\n                new BigInteger(\n                    numberSquared\n                        .toString()\n                        .substring(\n                            0,\n                            (\n                                numberSquared.toString().length() -\n                                number.length()\n                            )\n                        )\n                );\n            BigInteger rightDigits = new BigInteger(\n                numberSquared\n                    .toString()\n                    .substring(\n                        numberSquared.toString().length() - number.length()\n                    )\n            );\n            String x = leftDigits1.add(rightDigits).toString();\n            String y = leftDigits2.add(rightDigits).toString();\n            return (number.equals(x)) || (number.equals(y));\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n    /* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n    // Provides a list of kaprekarNumber in a range\n    public static List<Long> kaprekarNumberInRange(long start, long end)\n        throws Exception {\n        long n = end - start;\n        if (n < 0) throw new Exception(\"Invalid range\");\n        ArrayList<Long> list = new ArrayList<>();\n\n        for (long i = start; i <= end; i++) {\n            if (isKaprekarNumber(i)) list.add(i);\n        }\n\n        return list;\n    }\n\n    // Checks whether a given number is Kaprekar Number or not\n    public static boolean isKaprekarNumber(long num) {\n        String number = Long.toString(num);\n        BigInteger originalNumber = BigInteger.valueOf(num);\n        BigInteger numberSquared = originalNumber.multiply(originalNumber);\n        if (number.length() == numberSquared.toString().length()) {\n            return number.equals(numberSquared.toString());\n        } else {\n            BigInteger leftDigits1 = BigInteger.ZERO;\n            BigInteger leftDigits2;\n            if (numberSquared.toString().contains(\"0\")) {\n                leftDigits1 =\n                    new BigInteger(\n                        numberSquared\n                            .toString()\n                            .substring(0, numberSquared.toString().indexOf(\"0\"))\n                    );\n            }\n            leftDigits2 =\n                new BigInteger(\n                    numberSquared\n                        .toString()\n                        .substring(\n                            0,\n                            (\n                                numberSquared.toString().length() -\n                                number.length()\n                            )\n                        )\n                );\n            BigInteger rightDigits = new BigInteger(\n                numberSquared\n                    .toString()\n                    .substring(\n                        numberSquared.toString().length() - number.length()\n                    )\n            );\n            String x = leftDigits1.add(rightDigits).toString();\n            String y = leftDigits2.add(rightDigits).toString();\n            return (number.equals(x)) || (number.equals(y));\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\n\npublic class KaprekarNumbersTest {\n\n    @Test\n    void testFor1() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(1));\n    }\n\n    @Test\n    void testFor45() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(45));\n    }\n\n    @Test\n    void testFor297() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(297));\n    }\n\n    @Test\n    void testFor2223() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n    }\n\n    @Test\n    void testFor857143() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n    }\n\n    @Test\n    void testFor3() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(3));\n    }\n\n    @Test\n    void testFor26() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(26));\n    }\n\n    @Test\n    void testFor98() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(98));\n    }\n\n    @Test\n    void testForRangeOfNumber() {\n        try {\n            ArrayList<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(\n                1,\n                100000\n            );\n            long[] allTheNumbers = {\n                1,\n                9,\n                45,\n                55,\n                99,\n                297,\n                703,\n                999,\n                2223,\n                2728,\n                4950,\n                5050,\n                7272,\n                7777,\n                9999,\n                17344,\n                22222,\n                77778,\n                82656,\n                95121,\n                99999,\n            };\n            for (long i : allTheNumbers) {\n                assert rangedNumbers.contains(i);\n            }\n        } catch (Exception e) {\n            assert false;\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KaprekarNumbersTest {\n\n    @Test\n    void testFor1() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(1));\n    }\n\n    @Test\n    void testFor45() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(45));\n    }\n\n    @Test\n    void testFor297() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(297));\n    }\n\n    @Test\n    void testFor2223() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n    }\n\n    @Test\n    void testFor857143() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n    }\n\n    @Test\n    void testFor3() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(3));\n    }\n\n    @Test\n    void testFor26() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(26));\n    }\n\n    @Test\n    void testFor98() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(98));\n    }\n\n    @Test\n    void testForRangeOfNumber() {\n        try {\n            List<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(\n                1,\n                100000\n            );\n            long[] allTheNumbers = {\n                1,\n                9,\n                45,\n                55,\n                99,\n                297,\n                703,\n                999,\n                2223,\n                2728,\n                4950,\n                5050,\n                7272,\n                7777,\n                9999,\n                17344,\n                22222,\n                77778,\n                82656,\n                95121,\n                99999,\n            };\n            for (long i : allTheNumbers) {\n                assert rangedNumbers.contains(i);\n            }\n        } catch (Exception e) {\n            assert false;\n        }\n    }\n}"
    },
    {
        "product_commit": "cc17d60d5cb0a4f2b9d99d9d259d8887b71683fb",
        "test_commit": "cc17d60d5cb0a4f2b9d99d9d259d8887b71683fb",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/SimpleSubCipher.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/SimpleSubCipherTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n */\npublic class SimpleSubCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @param message\n     * @param cipherSmall\n     * @return Encrypted message\n     */\n    public static String encode(String message, String cipherSmall) {\n        String encoded = \"\";\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded += cipherMap.get(message.charAt(i));\n            } else {\n                encoded += message.charAt(i);\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @param encryptedMessage\n     * @param cipherSmall\n     * @return message\n     */\n    public static String decode(String encryptedMessage, String cipherSmall) {\n        String decoded = \"\";\n\n        Map<Character, Character> cipherMap = new HashMap<Character, Character>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded += cipherMap.get(encryptedMessage.charAt(i));\n            } else {\n                decoded += encryptedMessage.charAt(i);\n            }\n        }\n\n        return decoded;\n    }\n\n    public static void main(String[] args) {\n        String a = encode(\n            \"defend the east wall of the castle\",\n            \"phqgiumeaylnofdxjkrcvstzwb\"\n        );\n        String b = decode(a, \"phqgiumeaylnofdxjkrcvstzwb\");\n        System.out.println(b);\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n */\npublic class SimpleSubCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @param message\n     * @param cipherSmall\n     * @return Encrypted message\n     */\n    public String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @param encryptedMessage\n     * @param cipherSmall\n     * @return message\n     */\n    public String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass SimpleSubCipherTest {\n\n    SimpleSubCipher simpleSubCipher = new SimpleSubCipher();\n\n    @Test\n    void simpleSubCipherEncryptTest() {\n        // given\n        String text = \"defend the east wall of the castle\";\n        String cipherSmall = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // when\n        String cipherText = simpleSubCipher.encode(text, cipherSmall);\n\n        // then\n        assertEquals(\"giuifg cei iprc tpnn du cei qprcni\", cipherText);\n    }\n\n    @Test\n    void simpleSubCipherDecryptTest() {\n        // given\n        String encryptedText = \"giuifg cei iprc tpnn du cei qprcni\";\n        String cipherSmall = \"phqgiumeaylnofdxjkrcvstzwb\";\n\n        // when\n        String decryptedText = simpleSubCipher.decode(encryptedText, cipherSmall);\n\n        // then\n        assertEquals(\"defend the east wall of the castle\", decryptedText);\n    }\n\n}"
    },
    {
        "product_commit": "1c7da7af25e9da6fe1223f04fffe8ee5b1367c45",
        "test_commit": "1c7da7af25e9da6fe1223f04fffe8ee5b1367c45",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LongDivision.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LongDivisionTest.java",
        "product_old_content": null,
        "product_new_content": "//        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n//\n//        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, \n//        and -2.7335 would be truncated to -2.\n//        My method used Long Division, here is the source \"https://en.wikipedia.org/wiki/Long_division\"\n\npackage com.thealgorithms.maths;\n\npublic class LongDivision {\npublic static int divide(int dividend, int divisor) {\n        long new_dividend_1 = dividend;\n        long new_divisor_1 = divisor;\n\n        if (dividend < 0) {\n            new_dividend_1 = new_dividend_1 * -1;\n        }\n        if (divisor < 0) {\n            new_divisor_1 = new_divisor_1 * -1;\n        }\n\n        if (dividend == 0 || new_dividend_1 < new_divisor_1) {\n            return 0;\n        }\n\n        StringBuilder answer = new StringBuilder();\n\n        String dividend_string = \"\" + new_dividend_1;\n        int last_index = 0;\n\n        String remainder = \"\";\n\n\n        for (int i = 0; i < dividend_string.length(); i++) {\n            String part_v1 = remainder + \"\" + dividend_string.substring(last_index, i + 1);\n            long part_1 = Long.parseLong(part_v1);\n            if (part_1 > new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == new_divisor_1) {\n                int quotient = 0;\n                while (part_1 >= new_divisor_1) {\n                    part_1 = part_1 - new_divisor_1;\n                    quotient++;\n                }\n                answer.append(quotient);\n            } else if (part_1 == 0) {\n                answer.append(0);\n            } else if (part_1 < new_divisor_1) {\n                answer.append(0);\n            }\n            if (!(part_1 == 0)) {\n                remainder = String.valueOf(part_1);\n            }else{\n                remainder = \"\";\n            }\n\n            last_index++;\n        }\n\n        if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {\n            try {\n                return Integer.parseInt(answer.toString()) * (-1);\n            } catch (NumberFormatException e) {\n                return -2147483648;\n            }\n        }\n        try {\n            return Integer.parseInt(answer.toString());\n        } catch (NumberFormatException e) {\n            return 2147483647;\n        }\n\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LongDivisionTest {\n\t\n    @Test\n    void testOne() {\n        assertEquals(3, LongDivision.divide(10,3));\n    }\n  \n      @Test\n    void testTwo() {\n        assertEquals(-2, LongDivision.divide(7,-3));\n    }\n  \n  \n      @Test\n    void testThree() {\n        assertEquals(10, LongDivision.divide(105,10));\n    }\n\t\n}"
    },
    {
        "product_commit": "37a1659e18ab5156c88b6897eeaf1f599d63efcd",
        "test_commit": "37a1659e18ab5156c88b6897eeaf1f599d63efcd",
        "product_file_path": "src/main/java/com/thealgorithms/maths/HarshadNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/HarshadNumberTest.java",
        "product_old_content": "// Wikipedia for Harshad Number : https://en.wikipedia.org/wiki/Harshad_number\npackage com.thealgorithms.maths;\n\nimport java.util.Scanner;\n\npublic class HarshadNumber {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Enter a number : \");\n        long a = sc.nextLong();\n\n        checkHarshadNumber(a);\n    }\n\n    /**\n     * A function to check if a number is Harshad number or not\n     *\n     * @param a The number which should be checked\n     */\n    public static void checkHarshadNumber(long a) {\n        long b = a;\n        int sum = 0;\n\n        // this is just for showing the explanation else it's of no use you can ommit it\n        int[] each = new int[Long.toString(a).length()];\n\n        int c = 0;\n\n        while (b > 0) {\n            sum += b % 10;\n            each[c] = (int) (b % 10);\n            b /= 10;\n            c++;\n        }\n\n        if (a % sum == 0) {\n            System.out.println(a + \" is a Harshad Number\");\n\n            // For you better explanation how is that a Harshad Number\n            System.out.println(\"\\nExplaination :\");\n\n            for (int i = each.length - 1; i >= 0; i--) {\n                System.out.print(each[i] + \" \");\n                if (i != 0) {\n                    System.out.print(\"+ \");\n                }\n            }\n\n            System.out.println(\"= \" + sum);\n            System.out.println(sum + \" \u00d7 \" + (a / sum) + \" = \" + a);\n        } else {\n            System.out.println(a + \" is not a Harshad Number\");\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n// Wikipedia for Harshad Number : https://en.wikipedia.org/wiki/Harshad_number\n\npublic class HarshadNumber {\n\n    /**\n     * A function to check if a number is Harshad number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Harshad number, otherwise\n     *         {@code false}\n     */\n    public static boolean isHarshad(long n) {\n        if (n <= 0)\n            return false;\n\n        long t = n;\n        int sumOfDigits = 0;\n        while (t > 0) {\n            sumOfDigits += t % 10;\n            t /= 10;\n        }\n\n        return n % sumOfDigits == 0;\n    }\n\n    /**\n     * A function to check if a number is Harshad number or not\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Harshad number, otherwise\n     *         {@code false}\n     */\n    public static boolean isHarshad(String s) {\n        long n = Long.valueOf(s);\n        if (n <= 0)\n            return false;\n\n        int sumOfDigits = 0;\n        for (char ch : s.toCharArray()) {\n            sumOfDigits += ch - '0';\n        }\n\n        return n % sumOfDigits == 0;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class HarshadNumberTest {\n\n    @Test\n    public void harshadNumber() {\n        \n        assertTrue(HarshadNumber.isHarshad(18));\n        assertFalse(HarshadNumber.isHarshad(-18));\n        assertFalse(HarshadNumber.isHarshad(19));\n        assertTrue(HarshadNumber.isHarshad(999999999));\n        assertFalse(HarshadNumber.isHarshad(0));\n\n        assertTrue(HarshadNumber.isHarshad(\"18\"));\n        assertFalse(HarshadNumber.isHarshad(\"-18\"));\n        assertFalse(HarshadNumber.isHarshad(\"19\"));\n        assertTrue(HarshadNumber.isHarshad(\"999999999\"));\n        assertTrue(HarshadNumber.isHarshad(\"99999999999100\"));\n    }\n}"
    },
    {
        "product_commit": "37db41fd6b0bb80beb534fff39df51e5c2db75ae",
        "test_commit": "37db41fd6b0bb80beb534fff39df51e5c2db75ae",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AutomorphicNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\nimport java.io.*;\n\npublic class AutomorphicNumber {\n\n    //returns True if the number is a Automorphic number and False if it is not an Automorphic number\n    public static boolean isAutomorphic(int n) {\n        int m, c, r, p, k;\n        c = 0;\n        /**\n         * m = Temporary variable to store a copy of the number entered by the\n         * user. n = The number entered by the user c = Count the digits of the\n         * number entered by user. p = To calculate the square of the number. k\n         * = Support variable to count the digits of the number\n         */\n        double s;\n        m = n;\n        p = m * m; //Calculating square of the number\n        do {\n            k = n / 10;\n            c = c + 1; //Counting the digits of the number entered by user.\n            n = k;\n        } while (n != 0);\n        s = Math.pow(10, c);\n        r = p % (int) s;\n        if (m == r) { //Checking if the original number entered is present at the end of the square\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Method to check if number is Automorphic Number or Not 1) Input - Enter a\n     * Number: 25 Output - It is an Automorphic Number. 2) Input - Enter a\n     * Number: 7 Output - It is not an Automorphic Number.\n     */\n    public static void main(String args[]) throws IOException {\n        BufferedReader br = new BufferedReader(\n            new InputStreamReader(System.in)\n        );\n        System.out.println(\"Enter a Number: \");\n        int n = Integer.parseInt(br.readLine());\n        if (isAutomorphic(n)) {\n            System.out.println(\"It is an Automorphic Number.\");\n        } else {\n            System.out.println(\"It is not an Automorphic Number.\");\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Wikipedia link for Automorphic Number : https://en.wikipedia.org/wiki/Automorphic_number\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\n\nimport java.math.BigInteger;\n\npublic class AutomorphicNumber {\n\n    /**\n     * A function to check if a number is Automorphic number or not\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic(long n) {\n        if (n < 0)\n            return false;\n        long square = n * n; // Calculating square of the number\n        long t = n, numberOfdigits = 0;\n        while (t > 0) {\n            numberOfdigits++; // Calculating number of digits in n\n            t /= 10;\n        }\n        long lastDigits = square % (long) Math.pow(10, numberOfdigits); // Extracting last Digits of square\n        return n == lastDigits;\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using String functions\n     *\n     * @param n The number to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic2(long n) {\n        if (n < 0)\n            return false;\n        long square = n * n; // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n\n    /**\n     * A function to check if a number is Automorphic number or not by using BigInteger\n     *\n     * @param s The number in String to be checked\n     * @return {@code true} if {@code a} is Automorphic number, otherwise\n     *         {@code false}\n     */\n    public static boolean isAutomorphic3(String s) {\n        BigInteger n = new BigInteger(s);\n        if (n.signum() == -1) \n            return false; //if number is negative, return false\n        BigInteger square = n.multiply(n); // Calculating square of the number\n        return String.valueOf(square).endsWith(String.valueOf(n));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AutomorphicNumberTest {\n\n    @Test\n    void testAutomorphicNumber() {\n        assertThat(AutomorphicNumber.isAutomorphic(625)).isTrue();\n        assertThat(AutomorphicNumber.isAutomorphic(144)).isFalse();\n        assertThat(AutomorphicNumber.isAutomorphic(9376)).isTrue();\n        assertThat(AutomorphicNumber.isAutomorphic(169)).isFalse();\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AutomorphicNumberTest {\n\n    @Test\n    void testAutomorphicNumber() {\n        int trueTestCases[] = { 0, 1, 25, 625, 12890625};\n        int falseTestCases[] = { -5, 2, 26, 1234 };\n        for (Integer n : trueTestCases) {\n            assertTrue(AutomorphicNumber.isAutomorphic(n));\n            assertTrue(AutomorphicNumber.isAutomorphic2(n));\n            assertTrue(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(AutomorphicNumber.isAutomorphic(n));\n            assertFalse(AutomorphicNumber.isAutomorphic2(n));\n            assertFalse(AutomorphicNumber.isAutomorphic3(String.valueOf(n)));\n        }\n        assertTrue(AutomorphicNumber.isAutomorphic3(\"59918212890625\")); // Special case for BigInteger\n        assertFalse(AutomorphicNumber.isAutomorphic3(\"12345678912345\")); // Special case for BigInteger\n    }\n}"
    },
    {
        "product_commit": "1a391c2fe9b77904cde13d8aecb44cf3833673ba",
        "test_commit": "1a391c2fe9b77904cde13d8aecb44cf3833673ba",
        "product_file_path": "src/main/java/com/thealgorithms/strings/ValidParentheses.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/ValidParenthesesTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings;\n//        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n//        An input string is valid if:\n//        Open brackets must be closed by the same type of brackets.\n//        Open brackets must be closed in the correct order.\n//        Every close bracket has a corresponding open bracket of the same type.\n\n\npublic class ValidParentheses {\n\tpublic static boolean isValid(String s) {\n\t\tchar[] stack = new char[s.length()];\n\t\tint head = 0;\n\t\tfor(char c : s.toCharArray()) {\n\t\t\tswitch(c) {\n\t\t\t\tcase '{':\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstack[head++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif(head == 0 || stack[--head] != '{') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tif(head == 0 || stack[--head] != '(') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tif(head == 0 || stack[--head] != '[') return false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn head == 0;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ValidParenthesesTest {\n\t\n    @Test\n    void testOne() {\n        assertEquals(true, ValidParentheses.isValid(\"()\"));\n    }\n  \n    @Test\n    void testTwo() {\n        assertEquals(true, ValidParentheses.isValid(\"()[]{}\"));\n    }\n  \n  \n    @Test\n    void testThree() {\n        assertEquals(false, ValidParentheses.isValid(\"(]\"));\n    }\n\t\n}"
    },
    {
        "product_commit": "fea982d54df398b783733901184d1156a5701a9a",
        "test_commit": "fea982d54df398b783733901184d1156a5701a9a",
        "product_file_path": "src/main/java/com/thealgorithms/strings/MyAtoi.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/MyAtoiTest.java",
        "product_old_content": null,
        "product_new_content": "// Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function). Here is my implementation\n\npackage com.thealgorithms.strings;\n\npublic class MyAtoi {\npublic static int myAtoi(String s) {\n        s = s.trim();\n        char[] char_1 = s.toCharArray();\n        String number = \"\";\n        boolean negative = false;\n        boolean zero = false;\n        boolean isDigit = false;\n\n        for (char ch : char_1) {\n            if (Character.isDigit(ch)) {\n                if (number.length() > 1 && !isDigit) {\n                    number = \"0\";\n                    break;\n                }\n                isDigit = true;\n                if (zero) {\n                    number = \"0\";\n                    break;\n                }\n                switch (ch) {\n                    case '0' -> number += ch;\n                    case '1' -> number += ch;\n                    case '2' -> number += ch;\n                    case '3' -> number += ch;\n                    case '4' -> number += ch;\n                    case '5' -> number += ch;\n                    case '6' -> number += ch;\n                    case '7' -> number += ch;\n                    case '8' -> number += ch;\n                    case '9' -> number += ch;\n                }\n            } else if (ch == '-' && !isDigit) {\n                number += \"0\";\n                negative = true;\n            } else if (ch == '+' && !isDigit) {\n                number += \"0\";\n            } else if (ch == '.' && isDigit) {\n                break;\n            } else if (ch == '.') {\n                zero = true;\n            } else {\n                if (!isDigit) {\n                    number = \"0\";\n                }\n                break;\n            }\n        }\n    \n    if (!isDigit) {\n            return 0;\n        }\n    \n         number = number.replaceFirst(\"^0+(?!$)\", \"\");\n    \n    \n    if (number.length() > 10 && negative) {\n            return -2147483648;\n        } else if (number.length() > 10) {\n            return 2147483647;\n        } else if (number.length() == 10 && negative) {\n            double db1 = Double.parseDouble(number);\n            if (db1 >= 2147483648d) {\n                return -2147483648;\n            }\n        } else if (number.length() == 10) {\n            double db1 = Double.parseDouble(number);\n            if (db1 > (2147483647)) {\n                return 2147483647;\n            }\n        }else if (number.length() == 10 && negative) {\n            double db1 = Double.parseDouble(number);\n            if (db1 >= 2147483648d) {\n                return -2147483648;\n            }\n        }\n    \n    if(negative){\n        return Integer.parseInt(number)*-1;\n    }\n\n        return Integer.parseInt(number);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MyAtoiTest {\n\t\n    @Test\n    void testOne() {\n        assertEquals(42, MyAtoi.myAtoi(\"42\"));\n    }\n  \n      @Test\n    void testTwo() {\n        assertEquals(-42, MyAtoi.myAtoi(\"   -42\"));\n    }\n  \n  \n      @Test\n    void testThree() {\n        assertEquals(4193, MyAtoi.myAtoi(\"4193 with words\"));\n    }\n\t\n}"
    },
    {
        "product_commit": "d418bbd1cf1cfb2cc857194bd3d41d57f63b4c1a",
        "test_commit": "d418bbd1cf1cfb2cc857194bd3d41d57f63b4c1a",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PerfectNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PerfectNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * In number theory, a perfect number is a positive integer that is equal to the\n * sum of its positive divisors, excluding the number itself. For instance, 6\n * has divisors 1, 2 and 3 (excluding itself), and 1 + 2 + 3 = 6, so 6 is a\n * perfect number.\n *\n * <p>\n * link:https://en.wikipedia.org/wiki/Perfect_number\n */\npublic class PerfectNumber {\n\n    public static void main(String[] args) {\n        assert isPerfectNumber(6);\n        /* 1 + 2 + 3 == 6 */\n        assert !isPerfectNumber(8);\n        /* 1 + 2 + 4 != 8 */\n        assert isPerfectNumber(28);\n        /* 1 + 2 + 4 + 7 + 14 == 28 */\n    }\n\n    /**\n     * Check if {@code number} is perfect number or not\n     *\n     * @param number the number\n     * @return {@code true} if {@code number} is perfect number, otherwise false\n     */\n    public static boolean isPerfectNumber(int number) {\n        int sum = 0;\n        /* sum of its positive divisors */\n        for (int i = 1; i < number; ++i) {\n            if (number % i == 0) {\n                sum += i;\n            }\n        }\n        return sum == number;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * In number theory, a perfect number is a positive integer that is equal to the\n * sum of its positive divisors, excluding the number itself. For instance, 6\n * has divisors 1, 2 and 3 (excluding itself), and 1 + 2 + 3 = 6, so 6 is a\n * perfect number.\n *\n * link:https://en.wikipedia.org/wiki/Perfect_number\n */\npublic class PerfectNumber {\n\n    /**\n     * Check if {@code number} is perfect number or not\n     *\n     * @param number the number\n     * @return {@code true} if {@code number} is perfect number, otherwise false\n     */\n    public static boolean isPerfectNumber(int number) {\n        if (number <= 0)\n            return false;\n        int sum = 0;\n        /* sum of its positive divisors */\n        for (int i = 1; i < number; ++i) {\n            if (number % i == 0) {\n                sum += i;\n            }\n        }\n        return sum == number;\n    }\n    \n    /**\n     * Check if {@code n} is perfect number or not\n     *\n     * @param n the number\n     * @return {@code true} if {@code number} is perfect number, otherwise false\n     */\n    public static boolean isPerfectNumber2(int n) {\n        if (n <= 0)\n            return false;\n        int sum = 1;\n        double root = Math.sqrt(n);\n        \n        /*\n         * We can get the factors after the root by dividing number by its factors\n         * before the root.\n         * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n         * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n         * Now by dividing 100 by each factor before 10 we get:\n         * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n         * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n         */\n        for (int i = 2; i <= root; i++) {\n            if (n % i == 0) {\n                sum += i + n / i;\n            }\n        }\n        \n        // if n is a perfect square then its root was added twice in above loop, so subtracting root from sum\n        if (root == (int) root)\n            sum -= root;\n\n        return sum == n;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\nclass PerfectNumberTest {\n\n    @Test\n    public void perfectNumber() {\n        int trueTestCases[] = { 6, 28, 496, 8128, 33550336 };\n        int falseTestCases[] = { -6, 0, 1, 9, 123 };\n        for (Integer n : trueTestCases) {\n            assertTrue(PerfectNumber.isPerfectNumber(n));\n            assertTrue(PerfectNumber.isPerfectNumber2(n));\n        }\n        for (Integer n : falseTestCases) {\n            assertFalse(PerfectNumber.isPerfectNumber(n));\n            assertFalse(PerfectNumber.isPerfectNumber2(n));\n        }\n    }\n}"
    },
    {
        "product_commit": "9e7456a2a81a63649d3be35b136e61f8e0517846",
        "test_commit": "9e7456a2a81a63649d3be35b136e61f8e0517846",
        "product_file_path": "src/main/java/com/thealgorithms/strings/ReverseStringRecursive.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/ReverseStringRecursiveTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Reverse String using Recursion\n */\n\npublic class ReverseStringRecursive {\n    /**\n     * @param str string to be reversed\n     * @return reversed string\n     */\n    public static String reverse(String str)\n    {\n        if(str.isEmpty()){\n            return str;\n        } else {\n            return reverse(str.substring(1))+str.charAt(0);\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ReverseStringRecursiveTest {\n    ReverseStringRecursive stringRecursive = new ReverseStringRecursive();\n\n    @Test\n    void shouldAcceptWhenEmptyStringIsPassed() {\n        String expected = \"\";\n        String reversed  = stringRecursive.reverse(\"\");\n\n        assertEquals(expected,reversed);\n    }\n\n    @Test\n    void shouldAcceptNotWhenWhenSingleCharacterIsPassed() {\n        String expected = \"a\";\n        String reversed  = stringRecursive.reverse(\"a\");\n\n        assertEquals(expected,reversed);\n    }\n\n    @Test\n    void shouldAcceptWhenStringIsPassed() {\n        String expected = \"dlroWolleH\";\n        String reversed  = stringRecursive.reverse(\"HelloWorld\");\n\n        assertEquals(expected,reversed);\n    }\n}"
    },
    {
        "product_commit": "3542f1c4c19e24d94564515fa8c8bf6edb1c17df",
        "test_commit": "3542f1c4c19e24d94564515fa8c8bf6edb1c17df",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CheckTreeIsSymmetric.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckTreeIsSymmetricTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport com.thealgorithms.datastructures.trees.BinaryTree.Node;\n\n/**\n * Check if a binary tree is symmetric or not.\n * A binary tree is a symmetric tree if the left and right subtree of root are mirror image.\n * Below is a symmetric tree\n *                               1\n *                   /                         \\\n *                2                           2\n *         /                \\             /             \\\n *      3                    4         4                3\n *\n * Below is not symmetric because values is different in last level\n *                               1\n *                   /                         \\\n *                 2                           2\n *         /                \\             /             \\\n *      3                    5         4                3\n * <p>\n * Approach:\n * Recursively check for left and right subtree of root\n * 1. left subtrees root's values should be equal right subtree's root value\n * 2. recursively check with left subtrees' left child VS right subtree's right child AND\n * left subtree's right child VS right subtree left child\n * Complexity\n * 1. Time: O(n)\n * 2. Space: O(lg(n)) for height of tree\n *\n * @author kumanoit on 10/10/22 IST 12:52 AM\n */\npublic class CheckTreeIsSymmetric {\n\n    public static boolean isSymmetric(Node root) {\n        if (root == null) {\n            return true;\n        }\n        return isSymmetric(root.left, root.right);\n    }\n\n    private static boolean isSymmetric(Node leftSubtreeRoot, Node rightSubtreRoot) {\n        if (leftSubtreeRoot == null && rightSubtreRoot == null) {\n            return true;\n        }\n\n        if (leftSubtreeRoot == null || rightSubtreRoot == null || leftSubtreeRoot.data != rightSubtreRoot.data) {\n            return false;\n        }\n\n        return isSymmetric(leftSubtreeRoot.right, rightSubtreRoot.left) && isSymmetric(leftSubtreeRoot.left, rightSubtreRoot.right);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author kumanoit on 10/10/22 IST 1:02 AM\n */\npublic class CheckTreeIsSymmetricTest {\n\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(null));\n    }\n\n    @Test\n    public void testSingleNodeTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{100});\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n    @Test\n    public void testSymmetricTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1,2,2,3,4,4,3});\n        assertTrue(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n    @Test\n    public void testNonSymmetricTree() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1,2,2,3,5,4,3});\n        assertFalse(CheckTreeIsSymmetric.isSymmetric(root));\n    }\n\n}"
    },
    {
        "product_commit": "8efc71e609125b9b86337f3513969b8942076045",
        "test_commit": "8efc71e609125b9b86337f3513969b8942076045",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Perimeter.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PerimeterTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class Perimeter {\n\n    public static void main(String[] args) {\n        System.out.println(perimeter_polygon(5, 4));\n        System.out.println(perimeter_rectangle(3, 4));\n        System.out.printf(\"%,3f\", circumference(5));\n    }\n\n    // Perimeter of different 2D geometrical shapes\n    /**\n     *Calculate the Perimeter of polygon.\n     * @parameter length of side.\n     * @parameter number of sides.\n     * @return Perimeter of given polygon\n     */\n    public static float perimeter_polygon(int n, float side) {\n        float perimeter = n * side;\n        return perimeter;\n    }\n\n    /**\n     *Calculate the Perimeter of rectangle.\n     * @parameter length and breadth.\n     * @return Perimeter of given rectangle\n     */\n    public static float perimeter_rectangle(float length, float breadth) {\n        float perimeter = 2 * (length + breadth);\n        return perimeter;\n    }\n\n    /**\n     *Calculate the circumference of circle.\n     * @parameter radius of circle.\n     * @return circumference of given circle.\n     */\n    public static double circumference(float r) {\n        double circumference = 2 * Math.PI * r;\n        return circumference;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n// Perimeter of different 2D geometrical shapes\npublic class Perimeter {\n\n    /**\n     * Calculate the Perimeter of regular polygon (equals sides)\n     * Examples of regular polygon are Equilateral Triangle, Square, Regular Pentagon, Regular Hexagon. \n     * \n     * @param n for number of sides.\n     * @param side for length of each side.\n     * @return Perimeter of given polygon\n     */\n    public static float perimeterRegularPolygon(int n, float side) {\n        return n * side;\n    }\n\n    /**\n     * Calculate the Perimeter of irregular polygon (unequals sides)\n     * Examples of irregular polygon are scalent triangle, irregular quadrilateral, irregular Pentagon, irregular Hexagon. \n     * \n     * @param side1 for length of side 1\n     * @param side2 for length of side 2\n     * @param side3 for length of side 3\n     * @param sides for length of remaining sides\n     * @return Perimeter of given trapezoid.\n     */\n    public static float perimeterIrregularPolygon(float side1, float side2, float side3, float... sides) {\n        float perimeter = side1 + side2 + side3;\n        for (float side : sides) {\n            perimeter += side;\n        }\n        return perimeter;\n    }\n\n    /**\n     * Calculate the Perimeter of rectangle\n     * \n     * @param length for length of rectangle\n     * @param breadth for breadth of rectangle\n     * @return Perimeter of given rectangle\n     */\n    public static float perimeterRectangle(float length, float breadth) {\n        return 2 * (length + breadth);\n    }\n\n    /**\n     * Calculate the Perimeter or Circumference of circle.\n     * \n     * @param r for radius of circle.\n     * @return circumference of given circle.\n     */\n    public static double perimeterCircle(float r) {\n        return 2 * Math.PI * r;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PerimeterTest {\n\n    // Perimeter of Regular polygon\n    @Test\n    void testcase1() {\n        Assertions.assertEquals(20.0, Perimeter.perimeterRegularPolygon(4, 5));\n    }\n\n    @Test\n    void testcase2() {\n        Assertions.assertEquals(30.0, Perimeter.perimeterRegularPolygon(5, 6));\n    }\n\n    // Perimeter of Rectangle\n    @Test\n    void testcase3() {\n        Assertions.assertEquals(18.0, Perimeter.perimeterRectangle(4, 5));\n    }\n\n    @Test\n    void testcase4() {\n        Assertions.assertEquals(14.0, Perimeter.perimeterRectangle(4, 3));\n    }\n\n    // Circumference/Perimeter of a circle\n    @Test\n    void testcase5() {\n        Assertions.assertEquals(31.41592653589793, Perimeter.perimeterCircle(5));\n    }\n\n    @Test\n    void testcase6() {\n        Assertions.assertEquals(43.982297150257104, Perimeter.perimeterCircle(7));\n    }\n  \n    // Perimeter of Irregular polygon\n    @Test\n    void testcase7() {\n        Assertions.assertEquals(12.0, Perimeter.perimeterIrregularPolygon(4, 5, 3));\n    }\n\n    @Test\n    void testcase8() {\n        Assertions.assertEquals(21.0, Perimeter.perimeterIrregularPolygon(3, 4, 5, 3, 6));\n    }\n}"
    },
    {
        "product_commit": "957f633c931009e88b31bfd39b2aad3bc9e93758",
        "test_commit": "957f633c931009e88b31bfd39b2aad3bc9e93758",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PerfectCube.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PerfectCubeTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Cube_(algebra)\n */\npublic class PerfectCube {\n\n    public static void main(String[] args) {\n        assert !isPerfectCube(-1);\n        assert isPerfectCube(0);\n        assert isPerfectCube(1);\n        assert !isPerfectCube(4);\n        assert isPerfectCube(8);\n        assert isPerfectCube(27);\n    }\n\n    /**\n     * Check if a number is perfect cube or not\n     *\n     * @param number number to check\n     * @return {@code true} if {@code number} is perfect cube, otherwise\n     * {@code false}\n     */\n    public static boolean isPerfectCube(int number) {\n        int a = (int) Math.pow(number, 1.0 / 3);\n        return a * a * a == number;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Cube_(algebra)\n */\npublic class PerfectCube {\n\n    /**\n     * Check if a number is perfect cube or not\n     *\n     * @param number number to check\n     * @return {@code true} if {@code number} is perfect cube, otherwise\n     * {@code false}\n     */\n    public static boolean isPerfectCube(int number) {\n        number = Math.abs(number); // converting negative number to positive number\n        int a = (int) Math.pow(number, 1.0 / 3);\n        return a * a * a == number;\n    }\n    \n    /**\n     * Check if a number is perfect cube or not by using Math.cbrt function\n     *\n     * @param number number to check\n     * @return {@code true} if {@code number} is perfect cube, otherwise\n     * {@code false}\n     */\n    public static boolean isPerfectCubeMathCbrt(int number) {\n        double cubeRoot = Math.cbrt(number);\n        return cubeRoot == (int) cubeRoot;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nclass PerfectCubeTest {\n\n    @Test\n    public void perfectCube() {\n\n        Assertions.assertTrue(PerfectCube.isPerfectCube(-27));\n        Assertions.assertTrue(PerfectCube.isPerfectCubeMathCbrt(-27));\n        Assertions.assertTrue(PerfectCube.isPerfectCube(-1));\n        Assertions.assertTrue(PerfectCube.isPerfectCubeMathCbrt(-1));\n        Assertions.assertTrue(PerfectCube.isPerfectCube(0));\n        Assertions.assertTrue(PerfectCube.isPerfectCubeMathCbrt(0));\n        Assertions.assertTrue(PerfectCube.isPerfectCube(1));\n        Assertions.assertTrue(PerfectCube.isPerfectCubeMathCbrt(1));\n        Assertions.assertTrue(PerfectCube.isPerfectCube(8));\n        Assertions.assertTrue(PerfectCube.isPerfectCubeMathCbrt(8));\n        Assertions.assertTrue(PerfectCube.isPerfectCube(27));\n        Assertions.assertTrue(PerfectCube.isPerfectCubeMathCbrt(27));\n\n        Assertions.assertFalse(PerfectCube.isPerfectCube(-9));\n        Assertions.assertFalse(PerfectCube.isPerfectCubeMathCbrt(-9));\n        Assertions.assertFalse(PerfectCube.isPerfectCube(2));\n        Assertions.assertFalse(PerfectCube.isPerfectCubeMathCbrt(2));\n        Assertions.assertFalse(PerfectCube.isPerfectCube(4));\n        Assertions.assertFalse(PerfectCube.isPerfectCubeMathCbrt(4));\n        Assertions.assertFalse(PerfectCube.isPerfectCube(30));\n        Assertions.assertFalse(PerfectCube.isPerfectCubeMathCbrt(30));\n    }\n}"
    },
    {
        "product_commit": "5ab1b6c3195505bb77c4865e5e538370dc74777f",
        "test_commit": "5ab1b6c3195505bb77c4865e5e538370dc74777f",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Volume.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/VolumeTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/* Find volume of various shapes.*/\npublic class Volume {\n\n    public static void main(String[] args) {\n        /* test cube */\n        assert Double.compare(volumeCube(7), 343.0) == 0;\n\n        /* test cuboid */\n        assert Double.compare(volumeCuboid(2, 5, 7), 70.0) == 0;\n\n        /* test sphere */\n        assert Double.compare(volumeSphere(5), 523.5987755982989) == 0;\n\n        /* test cylinder */\n        assert Double.compare(volumeCylinder(1, 2), 12.566370614359172) == 0;\n\n        /* test hemisphere */\n        assert Double.compare(volumeHemisphere(5), 261.79938779914943) == 0;\n\n        /* test cone */\n        assert Double.compare(volumeCone(5, 7), 916.297857297023) == 0;\n\n        /*test prism*/\n        assert Double.compare(volumePrism(10, 2), 20.0) == 0;\n\n        /*test pyramid*/\n        assert Double.compare(volumePyramid(10, 3), 10.0) == 0;\n    }\n\n    /**\n     * Calculate the volume of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return volume of given cube\n     */\n    private static double volumeCube(double sidelength) {\n        return sidelength * sidelength * sidelength;\n    }\n\n    /**\n     * Calculate the volume of a cuboid.\n     *\n     * @param width of cuboid\n     * @param height of cuboid\n     * @param length of cuboid\n     * @return volume of given cuboid\n     */\n    private static double volumeCuboid(\n        double width,\n        double height,\n        double length\n    ) {\n        return width * height * length;\n    }\n\n    /**\n     * Calculate the volume of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return volume of given sphere\n     */\n    private static double volumeSphere(double radius) {\n        return 4 / 3 * Math.PI * radius * radius * radius;\n    }\n\n    /**\n     * Calculate volume of a cylinder\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    private static double volumeCylinder(double radius, double height) {\n        return Math.PI * radius * radius * height;\n    }\n\n    /**\n     * Calculate the volume of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return volume of given hemisphere\n     */\n    private static double volumeHemisphere(double radius) {\n        return 2 / 3 * Math.PI * radius * radius * radius;\n    }\n\n    /**\n     * Calculate the volume of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return volume of given cone.\n     */\n    private static double volumeCone(double radius, double height) {\n        return Math.PI * radius * radius * height / 3;\n    }\n\n    /**\n     * Calculate the volume of a prism.\n     *\n     * @param area of the base.\n     * @param height of prism.\n     * @return volume of given prism.\n     */\n    private static double volumePrism(double basearea, double height) {\n        return basearea * height;\n    }\n\n    /**\n     * Calculate the volume of a pyramid.\n     *\n     * @param area of the base.\n     * @param height of pyramid.\n     * @return volume of given pyramid.\n     */\n    private static double volumePyramid(double basearea, double height) {\n        return basearea * height / 3;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/* Find volume of various shapes.*/\npublic class Volume {\n\n    /**\n     * Calculate the volume of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return volume of given cube\n     */\n    public static double volumeCube(double sidelength) {\n        return sidelength * sidelength * sidelength;\n    }\n\n    /**\n     * Calculate the volume of a cuboid.\n     *\n     * @param width  of cuboid\n     * @param height of cuboid\n     * @param length of cuboid\n     * @return volume of given cuboid\n     */\n    public static double volumeCuboid(double width, double height, double length) {\n        return width * height * length;\n    }\n\n    /**\n     * Calculate the volume of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return volume of given sphere\n     */\n    public static double volumeSphere(double radius) {\n        return (4 * Math.PI * radius * radius * radius) / 3;\n    }\n\n    /**\n     * Calculate volume of a cylinder\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double volumeCylinder(double radius, double height) {\n        return Math.PI * radius * radius * height;\n    }\n\n    /**\n     * Calculate the volume of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return volume of given hemisphere\n     */\n    public static double volumeHemisphere(double radius) {\n        return (2 * Math.PI * radius * radius * radius) / 3;\n    }\n\n    /**\n     * Calculate the volume of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return volume of given cone.\n     */\n    public static double volumeCone(double radius, double height) {\n        return (Math.PI * radius * radius * height) / 3;\n    }\n\n    /**\n     * Calculate the volume of a prism.\n     *\n     * @param area   of the base.\n     * @param height of prism.\n     * @return volume of given prism.\n     */\n    public static double volumePrism(double basearea, double height) {\n        return basearea * height;\n    }\n\n    /**\n     * Calculate the volume of a pyramid.\n     *\n     * @param area   of the base.\n     * @param height of pyramid.\n     * @return volume of given pyramid.\n     */\n    public static double volumePyramid(double basearea, double height) {\n        return (basearea * height) / 3;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class VolumeTest {\n\n    @Test\n    public void volume() {\n\n        /* test cube */\n        assertTrue(Volume.volumeCube(7) == 343.0);\n\n        /* test cuboid */\n        assertTrue(Volume.volumeCuboid(2, 5, 7) == 70.0);\n\n        /* test sphere */\n        assertTrue(Volume.volumeSphere(7) == 1436.7550402417319);\n\n        /* test cylinder */\n        assertTrue(Volume.volumeCylinder(3, 7) == 197.92033717615698);\n\n        /* test hemisphere */\n        assertTrue(Volume.volumeHemisphere(7) == 718.3775201208659);\n\n        /* test cone */\n        assertTrue(Volume.volumeCone(3, 7) == 65.97344572538566);\n\n        /* test prism */\n        assertTrue(Volume.volumePrism(10, 2) == 20.0);\n\n        /* test pyramid */\n        assertTrue(Volume.volumePyramid(10, 3) == 10.0);\n    }\n}"
    },
    {
        "product_commit": "bd267bb7d85d6edf5df5542017f6c07582a56277",
        "test_commit": "bd267bb7d85d6edf5df5542017f6c07582a56277",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Palindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PalindromeTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] palindromes = { null, \"\", \"aba\", \"123321\" };\n        for (String s : palindromes) {\n            assert isPalindrome(s) &&\n            isPalindromeRecursion(s) &&\n            isPalindrome1(s);\n        }\n\n        String[] notPalindromes = { \"abb\", \"abc\", \"abc123\" };\n        for (String s : notPalindromes) {\n            assert !isPalindrome(s) &&\n            !isPalindromeRecursion(s) &&\n            !isPalindrome1(s);\n        }\n    }\n\n    /**\n     * Check if a string is palindrome string or not\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return (\n            (s == null || s.length() <= 1) ||\n            s.equals(new StringBuilder(s).reverse().toString())\n        );\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindrome(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not another way\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome1(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Check if a string is palindrome string or not using String Builder\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return (\n            (s == null || s.length() <= 1) ||\n            s.equals(new StringBuilder(s).reverse().toString())\n        );\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindromeRecursion(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not using two pointer technique\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeTwoPointer(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"kayak\";\n        String input2 = \"kayaks\";\n        Assertions.assertTrue(Palindrome.isPalindrome(input1));\n        Assertions.assertFalse(Palindrome.isPalindrome(input2));\n        Assertions.assertTrue(Palindrome.isPalindromeRecursion(input1));\n        Assertions.assertFalse(Palindrome.isPalindromeRecursion(input2));\n        Assertions.assertTrue(Palindrome.isPalindrome1(input1));\n        Assertions.assertFalse(Palindrome.isPalindrome1(input2));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n\n    @Test\n    public void palindrome() {\n\n        String[] palindromes = { null, \"\", \"aba\", \"123321\", \"kayak\" };\n        for (String s : palindromes) {\n            Assertions.assertTrue(Palindrome.isPalindrome(s) &&\n            Palindrome.isPalindromeRecursion(s) &&\n            Palindrome.isPalindromeTwoPointer(s));\n        }\n\n        String[] notPalindromes = { \"abb\", \"abc\", \"abc123\", \"kayaks\" };\n        for (String s : notPalindromes) {\n            Assertions.assertFalse(Palindrome.isPalindrome(s) ||\n            Palindrome.isPalindromeRecursion(s) ||\n            Palindrome.isPalindromeTwoPointer(s));\n        }\n        \n    }\n}"
    },
    {
        "product_commit": "acf7a86b9609077ba025431afb91788bd6163800",
        "test_commit": "acf7a86b9609077ba025431afb91788bd6163800",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Pangram.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PangramTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Checks if a String is Pangram or not by checking if each alhpabet is present or not\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram2(String s) {\n        if (s.length() < 26) {\n            return false;\n        }\n        s = s.toLowerCase(); // Converting s to Lower-Case\n        for (char i = 'a'; i <= 'z'; i++) {\n            if (s.indexOf(i) == -1) {\n                return false; // if any alphabet is not present, return false\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static com.thealgorithms.strings.Pangram.isPangram;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PangramTest {\n\n    @Test\n    public void testPangram() {\n        assertTrue(isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class PangramTest {\n\n    @Test\n    public void testPangram() {\n        assertTrue(Pangram.isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n        \n        assertTrue(Pangram.isPangram2(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(Pangram.isPangram2(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(Pangram.isPangram2(\"+-1234 This string is not alphabetical\"));\n        assertFalse(Pangram.isPangram2(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}"
    },
    {
        "product_commit": "b2393d62a00f395861b763813d17658b1dabe136",
        "test_commit": "b2393d62a00f395861b763813d17658b1dabe136",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/EggDropping.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/EggDroppingTest.java",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * DynamicProgramming solution for the Egg Dropping Puzzle\n */\npublic class EggDropping {\n\n    // min trials with n eggs and m floors\n    private static int minTrials(int n, int m) {\n        int[][] eggFloor = new int[n + 1][m + 1];\n        int result, x;\n\n        for (int i = 1; i <= n; i++) {\n            eggFloor[i][0] = 0; // Zero trial for zero floor.\n            eggFloor[i][1] = 1; // One trial for one floor\n        }\n\n        // j trials for only 1 egg\n        for (int j = 1; j <= m; j++) {\n            eggFloor[1][j] = j;\n        }\n\n        // Using bottom-up approach in DP\n        for (int i = 2; i <= n; i++) {\n            for (int j = 2; j <= m; j++) {\n                eggFloor[i][j] = Integer.MAX_VALUE;\n                for (x = 1; x <= j; x++) {\n                    result =\n                        1 +\n                        Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\n\n                    // choose min of all values for particular x\n                    if (result < eggFloor[i][j]) {\n                        eggFloor[i][j] = result;\n                    }\n                }\n            }\n        }\n\n        return eggFloor[n][m];\n    }\n\n    public static void main(String args[]) {\n        int n = 2, m = 4;\n        // result outputs min no. of trials in worst case for n eggs and m floors\n        int result = minTrials(n, m);\n        System.out.println(result);\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * DynamicProgramming solution for the Egg Dropping Puzzle\n */\npublic class EggDropping {\n\n    // min trials with n eggs and m floors\n    public static int minTrials(int n, int m) {\n        int[][] eggFloor = new int[n + 1][m + 1];\n        int result, x;\n\n        for (int i = 1; i <= n; i++) {\n            eggFloor[i][0] = 0; // Zero trial for zero floor.\n            eggFloor[i][1] = 1; // One trial for one floor\n        }\n\n        // j trials for only 1 egg\n        for (int j = 1; j <= m; j++) {\n            eggFloor[1][j] = j;\n        }\n\n        // Using bottom-up approach in DP\n        for (int i = 2; i <= n; i++) {\n            for (int j = 2; j <= m; j++) {\n                eggFloor[i][j] = Integer.MAX_VALUE;\n                for (x = 1; x <= j; x++) {\n                    result =\n                        1 +\n                        Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\n\n                    // choose min of all values for particular x\n                    if (result < eggFloor[i][j]) {\n                        eggFloor[i][j] = result;\n                    }\n                }\n            }\n        }\n\n        return eggFloor[n][m];\n    }\n\n    public static void main(String args[]) {\n        int n = 2, m = 4;\n        // result outputs min no. of trials in worst case for n eggs and m floors\n        int result = minTrials(n, m);\n        System.out.println(result);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class EggDroppingTest {\n\n    @Test\n    void hasMultipleEggSingleFloor(){\n        assertEquals(1,EggDropping.minTrials(3,1));\n    }\n\n    @Test\n    void hasSingleEggSingleFloor(){\n        assertEquals(1,EggDropping.minTrials(1,1));\n    }\n\n    @Test\n    void hasSingleEggMultipleFloor(){\n        assertEquals(3,EggDropping.minTrials(1,3));\n    }\n\n    @Test\n    void hasMultipleEggMultipleFloor(){\n        assertEquals(7,EggDropping.minTrials(100,101));\n    }\n}"
    },
    {
        "product_commit": "23949cac47bf70732803743fc3522534e7a09361",
        "test_commit": "23949cac47bf70732803743fc3522534e7a09361",
        "product_file_path": "src/main/java/com/thealgorithms/conversions/BinaryToDecimal.java",
        "test_file_path": "src/test/java/com/thealgorithms/conversions/BinaryToDecimalTest.java",
        "product_old_content": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\n/**\n * This class converts a Binary number to a Decimal number\n */\nclass BinaryToDecimal {\n\n    /**\n     * Main Method\n     *\n     * @param args Command line arguments\n     */\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int binNum, binCopy, d, s = 0, power = 0;\n        System.out.print(\"Binary number: \");\n        binNum = sc.nextInt();\n        binCopy = binNum;\n        while (binCopy != 0) {\n            d = binCopy % 10;\n            s += d * (int) Math.pow(2, power++);\n            binCopy /= 10;\n        }\n        System.out.println(\"Decimal equivalent:\" + s);\n        sc.close();\n    }\n}",
        "product_new_content": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\n/**\n * This class converts a Binary number to a Decimal number\n */\nclass BinaryToDecimal {\n\n    public static int binaryToDecimal(int binNum) {\n        int binCopy, d, s = 0, power = 0;\n        binCopy = binNum;\n        while (binCopy != 0) {\n            d = binCopy % 10;\n            s += d * (int) Math.pow(2, power++);\n            binCopy /= 10;\n        }\n        return s;\n    }\n\n    /**\n     * Main Method\n     *\n     * @param args Command line arguments\n     */\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Binary number: \");\n        System.out.println(\"Decimal equivalent:\" + binaryToDecimal(sc.nextInt()));\n        sc.close();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.conversions;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BinaryToDecimalTest {\n\n    @Test\n    public void testBinaryToDecimal() {\n        //zeros at the starting should be removed\n        assertEquals(0, BinaryToDecimal.binaryToDecimal(0));\n        assertEquals(1, BinaryToDecimal.binaryToDecimal(1));\n        assertEquals(5, BinaryToDecimal.binaryToDecimal(101));\n        assertEquals(63, BinaryToDecimal.binaryToDecimal(111111));\n        assertEquals(512, BinaryToDecimal.binaryToDecimal(1000000000));\n    }\n}"
    },
    {
        "product_commit": "2c9edc95b88cb76c256b8fb01a8f9912717d708b",
        "test_commit": "2c9edc95b88cb76c256b8fb01a8f9912717d708b",
        "product_file_path": "src/main/java/com/thealgorithms/conversions/HexaDecimalToBinary.java",
        "test_file_path": "src/test/java/com/thealgorithms/conversions/HexaDecimalToBinaryTest.java",
        "product_old_content": "package com.thealgorithms.conversions;\n\n// Hex [0-9],[A-F] -> Binary [0,1]\npublic class HexaDecimalToBinary {\n\n    private final int LONG_BITS = 8;\n\n    public void convert(String numHex) {\n        // String a HexaDecimal:\n        int conHex = Integer.parseInt(numHex, 16);\n        // Hex a Binary:\n        String binary = Integer.toBinaryString(conHex);\n        // Output:\n        System.out.println(numHex + \" = \" + completeDigits(binary));\n    }\n\n    public String completeDigits(String binNum) {\n        for (int i = binNum.length(); i < LONG_BITS; i++) {\n            binNum = \"0\" + binNum;\n        }\n        return binNum;\n    }\n\n    public static void main(String[] args) {\n        // Testing Numbers:\n        String[] hexNums = {\n            \"1\",\n            \"A1\",\n            \"ef\",\n            \"BA\",\n            \"AA\",\n            \"BB\",\n            \"19\",\n            \"01\",\n            \"02\",\n            \"03\",\n            \"04\",\n        };\n        HexaDecimalToBinary objConvert = new HexaDecimalToBinary();\n\n        for (String num : hexNums) {\n            objConvert.convert(num);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.conversions;\n\n// Hex [0-9],[A-F] -> Binary [0,1]\npublic class HexaDecimalToBinary {\n\n    private final int LONG_BITS = 8;\n\n    public String convert(String numHex) {\n        // String a HexaDecimal:\n        int conHex = Integer.parseInt(numHex, 16);\n        // Hex a Binary:\n        String binary = Integer.toBinaryString(conHex);\n        // Output:\n        return completeDigits(binary);\n    }\n\n    public String completeDigits(String binNum) {\n        for (int i = binNum.length(); i < LONG_BITS; i++) {\n            binNum = \"0\" + binNum;\n        }\n        return binNum;\n    }\n\n    public static void main(String[] args) {\n        // Testing Numbers:\n        String[] hexNums = {\n            \"1\",\n            \"A1\",\n            \"ef\",\n            \"BA\",\n            \"AA\",\n            \"BB\",\n            \"19\",\n            \"01\",\n            \"02\",\n            \"03\",\n            \"04\",\n        };\n        HexaDecimalToBinary objConvert = new HexaDecimalToBinary();\n\n        for (String num : hexNums) {\n            System.out.println(num + \" = \" + objConvert.convert(num));\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.conversions;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HexaDecimalToBinaryTest {\n\n    @Test\n    public void testHexaDecimalToBinary(){\n        HexaDecimalToBinary hexaDecimalToBinary = new HexaDecimalToBinary();\n        assertEquals(\"1111111111111111111111111111111\", hexaDecimalToBinary.convert(\"7fffffff\"));\n        assertEquals(\"101010111100110111101111\", hexaDecimalToBinary.convert(\"abcdef\"));\n    }\n}"
    },
    {
        "product_commit": "a0d03e814a34e02cb469de4efdd38459e56335ba",
        "test_commit": "a0d03e814a34e02cb469de4efdd38459e56335ba",
        "product_file_path": "src/main/java/com/thealgorithms/strings/WordLadder.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/WordLadderTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/*\n    **Problem Statement:**\n    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\n    Every adjacent pair of words differs by a single letter.\n    Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n    sk == endWord\n    Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\n    **Example 1:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    Output: 5 \n    Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n    **Example 2:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    Output: 0\n    Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n    **Constraints:**\n    1 <= beginWord.length <= 10\n    endWord.length == beginWord.length\n    1 <= wordList.length <= 5000\n    wordList[i].length == beginWord.length\n    beginWord, endWord, and wordList[i] consist of lowercase English letters.\n    beginWord != endWord\n    All the words in wordList are unique.\n */\nclass WordLadder {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String beginWord = \"hit\";\n        String endWord = \"cog\";\n        String words[] = { \"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\" };\n        List<String> wordList = Arrays.asList(words);\n\n        System.out.println(\n            \"Ladder Length: \" + ladderLength(beginWord, endWord, wordList)\n        );\n    }\n\n    /**\n     * This function finds the ladderLength\n     *\n     * @param beginWord: Starting word of the ladder\n     * @param endWord: Ending word of the ladder\n     * @param wordList: This list contains the words which needs to be included\n     * in ladder.\n     * @return ladderLength: This function will return the ladderLength(level)\n     * if the endword is there. Otherwise, will return the length as 0.\n     */\n    public static int ladderLength(\n        String beginWord,\n        String endWord,\n        List<String> wordList\n    ) {\n        HashSet<String> set = new HashSet();\n        for (String word : wordList) {\n            set.add(word);\n        }\n\n        if (!set.contains(endWord)) {\n            return 0;\n        }\n\n        Queue<String> queue = new LinkedList();\n        queue.offer(beginWord);\n        int level = 1;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String curr = queue.poll();\n                char[] words_chars = curr.toCharArray();\n                for (int j = 0; j < words_chars.length; j++) {\n                    char original_chars = words_chars[j];\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (words_chars[j] == c) {\n                            continue;\n                        }\n                        words_chars[j] = c;\n                        String new_word = String.valueOf(words_chars);\n                        if (new_word.equals(endWord)) {\n                            return level + 1;\n                        }\n                        if (set.contains(new_word)) {\n                            set.remove(new_word);\n                            queue.offer(new_word);\n                        }\n                    }\n                    words_chars[j] = original_chars;\n                }\n            }\n            level++;\n        }\n        return 0;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/*\n    **Problem Statement:**\n    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\n    Every adjacent pair of words differs by a single letter.\n    Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\n    sk == endWord\n    Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\n    **Example 1:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    Output: 5 \n    Explanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\n\n    **Example 2:**\n    Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    Output: 0\n    Explanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n\n    **Constraints:**\n    1 <= beginWord.length <= 10\n    endWord.length == beginWord.length\n    1 <= wordList.length <= 5000\n    wordList[i].length == beginWord.length\n    beginWord, endWord, and wordList[i] consist of lowercase English letters.\n    beginWord != endWord\n    All the words in wordList are unique.\n */\n\nclass WordLadder {\n\n    /**\n     * This function finds the ladderLength\n     *\n     * @param beginWord: Starting word of the ladder\n     * @param endWord: Ending word of the ladder\n     * @param wordList: This list contains the words which needs to be included\n     * in ladder.\n     * @return ladderLength: This function will return the ladderLength(level)\n     * if the endword is there. Otherwise, will return the length as 0.\n     */\n    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> set = new HashSet();\n        for (String word : wordList) {\n            set.add(word);\n        }\n\n        if (!set.contains(endWord)) {\n            return 0;\n        }\n\n        Queue<String> queue = new LinkedList();\n        queue.offer(beginWord);\n        int level = 1;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String curr = queue.poll();\n                char[] words_chars = curr.toCharArray();\n                for (int j = 0; j < words_chars.length; j++) {\n                    char original_chars = words_chars[j];\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (words_chars[j] == c) {\n                            continue;\n                        }\n                        words_chars[j] = c;\n                        String new_word = String.valueOf(words_chars);\n                        if (new_word.equals(endWord)) {\n                            return level + 1;\n                        }\n                        if (set.contains(new_word)) {\n                            set.remove(new_word);\n                            queue.offer(new_word);\n                        }\n                    }\n                    words_chars[j] = original_chars;\n                }\n            }\n            level++;\n        }\n        return 0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.*;\n\npublic class WordLadderTest {\n\n    @Test\n    public void testWordLadder() {\n        String words1[] = { \"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\" };\n        assertEquals(5, WordLadder.ladderLength(\"hit\", \"cog\", Arrays.asList(words1)));\n        String words2[] = { \"hot\", \"dot\", \"dog\", \"lot\", \"log\" };\n        assertEquals(0, WordLadder.ladderLength(\"hit\", \"cog\", Arrays.asList(words2)));\n     }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.util.*;\n\npublic class WordLadderTest {\n\n    @Test\n    public void testWordLadder() {\n       \n        /**\n         * Test 1:\n         * Input: beginWord = \"hit\", endWord = \"cog\", wordList =\n         * [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n         * Output: 5\n         * Explanation: One shortest transformation sequence is\n         * \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\"\n         * which is 5 words long.\n         */\n\n        List<String> wordList1 = Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\");\n        assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList1), 5);\n\n        /**\n         * Test 2:\n         * Input: beginWord = \"hit\", endWord = \"cog\", wordList =\n         * [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n         * Output: 0\n         * Explanation: The endWord \"cog\" is not in wordList,\n         * therefore there is no valid transformation sequence.\n         */\n\n        List<String> wordList2 = Arrays.asList(\"hot\", \"dot\", \"dog\", \"lot\", \"log\");\n        assertEquals(WordLadder.ladderLength(\"hit\", \"cog\", wordList2), 0);\n\n     }\n}"
    },
    {
        "product_commit": "eecec0f706018071f4a347260f320d52c1e69798",
        "test_commit": "eecec0f706018071f4a347260f320d52c1e69798",
        "product_file_path": "src/main/java/com/thealgorithms/strings/LetterCombinationsOfPhoneNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/LetterCombinationsOfPhoneNumberTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.*;\n\npublic class LetterCombinationsOfPhoneNumber {\n\n    static Character[][] numberToCharMap;\n\n    protected static List<String> printWords(int[] numbers, int len, int numIndex, String s) {\n        if (len == numIndex) {\n            return new ArrayList<>(Collections.singleton(s));\n        }\n\n        List<String> stringList = new ArrayList<>();\n\n        for (int i = 0; i < numberToCharMap[numbers[numIndex]].length; i++) {\n            String sCopy = String.copyValueOf(s.toCharArray());\n            sCopy =\n                sCopy.concat(numberToCharMap[numbers[numIndex]][i].toString());\n            stringList.addAll(printWords(numbers, len, numIndex + 1, sCopy));\n        }\n        return stringList;\n    }\n\n    private static void printWords(int[] numbers) {\n        generateNumberToCharMap();\n        List<String> stringList = printWords(numbers, numbers.length, 0, \"\");\n        stringList.stream().forEach(System.out::println);\n    }\n\n    protected static void generateNumberToCharMap() {\n        numberToCharMap = new Character[10][5];\n        numberToCharMap[0] = new Character[] { '\\0' };\n        numberToCharMap[1] = new Character[] { '\\0' };\n        numberToCharMap[2] = new Character[] { 'a', 'b', 'c' };\n        numberToCharMap[3] = new Character[] { 'd', 'e', 'f' };\n        numberToCharMap[4] = new Character[] { 'g', 'h', 'i' };\n        numberToCharMap[5] = new Character[] { 'j', 'k', 'l' };\n        numberToCharMap[6] = new Character[] { 'm', 'n', 'o' };\n        numberToCharMap[7] = new Character[] { 'p', 'q', 'r', 's' };\n        numberToCharMap[8] = new Character[] { 't', 'u', 'v' };\n        numberToCharMap[9] = new Character[] { 'w', 'x', 'y', 'z' };\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        int number[] = { 2, 3, 4 };\n        printWords(number);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport java.util.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class LetterCombinationsOfPhoneNumberTest {\n\n    @Test\n    public void letterCombinationsOfPhoneNumber() {\n        LetterCombinationsOfPhoneNumber ob = new LetterCombinationsOfPhoneNumber();\n        ob.generateNumberToCharMap();\n\n        // ** Test 1 **\n        // Input: digits = \"\"\n        // Output: []\n        int[] numbers1 = {};\n        List<String> output1 = Arrays.asList(\"\");\n        assertTrue(ob.printWords(numbers1, numbers1.length, 0, \"\").equals(output1));\n\n        // ** Test 2 **\n        // Input: digits = \"2\"\n        // Output: [\"a\",\"b\",\"c\"]\n        int[] numbers2 = { 2 };\n        List<String> output2 = Arrays.asList(\"a\", \"b\", \"c\");\n        assertTrue(ob.printWords(numbers2, numbers2.length, 0, \"\").equals(output2));\n\n        // ** Test 3 **\n        // Input: digits = \"23\"\n        // Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        int[] numbers3 = { 2, 3 };\n        List<String> output3 = Arrays.asList(\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\");\n        assertTrue(ob.printWords(numbers3, numbers3.length, 0, \"\").equals(output3));\n\n        // ** Test 4 **\n        // Input: digits = \"234\"\n        // Output: [\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\",\n        // \"bdg\", \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\",\n        // \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\", \"cfh\", \"cfi\"]\n        int[] numbers4 = { 2, 3, 4 };\n        List<String> output4 = Arrays.asList(\"adg\", \"adh\", \"adi\", \"aeg\", \"aeh\", \"aei\", \"afg\", \"afh\", \"afi\", \"bdg\",\n                \"bdh\", \"bdi\", \"beg\", \"beh\", \"bei\", \"bfg\", \"bfh\", \"bfi\", \"cdg\", \"cdh\", \"cdi\", \"ceg\", \"ceh\", \"cei\", \"cfg\",\n                \"cfh\", \"cfi\");\n        assertTrue(ob.printWords(numbers4, numbers4.length, 0, \"\").equals(output4));\n    }\n}"
    },
    {
        "product_commit": "8c6ed9c24061b15693705857e16f270275030ff2",
        "test_commit": "8c6ed9c24061b15693705857e16f270275030ff2",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/RSA.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/RSATest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\nimport javax.swing.*;\n\n/**\n * @author Nguyen Duy Tiep on 23-Oct-17.\n */\npublic final class RSA {\n\n    public static void main(String[] args) {\n        RSA rsa = new RSA(1024);\n        String text1 = JOptionPane.showInputDialog(\n            \"Enter a message to encrypt :\"\n        );\n\n        String ciphertext = rsa.encrypt(text1);\n        JOptionPane.showMessageDialog(\n            null,\n            \"Your encrypted message : \" + ciphertext\n        );\n\n        JOptionPane.showMessageDialog(\n            null,\n            \"Your message after decrypt : \" + rsa.decrypt(ciphertext)\n        );\n    }\n\n    private BigInteger modulus, privateKey, publicKey;\n\n    public RSA(int bits) {\n        generateKeys(bits);\n    }\n\n    /**\n     * @return encrypted message\n     */\n    public synchronized String encrypt(String message) {\n        return (new BigInteger(message.getBytes())).modPow(publicKey, modulus)\n            .toString();\n    }\n\n    /**\n     * @return encrypted message as big integer\n     */\n    public synchronized BigInteger encrypt(BigInteger message) {\n        return message.modPow(publicKey, modulus);\n    }\n\n    /**\n     * @return plain message\n     */\n    public synchronized String decrypt(String encryptedMessage) {\n        return new String(\n            (new BigInteger(encryptedMessage)).modPow(privateKey, modulus)\n                .toByteArray()\n        );\n    }\n\n    /**\n     * @return plain message as big integer\n     */\n    public synchronized BigInteger decrypt(BigInteger encryptedMessage) {\n        return encryptedMessage.modPow(privateKey, modulus);\n    }\n\n    /**\n     * Generate a new public and private key set.\n     */\n    public synchronized void generateKeys(int bits) {\n        SecureRandom r = new SecureRandom();\n        BigInteger p = new BigInteger(bits / 2, 100, r);\n        BigInteger q = new BigInteger(bits / 2, 100, r);\n        modulus = p.multiply(q);\n\n        BigInteger m =\n            (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\n\n        publicKey = new BigInteger(\"3\");\n\n        while (m.gcd(publicKey).intValue() > 1) {\n            publicKey = publicKey.add(new BigInteger(\"2\"));\n        }\n\n        privateKey = publicKey.modInverse(m);\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\n\n/**\n * @author Nguyen Duy Tiep on 23-Oct-17.\n */\npublic class RSA {\n\n    private BigInteger modulus;\n    private BigInteger privateKey;\n    private BigInteger publicKey;\n\n    public RSA(int bits) {\n        generateKeys(bits);\n    }\n\n    /**\n     * @return encrypted message\n     */\n    public synchronized String encrypt(String message) {\n        return (new BigInteger(message.getBytes())).modPow(publicKey, modulus)\n            .toString();\n    }\n\n    /**\n     * @return encrypted message as big integer\n     */\n    public synchronized BigInteger encrypt(BigInteger message) {\n        return message.modPow(publicKey, modulus);\n    }\n\n    /**\n     * @return plain message\n     */\n    public synchronized String decrypt(String encryptedMessage) {\n        return new String(\n            (new BigInteger(encryptedMessage)).modPow(privateKey, modulus)\n                .toByteArray()\n        );\n    }\n\n    /**\n     * @return plain message as big integer\n     */\n    public synchronized BigInteger decrypt(BigInteger encryptedMessage) {\n        return encryptedMessage.modPow(privateKey, modulus);\n    }\n\n    /**\n     * Generate a new public and private key set.\n     */\n    public synchronized void generateKeys(int bits) {\n        SecureRandom r = new SecureRandom();\n        BigInteger p = new BigInteger(bits / 2, 100, r);\n        BigInteger q = new BigInteger(bits / 2, 100, r);\n        modulus = p.multiply(q);\n\n        BigInteger m =\n            (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\n\n        publicKey = BigInteger.valueOf(3L);\n\n        while (m.gcd(publicKey).intValue() > 1) {\n            publicKey = publicKey.add(BigInteger.valueOf(2L));\n        }\n\n        privateKey = publicKey.modInverse(m);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass RSATest {\n\n    RSA rsa = new RSA(1024);\n\n    @Test\n    void testRSA() {\n        // given\n        String textToEncrypt = \"Such secure\";\n\n        // when\n        String cipherText = rsa.encrypt(textToEncrypt);\n        String decryptedText = rsa.decrypt(cipherText);\n\n        // then\n        assertEquals(\"Such secure\", decryptedText);\n    }\n\n}"
    },
    {
        "product_commit": "f8897f166dc0d7850a640d409f9402945261e5e6",
        "test_commit": "f8897f166dc0d7850a640d409f9402945261e5e6",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Caesar.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/CaesarTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\nimport java.util.Scanner;\n\n/**\n * A Java implementation of Caesar Cipher. /It is a type of substitution cipher\n * in which each letter in the plaintext is replaced by a letter some fixed\n * number of positions down the alphabet. /\n *\n * @author FAHRI YARDIMCI\n * @author khalil2535\n */\npublic class Caesar {\n\n    /**\n     * Encrypt text by shifting every Latin char by add number shift for ASCII\n     * Example : A + 1 -> B\n     *\n     * @return Encrypted message\n     */\n    public static String encode(String message, int shift) {\n        StringBuilder encoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = message.length();\n        for (int i = 0; i < length; i++) {\n            //            int current = message.charAt(i); //using char to shift characters because ascii\n            // is in-order latin alphabet\n            char current = message.charAt(i); // Java law : char + int = char\n\n            if (IsCapitalLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters\n            } else if (IsSmallLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters\n            } else {\n                encoded.append(current);\n            }\n        }\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by shifting back every Latin char to previous the ASCII\n     * Example : B - 1 -> A\n     *\n     * @return message\n     */\n    public static String decode(String encryptedMessage, int shift) {\n        StringBuilder decoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = encryptedMessage.length();\n        for (int i = 0; i < length; i++) {\n            char current = encryptedMessage.charAt(i);\n            if (IsCapitalLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n            } else if (IsSmallLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n            } else {\n                decoded.append(current);\n            }\n        }\n        return decoded.toString();\n    }\n\n    /**\n     * @return true if character is capital Latin letter or false for others\n     */\n    private static boolean IsCapitalLatinLetter(char c) {\n        return c >= 'A' && c <= 'Z';\n    }\n\n    /**\n     * @return true if character is small Latin letter or false for others\n     */\n    private static boolean IsSmallLatinLetter(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    /**\n     *  @return string array which contains all the possible decoded combination.\n     */\n    public static String[] bruteforce(String encryptedMessage) {\n        String[] listOfAllTheAnswers = new String[27];\n        for (int i = 0; i <= 26; i++) {\n            listOfAllTheAnswers[i] = decode(encryptedMessage, i);\n        }\n\n        return listOfAllTheAnswers;\n    }\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int shift = 0;\n        System.out.println(\"Please enter the message (Latin Alphabet)\");\n        String message = input.nextLine();\n        System.out.println(message);\n        System.out.println(\"(E)ncode or (D)ecode or (B)ruteforce?\");\n        char choice = input.next().charAt(0);\n        switch (choice) {\n            case 'E':\n            case 'e':\n                System.out.println(\"Please enter the shift number\");\n                shift = input.nextInt() % 26;\n                System.out.println(\n                    \"ENCODED MESSAGE IS \\n\" + encode(message, shift)\n                ); // send our function to handle\n                break;\n            case 'D':\n            case 'd':\n                System.out.println(\"Please enter the shift number\");\n                shift = input.nextInt() % 26;\n                System.out.println(\n                    \"DECODED MESSAGE IS \\n\" + decode(message, shift)\n                );\n                break;\n            case 'B':\n            case 'b':\n                String[] listOfAllTheAnswers = bruteforce(message);\n                for (int i = 0; i <= 26; i++) {\n                    System.out.println(\n                        \"FOR SHIFT \" +\n                        String.valueOf(i) +\n                        \" decoded message is \" +\n                        listOfAllTheAnswers[i]\n                    );\n                }\n            default:\n                System.out.println(\"default case\");\n        }\n\n        input.close();\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Caesar Cipher. /It is a type of substitution cipher\n * in which each letter in the plaintext is replaced by a letter some fixed\n * number of positions down the alphabet. /\n *\n * @author FAHRI YARDIMCI\n * @author khalil2535\n */\npublic class Caesar {\n\n    /**\n     * Encrypt text by shifting every Latin char by add number shift for ASCII\n     * Example : A + 1 -> B\n     *\n     * @return Encrypted message\n     */\n    public String encode(String message, int shift) {\n        StringBuilder encoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = message.length();\n        for (int i = 0; i < length; i++) {\n            //            int current = message.charAt(i); //using char to shift characters because ascii\n            // is in-order latin alphabet\n            char current = message.charAt(i); // Java law : char + int = char\n\n            if (isCapitalLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters\n            } else {\n                encoded.append(current);\n            }\n        }\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by shifting back every Latin char to previous the ASCII\n     * Example : B - 1 -> A\n     *\n     * @return message\n     */\n    public String decode(String encryptedMessage, int shift) {\n        StringBuilder decoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = encryptedMessage.length();\n        for (int i = 0; i < length; i++) {\n            char current = encryptedMessage.charAt(i);\n            if (isCapitalLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n            } else {\n                decoded.append(current);\n            }\n        }\n        return decoded.toString();\n    }\n\n    /**\n     * @return true if character is capital Latin letter or false for others\n     */\n    private static boolean isCapitalLatinLetter(char c) {\n        return c >= 'A' && c <= 'Z';\n    }\n\n    /**\n     * @return true if character is small Latin letter or false for others\n     */\n    private static boolean isSmallLatinLetter(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    /**\n     *  @return string array which contains all the possible decoded combination.\n     */\n    public String[] bruteforce(String encryptedMessage) {\n        String[] listOfAllTheAnswers = new String[27];\n        for (int i = 0; i <= 26; i++) {\n            listOfAllTheAnswers[i] = decode(encryptedMessage, i);\n        }\n\n        return listOfAllTheAnswers;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CaesarTest {\n\n    Caesar caesar = new Caesar();\n\n    @Test\n    void caesarEncryptTest() {\n        // given\n        String textToEncrypt = \"Encrypt this text\";\n\n        // when\n        String cipherText = caesar.encode(textToEncrypt, 5);\n\n        // then\n        assertEquals(\"Jshwduy ymnx yjcy\", cipherText);\n    }\n\n    @Test\n    void caesarDecryptTest() {\n        // given\n        String encryptedText = \"Jshwduy ymnx yjcy\";\n\n        // when\n        String cipherText = caesar.decode(encryptedText, 5);\n\n        // then\n        assertEquals(\"Encrypt this text\", cipherText);\n    }\n\n    @Test\n    void caesarBruteForce() {\n        // given\n        String encryptedText = \"Jshwduy ymnx yjcy\";\n\n        // when\n        String[] allPossibleAnswers = caesar.bruteforce(encryptedText);\n\n        assertEquals(27, allPossibleAnswers.length);\n        assertEquals(\"Encrypt this text\", allPossibleAnswers[5]);\n    }\n\n}"
    },
    {
        "product_commit": "7ef75980d5ab9a1c33303abf132236045f8ed06a",
        "test_commit": "7ef75980d5ab9a1c33303abf132236045f8ed06a",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Vigenere.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/VigenereTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Vigenere Cipher.\n *\n * @author straiffix\n * @author beingmartinbmc\n */\npublic class Vigenere {\n\n    public static String encrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        for (int i = 0, j = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append(\n                        (char) (\n                            (c + key.toUpperCase().charAt(j) - 2 * 'A') %\n                            26 +\n                            'A'\n                        )\n                    );\n                } else {\n                    result.append(\n                        (char) (\n                            (c + key.toLowerCase().charAt(j) - 2 * 'a') %\n                            26 +\n                            'a'\n                        )\n                    );\n                }\n            } else {\n                result.append(c);\n            }\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n\n    public static String decrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        for (int i = 0, j = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append(\n                        (char) (\n                            'Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26\n                        )\n                    );\n                } else {\n                    result.append(\n                        (char) (\n                            'z' - (25 - (c - key.toLowerCase().charAt(j))) % 26\n                        )\n                    );\n                }\n            } else {\n                result.append(c);\n            }\n\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        String text = \"Hello World!\";\n        String key = \"itsakey\";\n        System.out.println(text);\n        String ciphertext = encrypt(text, key);\n        System.out.println(ciphertext);\n        System.out.println(decrypt(ciphertext, key));\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Vigenere Cipher.\n *\n * @author straiffix\n * @author beingmartinbmc\n */\npublic class Vigenere {\n\n    public String encrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        int j = 0;\n        for (int i = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append(\n                        (char) (\n                            (c + key.toUpperCase().charAt(j) - 2 * 'A') %\n                            26 +\n                            'A'\n                        )\n                    );\n                } else {\n                    result.append(\n                        (char) (\n                            (c + key.toLowerCase().charAt(j) - 2 * 'a') %\n                            26 +\n                            'a'\n                        )\n                    );\n                }\n            } else {\n                result.append(c);\n            }\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n\n    public String decrypt(final String message, final String key) {\n        StringBuilder result = new StringBuilder();\n\n        int j = 0;\n        for (int i = 0; i < message.length(); i++) {\n            char c = message.charAt(i);\n            if (Character.isLetter(c)) {\n                if (Character.isUpperCase(c)) {\n                    result.append(\n                        (char) (\n                            'Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26\n                        )\n                    );\n                } else {\n                    result.append(\n                        (char) (\n                            'z' - (25 - (c - key.toLowerCase().charAt(j))) % 26\n                        )\n                    );\n                }\n            } else {\n                result.append(c);\n            }\n\n            j = ++j % key.length();\n        }\n        return result.toString();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass VigenereTest {\n\n    Vigenere vigenere = new Vigenere();\n\n    @Test\n    void vigenereEncryptTest() {\n        // given\n        String text = \"Hello World!\";\n        String key = \"suchsecret\";\n\n        // when\n        String cipherText = vigenere.encrypt(text, key);\n\n        // then\n        assertEquals(\"Zynsg Yfvev!\", cipherText);\n    }\n\n    @Test\n    void vigenereDecryptTest() {\n        // given\n        String encryptedText = \"Zynsg Yfvev!\";\n        String key = \"suchsecret\";\n\n        // when\n        String decryptedText = vigenere.decrypt(encryptedText, key);\n\n        // then\n        assertEquals(\"Hello World!\", decryptedText);\n    }\n\n}"
    },
    {
        "product_commit": "315e947c87c8c18b5988939bc531ae234cdc952c",
        "test_commit": "315e947c87c8c18b5988939bc531ae234cdc952c",
        "product_file_path": "src/main/java/com/thealgorithms/divideandconquer/BinaryExponentiation.java",
        "test_file_path": "src/test/java/com/thealgorithms/divideandconquer/BinaryExponentiationTest.java",
        "product_old_content": "package com.thealgorithms.divideandconquer;\n\npublic class BinaryExponentiation {\n\n    public static void main(String args[]) {\n        System.out.println(calculatePower(2, 30));\n    }\n\n    // Function to calculate x^y\n    // Time Complexity: O(logn)\n    public static long calculatePower(long x, long y) {\n        if (y == 0) {\n            return 1;\n        }\n        long val = calculatePower(x, y / 2);\n        val *= val;\n        if (y % 2 == 1) {\n            val *= x;\n        }\n        return val;\n    }\n}",
        "product_new_content": "package com.thealgorithms.divideandconquer;\n\n// Java Program to Implement Binary Exponentiation (power in log n)\n\n/*\n * Binary Exponentiation is a method to calculate a to the power of b.\n * It is used to calculate a^n in O(log n) time.\n * \n * Reference:\n * https://iq.opengenus.org/binary-exponentiation/\n */\n\npublic class BinaryExponentiation {\n\n    // recursive function to calculate a to the power of b\n    public static long calculatePower(long x, long y) {\n        if (y == 0) {\n            return 1;\n        }\n        long val = calculatePower(x, y / 2);\n        if (y % 2 == 0) {\n            return val * val;\n        }\n        return val * val * x;\n    }\n\n    // iterative function to calculate a to the power of b\n    long power(long N, long M) {\n        long power = N, sum = 1;\n        while (M > 0) {\n            if ((M & 1) == 1) {\n                sum *= power;\n            }\n            power = power * power;\n            M = M >> 1;\n        }\n        return sum;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.divideandconquer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BinaryExponentiationTest {\n\n    @Test\n    public void testCalculatePower() {\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 1000000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 10000000000000000L));\n        assertEquals(1, BinaryExponentiation.calculatePower(1, 100000000000000000L));\n    }\n\n    @Test\n    public void testPower() {\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 1000000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 10000000000000000L));\n        assertEquals(1, new BinaryExponentiation().power(1, 100000000000000000L));\n    }\n\n}"
    },
    {
        "product_commit": "315e947c87c8c18b5988939bc531ae234cdc952c",
        "test_commit": "315e947c87c8c18b5988939bc531ae234cdc952c",
        "product_file_path": "src/main/java/com/thealgorithms/divideandconquer/StrassenMatrixMultiplication.java",
        "test_file_path": "src/test/java/com/thealgorithms/divideandconquer/StrassenMatrixMultiplicationTest.java",
        "product_old_content": "package com.thealgorithms.divideandconquer;\n\n// Java Program to Implement Strassen Algorithm\n// Class Strassen matrix multiplication\npublic class StrassenMatrixMultiplication {\n\n    // Method 1\n    // Function to multiply matrices\n    public int[][] multiply(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] R = new int[n][n];\n\n        if (n == 1) {\n            R[0][0] = A[0][0] * B[0][0];\n        } else {\n            // Dividing Matrix into parts\n            // by storing sub-parts to variables\n            int[][] A11 = new int[n / 2][n / 2];\n            int[][] A12 = new int[n / 2][n / 2];\n            int[][] A21 = new int[n / 2][n / 2];\n            int[][] A22 = new int[n / 2][n / 2];\n            int[][] B11 = new int[n / 2][n / 2];\n            int[][] B12 = new int[n / 2][n / 2];\n            int[][] B21 = new int[n / 2][n / 2];\n            int[][] B22 = new int[n / 2][n / 2];\n\n            // Dividing matrix A into 4 parts\n            split(A, A11, 0, 0);\n            split(A, A12, 0, n / 2);\n            split(A, A21, n / 2, 0);\n            split(A, A22, n / 2, n / 2);\n\n            // Dividing matrix B into 4 parts\n            split(B, B11, 0, 0);\n            split(B, B12, 0, n / 2);\n            split(B, B21, n / 2, 0);\n            split(B, B22, n / 2, n / 2);\n\n            // Using Formulas as described in algorithm\n            // M1:=(A1+A3)\u00d7(B1+B2)\n            int[][] M1 = multiply(add(A11, A22), add(B11, B22));\n\n            // M2:=(A2+A4)\u00d7(B3+B4)\n            int[][] M2 = multiply(add(A21, A22), B11);\n\n            // M3:=(A1\u2212A4)\u00d7(B1+A4)\n            int[][] M3 = multiply(A11, sub(B12, B22));\n\n            // M4:=A1\u00d7(B2\u2212B4)\n            int[][] M4 = multiply(A22, sub(B21, B11));\n\n            // M5:=(A3+A4)\u00d7(B1)\n            int[][] M5 = multiply(add(A11, A12), B22);\n\n            // M6:=(A1+A2)\u00d7(B4)\n            int[][] M6 = multiply(sub(A21, A11), add(B11, B12));\n\n            // M7:=A4\u00d7(B3\u2212B1)\n            int[][] M7 = multiply(sub(A12, A22), add(B21, B22));\n\n            // P:=M2+M3\u2212M6\u2212M7\n            int[][] C11 = add(sub(add(M1, M4), M5), M7);\n\n            // Q:=M4+M6\n            int[][] C12 = add(M3, M5);\n\n            // R:=M5+M7\n            int[][] C21 = add(M2, M4);\n\n            // S:=M1\u2212M3\u2212M4\u2212M5\n            int[][] C22 = add(sub(add(M1, M3), M2), M6);\n\n            join(C11, R, 0, 0);\n            join(C12, R, 0, n / 2);\n            join(C21, R, n / 2, 0);\n            join(C22, R, n / 2, n / 2);\n        }\n\n        return R;\n    }\n\n    // Method 2\n    // Function to subtract two matrices\n    public int[][] sub(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] - B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Method 3\n    // Function to add two matrices\n    public int[][] add(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] + B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Method 4\n    // Function to split parent matrix\n    // into child matrices\n    public void split(int[][] P, int[][] C, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                C[i1][j1] = P[i2][j2];\n            }\n        }\n    }\n\n    // Method 5\n    // Function to join child matrices\n    // into (to) parent matrix\n    public void join(int[][] C, int[][] P, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                P[i2][j2] = C[i1][j1];\n            }\n        }\n    }\n\n    // Method 5\n    // Main driver method\n    public static void main(String[] args) {\n        System.out.println(\n            \"Strassen Multiplication Algorithm Implementation For Matrix Multiplication :\\n\"\n        );\n\n        StrassenMatrixMultiplication s = new StrassenMatrixMultiplication();\n\n        // Size of matrix\n        // Considering size as 4 in order to illustrate\n        int N = 4;\n\n        // Matrix A\n        // Custom input to matrix\n        int[][] A = {\n            { 1, 2, 5, 4 },\n            { 9, 3, 0, 6 },\n            { 4, 6, 3, 1 },\n            { 0, 2, 0, 6 },\n        };\n\n        // Matrix B\n        // Custom input to matrix\n        int[][] B = {\n            { 1, 0, 4, 1 },\n            { 1, 2, 0, 2 },\n            { 0, 3, 1, 3 },\n            { 1, 8, 1, 2 },\n        };\n\n        // Matrix C computations\n        // Matrix C calling method to get Result\n        int[][] C = s.multiply(A, B);\n\n        System.out.println(\"\\nProduct of matrices A and  B : \");\n\n        // Print the output\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                System.out.print(C[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.divideandconquer;\n\n// Java Program to Implement Strassen Algorithm for Matrix Multiplication\n\n/*\n * Uses the divide and conquer approach to multiply two matrices.\n * Time Complexity: O(n^2.8074) better than the O(n^3) of the standard matrix multiplication algorithm.\n * Space Complexity: O(n^2)\n * \n * This Matrix multiplication can be performed only on square matrices \n * where n is a power of 2. Order of both of the matrices are n \u00d7 n.\n * \n * Reference:\n * https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_strassens_matrix_multiplication.htm#:~:text=Strassen's%20Matrix%20multiplication%20can%20be,matrices%20are%20n%20%C3%97%20n.\n * https://www.geeksforgeeks.org/strassens-matrix-multiplication/\n */\n\npublic class StrassenMatrixMultiplication {\n\n    // Function to multiply matrices\n    public int[][] multiply(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] R = new int[n][n];\n\n        if (n == 1) {\n            R[0][0] = A[0][0] * B[0][0];\n        } else {\n            // Dividing Matrix into parts\n            // by storing sub-parts to variables\n            int[][] A11 = new int[n / 2][n / 2];\n            int[][] A12 = new int[n / 2][n / 2];\n            int[][] A21 = new int[n / 2][n / 2];\n            int[][] A22 = new int[n / 2][n / 2];\n            int[][] B11 = new int[n / 2][n / 2];\n            int[][] B12 = new int[n / 2][n / 2];\n            int[][] B21 = new int[n / 2][n / 2];\n            int[][] B22 = new int[n / 2][n / 2];\n\n            // Dividing matrix A into 4 parts\n            split(A, A11, 0, 0);\n            split(A, A12, 0, n / 2);\n            split(A, A21, n / 2, 0);\n            split(A, A22, n / 2, n / 2);\n\n            // Dividing matrix B into 4 parts\n            split(B, B11, 0, 0);\n            split(B, B12, 0, n / 2);\n            split(B, B21, n / 2, 0);\n            split(B, B22, n / 2, n / 2);\n\n            // Using Formulas as described in algorithm\n            // M1:=(A1+A3)\u00d7(B1+B2)\n            int[][] M1 = multiply(add(A11, A22), add(B11, B22));\n\n            // M2:=(A2+A4)\u00d7(B3+B4)\n            int[][] M2 = multiply(add(A21, A22), B11);\n\n            // M3:=(A1\u2212A4)\u00d7(B1+A4)\n            int[][] M3 = multiply(A11, sub(B12, B22));\n\n            // M4:=A1\u00d7(B2\u2212B4)\n            int[][] M4 = multiply(A22, sub(B21, B11));\n\n            // M5:=(A3+A4)\u00d7(B1)\n            int[][] M5 = multiply(add(A11, A12), B22);\n\n            // M6:=(A1+A2)\u00d7(B4)\n            int[][] M6 = multiply(sub(A21, A11), add(B11, B12));\n\n            // M7:=A4\u00d7(B3\u2212B1)\n            int[][] M7 = multiply(sub(A12, A22), add(B21, B22));\n\n            // P:=M2+M3\u2212M6\u2212M7\n            int[][] C11 = add(sub(add(M1, M4), M5), M7);\n\n            // Q:=M4+M6\n            int[][] C12 = add(M3, M5);\n\n            // R:=M5+M7\n            int[][] C21 = add(M2, M4);\n\n            // S:=M1\u2212M3\u2212M4\u2212M5\n            int[][] C22 = add(sub(add(M1, M3), M2), M6);\n\n            join(C11, R, 0, 0);\n            join(C12, R, 0, n / 2);\n            join(C21, R, n / 2, 0);\n            join(C22, R, n / 2, n / 2);\n        }\n\n        return R;\n    }\n\n    // Function to subtract two matrices\n    public int[][] sub(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] - B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Function to add two matrices\n    public int[][] add(int[][] A, int[][] B) {\n        int n = A.length;\n\n        int[][] C = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                C[i][j] = A[i][j] + B[i][j];\n            }\n        }\n\n        return C;\n    }\n\n    // Function to split parent matrix into child matrices\n    public void split(int[][] P, int[][] C, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                C[i1][j1] = P[i2][j2];\n            }\n        }\n    }\n\n    // Function to join child matrices into (to) parent matrix\n    public void join(int[][] C, int[][] P, int iB, int jB) {\n        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {\n            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {\n                P[i2][j2] = C[i1][j1];\n            }\n        }\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.divideandconquer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass StrassenMatrixMultiplicationTest {\n\n    StrassenMatrixMultiplication SMM = new StrassenMatrixMultiplication();\n\n    // Strassen Matrix Multiplication can only be allplied to matrices of size 2^n\n    // and has to be a Square Matrix\n\n    @Test\n    public void StrassenMatrixMultiplicationTest2x2() {\n        int[][] A = { { 1, 2 }, { 3, 4 } };\n        int[][] B = { { 5, 6 }, { 7, 8 } };\n        int[][] expResult = { { 19, 22 }, { 43, 50 } };\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    void StrassenMatrixMultiplicationTest4x4() {\n        int[][] A = { { 1, 2, 5, 4 }, { 9, 3, 0, 6 }, { 4, 6, 3, 1 }, { 0, 2, 0, 6 } };\n        int[][] B = { { 1, 0, 4, 1 }, { 1, 2, 0, 2 }, { 0, 3, 1, 3 }, { 1, 8, 1, 2 } };\n        int[][] expResult = { { 7, 51, 13, 28 }, { 18, 54, 42, 27 }, { 11, 29, 20, 27 }, { 8, 52, 6, 16 } };\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    void StrassenMatrixMultiplicationTestNegetiveNumber4x4() {\n        int[][] A = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }, { 13, 14, 15, 16 } };\n        int[][] B = { { 1, -2, -3, 4 }, { 4, -3, -2, 1 }, { 5, -6, -7, 8 }, { 8, -7, -6, -5 } };\n        int[][] expResult = { { 56, -54, -52, 10 }, { 128, -126, -124, 42 }, { 200, -198, -196, 74 },\n                { 272, -270, -268, 106 } };\n        int[][] actResult = SMM.multiply(A, B);\n        assertArrayEquals(expResult, actResult);\n    }\n\n}"
    },
    {
        "product_commit": "6235fd6505c0b7f19c527a6d0ad76456a7cae4f8",
        "test_commit": "6235fd6505c0b7f19c527a6d0ad76456a7cae4f8",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Average.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AverageTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Calculate average of a list of numbers\n */\npublic class Average {\n\n    private static final double SMALL_VALUE = 0.00001f;\n\n    public static void main(String[] args) {\n        assert Math.abs(\n            average(new double[] { 3, 6, 9, 12, 15, 18, 21 }) - 12\n        ) <\n        SMALL_VALUE;\n        assert Math.abs(\n            average(new double[] { 5, 10, 15, 20, 25, 30, 35 }) - 20\n        ) <\n        SMALL_VALUE;\n        assert Math.abs(\n            average(new double[] { 1, 2, 3, 4, 5, 6, 7, 8 }) - 4.5\n        ) <\n        SMALL_VALUE;\n        int[] array = { 2, 4, 10 };\n        assert average(array) == 5;\n    }\n\n    /**\n     * Calculate average of a list of numbers\n     *\n     * @param numbers array to store numbers\n     * @return mean of given numbers\n     */\n    public static double average(double[] numbers) {\n        double sum = 0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        return sum / numbers.length;\n    }\n\n    /**\n     * find average value of int array\n     *\n     * @param array the array contains element and the sum does not excess long\n     * value limit\n     * @return average value\n     */\n    public static int average(int[] array) {\n        long sum = 0;\n        for (int i = 0; i < array.length; ++i) {\n            sum += array[i];\n        }\n        return (int) (sum / array.length);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Calculate average of a list of numbers\n */\npublic class Average {\n\n    /**\n     * Calculate average of a list of numbers\n     *\n     * @param numbers array to store numbers\n     * @return mean of given numbers\n     */\n    public static double average(double[] numbers) {\n        double sum = 0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        return sum / numbers.length;\n    }\n\n    /**\n     * find average value of int array\n     *\n     * @param numbers the array contains element and the sum does not excess long\n     *                value limit\n     * @return average value\n     */\n    public static int average(int[] numbers) {\n        long sum = 0;\n        for (int number : numbers) {\n            sum += number;\n        }\n        return (int) (sum / numbers.length);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class AverageTest {\n\n    double[] numbers = { 3, 6, 9, 12, 15, 18, 21 };\n\n    @Test\n    public void testAverage() {\n        Assertions.assertEquals(12, Average.average(numbers));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class AverageTest {\n\n    private static final double SMALL_VALUE = 0.00001d;\n\n    @Test\n    public void testAverage_double_12() {\n        double[] numbers = {3d, 6d, 9d, 12d, 15d, 18d, 21d};\n        Assertions.assertEquals(12d, Average.average(numbers), SMALL_VALUE);\n    }\n\n    @Test\n    public void testAverage_double_20() {\n        double[] numbers = {5d, 10d, 15d, 20d, 25d, 30d, 35d};\n        Assertions.assertEquals(20d, Average.average(numbers), SMALL_VALUE);\n    }\n\n    @Test\n    public void testAverage_double_4_5() {\n        double[] numbers = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d};\n        Assertions.assertEquals(4.5d, Average.average(numbers), SMALL_VALUE);\n    }\n\n    @Test\n    public void testAverage_int_5() {\n        int[] numbers = {2, 4, 10};\n        Assertions.assertEquals(5, Average.average(numbers));\n    }\n\n}"
    },
    {
        "product_commit": "8d4b048cb3a499cd57449d08730dd86952e7b175",
        "test_commit": "8d4b048cb3a499cd57449d08730dd86952e7b175",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/LongestValidParentheses.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/LongestValidParenthesesTest",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport java.util.Scanner;\n\n/**\n * Given a string containing just the characters '(' and ')', find the length of\n * the longest valid (well-formed) parentheses substring.\n *\n * @author Libin Yang (https://github.com/yanglbme)\n * @since 2018/10/5\n */\npublic class LongestValidParentheses {\n\n    public static int getLongestValidParentheses(String s) {\n        if (s == null || s.length() < 2) {\n            return 0;\n        }\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        int[] res = new int[n];\n        res[0] = 0;\n        res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;\n\n        int max = res[1];\n\n        for (int i = 2; i < n; ++i) {\n            if (chars[i] == ')') {\n                if (chars[i - 1] == '(') {\n                    res[i] = res[i - 2] + 2;\n                } else {\n                    int index = i - res[i - 1] - 1;\n                    if (index >= 0 && chars[index] == '(') {\n                        // ()(())\n                        res[i] =\n                            res[i - 1] +\n                            2 +\n                            (index - 1 >= 0 ? res[index - 1] : 0);\n                    }\n                }\n            }\n            max = Math.max(max, res[i]);\n        }\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            String str = sc.nextLine();\n            if (\"quit\".equals(str)) {\n                break;\n            }\n\n            System.out.println(\"Len is: \" + getLongestValidParentheses(str));\n        }\n\n        sc.close();\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport java.util.Scanner;\n\n/**\n * Given a string containing just the characters '(' and ')', find the length of\n * the longest valid (well-formed) parentheses substring.\n *\n * @author Libin Yang (https://github.com/yanglbme)\n * @since 2018/10/5\n */\npublic class LongestValidParentheses {\n\n    public static int getLongestValidParentheses(String s) {\n        if (s == null || s.length() < 2) {\n            return 0;\n        }\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        int[] res = new int[n];\n        res[0] = 0;\n        res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;\n\n        int max = res[1];\n\n        for (int i = 2; i < n; ++i) {\n            if (chars[i] == ')') {\n                if (chars[i - 1] == '(') {\n                    res[i] = res[i - 2] + 2;\n                } else {\n                    int index = i - res[i - 1] - 1;\n                    if (index >= 0 && chars[index] == '(') {\n                        // ()(())\n                        res[i] =\n                            res[i - 1] +\n                            2 +\n                            (index - 1 >= 0 ? res[index - 1] : 0);\n                    }\n                }\n            }\n            max = Math.max(max, res[i]);\n        }\n\n        return max;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass LongestValidParenthesesTest {\n\n    LongestValidParentheses longestValidParentheses = new LongestValidParentheses();\n\n    @Test\n    void shouldReturnZeroWhenSingleOpeningParenthesisIsGiven() {\n        String input = \"(\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(0, validLength);\n    }\n\n    @Test\n    void shouldReturnZeroWhenSingleClosingParenthesisIsGiven() {\n        String input = \")\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(0, validLength);\n    }\n\n    @Test\n    void shouldReturnZeroWhenNullStringIsGiven() {\n        String input = \"\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(0, validLength);\n    }\n\n    @Test\n    void shouldReturnTwoWhenTwoBalancedParenthesesAreGiven() {\n        String input = \"()\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(2, validLength);\n    }\n\n    @Test\n    void shouldReturnLengthWhenInputStringIsValid() {\n        String input = \"()((()))\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(8, validLength);\n    }\n\n    @Test\n    void shouldReturnValidLengthWhenInputStringIsGiven() {\n        String input = \"((()((())))\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(10, validLength);\n    }\n}"
    },
    {
        "product_commit": "ea05286c862828287aaf96a9e931b7303ed6940e",
        "test_commit": "ea05286c862828287aaf96a9e931b7303ed6940e",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/PowerSum.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/PowerSumTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\nimport java.util.Scanner;\n\n/*\n * Problem Statement :\n * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers of unique, natural numbers.\n * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3.\n * Therefore output will be 1.\n */\npublic class PowerSum {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the number and the power\");\n        int N = sc.nextInt();\n        int X = sc.nextInt();\n        PowerSum ps = new PowerSum();\n        int count = ps.powSum(N, X);\n        //printing the answer.\n        System.out.println(\n            \"Number of combinations of different natural number's raised to \" +\n            X +\n            \" having sum \" +\n            N +\n            \" are : \"\n        );\n        System.out.println(count);\n        sc.close();\n    }\n\n    private int count = 0, sum = 0;\n\n    public int powSum(int N, int X) {\n        Sum(N, X, 1);\n        return count;\n    }\n\n    //here i is the natural number which will be raised by X and added in sum.\n    public void Sum(int N, int X, int i) {\n        //if sum is equal to N that is one of our answer and count is increased.\n        if (sum == N) {\n            count++;\n            return;\n        } //we will be adding next natural number raised to X only if on adding it in sum the result is less than N.\n        else if (sum + power(i, X) <= N) {\n            sum += power(i, X);\n            Sum(N, X, i + 1);\n            //backtracking and removing the number added last since no possible combination is there with it.\n            sum -= power(i, X);\n        }\n        if (power(i, X) < N) {\n            //calling the sum function with next natural number after backtracking if when it is raised to X is still less than X.\n            Sum(N, X, i + 1);\n        }\n    }\n\n    //creating a separate power function so that it can be used again and again when required.\n    private int power(int a, int b) {\n        return (int) Math.pow(a, b);\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.Scanner;\n\n/*\n * Problem Statement :\n * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers of unique, natural numbers.\n * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3.\n * Therefore output will be 1.\n */\npublic class PowerSum {\n\n    private int count = 0, sum = 0;\n\n    public int powSum(int N, int X) {\n        Sum(N, X, 1);\n        return count;\n    }\n\n    //here i is the natural number which will be raised by X and added in sum.\n    public void Sum(int N, int X, int i) {\n        //if sum is equal to N that is one of our answer and count is increased.\n        if (sum == N) {\n            count++;\n            return;\n        } //we will be adding next natural number raised to X only if on adding it in sum the result is less than N.\n        else if (sum + power(i, X) <= N) {\n            sum += power(i, X);\n            Sum(N, X, i + 1);\n            //backtracking and removing the number added last since no possible combination is there with it.\n            sum -= power(i, X);\n        }\n        if (power(i, X) < N) {\n            //calling the sum function with next natural number after backtracking if when it is raised to X is still less than X.\n            Sum(N, X, i + 1);\n        }\n    }\n\n    //creating a separate power function so that it can be used again and again when required.\n    private int power(int a, int b) {\n        return (int) Math.pow(a, b);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class PowerSumTest {\n\n    @Test\n    void testNumberZeroAndPowerZero() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(0, 0);\n        assertEquals(1, result);\n    }\n\n    @Test\n    void testNumberHundredAndPowerTwo() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 2);\n        assertEquals(3, result);\n    }\n  \n    @Test\n    void testNumberHundredAndPowerThree() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 3);\n        assertEquals(1, result);\n    }\n    \n}"
    },
    {
        "product_commit": "3ef3d761c6aac100adfcd9cce2bd9186e0aff6dd",
        "test_commit": "3ef3d761c6aac100adfcd9cce2bd9186e0aff6dd",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/SubsetCount.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/SubsetCountTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\n/**\n * Find the number of subsets present in the given array with a sum equal to target.\n * Based on Solution discussed on StackOverflow(https://stackoverflow.com/questions/22891076/count-number-of-subsets-with-sum-equal-to-k)\n * @author Samrat Podder(https://github.com/samratpodder)\n */\npublic class SubsetCount {\n\n\n    /**\n     * Dynamic Programming Implementation.\n     * Method to find out the number of subsets present in the given array with a sum equal to target.\n     * Time Complexity is O(n*target) and Space Complexity is O(n*target)\n     * @param arr is the input array on which subsets are  to searched\n     * @param target is the sum of each element of the subset taken together\n     *\n     */\n    public int getCount(int[] arr, int target){\n        /**\n         * Base Cases - If target becomes zero, we have reached the required sum for the subset\n         * If we reach the end of the array arr then, either if target==arr[end], then we add one to the final count\n         * Otherwise we add 0 to the final count\n         */\n        int n = arr.length;\n        int[][] dp = new int[n][target+1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = 1;\n        }\n        if(arr[0]<=target) dp[0][arr[0]] = 1;\n        for(int t=1;t<=target;t++){\n            for (int idx = 1; idx < n; idx++) {\n                int notpick = dp[idx-1][t];\n                int pick =0;\n                if(arr[idx]<=t) pick+=dp[idx-1][target-t];\n                dp[idx][target] = pick+notpick;\n            }\n        }\n        return dp[n-1][target];\n    }\n\n\n    /**\n     * This Method is a Space Optimized version of the getCount(int[], int) method and solves the same problem\n     * This approach is a bit better in terms of Space Used\n     * Time Complexity is O(n*target) and Space Complexity is O(target)\n     * @param arr is the input array on which subsets are  to searched\n     * @param target is the sum of each element of the subset taken together\n     */\n    public int getCountSO(int[] arr, int target){\n        int n = arr.length;\n        int prev[]=new int[target+1];\n        prev[0] =1;\n        if(arr[0]<=target) prev[arr[0]] = 1;\n        for(int ind = 1; ind<n; ind++){\n            int cur[]=new int[target+1];\n            cur[0]=1;\n            for(int t= 1; t<=target; t++){\n                int notTaken = prev[t];\n                int taken = 0;\n                if(arr[ind]<=t) taken = prev[t-arr[ind]];\n                cur[t]= notTaken + taken;\n            }\n            prev = cur;\n        }\n        return prev[target];\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class SubsetCountTest {\n    public static SubsetCount obj = new SubsetCount();\n\n    @Test\n    void hasMultipleSubset(){\n        int[] arr = new int[]{1,2,3,3};\n        assertEquals(3, obj.getCount(arr, 6));\n    }\n    @Test\n    void singleElementSubset(){\n        int[] arr = new int[]{1,1,1,1};\n        assertEquals(4, obj.getCount(arr, 1));\n    }\n\n    @Test\n    void hasMultipleSubsetSO(){\n        int[] arr = new int[]{1,2,3,3};\n        assertEquals(3, obj.getCountSO(arr, 6));\n    }\n    @Test\n    void singleSubsetSO(){\n        int[] arr = new int[]{1,1,1,1};\n        assertEquals(1,obj.getCountSO(arr, 4));\n    }\n}"
    },
    {
        "product_commit": "8803b7f5e7a05ba832aec0ed8ec2928a6d57fd55",
        "test_commit": "8803b7f5e7a05ba832aec0ed8ec2928a6d57fd55",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Area.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AreaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    public static void main(String[] args) {\n        /* test cube */\n        assert Double.compare(surfaceAreaCube(1), 6.0) == 0;\n\n        /* test sphere */\n        assert Double.compare(surfaceAreaSphere(5), 314.1592653589793) == 0;\n        assert Double.compare(surfaceAreaSphere(1), 12.566370614359172) == 0;\n\n        /* test rectangle */\n        assert Double.compare(surfaceAreaRectangle(10, 20), 200.0) == 0;\n\n        /* test square */\n        assert Double.compare(surfaceAreaSquare(10), 100.0) == 0;\n\n        /* test triangle */\n        assert Double.compare(surfaceAreaTriangle(10, 10), 50.0) == 0;\n\n        /* test parallelogram */\n        assert Double.compare(surfaceAreaParallelogram(10, 20), 200.0) == 0;\n\n        /* test trapezium */\n        assert Double.compare(surfaceAreaTrapezium(10, 20, 30), 450.0) == 0;\n\n        /* test circle */\n        assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;\n\n        /* test cylinder */\n        assert Double.compare(surfaceAreaCylinder(1, 2), 18.84955592153876) ==\n        0;\n\n        /* test hemisphere */\n        assert Double.compare(surfaceAreaHemisphere(5), 235.61944901923448) ==\n        0;\n        assert Double.compare(surfaceAreaHemisphere(1), 9.42477796076938) == 0;\n\n        /* test cone */\n        assert Double.compare(surfaceAreaCone(6, 8), 301.59289474462014) == 0;\n        assert Double.compare(surfaceAreaCone(10, 24), 1130.9733552923256) == 0;\n    }\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    private static double surfaceAreaCube(double sideLength) {\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    private static double surfaceAreaSphere(double radius) {\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle\n     *\n     * @param length length of rectangle\n     * @param width width of rectangle\n     * @return area of given rectangle\n     */\n    private static double surfaceAreaRectangle(double length, double width) {\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    private static double surfaceAreaCylinder(double radius, double height) {\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    private static double surfaceAreaSquare(double sideLength) {\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle\n     *\n     * @param base base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    private static double surfaceAreaTriangle(double base, double height) {\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram\n     *\n     * @param base base of parallelogram\n     * @param height height of parallelogram\n     * @return area of given parallelogram\n     */\n    private static double surfaceAreaParallelogram(double base, double height) {\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium\n     *\n     * @param base1 upper base of trapezium\n     * @param base2 bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    private static double surfaceAreaTrapezium(\n        double base1,\n        double base2,\n        double height\n    ) {\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    private static double surfaceAreaCircle(double radius) {\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    private static double surfaceAreaHemisphere(double radius) {\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    private static double surfaceAreaCone(double radius, double height) {\n        return (\n            Math.PI *\n            radius *\n            (radius + Math.pow((height * height + radius * radius), 0.5))\n        );\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1))\n        );\n    }\n}"
    },
    {
        "product_commit": "ddcb5cfead1b834f39eb6d5f5ace3764e44ff151",
        "test_commit": "ddcb5cfead1b834f39eb6d5f5ace3764e44ff151",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SlowSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SlowSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * @author Amir Hassan (https://github.com/ahsNT)\n * @see SortAlgorithm\n */\npublic class SlowSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        sort(unsortedArray, 0, unsortedArray.length - 1);\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> void sort(T[] array, int i, int j) {\n        if (SortUtils.greaterOrEqual(i, j)) {\n            return;\n        }\n        int m = (i + j) / 2;\n        sort(array, i, m);\n        sort(array, m + 1, j);\n        if (SortUtils.less(array[j], array[m])) {\n            T temp = array[j];\n            array[j] = array[m];\n            array[m] = temp;\n        }\n        sort(array, i, j - 1);\n    }\n\n    public static void main(String[] args) {\n        SlowSort slowSort = new SlowSort();\n\n        Integer[] integerArray = { 8, 84, 53, 953, 64, 2, 202, 98 };\n        // Print integerArray unsorted\n        SortUtils.print(integerArray);\n\n        slowSort.sort(integerArray);\n        // Print integerArray sorted\n        SortUtils.print(integerArray);\n\n        String[] stringArray = { \"g\", \"d\", \"a\", \"b\", \"f\", \"c\", \"e\" };\n        // Print stringArray unsorted\n        SortUtils.print(stringArray);\n\n        slowSort.sort(stringArray);\n        // Print stringArray sorted\n        SortUtils.print(stringArray);\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * @author Amir Hassan (https://github.com/ahsNT)\n * @see SortAlgorithm\n */\npublic class SlowSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        sort(unsortedArray, 0, unsortedArray.length - 1);\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> void sort(T[] array, int i, int j) {\n        if (SortUtils.greaterOrEqual(i, j)) {\n            return;\n        }\n        int m = (i + j) / 2;\n        sort(array, i, m);\n        sort(array, m + 1, j);\n        if (SortUtils.less(array[j], array[m])) {\n            T temp = array[j];\n            array[j] = array[m];\n            array[m] = temp;\n        }\n        sort(array, i, j - 1);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Rebecca Velez (https://github.com/rebeccavelez)\n * @see SlowSort\n */\n\npublic class SlowSortTest {\n\n    private SlowSort slowSort = new SlowSort();\n\n    @Test\n    public void slowSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortSingleIntegerElementArray() {\n        Integer[] inputArray = {5};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {5};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortSingleStringElementArray() {\n        String[] inputArray = {\"k\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"k\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortIntegerArray() {\n        Integer[] inputArray = {8, 84, 53, -683, 953, 64, 2, 202, 98, -10};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {-683, -10, 2, 8, 53, 64, 84, 98, 202, 953};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortDuplicateIntegerArray() {\n        Integer[] inputArray = {8, 84, 8, -2, 953, 64, 2, 953, 98};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {-2, 2, 8, 8, 64, 84, 98, 953, 953};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortStringArray() {\n        String[] inputArray = {\"g\", \"d\", \"a\", \"b\", \"f\", \"c\", \"e\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortDuplicateStringArray() {\n        String[] inputArray = {\"g\", \"d\", \"a\", \"g\", \"b\", \"f\", \"d\", \"c\", \"e\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"d\", \"e\", \"f\", \"g\", \"g\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortStringSymbolArray() {\n        String[] inputArray = {\"cbf\", \"auk\", \"\u00f3\", \"(b\", \"a\", \")\", \"au\", \"\u00e1\", \"cba\", \"auk\", \"(a\", \"bhy\", \"cba\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"(a\", \"(b\", \")\", \"a\", \"au\", \"auk\", \"auk\", \"bhy\", \"cba\", \"cba\", \"cbf\", \"\u00e1\", \"\u00f3\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "cdd12a128d061bd6a5cfae4e0d8d2478d24d1c47",
        "test_commit": "cdd12a128d061bd6a5cfae4e0d8d2478d24d1c47",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/DualPivotQuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DualPivotQuickSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * Dual Pivot Quick Sort Algorithm\n * \n * @author Debasish Biswas (https://github.com/debasishbsws) *\n * @see SortAlgorithm\n */\npublic class DualPivotQuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Dual pivot Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        dualPivotQuicksort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left  The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void dualPivotQuicksort(T[] array, int left, int right) {\n        if (left < right) {\n            int[] pivots = partition(array, left, right);\n\n            dualPivotQuicksort(array, left, pivots[0] - 1);\n            dualPivotQuicksort(array, pivots[0] + 1, pivots[1] - 1);\n            dualPivotQuicksort(array, pivots[1] + 1, right);\n        }\n    }\n\n    /**\n     * This method finds the partition indices for an array\n     *\n     * @param array The array to be sorted\n     * @param left  The first index of an array\n     * @param right The last index of an array Finds the partition index of an array\n     */\n    private static <T extends Comparable<T>> int[] partition(T[] array, int left, int right) {\n        if (array[left].compareTo(array[right]) > 0)\n            swap(array, left, right);\n\n        T pivot1 = array[left];\n        T pivot2 = array[right];\n\n        int j = left + 1;\n        int less = left + 1;\n        int great = right - 1;\n\n        while (less <= great) {\n            // If element is less than pivot1\n            if (array[less].compareTo(pivot1) < 0) {\n                swap(array, less, left++);\n            }\n\n            // If element is greater or equal to pivot2\n            else if (array[less].compareTo(pivot2) >= 0) {\n                while (less < great && array[great].compareTo(pivot2) > 0)\n                    great--;\n\n                swap(array, less, great--);\n\n                if (array[less].compareTo(pivot1) < 0)\n                    swap(array, less, left++);\n\n            }\n\n            less++;\n        }\n        j--;\n        great++;\n        // Bring the pivots to their appropriate positions\n        swap(array, left, j);\n        swap(array, right, great);\n\n        // return the pivots' indices\n        return new int[] { less, great };\n    }\n\n    private static <T extends Comparable<T>> void swap(T[] array, int left, int right) {\n        T temp = array[left];\n        array[left] = array[right];\n        array[right] = temp;\n    }\n\n    /**\n     * Main method\n     *\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Integer array[] = { 24, 8, -42, 75, -29, -77, 38, 57 };\n        DualPivotQuickSort dualPivotQuickSort = new DualPivotQuickSort();\n        dualPivotQuickSort.sort(array);\n        for (int i = 0; i < array.length; i++) {\n            System.out.print(array[i] + \" \");\n        }\n    }\n\n    /*\n     * References: https://www.geeksforgeeks.org/dual-pivot-quicksort/\n     */\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = { 7 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 7 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = { 49, 4, 36, 9, 144, 1 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 4, 9, 36, 49, 144 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = { 49, -36, -124, -49, 12, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { -124, -49, -36, 9, 12, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = { 36, 1, 49, 1, 4, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 1, 4, 9, 36, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = { \"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\" };\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = { \"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\" };\n        assertArrayEquals(expected, sorted);\n    }\n\n}"
    },
    {
        "product_commit": "efac505a6dab22254f6d0458fa8df29d54ca733f",
        "test_commit": "efac505a6dab22254f6d0458fa8df29d54ca733f",
        "product_file_path": "src/main/java/com/thealgorithms/maths/TwinPrime.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/TwinPrimeTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n/*\n * Java program to find 'twin prime' of a prime number\n * Twin Prime: Twin prime of a number n is (n+2) \n * if and only if n & (n+2) are prime.\n * Wikipedia: https://en.wikipedia.org/wiki/Twin_prime\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class TwinPrime {\n\t\n\t/**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */\n\tstatic int getTwinPrime(int inputNumber) {\n\t\t\n\t\t//if inputNumber and (inputNumber + 2) are both prime \n\t\t//then return (inputNumber + 2) as a result\n\t\tif(PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2) ) {\n\t\t\treturn inputNumber + 2;\n\t\t}\n\t\t//if any one from inputNumber and (inputNumber + 2) or if both of them are not prime \n\t\t//then return -1 as a result\n\t\treturn -1;\n\t}\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass TwinPrimeTest {\n\n\t@Test\n\tvoid shouldReturn7() {\n\t\t//given\n\t\tint number = 5;\n\t\tint expectedResult = 7;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n\t\n\t@Test\n\tvoid shouldReturn5() {\n\t\t//given\n\t\tint number = 3;\n\t\tint expectedResult = 5;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n\t\n\t@Test\n\tvoid shouldReturnNegative1() {\n\t\t//given\n\t\tint number = 4;\n\t\tint expectedResult = -1;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n\t\n\t@Test\n\tvoid shouldReturn19() {\n\t\t//given\n\t\tint number = 17;\n\t\tint expectedResult = 19;\n\t\t\n\t\t//when\n\t\tint actualResult = TwinPrime.getTwinPrime(number);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedResult,actualResult);\n\t}\n}"
    },
    {
        "product_commit": "c805437c0c5e057f3ad60c397fe6550eec7be453",
        "test_commit": "c805437c0c5e057f3ad60c397fe6550eec7be453",
        "product_file_path": "src/main/java/com/thealgorithms/others/CountChar.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/CountCharTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\n\npublic class CountChar {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.print(\"Enter your text: \");\n        String str = input.nextLine();\n        input.close();\n        System.out.println(\n            \"There are \" + CountCharacters(str) + \" characters.\"\n        );\n    }\n\n    /**\n     * Count non space character in string\n     *\n     * @param str String to count the characters\n     * @return number of character in the specified string\n     */\n    private static int CountCharacters(String str) {\n        return str.replaceAll(\"\\\\s\", \"\").length();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\npublic class CountChar {\n\n    /**\n     * Count non space character in string\n     *\n     * @param str String to count the characters\n     * @return number of character in the specified string\n     */\n\n    public static int CountCharacters(String str) {\n        return str.replaceAll(\"\\\\s\", \"\").length();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CountCharTest {\n\n    @Test\n    void testCountCharacters(){\n        String input = \"12345\";\n        int expectedValue = 5;\n\n        assertEquals(expectedValue, CountChar.CountCharacters(input));\n    }\n\n}"
    },
    {
        "product_commit": "c59fc923bf29a511fac513d33a81c364ebd59a54",
        "test_commit": "c59fc923bf29a511fac513d33a81c364ebd59a54",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/FCFSScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/FCFSSchedulingTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\n\nimport java.util.List;\n\n/**\n * Non-pre-emptive First Come First Serve scheduling. This can be understood here - https://www.scaler.com/topics/first-come-first-serve/\n */\npublic class FCFSScheduling {\n\n    private List<ProcessDetails> processes;\n\n    FCFSScheduling(final List<ProcessDetails> processes) {\n        this.processes = processes;\n    }\n\n    public void scheduleProcesses() {\n        evaluateWaitingTime();\n        evaluateTurnAroundTime();\n    }\n\n    private void evaluateWaitingTime() {\n        int processesNumber = processes.size();\n\n        if(processesNumber == 0) {\n            return;\n        }\n\n        int waitingTime = 0;\n        int burstTime = processes.get(0).getBurstTime();\n\n        processes.get(0).setWaitingTime(waitingTime); // for the first process, waiting time will be 0.\n\n        for(int i=1; i<processesNumber; i++) {\n           processes.get(i).setWaitingTime(waitingTime + burstTime);\n           waitingTime = processes.get(i).getWaitingTime();\n           burstTime = processes.get(i).getBurstTime();\n        }\n    }\n\n    private void evaluateTurnAroundTime() {\n        for(int i=0; i<processes.size(); i++) {\n            processes.get(i).setTurnAroundTimeTime(processes.get(i).getBurstTime() + processes.get(i).getWaitingTime());\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.scheduling;\n\nimport com.thealgorithms.devutils.entities.ProcessDetails;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class FCFSSchedulingTest {\n\n\n    @Test\n    public void testingProcesses() {\n        List<ProcessDetails> processes = addProcessesForFCFS();\n        final FCFSScheduling fcfsScheduling = new FCFSScheduling(processes); // for sending to FCFS\n\n        fcfsScheduling.scheduleProcesses();\n\n        assertEquals(3, processes.size());\n\n        assertEquals(\"P1\", processes.get(0).getProcessId());\n        assertEquals(0, processes.get(0).getWaitingTime());\n        assertEquals(10, processes.get(0).getTurnAroundTimeTime());\n\n        assertEquals(\"P2\", processes.get(1).getProcessId());\n        assertEquals(10, processes.get(1).getWaitingTime());\n        assertEquals(15, processes.get(1).getTurnAroundTimeTime());\n\n        assertEquals(\"P3\", processes.get(2).getProcessId());\n        assertEquals(15, processes.get(2).getWaitingTime());\n        assertEquals(23, processes.get(2).getTurnAroundTimeTime());\n\n    }\n\n    private List<ProcessDetails> addProcessesForFCFS() {\n        final ProcessDetails process1 = new ProcessDetails(\"P1\", 0, 10);\n        final ProcessDetails process2 = new ProcessDetails(\"P2\", 1, 5);\n        final ProcessDetails process3 = new ProcessDetails(\"P3\", 2, 8);\n\n        final List<ProcessDetails> processDetails = new ArrayList<>();\n        processDetails.add(process1);\n        processDetails.add(process2);\n        processDetails.add(process3);\n\n        return processDetails;\n    }\n\n}"
    },
    {
        "product_commit": "911b98472c59275da3c96a92d85b19120e14bf74",
        "test_commit": "911b98472c59275da3c96a92d85b19120e14bf74",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DudeneyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DudeneyNumberTest.java",
        "product_old_content": "/**\n * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.\n * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.\n *          Since, the sum of the digits is equal to the cube root of the entered number;\n *          it is a Dudeney Number.\n */\npackage com.thealgorithms.maths;\n\nimport java.io.*;\n\npublic class DudeneyNumber {\n\n    //returns True if the number is a Dudeney number and False if it is not a Dudeney number.\n    public static boolean isDudeney(int n) {\n        // Calculating Cube Root\n        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));\n        // If the number is not a perfect cube the method returns false.\n        if (cube_root * cube_root * cube_root != n) {\n            return false;\n        }\n        int sum_of_digits = 0; // Stores the sums of the digit of the entered number\n        int temp = n; //A temporary variable to store the entered number\n        // Loop to calculate sum of the digits.\n        while (temp > 0) {\n            // Extracting Last digit of the number\n            int rem = temp % 10;\n\n            // Calculating sum of digits.\n            sum_of_digits += rem;\n\n            // Removing the last digit\n            temp /= 10;\n        }\n\n        //If the cube root of the number is not equal to the sum of its digits we return false.\n        if (cube_root != sum_of_digits) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Method to check if number is Dudeney Number or Not 1) Input - Enter a\n     * Number: 512 Output - It is a Dudeney Number. 2) Input - Enter a Number:\n     * 125 Output - It is not a Dudeney Number.\n     */\n    public static void main(String args[]) throws IOException {\n        BufferedReader br = new BufferedReader(\n            new InputStreamReader(System.in)\n        );\n        System.out.println(\"Enter a Number: \");\n        int n = Integer.parseInt(br.readLine());\n        if (isDudeney(n)) {\n            System.out.println(\"It is a Dudeney Number.\");\n        } else {\n            System.out.println(\"It is not a Dudeney Number.\");\n        }\n    }\n}",
        "product_new_content": "/**\n * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.\n * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.\n *          Since, the sum of the digits is equal to the cube root of the entered number;\n *          it is a Dudeney Number.\n */\npackage com.thealgorithms.maths;\n\nimport java.io.*;\n\npublic class DudeneyNumber {\n\n    //returns True if the number is a Dudeney number and False if it is not a Dudeney number.\n    public static boolean isDudeney(int n) {\n        // Calculating Cube Root\n        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));\n        // If the number is not a perfect cube the method returns false.\n        if (cube_root * cube_root * cube_root != n) {\n            return false;\n        }\n        int sum_of_digits = 0; // Stores the sums of the digit of the entered number\n        int temp = n; //A temporary variable to store the entered number\n        // Loop to calculate sum of the digits.\n        while (temp > 0) {\n            // Extracting Last digit of the number\n            int rem = temp % 10;\n\n            // Calculating sum of digits.\n            sum_of_digits += rem;\n\n            // Removing the last digit\n            temp /= 10;\n        }\n\n        //If the cube root of the number is not equal to the sum of its digits we return false.\n        if (cube_root != sum_of_digits) {\n            return false;\n        }\n\n        return true;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass DudeneyNumberTest {\n\n    @Test\n    void isDudeney() {\n        final int validDudeneyNumber = 512;\n        final int invalidDudeneyNumber = 125;\n\n        assertTrue(() -> DudeneyNumber.isDudeney(validDudeneyNumber));\n        assertFalse(() -> DudeneyNumber.isDudeney(invalidDudeneyNumber));\n\n    }\n}"
    },
    {
        "product_commit": "8661d07276caaed4eba8d613f0eac1a44af8767d",
        "test_commit": "8661d07276caaed4eba8d613f0eac1a44af8767d",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SumWithoutArithmeticOperators.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SumWithoutArithmeticOperatorsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class SumWithoutArithmeticOperators {\n\n    /**\n        * Calculate the sum of two numbers a and b without using any arithmetic operators (+, -, *, /).\n        * All the integers associated are unsigned 32-bit integers\n        *https://stackoverflow.com/questions/365522/what-is-the-best-way-to-add-two-numbers-without-using-the-operator\n        *@param a - It is the first number \n        *@param b - It is the second number\n        *@return returns an integer which is the sum of the first and second number\n    */ \n\n    public int getSum(int a, int b){\n        if(b==0) return a;\n        int sum = a^b;\n        int carry = (a&b)<<1;\n        return getSum(sum, carry);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class SumWithoutArithmeticOperatorsTest {\n    SumWithoutArithmeticOperators obj = new SumWithoutArithmeticOperators();\n\n    @Test\n    void addZerotoZero(){\n        assertEquals(0,obj.getSum(0, 0));\n    }\n\n    @Test\n    void addZerotoNumber(){\n        assertEquals(5,obj.getSum(0, 5));\n        assertEquals(28,obj.getSum(28, 0));\n    }\n\n    @Test\n    void addOddtoEven(){\n        assertEquals(13,obj.getSum(3, 10));\n        assertEquals(55,obj.getSum(49, 6));\n    }\n\n    @Test\n    void addEventoOdd(){\n        assertEquals(13,obj.getSum(10, 3));\n        assertEquals(41,obj.getSum(40, 1));\n    }\n\n    @Test\n    void addRandoms(){\n        assertEquals(88,obj.getSum(44, 44));\n        assertEquals(370,obj.getSum(100, 270));\n        assertEquals(3,obj.getSum(1, 2));\n        assertEquals(5,obj.getSum(2, 3));\n    }\n}"
    },
    {
        "product_commit": "03a4832a7da6c98b2083e8dda90f0a5d8c8a9a47",
        "test_commit": "cce1dbd124de7197de383deb11c936a39a3e5463",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\n// The search is for any array which is sorted row and column-wise too. For ex :\n// int[][] arr = { {10, 20, 30, 40},\n//                 {15, 25, 35, 45},\n//                 {18, 28, 38, 48},\n//                 {21, 31, 41, 51}\n//                };\n// This array is sorted in both row and column manner.\n// In this two pointers are taken, the first points to the 0th row and the second one points to end column, and then the\n// element corresponding to the pointers placed in the array is compared with the target that either its equal, greater or\n// smaller than the target. If the element is equal to the target, the co-ordinates of that element is returned i.e. an\n// array of the two pointers will be returned, else if the target is greater than corresponding element then the pointer\n// pointing to the 0th row will be incremented by 1, else if the target is lesser than the corresponding element then the\n// pointer pointing to the end column will be decremented by 1. And if the element doesn't exist in the array, an array\n// {-1, -1} will be returned.\n\npublic class RowColumnWiseSorted2dArrayBinarySearch {\n\n    public static int[] search(int[][] matrix, int target) {\n\n        int rowPointer = 0;                 //The pointer at 0th row\n        int colPointer = matrix.length-1;   //The pointer at end column\n\n        while (rowPointer < matrix.length && colPointer >= 0){\n\n            if (matrix[rowPointer][colPointer] == target)\n                return new int[] {rowPointer, colPointer};\n\n            else if (matrix[rowPointer][colPointer] < target)\n                rowPointer++;               //Incrementing the row pointer if the target is greater\n            else\n                colPointer--;               //Decrementing the column pointer if the target is lesser\n        }\n        return new int[] {-1, -1};          //The not found condition\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.MatrixSearchAlgorithm;\n\n/**\n * The search is for any array which is sorted row and column-wise too. For ex :\n * {{10, 20, 30, 40},\n *  {15, 25, 35, 45},\n *  {18, 28, 38, 48},\n *  {21, 31, 41, 51}}\n *\n * This array is sorted in both row and column manner.\n * In this two pointers are taken, the first points to the 0th row and the second one points to end column, and then the\n * element corresponding to the pointers placed in the array is compared with the target that either its equal, greater or\n * smaller than the target. If the element is equal to the target, the co-ordinates of that element is returned i.e. an\n * array of the two pointers will be returned, else if the target is greater than corresponding element then the pointer\n * pointing to the 0th row will be incremented by 1, else if the target is lesser than the corresponding element then the\n * pointer pointing to the end column will be decremented by 1. And if the element doesn't exist in the array, an array\n * {-1, -1} will be returned.\n */\npublic class RowColumnWiseSorted2dArrayBinarySearch\n  implements MatrixSearchAlgorithm {\n\n  @Override\n  public <T extends Comparable<T>> int[] find(T[][] matrix, T key) {\n    return search(matrix, key);\n  }\n\n  public static <T extends Comparable<T>> int[] search(T[][] matrix, T target) {\n    int rowPointer = 0; //The pointer at 0th row\n    int colPointer = matrix.length - 1; //The pointer at end column\n\n    while (rowPointer < matrix.length && colPointer >= 0) {\n      int comp = target.compareTo(matrix[rowPointer][colPointer]);\n\n      if (comp == 0) {\n        return new int[] { rowPointer, colPointer };\n      } else if (comp > 0) {\n        rowPointer++; //Incrementing the row pointer if the target is greater\n      } else {\n        colPointer--; //Decrementing the column pointer if the target is lesser\n      }\n    }\n    return new int[] { -1, -1 }; //The not found condition\n  }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\npublic class RowColumnWiseSorted2dArrayBinarySearchTest {\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestMiddle() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 35;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {1,2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 48;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {2,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpper() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 20;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpperSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 40;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLower() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 31;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLowerSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 51;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestNotFound() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 101;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {-1,-1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n}"
    },
    {
        "product_commit": "cce1dbd124de7197de383deb11c936a39a3e5463",
        "test_commit": "cce1dbd124de7197de383deb11c936a39a3e5463",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearchTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\n\n// The search is for any array which is sorted row and column-wise too. For ex :\n// int[][] arr = { {10, 20, 30, 40},\n//                 {15, 25, 35, 45},\n//                 {18, 28, 38, 48},\n//                 {21, 31, 41, 51}\n//                };\n// This array is sorted in both row and column manner.\n// In this two pointers are taken, the first points to the 0th row and the second one points to end column, and then the\n// element corresponding to the pointers placed in the array is compared with the target that either its equal, greater or\n// smaller than the target. If the element is equal to the target, the co-ordinates of that element is returned i.e. an\n// array of the two pointers will be returned, else if the target is greater than corresponding element then the pointer\n// pointing to the 0th row will be incremented by 1, else if the target is lesser than the corresponding element then the\n// pointer pointing to the end column will be decremented by 1. And if the element doesn't exist in the array, an array\n// {-1, -1} will be returned.\n\npublic class RowColumnWiseSorted2dArrayBinarySearch {\n\n    public static int[] search(int[][] matrix, int target) {\n\n        int rowPointer = 0;                 //The pointer at 0th row\n        int colPointer = matrix.length-1;   //The pointer at end column\n\n        while (rowPointer < matrix.length && colPointer >= 0){\n\n            if (matrix[rowPointer][colPointer] == target)\n                return new int[] {rowPointer, colPointer};\n\n            else if (matrix[rowPointer][colPointer] < target)\n                rowPointer++;               //Incrementing the row pointer if the target is greater\n            else\n                colPointer--;               //Decrementing the column pointer if the target is lesser\n        }\n        return new int[] {-1, -1};          //The not found condition\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\npublic class RowColumnWiseSorted2dArrayBinarySearchTest {\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestMiddle() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 35;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {1,2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 48;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {2,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpper() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 20;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpperSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 40;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLower() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 31;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLowerSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 51;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestNotFound() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 101;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {-1,-1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n}"
    },
    {
        "product_commit": "471d2c0b5d671d0caf98e84a88673de7b5778801",
        "test_commit": "471d2c0b5d671d0caf98e84a88673de7b5778801",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/buffers/CircularBuffer.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/buffers/CircularBufferTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.buffers;\n\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CircularBuffer {\n\n    private char[] _buffer;\n    public final int _buffer_size;\n    private int _write_index = 0;\n    private int _read_index = 0;\n    private AtomicInteger _readable_data = new AtomicInteger(0);\n\n    public CircularBuffer(int buffer_size) {\n        if (!IsPowerOfTwo(buffer_size)) {\n            throw new IllegalArgumentException();\n        }\n        this._buffer_size = buffer_size;\n        _buffer = new char[buffer_size];\n    }\n\n    private boolean IsPowerOfTwo(int i) {\n        return (i & (i - 1)) == 0;\n    }\n\n    private int getTrueIndex(int i) {\n        return i % _buffer_size;\n    }\n\n    public Character readOutChar() {\n        Character result = null;\n\n        // if we have data to read\n        if (_readable_data.get() > 0) {\n            result = Character.valueOf(_buffer[getTrueIndex(_read_index)]);\n            _readable_data.decrementAndGet();\n            _read_index++;\n        }\n\n        return result;\n    }\n\n    public boolean writeToCharBuffer(char c) {\n        boolean result = false;\n\n        // if we can write to the buffer\n        if (_readable_data.get() < _buffer_size) {\n            // write to buffer\n            _buffer[getTrueIndex(_write_index)] = c;\n            _readable_data.incrementAndGet();\n            _write_index++;\n            result = true;\n        }\n\n        return result;\n    }\n\n    private static class TestWriteWorker implements Runnable {\n\n        String _alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n        Random _random = new Random();\n        CircularBuffer _buffer;\n\n        public TestWriteWorker(CircularBuffer cb) {\n            this._buffer = cb;\n        }\n\n        private char getRandomChar() {\n            return _alphabet.charAt(_random.nextInt(_alphabet.length()));\n        }\n\n        public void run() {\n            while (!Thread.interrupted()) {\n                if (!_buffer.writeToCharBuffer(getRandomChar())) {\n                    Thread.yield();\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    private static class TestReadWorker implements Runnable {\n\n        CircularBuffer _buffer;\n\n        public TestReadWorker(CircularBuffer cb) {\n            this._buffer = cb;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(\"Printing Buffer:\");\n            while (!Thread.interrupted()) {\n                Character c = _buffer.readOutChar();\n                if (c != null) {\n                    System.out.print(c.charValue());\n                } else {\n                    Thread.yield();\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        System.out.println();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        int buffer_size = 1024;\n        // create circular buffer\n        CircularBuffer cb = new CircularBuffer(buffer_size);\n\n        // create threads that read and write the buffer.\n        Thread write_thread = new Thread(new TestWriteWorker(cb));\n        Thread read_thread = new Thread(new TestReadWorker(cb));\n        read_thread.start();\n        write_thread.start();\n\n        // wait some amount of time\n        Thread.sleep(10000);\n\n        // interrupt threads and exit\n        write_thread.interrupt();\n        read_thread.interrupt();\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.buffers;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CircularBuffer<Item> {\n    private final Item[] buffer;\n    private final CircularPointer putPointer;\n    private final CircularPointer getPointer;\n    private final AtomicInteger size = new AtomicInteger(0);\n\n    public CircularBuffer(int size) {\n        //noinspection unchecked\n        this.buffer = (Item[]) new Object[size];\n        this.putPointer = new CircularPointer(0, size);\n        this.getPointer = new CircularPointer(0, size);\n    }\n\n    public boolean isEmpty() {\n        return size.get() == 0;\n    }\n\n    public boolean isFull() {\n        return size.get() == buffer.length;\n    }\n\n    public Item get() {\n        if (isEmpty())\n            return null;\n\n        Item item = buffer[getPointer.getAndIncrement()];\n        size.decrementAndGet();\n        return item;\n    }\n\n    public boolean put(Item item) {\n        if (isFull())\n            return false;\n\n        buffer[putPointer.getAndIncrement()] = item;\n        size.incrementAndGet();\n        return true;\n    }\n\n    private static class CircularPointer {\n        private int pointer;\n        private final int max;\n\n        public CircularPointer(int pointer, int max) {\n            this.pointer = pointer;\n            this.max = max;\n        }\n\n        public int getAndIncrement() {\n            if (pointer == max)\n                pointer = 0;\n            int tmp = pointer;\n            pointer++;\n            return tmp;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.buffers;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CircularBufferTest {\n    private static final int BUFFER_SIZE = 10;\n    private CircularBuffer<Integer> buffer;\n\n    @BeforeEach\n    void setUp() {\n        buffer = new CircularBuffer<>(BUFFER_SIZE);\n    }\n\n    @Test\n    void isEmpty() {\n        assertTrue(buffer.isEmpty());\n        buffer.put(generateInt());\n        assertFalse(buffer.isEmpty());\n    }\n\n    @Test\n    void isFull() {\n        assertFalse(buffer.isFull());\n        buffer.put(generateInt());\n        assertFalse(buffer.isFull());\n\n        for (int i = 1; i < BUFFER_SIZE; i++)\n            buffer.put(generateInt());\n        assertTrue(buffer.isFull());\n    }\n\n    @Test\n    void get() {\n        assertNull(buffer.get());\n        for (int i = 0; i < 100; i++)\n            buffer.put(i);\n        for (int i = 0; i < BUFFER_SIZE; i++)\n            assertEquals(i, buffer.get());\n        assertNull(buffer.get());\n    }\n\n    @Test\n    void put() {\n        for (int i = 0; i < BUFFER_SIZE; i++)\n            assertTrue(buffer.put(generateInt()));\n        assertFalse(buffer.put(generateInt()));\n    }\n\n    @RepeatedTest(1000)\n    void concurrentTest() throws InterruptedException {\n        final int numberOfThreadsForProducers = 3;\n        final int numberOfThreadsForConsumers = 2;\n        final int numberOfItems = 300;\n        final CountDownLatch producerCountDownLatch = new CountDownLatch(numberOfItems);\n        final CountDownLatch consumerCountDownLatch = new CountDownLatch(numberOfItems);\n        final AtomicIntegerArray resultAtomicArray = new AtomicIntegerArray(numberOfItems);\n\n        // We are running 2 ExecutorService simultaneously 1 - producer, 2 - consumer\n        // Run producer threads to populate buffer.\n        ExecutorService putExecutors = Executors.newFixedThreadPool(numberOfThreadsForProducers);\n        putExecutors.execute(() -> {\n            while (producerCountDownLatch.getCount() > 0) {\n                int count = (int) producerCountDownLatch.getCount();\n                boolean put = buffer.put(count);\n                while (!put) put = buffer.put(count);\n                producerCountDownLatch.countDown();\n            }\n        });\n\n        // Run consumer threads to retrieve the data from buffer.\n        ExecutorService getExecutors = Executors.newFixedThreadPool(numberOfThreadsForConsumers);\n        getExecutors.execute(() -> {\n            while (consumerCountDownLatch.getCount() > 0) {\n                int count = (int) consumerCountDownLatch.getCount();\n                Integer item = buffer.get();\n                while (item == null) item = buffer.get();\n                resultAtomicArray.set(count - 1, item);\n                consumerCountDownLatch.countDown();\n            }\n        });\n\n        producerCountDownLatch.await();\n        consumerCountDownLatch.await();\n        putExecutors.shutdown();\n        getExecutors.shutdown();\n        shutDownExecutorSafely(putExecutors);\n        shutDownExecutorSafely(getExecutors);\n\n        List<Integer> resultArray = getSortedListFrom(resultAtomicArray);\n        for (int i = 0; i < numberOfItems; i++) {\n            int expectedItem = i + 1;\n            assertEquals(expectedItem, resultArray.get(i));\n        }\n    }\n\n    private int generateInt() {\n        return ThreadLocalRandom.current().nextInt(0, 100);\n    }\n\n    private void shutDownExecutorSafely(ExecutorService executorService) {\n        try {\n            if (!executorService.awaitTermination(1_000, TimeUnit.MILLISECONDS))\n                executorService.shutdownNow();\n        } catch (InterruptedException e) {\n            executorService.shutdownNow();\n        }\n    }\n\n    public List<Integer> getSortedListFrom(AtomicIntegerArray atomicArray) {\n        int length = atomicArray.length();\n        ArrayList<Integer> result = new ArrayList<>(length);\n        for (int i = 0; i < length; i++)\n            result.add(atomicArray.get(i));\n        result.sort(Comparator.comparingInt(o -> o));\n        return result;\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/Combination.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/CombinationTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\nimport java.util.*;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Combination {\n    private static int length;\n    /**\n     * Find all combinations of given array using backtracking\n     * @param arr the array.\n     * @param n length of combination\n     * @param <T> the type of elements in the array.\n     * @return a list of all combinations of length n. If n == 0, return null.\n     */\n    public static <T> List<TreeSet<T>> combination(T[] arr, int n) {\n        if (n == 0) {\n            return null;\n        }\n        length = n;\n        T[] array = arr.clone();\n        Arrays.sort(array);\n        List<TreeSet<T>> result = new LinkedList<>();\n        backtracking(array, 0, new TreeSet<T>(), result);\n        return result;\n    }\n    /**\n     * Backtrack all possible combinations of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param currSet set that tracks current combination\n     * @param result the list contains all combination.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(T[] arr, int index, TreeSet<T> currSet, List<TreeSet<T>> result) {\n        if (index + length - currSet.size() > arr.length) return;\n        if (length - 1 == currSet.size()) {\n            for (int i = index; i < arr.length; i++) {\n                currSet.add(arr[i]);\n                result.add((TreeSet<T>) currSet.clone());\n                currSet.remove(arr[i]);\n            }\n        }\n        for (int i = index; i < arr.length; i++) {\n            currSet.add(arr[i]);\n            backtracking(arr, i + 1, currSet, result);\n            currSet.remove(arr[i]);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.*;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Combination {\n\n    private static int length;\n\n    /**\n     * Find all combinations of given array using backtracking\n     * @param arr the array.\n     * @param n length of combination\n     * @param <T> the type of elements in the array.\n     * @return a list of all combinations of length n. If n == 0, return null.\n     */\n    public static <T> List<TreeSet<T>> combination(T[] arr, int n) {\n        if (n == 0) {\n            return null;\n        }\n        length = n;\n        T[] array = arr.clone();\n        Arrays.sort(array);\n        List<TreeSet<T>> result = new LinkedList<>();\n        backtracking(array, 0, new TreeSet<T>(), result);\n        return result;\n    }\n\n    /**\n     * Backtrack all possible combinations of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param currSet set that tracks current combination\n     * @param result the list contains all combination.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(\n        T[] arr,\n        int index,\n        TreeSet<T> currSet,\n        List<TreeSet<T>> result\n    ) {\n        if (index + length - currSet.size() > arr.length) return;\n        if (length - 1 == currSet.size()) {\n            for (int i = index; i < arr.length; i++) {\n                currSet.add(arr[i]);\n                result.add((TreeSet<T>) currSet.clone());\n                currSet.remove(arr[i]);\n            }\n        }\n        for (int i = index; i < arr.length; i++) {\n            currSet.add(arr[i]);\n            backtracking(arr, i + 1, currSet, result);\n            currSet.remove(arr[i]);\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class CombinationTest {\n    @Test\n    void testNoElement()\n    {\n        List<TreeSet<Integer>> result  = Combination.combination(new Integer[]{1, 2}, 0);\n        assertTrue(result == null);\n    }\n    @Test\n    void testLengthOne()\n    {\n        List<TreeSet<Integer>> result  = Combination.combination(new Integer[]{1, 2}, 1);\n        assertTrue(result.get(0).iterator().next() == 1);\n        assertTrue(result.get(1).iterator().next() == 2);\n    }\n    @Test\n    void testLengthTwo()\n    {\n        List<TreeSet<Integer>> result  = Combination.combination(new Integer[]{1, 2}, 2);\n        Integer[] arr = result.get(0).toArray(new Integer[2]);\n        assertTrue(arr[0] == 1);\n        assertTrue(arr[1] == 2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport java.util.TreeSet;\nimport org.junit.jupiter.api.Test;\n\npublic class CombinationTest {\n\n    @Test\n    void testNoElement() {\n        List<TreeSet<Integer>> result = Combination.combination(\n            new Integer[] { 1, 2 },\n            0\n        );\n        assertTrue(result == null);\n    }\n\n    @Test\n    void testLengthOne() {\n        List<TreeSet<Integer>> result = Combination.combination(\n            new Integer[] { 1, 2 },\n            1\n        );\n        assertTrue(result.get(0).iterator().next() == 1);\n        assertTrue(result.get(1).iterator().next() == 2);\n    }\n\n    @Test\n    void testLengthTwo() {\n        List<TreeSet<Integer>> result = Combination.combination(\n            new Integer[] { 1, 2 },\n            2\n        );\n        Integer[] arr = result.get(0).toArray(new Integer[2]);\n        assertTrue(arr[0] == 1);\n        assertTrue(arr[1] == 2);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/FloodFill.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/FloodFillTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given co-odrinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\t\n\tpublic static int getPixel(int[][] image, int x, int y) {\n\t\n\t\treturn image[x][y];\n\t\n\t}\n\t\n    /**\n     * Put the color at the given co-odrinates of a 2D image\n     *\n     * @param image The image to be filed\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n\tpublic static void putPixel(int[][] image, int x, int y, int newColor) {\n\t\t\n\t\timage[x][y] = newColor;\n\t\n\t}\n\t\n\t\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filed\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     * @return\n     */\n\tpublic static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {\n\n\t\tif(x < 0 || x >= image.length) return;\n\t\tif(y < 0 || y >= image[x].length) return;\n\t\tif(getPixel(image, x, y) != oldColor) return;\n\n\t\tputPixel(image, x, y, newColor);\n\n\t\t/* Recursively check for horizontally & vertically adjacent coordinates */\n\t\tfloodFill(image, x + 1, y, newColor, oldColor);\n\t\tfloodFill(image, x - 1, y, newColor, oldColor);\n\t\tfloodFill(image, x, y + 1, newColor, oldColor);\n\t\tfloodFill(image, x, y - 1, newColor, oldColor);\n\n\t\t/* Recursively check for diagonally adjacent coordinates  */\n\t\tfloodFill(image, x + 1, y - 1, newColor, oldColor);\n\t\tfloodFill(image, x - 1, y + 1, newColor, oldColor);\n\t\tfloodFill(image, x + 1, y + 1, newColor, oldColor);\n\t\tfloodFill(image, x - 1, y - 1, newColor, oldColor);\n\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given co-odrinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given co-odrinates of a 2D image\n     *\n     * @param image The image to be filed\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filed\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     * @return\n     */\n    public static void floodFill(\n        int[][] image,\n        int x,\n        int y,\n        int newColor,\n        int oldColor\n    ) {\n        if (x < 0 || x >= image.length) return;\n        if (y < 0 || y >= image[x].length) return;\n        if (getPixel(image, x, y) != oldColor) return;\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage()\n    {\n        int image[][] = {};\n        int expected[][] = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForSingleElementImage()\n    {\n        int image[][] = {{1}};\n        int expected[][] = {{3}};\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForImageOne()\n    {\n        int image[][] = {\n                { 0,0,0,0,0,0,0 },\n                { 0,3,3,3,3,0,0 },\n                { 0,3,1,1,5,0,0 },\n                { 0,3,1,1,5,5,3 },\n                { 0,3,5,5,1,1,3 },\n                { 0,0,0,5,1,1,3 },\n                { 0,0,0,3,3,3,3 }\n        };\n\n        int expected[][] = {\n                { 0,0,0,0,0,0,0 },\n                { 0,3,3,3,3,0,0 },\n                { 0,3,2,2,5,0,0 },\n                { 0,3,2,2,5,5,3 },\n                { 0,3,5,5,2,2,3 },\n                { 0,0,0,5,2,2,3 },\n                { 0,0,0,3,3,3,3 }\n        };\n\n        FloodFill.floodFill(image,2,2,2,1);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForImageTwo()\n    {\n        int image[][] = {\n                { 0,0,1,1,0,0,0 },\n                { 1,1,3,3,3,0,0 },\n                { 1,3,1,1,5,0,0 },\n                { 0,3,1,1,5,5,3 },\n                { 0,3,5,5,1,1,3 },\n                { 0,0,0,5,1,1,3 },\n                { 0,0,0,1,3,1,3 }\n        };\n\n        int expected[][] = {\n                { 0,0,2,2,0,0,0 },\n                { 2,2,3,3,3,0,0 },\n                { 2,3,2,2,5,0,0 },\n                { 0,3,2,2,5,5,3 },\n                { 0,3,5,5,2,2,3 },\n                { 0,0,0,5,2,2,3 },\n                { 0,0,0,2,3,2,3 }\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForImageThree()\n    {\n        int image[][] = {\n                { 1,1,2,3,1,1,1 },\n                { 1,0,0,1,0,0,1 },\n                { 1,1,1,0,3,1,2 }\n        };\n\n        int expected[][] = {\n                { 4,4,2,3,4,4,4 },\n                { 4,0,0,4,0,0,4 },\n                { 4,4,4,0,3,4,2 },\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage() {\n        int image[][] = {};\n        int expected[][] = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForSingleElementImage() {\n        int image[][] = { { 1 } };\n        int expected[][] = { { 3 } };\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageOne() {\n        int image[][] = {\n            { 0, 0, 0, 0, 0, 0, 0 },\n            { 0, 3, 3, 3, 3, 0, 0 },\n            { 0, 3, 1, 1, 5, 0, 0 },\n            { 0, 3, 1, 1, 5, 5, 3 },\n            { 0, 3, 5, 5, 1, 1, 3 },\n            { 0, 0, 0, 5, 1, 1, 3 },\n            { 0, 0, 0, 3, 3, 3, 3 },\n        };\n\n        int expected[][] = {\n            { 0, 0, 0, 0, 0, 0, 0 },\n            { 0, 3, 3, 3, 3, 0, 0 },\n            { 0, 3, 2, 2, 5, 0, 0 },\n            { 0, 3, 2, 2, 5, 5, 3 },\n            { 0, 3, 5, 5, 2, 2, 3 },\n            { 0, 0, 0, 5, 2, 2, 3 },\n            { 0, 0, 0, 3, 3, 3, 3 },\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageTwo() {\n        int image[][] = {\n            { 0, 0, 1, 1, 0, 0, 0 },\n            { 1, 1, 3, 3, 3, 0, 0 },\n            { 1, 3, 1, 1, 5, 0, 0 },\n            { 0, 3, 1, 1, 5, 5, 3 },\n            { 0, 3, 5, 5, 1, 1, 3 },\n            { 0, 0, 0, 5, 1, 1, 3 },\n            { 0, 0, 0, 1, 3, 1, 3 },\n        };\n\n        int expected[][] = {\n            { 0, 0, 2, 2, 0, 0, 0 },\n            { 2, 2, 3, 3, 3, 0, 0 },\n            { 2, 3, 2, 2, 5, 0, 0 },\n            { 0, 3, 2, 2, 5, 5, 3 },\n            { 0, 3, 5, 5, 2, 2, 3 },\n            { 0, 0, 0, 5, 2, 2, 3 },\n            { 0, 0, 0, 2, 3, 2, 3 },\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    void testForImageThree() {\n        int image[][] = {\n            { 1, 1, 2, 3, 1, 1, 1 },\n            { 1, 0, 0, 1, 0, 0, 1 },\n            { 1, 1, 1, 0, 3, 1, 2 },\n        };\n\n        int expected[][] = {\n            { 4, 4, 2, 3, 4, 4, 4 },\n            { 4, 0, 0, 4, 0, 0, 4 },\n            { 4, 4, 4, 0, 3, 4, 2 },\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/MazeRecursionTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n\n\tpublic static void mazeRecursion() {\n\t\t// First create a 2 dimensions array to mimic a maze map\n\t\tint[][] map = new int[8][7];\n\t\tint[][] map2 = new int[8][7];\n\n\t\t// We use 1 to indicate wall\n\t\t// Set the ceiling and floor to 1\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tmap[0][i] = 1;\n\t\t\tmap[7][i] = 1;\n\t\t}\n\n\t\t// Then we set the left and right wall to 1\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tmap[i][0] = 1;\n\t\t\tmap[i][6] = 1;\n\t\t}\n\n\t\t// Now we have created a maze with its wall initialized\n\n\t\t// Here we set the obstacle\n\t\tmap[3][1] = 1;\n\t\tmap[3][2] = 1;\n\n\t\t// Print the current map\n\t\tSystem.out.println(\"The condition of the map\uff1a \");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t// clone another map for setWay2 method\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\tmap2[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// By using recursive backtracking to let your ball(target) find its way in the\n\t\t// maze\n\t\t// The first parameter is the map\n\t\t// Second parameter is x coordinate of your target\n\t\t// Thrid parameter is the y coordinate of your target\n\t\tsetWay(map, 1, 1);\n\t\tsetWay2(map2, 1, 1);\n\n\t\t// Print out the new map1, with the ball footprint\n\t\tSystem.out.println(\"After the ball goes through the map1\uff0cshow the current map1 condition\");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t// Print out the new map2, with the ball footprint\n\t\tSystem.out.println(\"After the ball goes through the map2\uff0cshow the current map2 condition\");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map2[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\n\n\t// Using recursive path finding to help the ball find its way in the maze\n\t// Description\uff1a\n\t// 1. map (means the maze)\n\t// 2. i, j (means the initial coordinate of the ball in the maze)\n\t// 3. if the ball can reach the end of maze, that is position of map[6][5],\n\t// means the we have found a path for the ball\n\t// 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n\t// through this position, 1 means the wall, 2 means the path is feasible, 3\n\t// means the ball has gone through the path but this path is dead end\n\t// 5. We will need strategy for the ball to pass through the maze for example:\n\t// Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n\t/**\n\t *\n\t * @Description\n\t * @author OngLipWei\n\t * @date Jun 23, 202111:36:14 AM\n\t * @param map The maze\n\t * @param i   x coordinate of your ball(target)\n\t * @param j   y coordinate of your ball(target)\n\t * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n\t */\n\tpublic static boolean setWay(int[][] map, int i, int j) {\n\t\tif (map[6][5] == 2) {// means the ball find its path, ending condition\n\t\t\treturn true;\n\t\t}\n\t\tif (map[i][j] == 0) { // if the ball haven't gone through this point\n\t\t\t// then the ball follows the move strategy : down -> right -> up -> left\n\t\t\tmap[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n\t\t\tif (setWay(map, i + 1, j)) { // go down\n\t\t\t\treturn true;\n\t\t\t} else if (setWay(map, i, j + 1)) { // go right\n\t\t\t\treturn true;\n\t\t\t} else if (setWay(map, i - 1, j)) { // go up\n\t\t\t\treturn true;\n\t\t\t} else if (setWay(map, i, j - 1)) { // go left\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// means that the current point is the dead end, the ball cannot proceed, set\n\t\t\t\t// the current point to 3 and return false, the backtraking will start, it will\n\t\t\t\t// go to the previous step and check for feasible path again\n\t\t\t\tmap[i][j] = 3;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t} else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n\t\t\t// ball cannot hit the wall, cannot go to the path that has gone though before,\n\t\t\t// and cannot head to deadend.\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\t// Here is another move strategy for the ball: up->right->down->left\n\tpublic static boolean setWay2(int[][] map, int i, int j) {\n\t\tif (map[6][5] == 2) {// means the ball find its path, ending condition\n\t\t\treturn true;\n\t\t}\n\t\tif (map[i][j] == 0) { // if the ball haven't gone through this point\n\t\t\t// then the ball follows the move strategy : up->right->down->left\n\t\t\tmap[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n\t\t\tif (setWay2(map, i - 1, j)) { // go up\n\t\t\t\treturn true;\n\t\t\t} else if (setWay2(map, i, j + 1)) { // go right\n\t\t\t\treturn true;\n\t\t\t} else if (setWay2(map, i + 1, j)) { // go down\n\t\t\t\treturn true;\n\t\t\t} else if (setWay2(map, i, j - 1)) { // go left\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// means that the current point is the dead end, the ball cannot proceed, set\n\t\t\t\t// the current point to 3 and return false, the backtraking will start, it will\n\t\t\t\t// go to the previous step and check for feasible path again\n\t\t\t\tmap[i][j] = 3;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t} else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n\t\t\t// ball cannot hit the wall, cannot go to the path that has gone though before,\n\t\t\t// and cannot head to deadend.\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n\n    public static void mazeRecursion() {\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Print the current map\n        System.out.println(\"The condition of the map\uff1a \");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // clone another map for setWay2 method\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                map2[i][j] = map[i][j];\n            }\n        }\n\n        // By using recursive backtracking to let your ball(target) find its way in the\n        // maze\n        // The first parameter is the map\n        // Second parameter is x coordinate of your target\n        // Thrid parameter is the y coordinate of your target\n        setWay(map, 1, 1);\n        setWay2(map2, 1, 1);\n\n        // Print out the new map1, with the ball footprint\n        System.out.println(\n            \"After the ball goes through the map1\uff0cshow the current map1 condition\"\n        );\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // Print out the new map2, with the ball footprint\n        System.out.println(\n            \"After the ball goes through the map2\uff0cshow the current map2 condition\"\n        );\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map2[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    // Using recursive path finding to help the ball find its way in the maze\n    // Description\uff1a\n    // 1. map (means the maze)\n    // 2. i, j (means the initial coordinate of the ball in the maze)\n    // 3. if the ball can reach the end of maze, that is position of map[6][5],\n    // means the we have found a path for the ball\n    // 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n    // through this position, 1 means the wall, 2 means the path is feasible, 3\n    // means the ball has gone through the path but this path is dead end\n    // 5. We will need strategy for the ball to pass through the maze for example:\n    // Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n    /**\n     *\n     * @Description\n     * @author OngLipWei\n     * @date Jun 23, 202111:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */\n    public static boolean setWay(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : down -> right -> up -> left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n            if (setWay(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtraking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone though before,\n            // and cannot head to deadend.\n            return false;\n        }\n    }\n\n    // Here is another move strategy for the ball: up->right->down->left\n    public static boolean setWay2(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : up->right->down->left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n            if (setWay2(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay2(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay2(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay2(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtraking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone though before,\n            // and cannot head to deadend.\n            return false;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * @author onglipwei\n * @create 2022-08-03 5:17 AM\n */\npublic class MazeRecursionTest {\n\n    @Test\n    public void testMaze() {\n\n\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        //clone another map for setWay2 method\n        for (int i = 0; i < map.length;i++) {\n            for (int j = 0; j < map[i].length;j++) {\n                map2[i][j]=map[i][j];\n            }\n        }\n\n        MazeRecursion.setWay(map, 1, 1);\n        MazeRecursion.setWay2(map2, 1, 1);\n\n\n        int expectedMap[][] = new int[][]{\n                {1,1,1,1,1,1,1},\n                {1,2,0,0,0,0,1},\n                {1,2,2,2,0,0,1},\n                {1,1,1,2,0,0,1},\n                {1,0,0,2,0,0,1},\n                {1,0,0,2,0,0,1},\n                {1,0,0,2,2,2,1},\n                {1,1,1,1,1,1,1}\n        };\n\n        int expectedMap2[][] = new int[][]{\n                {1,1,1,1,1,1,1},\n                {1,2,2,2,2,2,1},\n                {1,0,0,0,0,2,1},\n                {1,1,1,0,0,2,1},\n                {1,0,0,0,0,2,1},\n                {1,0,0,0,0,2,1},\n                {1,0,0,0,0,2,1},\n                {1,1,1,1,1,1,1}\n        };\n\n        assertArrayEquals(map, expectedMap);\n        assertArrayEquals(map2, expectedMap2);\n\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author onglipwei\n * @create 2022-08-03 5:17 AM\n */\npublic class MazeRecursionTest {\n\n    @Test\n    public void testMaze() {\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        //clone another map for setWay2 method\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                map2[i][j] = map[i][j];\n            }\n        }\n\n        MazeRecursion.setWay(map, 1, 1);\n        MazeRecursion.setWay2(map2, 1, 1);\n\n        int expectedMap[][] = new int[][] {\n            { 1, 1, 1, 1, 1, 1, 1 },\n            { 1, 2, 0, 0, 0, 0, 1 },\n            { 1, 2, 2, 2, 0, 0, 1 },\n            { 1, 1, 1, 2, 0, 0, 1 },\n            { 1, 0, 0, 2, 0, 0, 1 },\n            { 1, 0, 0, 2, 0, 0, 1 },\n            { 1, 0, 0, 2, 2, 2, 1 },\n            { 1, 1, 1, 1, 1, 1, 1 },\n        };\n\n        int expectedMap2[][] = new int[][] {\n            { 1, 1, 1, 1, 1, 1, 1 },\n            { 1, 2, 2, 2, 2, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 1, 1, 0, 0, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 0, 0, 0, 0, 2, 1 },\n            { 1, 1, 1, 1, 1, 1, 1 },\n        };\n\n        assertArrayEquals(map, expectedMap);\n        assertArrayEquals(map2, expectedMap2);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/Permutation.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/PermutationTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Permutation {\n    /**\n     * Find all permutations of given array using backtracking\n     * @param arr the array.\n     * @param <T> the type of elements in the array.\n     * @return a list of all permutations.\n     */\n    public static <T> List<T[]> permutation(T[] arr) {\n        T[] array = arr.clone();\n        List<T[]> result = new LinkedList<>();\n        backtracking(array, 0, result);\n        return result;\n    }\n    /**\n     * Backtrack all possible orders of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param result the list contains all permutations.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(T[] arr, int index, List<T[]> result) {\n        if (index == arr.length) {\n            result.add(arr.clone());\n        }\n        for (int i = index; i < arr.length; i++) {\n            swap(index, i, arr);\n            backtracking(arr, index + 1, result);\n            swap(index, i, arr);\n        }\n    }\n    /**\n     * Swap two element for a given array\n     * @param a first index\n     * @param b second index\n     * @param arr the array.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void swap(int a, int b, T[] arr) {\n        T temp = arr[a];\n        arr[a] = arr[b];\n        arr[b] = temp;\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Permutation {\n\n    /**\n     * Find all permutations of given array using backtracking\n     * @param arr the array.\n     * @param <T> the type of elements in the array.\n     * @return a list of all permutations.\n     */\n    public static <T> List<T[]> permutation(T[] arr) {\n        T[] array = arr.clone();\n        List<T[]> result = new LinkedList<>();\n        backtracking(array, 0, result);\n        return result;\n    }\n\n    /**\n     * Backtrack all possible orders of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param result the list contains all permutations.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(T[] arr, int index, List<T[]> result) {\n        if (index == arr.length) {\n            result.add(arr.clone());\n        }\n        for (int i = index; i < arr.length; i++) {\n            swap(index, i, arr);\n            backtracking(arr, index + 1, result);\n            swap(index, i, arr);\n        }\n    }\n\n    /**\n     * Swap two element for a given array\n     * @param a first index\n     * @param b second index\n     * @param arr the array.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void swap(int a, int b, T[] arr) {\n        T temp = arr[a];\n        arr[a] = arr[b];\n        arr[b] = temp;\n    }\n}",
        "test_old_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PermutationTest {\n    @Test\n    void testNoElement()\n    {\n        List<Integer []> result = Permutation.permutation(new Integer[]{});\n        assertEquals(result.get(0).length, 0);\n    }\n    @Test\n    void testSingleElement()\n    {\n        List<Integer []> result = Permutation.permutation(new Integer[]{1});\n        assertEquals(result.get(0)[0], 1);\n    }\n    @Test\n    void testMultipleElements()\n    {\n        List<Integer []> result = Permutation.permutation(new Integer[]{1, 2});\n        assertTrue(Arrays.equals(result.get(0), new Integer[]{1,2}));\n        assertTrue(Arrays.equals(result.get(1), new Integer[]{2,1}));\n    }\n\n\n}",
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class PermutationTest {\n\n    @Test\n    void testNoElement() {\n        List<Integer[]> result = Permutation.permutation(new Integer[] {});\n        assertEquals(result.get(0).length, 0);\n    }\n\n    @Test\n    void testSingleElement() {\n        List<Integer[]> result = Permutation.permutation(new Integer[] { 1 });\n        assertEquals(result.get(0)[0], 1);\n    }\n\n    @Test\n    void testMultipleElements() {\n        List<Integer[]> result = Permutation.permutation(\n            new Integer[] { 1, 2 }\n        );\n        assertTrue(Arrays.equals(result.get(0), new Integer[] { 1, 2 }));\n        assertTrue(Arrays.equals(result.get(1), new Integer[] { 2, 1 }));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Blowfish.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/BlowfishTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/*\n * Java program for Blowfish Algorithm \n * Wikipedia: https://en.wikipedia.org/wiki/Blowfish_(cipher)\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class Blowfish {\n\t\n\t//Initializing substitution boxes\n\tString S[][]\n\t\t\t= { { \"d1310ba6\", \"98dfb5ac\", \"2ffd72db\", \"d01adfb7\", \"b8e1afed\",\n\t\t\t\t\"6a267e96\", \"ba7c9045\", \"f12c7f99\", \"24a19947\", \"b3916cf7\",\n\t\t\t\t\"0801f2e2\", \"858efc16\", \"636920d8\", \"71574e69\", \"a458fea3\",\n\t\t\t\t\"f4933d7e\", \"0d95748f\", \"728eb658\", \"718bcd58\", \"82154aee\",\n\t\t\t\t\"7b54a41d\", \"c25a59b5\", \"9c30d539\", \"2af26013\", \"c5d1b023\",\n\t\t\t\t\"286085f0\", \"ca417918\", \"b8db38ef\", \"8e79dcb0\", \"603a180e\",\n\t\t\t\t\"6c9e0e8b\", \"b01e8a3e\", \"d71577c1\", \"bd314b27\", \"78af2fda\",\n\t\t\t\t\"55605c60\", \"e65525f3\", \"aa55ab94\", \"57489862\", \"63e81440\",\n\t\t\t\t\"55ca396a\", \"2aab10b6\", \"b4cc5c34\", \"1141e8ce\", \"a15486af\",\n\t\t\t\t\"7c72e993\", \"b3ee1411\", \"636fbc2a\", \"2ba9c55d\", \"741831f6\",\n\t\t\t\t\"ce5c3e16\", \"9b87931e\", \"afd6ba33\", \"6c24cf5c\", \"7a325381\",\n\t\t\t\t\"28958677\", \"3b8f4898\", \"6b4bb9af\", \"c4bfe81b\", \"66282193\",\n\t\t\t\t\"61d809cc\", \"fb21a991\", \"487cac60\", \"5dec8032\", \"ef845d5d\",\n\t\t\t\t\"e98575b1\", \"dc262302\", \"eb651b88\", \"23893e81\", \"d396acc5\",\n\t\t\t\t\"0f6d6ff3\", \"83f44239\", \"2e0b4482\", \"a4842004\", \"69c8f04a\",\n\t\t\t\t\"9e1f9b5e\", \"21c66842\", \"f6e96c9a\", \"670c9c61\", \"abd388f0\",\n\t\t\t\t\"6a51a0d2\", \"d8542f68\", \"960fa728\", \"ab5133a3\", \"6eef0b6c\",\n\t\t\t\t\"137a3be4\", \"ba3bf050\", \"7efb2a98\", \"a1f1651d\", \"39af0176\",\n\t\t\t\t\"66ca593e\", \"82430e88\", \"8cee8619\", \"456f9fb4\", \"7d84a5c3\",\n\t\t\t\t\"3b8b5ebe\", \"e06f75d8\", \"85c12073\", \"401a449f\", \"56c16aa6\",\n\t\t\t\t\"4ed3aa62\", \"363f7706\", \"1bfedf72\", \"429b023d\", \"37d0d724\",\n\t\t\t\t\"d00a1248\", \"db0fead3\", \"49f1c09b\", \"075372c9\", \"80991b7b\",\n\t\t\t\t\"25d479d8\", \"f6e8def7\", \"e3fe501a\", \"b6794c3b\", \"976ce0bd\",\n\t\t\t\t\"04c006ba\", \"c1a94fb6\", \"409f60c4\", \"5e5c9ec2\", \"196a2463\",\n\t\t\t\t\"68fb6faf\", \"3e6c53b5\", \"1339b2eb\", \"3b52ec6f\", \"6dfc511f\",\n\t\t\t\t\"9b30952c\", \"cc814544\", \"af5ebd09\", \"bee3d004\", \"de334afd\",\n\t\t\t\t\"660f2807\", \"192e4bb3\", \"c0cba857\", \"45c8740f\", \"d20b5f39\",\n\t\t\t\t\"b9d3fbdb\", \"5579c0bd\", \"1a60320a\", \"d6a100c6\", \"402c7279\",\n\t\t\t\t\"679f25fe\", \"fb1fa3cc\", \"8ea5e9f8\", \"db3222f8\", \"3c7516df\",\n\t\t\t\t\"fd616b15\", \"2f501ec8\", \"ad0552ab\", \"323db5fa\", \"fd238760\",\n\t\t\t\t\"53317b48\", \"3e00df82\", \"9e5c57bb\", \"ca6f8ca0\", \"1a87562e\",\n\t\t\t\t\"df1769db\", \"d542a8f6\", \"287effc3\", \"ac6732c6\", \"8c4f5573\",\n\t\t\t\t\"695b27b0\", \"bbca58c8\", \"e1ffa35d\", \"b8f011a0\", \"10fa3d98\",\n\t\t\t\t\"fd2183b8\", \"4afcb56c\", \"2dd1d35b\", \"9a53e479\", \"b6f84565\",\n\t\t\t\t\"d28e49bc\", \"4bfb9790\", \"e1ddf2da\", \"a4cb7e33\", \"62fb1341\",\n\t\t\t\t\"cee4c6e8\", \"ef20cada\", \"36774c01\", \"d07e9efe\", \"2bf11fb4\",\n\t\t\t\t\"95dbda4d\", \"ae909198\", \"eaad8e71\", \"6b93d5a0\", \"d08ed1d0\",\n\t\t\t\t\"afc725e0\", \"8e3c5b2f\", \"8e7594b7\", \"8ff6e2fb\", \"f2122b64\",\n\t\t\t\t\"8888b812\", \"900df01c\", \"4fad5ea0\", \"688fc31c\", \"d1cff191\",\n\t\t\t\t\"b3a8c1ad\", \"2f2f2218\", \"be0e1777\", \"ea752dfe\", \"8b021fa1\",\n\t\t\t\t\"e5a0cc0f\", \"b56f74e8\", \"18acf3d6\", \"ce89e299\", \"b4a84fe0\",\n\t\t\t\t\"fd13e0b7\", \"7cc43b81\", \"d2ada8d9\", \"165fa266\", \"80957705\",\n\t\t\t\t\"93cc7314\", \"211a1477\", \"e6ad2065\", \"77b5fa86\", \"c75442f5\",\n\t\t\t\t\"fb9d35cf\", \"ebcdaf0c\", \"7b3e89a0\", \"d6411bd3\", \"ae1e7e49\",\n\t\t\t\t\"00250e2d\", \"2071b35e\", \"226800bb\", \"57b8e0af\", \"2464369b\",\n\t\t\t\t\"f009b91e\", \"5563911d\", \"59dfa6aa\", \"78c14389\", \"d95a537f\",\n\t\t\t\t\"207d5ba2\", \"02e5b9c5\", \"83260376\", \"6295cfa9\", \"11c81968\",\n\t\t\t\t\"4e734a41\", \"b3472dca\", \"7b14a94a\", \"1b510052\", \"9a532915\",\n\t\t\t\t\"d60f573f\", \"bc9bc6e4\", \"2b60a476\", \"81e67400\", \"08ba6fb5\",\n\t\t\t\t\"571be91f\", \"f296ec6b\", \"2a0dd915\", \"b6636521\", \"e7b9f9b6\",\n\t\t\t\t\"ff34052e\", \"c5855664\", \"53b02d5d\", \"a99f8fa1\", \"08ba4799\",\n\t\t\t\"6e85076a\" },\n\t\t\t\t\t{ \"4b7a70e9\", \"b5b32944\", \"db75092e\", \"c4192623\", \"ad6ea6b0\",\n\t\t\t\t\"49a7df7d\", \"9cee60b8\", \"8fedb266\", \"ecaa8c71\", \"699a17ff\",\n\t\t\t\t\"5664526c\", \"c2b19ee1\", \"193602a5\", \"75094c29\", \"a0591340\",\n\t\t\t\t\"e4183a3e\", \"3f54989a\", \"5b429d65\", \"6b8fe4d6\", \"99f73fd6\",\n\t\t\t\t\"a1d29c07\", \"efe830f5\", \"4d2d38e6\", \"f0255dc1\", \"4cdd2086\",\n\t\t\t\t\"8470eb26\", \"6382e9c6\", \"021ecc5e\", \"09686b3f\", \"3ebaefc9\",\n\t\t\t\t\"3c971814\", \"6b6a70a1\", \"687f3584\", \"52a0e286\", \"b79c5305\",\n\t\t\t\t\"aa500737\", \"3e07841c\", \"7fdeae5c\", \"8e7d44ec\", \"5716f2b8\",\n\t\t\t\t\"b03ada37\", \"f0500c0d\", \"f01c1f04\", \"0200b3ff\", \"ae0cf51a\",\n\t\t\t\t\"3cb574b2\", \"25837a58\", \"dc0921bd\", \"d19113f9\", \"7ca92ff6\",\n\t\t\t\t\"94324773\", \"22f54701\", \"3ae5e581\", \"37c2dadc\", \"c8b57634\",\n\t\t\t\t\"9af3dda7\", \"a9446146\", \"0fd0030e\", \"ecc8c73e\", \"a4751e41\",\n\t\t\t\t\"e238cd99\", \"3bea0e2f\", \"3280bba1\", \"183eb331\", \"4e548b38\",\n\t\t\t\t\"4f6db908\", \"6f420d03\", \"f60a04bf\", \"2cb81290\", \"24977c79\",\n\t\t\t\t\"5679b072\", \"bcaf89af\", \"de9a771f\", \"d9930810\", \"b38bae12\",\n\t\t\t\t\"dccf3f2e\", \"5512721f\", \"2e6b7124\", \"501adde6\", \"9f84cd87\",\n\t\t\t\t\"7a584718\", \"7408da17\", \"bc9f9abc\", \"e94b7d8c\", \"ec7aec3a\",\n\t\t\t\t\"db851dfa\", \"63094366\", \"c464c3d2\", \"ef1c1847\", \"3215d908\",\n\t\t\t\t\"dd433b37\", \"24c2ba16\", \"12a14d43\", \"2a65c451\", \"50940002\",\n\t\t\t\t\"133ae4dd\", \"71dff89e\", \"10314e55\", \"81ac77d6\", \"5f11199b\",\n\t\t\t\t\"043556f1\", \"d7a3c76b\", \"3c11183b\", \"5924a509\", \"f28fe6ed\",\n\t\t\t\t\"97f1fbfa\", \"9ebabf2c\", \"1e153c6e\", \"86e34570\", \"eae96fb1\",\n\t\t\t\t\"860e5e0a\", \"5a3e2ab3\", \"771fe71c\", \"4e3d06fa\", \"2965dcb9\",\n\t\t\t\t\"99e71d0f\", \"803e89d6\", \"5266c825\", \"2e4cc978\", \"9c10b36a\",\n\t\t\t\t\"c6150eba\", \"94e2ea78\", \"a5fc3c53\", \"1e0a2df4\", \"f2f74ea7\",\n\t\t\t\t\"361d2b3d\", \"1939260f\", \"19c27960\", \"5223a708\", \"f71312b6\",\n\t\t\t\t\"ebadfe6e\", \"eac31f66\", \"e3bc4595\", \"a67bc883\", \"b17f37d1\",\n\t\t\t\t\"018cff28\", \"c332ddef\", \"be6c5aa5\", \"65582185\", \"68ab9802\",\n\t\t\t\t\"eecea50f\", \"db2f953b\", \"2aef7dad\", \"5b6e2f84\", \"1521b628\",\n\t\t\t\t\"29076170\", \"ecdd4775\", \"619f1510\", \"13cca830\", \"eb61bd96\",\n\t\t\t\t\"0334fe1e\", \"aa0363cf\", \"b5735c90\", \"4c70a239\", \"d59e9e0b\",\n\t\t\t\t\"cbaade14\", \"eecc86bc\", \"60622ca7\", \"9cab5cab\", \"b2f3846e\",\n\t\t\t\t\"648b1eaf\", \"19bdf0ca\", \"a02369b9\", \"655abb50\", \"40685a32\",\n\t\t\t\t\"3c2ab4b3\", \"319ee9d5\", \"c021b8f7\", \"9b540b19\", \"875fa099\",\n\t\t\t\t\"95f7997e\", \"623d7da8\", \"f837889a\", \"97e32d77\", \"11ed935f\",\n\t\t\t\t\"16681281\", \"0e358829\", \"c7e61fd6\", \"96dedfa1\", \"7858ba99\",\n\t\t\t\t\"57f584a5\", \"1b227263\", \"9b83c3ff\", \"1ac24696\", \"cdb30aeb\",\n\t\t\t\t\"532e3054\", \"8fd948e4\", \"6dbc3128\", \"58ebf2ef\", \"34c6ffea\",\n\t\t\t\t\"fe28ed61\", \"ee7c3c73\", \"5d4a14d9\", \"e864b7e3\", \"42105d14\",\n\t\t\t\t\"203e13e0\", \"45eee2b6\", \"a3aaabea\", \"db6c4f15\", \"facb4fd0\",\n\t\t\t\t\"c742f442\", \"ef6abbb5\", \"654f3b1d\", \"41cd2105\", \"d81e799e\",\n\t\t\t\t\"86854dc7\", \"e44b476a\", \"3d816250\", \"cf62a1f2\", \"5b8d2646\",\n\t\t\t\t\"fc8883a0\", \"c1c7b6a3\", \"7f1524c3\", \"69cb7492\", \"47848a0b\",\n\t\t\t\t\"5692b285\", \"095bbf00\", \"ad19489d\", \"1462b174\", \"23820e00\",\n\t\t\t\t\"58428d2a\", \"0c55f5ea\", \"1dadf43e\", \"233f7061\", \"3372f092\",\n\t\t\t\t\"8d937e41\", \"d65fecf1\", \"6c223bdb\", \"7cde3759\", \"cbee7460\",\n\t\t\t\t\"4085f2a7\", \"ce77326e\", \"a6078084\", \"19f8509e\", \"e8efd855\",\n\t\t\t\t\"61d99735\", \"a969a7aa\", \"c50c06c2\", \"5a04abfc\", \"800bcadc\",\n\t\t\t\t\"9e447a2e\", \"c3453484\", \"fdd56705\", \"0e1e9ec9\", \"db73dbd3\",\n\t\t\t\t\"105588cd\", \"675fda79\", \"e3674340\", \"c5c43465\", \"713e38d8\",\n\t\t\t\t\"3d28f89e\", \"f16dff20\", \"153e21e7\", \"8fb03d4a\", \"e6e39f2b\",\n\t\t\t\t\t\"db83adf7\" },\n\t\t\t\t\t{ \"e93d5a68\", \"948140f7\", \"f64c261c\", \"94692934\", \"411520f7\",\n\t\t\t\t\t\t\"7602d4f7\", \"bcf46b2e\", \"d4a20068\", \"d4082471\", \"3320f46a\",\n\t\t\t\t\t\t\"43b7d4b7\", \"500061af\", \"1e39f62e\", \"97244546\", \"14214f74\",\n\t\t\t\t\t\t\"bf8b8840\", \"4d95fc1d\", \"96b591af\", \"70f4ddd3\", \"66a02f45\",\n\t\t\t\t\t\t\"bfbc09ec\", \"03bd9785\", \"7fac6dd0\", \"31cb8504\", \"96eb27b3\",\n\t\t\t\t\t\t\"55fd3941\", \"da2547e6\", \"abca0a9a\", \"28507825\", \"530429f4\",\n\t\t\t\t\t\t\"0a2c86da\", \"e9b66dfb\", \"68dc1462\", \"d7486900\", \"680ec0a4\",\n\t\t\t\t\t\t\"27a18dee\", \"4f3ffea2\", \"e887ad8c\", \"b58ce006\", \"7af4d6b6\",\n\t\t\t\t\t\t\"aace1e7c\", \"d3375fec\", \"ce78a399\", \"406b2a42\", \"20fe9e35\",\n\t\t\t\t\t\t\"d9f385b9\", \"ee39d7ab\", \"3b124e8b\", \"1dc9faf7\", \"4b6d1856\",\n\t\t\t\t\t\t\"26a36631\", \"eae397b2\", \"3a6efa74\", \"dd5b4332\", \"6841e7f7\",\n\t\t\t\t\t\t\"ca7820fb\", \"fb0af54e\", \"d8feb397\", \"454056ac\", \"ba489527\",\n\t\t\t\t\t\t\"55533a3a\", \"20838d87\", \"fe6ba9b7\", \"d096954b\", \"55a867bc\",\n\t\t\t\t\t\t\"a1159a58\", \"cca92963\", \"99e1db33\", \"a62a4a56\", \"3f3125f9\",\n\t\t\t\t\t\t\"5ef47e1c\", \"9029317c\", \"fdf8e802\", \"04272f70\", \"80bb155c\",\n\t\t\t\t\t\t\"05282ce3\", \"95c11548\", \"e4c66d22\", \"48c1133f\", \"c70f86dc\",\n\t\t\t\t\t\t\"07f9c9ee\", \"41041f0f\", \"404779a4\", \"5d886e17\", \"325f51eb\",\n\t\t\t\t\t\t\"d59bc0d1\", \"f2bcc18f\", \"41113564\", \"257b7834\", \"602a9c60\",\n\t\t\t\t\t\t\"dff8e8a3\", \"1f636c1b\", \"0e12b4c2\", \"02e1329e\", \"af664fd1\",\n\t\t\t\t\t\t\"cad18115\", \"6b2395e0\", \"333e92e1\", \"3b240b62\", \"eebeb922\",\n\t\t\t\t\t\t\"85b2a20e\", \"e6ba0d99\", \"de720c8c\", \"2da2f728\", \"d0127845\",\n\t\t\t\t\t\t\"95b794fd\", \"647d0862\", \"e7ccf5f0\", \"5449a36f\", \"877d48fa\",\n\t\t\t\t\t\t\"c39dfd27\", \"f33e8d1e\", \"0a476341\", \"992eff74\", \"3a6f6eab\",\n\t\t\t\t\t\t\"f4f8fd37\", \"a812dc60\", \"a1ebddf8\", \"991be14c\", \"db6e6b0d\",\n\t\t\t\t\t\t\"c67b5510\", \"6d672c37\", \"2765d43b\", \"dcd0e804\", \"f1290dc7\",\n\t\t\t\t\t\t\"cc00ffa3\", \"b5390f92\", \"690fed0b\", \"667b9ffb\", \"cedb7d9c\",\n\t\t\t\t\t\t\"a091cf0b\", \"d9155ea3\", \"bb132f88\", \"515bad24\", \"7b9479bf\",\n\t\t\t\t\t\t\"763bd6eb\", \"37392eb3\", \"cc115979\", \"8026e297\", \"f42e312d\",\n\t\t\t\t\t\t\"6842ada7\", \"c66a2b3b\", \"12754ccc\", \"782ef11c\", \"6a124237\",\n\t\t\t\t\t\t\"b79251e7\", \"06a1bbe6\", \"4bfb6350\", \"1a6b1018\", \"11caedfa\",\n\t\t\t\t\t\t\"3d25bdd8\", \"e2e1c3c9\", \"44421659\", \"0a121386\", \"d90cec6e\",\n\t\t\t\t\t\t\"d5abea2a\", \"64af674e\", \"da86a85f\", \"bebfe988\", \"64e4c3fe\",\n\t\t\t\t\t\t\"9dbc8057\", \"f0f7c086\", \"60787bf8\", \"6003604d\", \"d1fd8346\",\n\t\t\t\t\t\t\"f6381fb0\", \"7745ae04\", \"d736fccc\", \"83426b33\", \"f01eab71\",\n\t\t\t\t\t\t\"b0804187\", \"3c005e5f\", \"77a057be\", \"bde8ae24\", \"55464299\",\n\t\t\t\t\t\t\"bf582e61\", \"4e58f48f\", \"f2ddfda2\", \"f474ef38\", \"8789bdc2\",\n\t\t\t\t\t\t\"5366f9c3\", \"c8b38e74\", \"b475f255\", \"46fcd9b9\", \"7aeb2661\",\n\t\t\t\t\t\t\"8b1ddf84\", \"846a0e79\", \"915f95e2\", \"466e598e\", \"20b45770\",\n\t\t\t\t\t\t\"8cd55591\", \"c902de4c\", \"b90bace1\", \"bb8205d0\", \"11a86248\",\n\t\t\t\t\t\t\"7574a99e\", \"b77f19b6\", \"e0a9dc09\", \"662d09a1\", \"c4324633\",\n\t\t\t\t\t\t\"e85a1f02\", \"09f0be8c\", \"4a99a025\", \"1d6efe10\", \"1ab93d1d\",\n\t\t\t\t\t\t\"0ba5a4df\", \"a186f20f\", \"2868f169\", \"dcb7da83\", \"573906fe\",\n\t\t\t\t\t\t\"a1e2ce9b\", \"4fcd7f52\", \"50115e01\", \"a70683fa\", \"a002b5c4\",\n\t\t\t\t\t\t\"0de6d027\", \"9af88c27\", \"773f8641\", \"c3604c06\", \"61a806b5\",\n\t\t\t\t\t\t\"f0177a28\", \"c0f586e0\", \"006058aa\", \"30dc7d62\", \"11e69ed7\",\n\t\t\t\t\t\t\"2338ea63\", \"53c2dd94\", \"c2c21634\", \"bbcbee56\", \"90bcb6de\",\n\t\t\t\t\t\t\"ebfc7da1\", \"ce591d76\", \"6f05e409\", \"4b7c0188\", \"39720a3d\",\n\t\t\t\t\t\t\"7c927c24\", \"86e3725f\", \"724d9db9\", \"1ac15bb4\", \"d39eb8fc\",\n\t\t\t\t\t\t\"ed545578\", \"08fca5b5\", \"d83d7cd3\", \"4dad0fc4\", \"1e50ef5e\",\n\t\t\t\t\t\t\"b161e6f8\", \"a28514d9\", \"6c51133c\", \"6fd5c7e7\", \"56e14ec4\",\n\t\t\t\t\t\t\"362abfce\", \"ddc6c837\", \"d79a3234\", \"92638212\", \"670efa8e\",\n\t\t\t\t\t\"406000e0\" },\n\t\t\t\t\t{ \"3a39ce37\", \"d3faf5cf\", \"abc27737\", \"5ac52d1b\", \"5cb0679e\",\n\t\t\t\t\t\t\"4fa33742\", \"d3822740\", \"99bc9bbe\", \"d5118e9d\", \"bf0f7315\",\n\t\t\t\t\t\t\"d62d1c7e\", \"c700c47b\", \"b78c1b6b\", \"21a19045\", \"b26eb1be\",\n\t\t\t\t\t\t\"6a366eb4\", \"5748ab2f\", \"bc946e79\", \"c6a376d2\", \"6549c2c8\",\n\t\t\t\t\t\t\"530ff8ee\", \"468dde7d\", \"d5730a1d\", \"4cd04dc6\", \"2939bbdb\",\n\t\t\t\t\t\t\"a9ba4650\", \"ac9526e8\", \"be5ee304\", \"a1fad5f0\", \"6a2d519a\",\n\t\t\t\t\t\t\"63ef8ce2\", \"9a86ee22\", \"c089c2b8\", \"43242ef6\", \"a51e03aa\",\n\t\t\t\t\t\t\"9cf2d0a4\", \"83c061ba\", \"9be96a4d\", \"8fe51550\", \"ba645bd6\",\n\t\t\t\t\t\t\"2826a2f9\", \"a73a3ae1\", \"4ba99586\", \"ef5562e9\", \"c72fefd3\",\n\t\t\t\t\t\t\"f752f7da\", \"3f046f69\", \"77fa0a59\", \"80e4a915\", \"87b08601\",\n\t\t\t\t\t\t\"9b09e6ad\", \"3b3ee593\", \"e990fd5a\", \"9e34d797\", \"2cf0b7d9\",\n\t\t\t\t\t\t\"022b8b51\", \"96d5ac3a\", \"017da67d\", \"d1cf3ed6\", \"7c7d2d28\",\n\t\t\t\t\t\t\"1f9f25cf\", \"adf2b89b\", \"5ad6b472\", \"5a88f54c\", \"e029ac71\",\n\t\t\t\t\t\t\"e019a5e6\", \"47b0acfd\", \"ed93fa9b\", \"e8d3c48d\", \"283b57cc\",\n\t\t\t\t\t\t\"f8d56629\", \"79132e28\", \"785f0191\", \"ed756055\", \"f7960e44\",\n\t\t\t\t\t\t\"e3d35e8c\", \"15056dd4\", \"88f46dba\", \"03a16125\", \"0564f0bd\",\n\t\t\t\t\t\t\"c3eb9e15\", \"3c9057a2\", \"97271aec\", \"a93a072a\", \"1b3f6d9b\",\n\t\t\t\t\t\t\"1e6321f5\", \"f59c66fb\", \"26dcf319\", \"7533d928\", \"b155fdf5\",\n\t\t\t\t\t\t\"03563482\", \"8aba3cbb\", \"28517711\", \"c20ad9f8\", \"abcc5167\",\n\t\t\t\t\t\t\"ccad925f\", \"4de81751\", \"3830dc8e\", \"379d5862\", \"9320f991\",\n\t\t\t\t\t\t\"ea7a90c2\", \"fb3e7bce\", \"5121ce64\", \"774fbe32\", \"a8b6e37e\",\n\t\t\t\t\t\t\"c3293d46\", \"48de5369\", \"6413e680\", \"a2ae0810\", \"dd6db224\",\n\t\t\t\t\t\t\"69852dfd\", \"09072166\", \"b39a460a\", \"6445c0dd\", \"586cdecf\",\n\t\t\t\t\t\t\"1c20c8ae\", \"5bbef7dd\", \"1b588d40\", \"ccd2017f\", \"6bb4e3bb\",\n\t\t\t\t\t\t\"dda26a7e\", \"3a59ff45\", \"3e350a44\", \"bcb4cdd5\", \"72eacea8\",\n\t\t\t\t\t\t\"fa6484bb\", \"8d6612ae\", \"bf3c6f47\", \"d29be463\", \"542f5d9e\",\n\t\t\t\t\t\t\"aec2771b\", \"f64e6370\", \"740e0d8d\", \"e75b1357\", \"f8721671\",\n\t\t\t\t\t\t\"af537d5d\", \"4040cb08\", \"4eb4e2cc\", \"34d2466a\", \"0115af84\",\n\t\t\t\t\t\t\"e1b00428\", \"95983a1d\", \"06b89fb4\", \"ce6ea048\", \"6f3f3b82\",\n\t\t\t\t\t\t\"3520ab82\", \"011a1d4b\", \"277227f8\", \"611560b1\", \"e7933fdc\",\n\t\t\t\t\t\t\"bb3a792b\", \"344525bd\", \"a08839e1\", \"51ce794b\", \"2f32c9b7\",\n\t\t\t\t\t\t\"a01fbac9\", \"e01cc87e\", \"bcc7d1f6\", \"cf0111c3\", \"a1e8aac7\",\n\t\t\t\t\t\t\"1a908749\", \"d44fbd9a\", \"d0dadecb\", \"d50ada38\", \"0339c32a\",\n\t\t\t\t\t\t\"c6913667\", \"8df9317c\", \"e0b12b4f\", \"f79e59b7\", \"43f5bb3a\",\n\t\t\t\t\t\t\"f2d519ff\", \"27d9459c\", \"bf97222c\", \"15e6fc2a\", \"0f91fc71\",\n\t\t\t\t\t\t\"9b941525\", \"fae59361\", \"ceb69ceb\", \"c2a86459\", \"12baa8d1\",\n\t\t\t\t\t\t\"b6c1075e\", \"e3056a0c\", \"10d25065\", \"cb03a442\", \"e0ec6e0e\",\n\t\t\t\t\t\t\"1698db3b\", \"4c98a0be\", \"3278e964\", \"9f1f9532\", \"e0d392df\",\n\t\t\t\t\t\t\"d3a0342b\", \"8971f21e\", \"1b0a7441\", \"4ba3348c\", \"c5be7120\",\n\t\t\t\t\t\t\"c37632d8\", \"df359f8d\", \"9b992f2e\", \"e60b6f47\", \"0fe3f11d\",\n\t\t\t\t\t\t\"e54cda54\", \"1edad891\", \"ce6279cf\", \"cd3e7e6f\", \"1618b166\",\n\t\t\t\t\t\t\"fd2c1d05\", \"848fd2c5\", \"f6fb2299\", \"f523f357\", \"a6327623\",\n\t\t\t\t\t\t\"93a83531\", \"56cccd02\", \"acf08162\", \"5a75ebb5\", \"6e163697\",\n\t\t\t\t\t\t\"88d273cc\", \"de966292\", \"81b949d0\", \"4c50901b\", \"71c65614\",\n\t\t\t\t\t\t\"e6c6c7bd\", \"327a140a\", \"45e1d006\", \"c3f27b9a\", \"c9aa53fd\",\n\t\t\t\t\t\t\"62a80f00\", \"bb25bfe2\", \"35bdd2f6\", \"71126905\", \"b2040222\",\n\t\t\t\t\t\t\"b6cbcf7c\", \"cd769c2b\", \"53113ec0\", \"1640e3d3\", \"38abbd60\",\n\t\t\t\t\t\t\"2547adf0\", \"ba38209c\", \"f746ce76\", \"77afa1c5\", \"20756060\",\n\t\t\t\t\t\t\"85cbfe4e\", \"8ae88dd8\", \"7aaaf9b0\", \"4cf9aa7e\", \"1948c25c\",\n\t\t\t\t\t\t\"02fb8a8c\", \"01c36ae4\", \"d6ebe1f9\", \"90d4f869\", \"a65cdea0\",\n\t\t\t\t\t\t\"3f09252d\", \"c208e69f\", \"b74e6132\", \"ce77e25b\", \"578fdfe3\",\n\t\t\t\t\t\"3ac372e6\" } };\n\n\t//Initializing subkeys with digits of pi\n\tString P[] = { \"243f6a88\", \"85a308d3\", \"13198a2e\", \"03707344\", \"a4093822\",\n\t\t\t\"299f31d0\", \"082efa98\", \"ec4e6c89\", \"452821e6\", \"38d01377\",\n\t\t\t\"be5466cf\", \"34e90c6c\", \"c0ac29b7\", \"c97c50dd\", \"3f84d5b5\",\n\t\t\t\"b5470917\", \"9216d5d9\", \"8979fb1b\" };\n\n\t//Initializing modVal to 2^32\n\tlong modVal = 4294967296L;\n\t\n\n    /**\n     * This method returns binary representation of the hexadecimal number passed as parameter\n     *\n     * @param hex Number for which binary representation is required\n     * @return String object which is a binary representation of the hex number passed as parameter\n     */\n\tprivate String hexToBin(String hex)\n\t{\n\t\tString binary = \"\";\n\t\tLong num;\n\t\tString binary4B;\n\t\tint n = hex.length();\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tnum = Long.parseUnsignedLong(\n\t\t\t\t\thex.charAt(i) + \"\", 16);\n\t\t\tbinary4B = Long.toBinaryString(num);\n\n\t\t\tbinary4B = \"0000\" + binary4B;\n\n\t\t\tbinary4B = binary4B.substring(binary4B.length() - 4);\n\t\t\tbinary += binary4B;\n\t\t}\n\t\treturn binary;\n\t}\n\n    /**\n     * This method returns hexadecimal representation of the binary number passed as parameter\n     *\n     * @param binary Number for which hexadecimal representation is required\n     * @return String object which is a hexadecimal representation of the binary number passed as parameter\n     */\n\tprivate String binToHex(String binary)\n\t{\n\n\t\tlong num = Long.parseUnsignedLong(binary, 2);\n\t\tString hex = Long.toHexString(num);\n\t\twhile (hex.length() < (binary.length() / 4))\n\t\t\thex = \"0\" + hex;\n\n\t\treturn hex;\n\t}\n\n    /**\n     * This method returns a string obtained by XOR-ing two strings of same length passed a method parameters\n     *      \n     * @param String a and b are string objects which will be XORed and are to be of same length\n     * @return String object obtained by XOR operation on String a and String b\n     * */\n\tprivate String xor(String a, String b)\n\t{\n\t\ta = hexToBin(a);\n\t\tb = hexToBin(b);\n\t\tString ans = \"\";\n\t\tfor (int i = 0; i < a.length(); i++)\n\t\t\tans += (char)(((a.charAt(i) - '0')\n\t\t\t\t\t^ (b.charAt(i) - '0'))\n\t\t\t\t\t+ '0');\n\t\tans = binToHex(ans);\n\t\treturn ans;\n\t}\n\n    /**\n     * This method returns addition of two hexadecimal numbers passed as parameters and moded with 2^32 \n     *\n     * @param String a and b are hexadecimal numbers\n     * @return String object which is a is addition that is then moded with 2^32 of hex numbers passed as parameters\n     */\n\tprivate String addBin(String a, String b)\n\t{\n\t\tString ans = \"\";\n\t\tlong n1 = Long.parseUnsignedLong(a, 16);\n\t\tlong n2 = Long.parseUnsignedLong(b, 16);\n\t\tn1 = (n1 + n2) % modVal;\n\t\tans = Long.toHexString(n1);\n\t\tans = \"00000000\" + ans;\n\t\treturn ans.substring(ans.length() - 8);\n\t}\n\n\t/*F-function splits the 32-bit input into four 8-bit quarters \n\t and uses the quarters as input to the S-boxes. \n\t The S-boxes accept 8-bit input and produce 32-bit output. \n\t The outputs are added modulo 232 and XORed to produce the final 32-bit output \n\t*/\n\tprivate String f(String plainText)\n\t{\n\t\tString a[] = new String[4];\n\t\tString ans = \"\";\n\t\tfor (int i = 0; i < 8; i += 2) {\n\t\t\t//column number for S-box is a 8-bit value\n\t\t\tlong col\n\t\t\t= Long.parseUnsignedLong(\n\t\t\t\t\thexToBin(\n\t\t\t\t\t\t\tplainText\n\t\t\t\t\t\t\t.substring(i, i + 2)),\n\t\t\t\t\t2);\n\t\t\ta[i / 2] = S[i / 2][(int)col];\n\t\t}\n\t\tans = addBin(a[0], a[1]);\n\t\tans = xor(ans, a[2]);\n\t\tans = addBin(ans, a[3]);\n\t\treturn ans;\n\t}\n\n\t//generate subkeys\n\tprivate void keyGenerate(String key)\n\t{\n\t\tint j = 0;\n\t\tfor (int i = 0; i < P.length; i++) {\n\n\t\t\t//XOR-ing 32-bit parts of the key with initial subkeys\n\t\t\tP[i] = xor(P[i], key.substring(j, j + 8));\n\n\t\t\tj = (j + 8) % key.length();\n\t\t}\n\t}\n\n\t//round function\n\tprivate String round(int time, String plainText)\n\t{\n\t\tString left, right;\n\t\tleft = plainText.substring(0, 8);\n\t\tright = plainText.substring(8, 16);\n\t\tleft = xor(left, P[time]);\n\n\t\t//output from F function\n\t\tString fOut = f(left);\n\n\t\tright = xor(fOut, right);\n\n\t\t//swap left and right\n\t\treturn right + left;\n\t}\n\n    /**\n     * This method returns cipher text for the plaintext passed as the first parameter generated\n     * using the key passed as the second parameter\n     *\n     * @param String plainText is the text which is to be encrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String cipherText is the encrypted value\n     */\n\tString encrypt(String plainText, String key)\n\t{\n\t\t//generating key\n\t\tkeyGenerate(key);\n\t\t\n\t\tfor (int i = 0; i < 16; i++)\n\t\t\tplainText = round(i, plainText);\n\n\t\t//postprocessing\n\t\tString right = plainText.substring(0, 8);\n\t\tString left = plainText.substring(8, 16);\n\t\tright = xor(right, P[16]);\n\t\tleft = xor(left, P[17]);\n\t\treturn left + right;\n\t}\n\t\n    /**\n     * This method returns plaintext for the ciphertext passed as the first parameter decoded\n     * using the key passed as the second parameter\n     *\n     * @param String ciphertext is the text which is to be decrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String plainText is the decrypted text\n     */\n    String decrypt(String cipherText,String key)\n    {\n    \t//generating key\n    \tkeyGenerate(key);\n    \t\n        for (int i = 17; i > 1; i--)\n            cipherText = round(i, cipherText);\n \n        //postprocessing\n        String right = cipherText.substring(0, 8);\n        String left = cipherText.substring(8, 16);\n        right = xor(right, P[1]);\n        left = xor(left, P[0]);\n        return left + right;\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/*\n * Java program for Blowfish Algorithm\n * Wikipedia: https://en.wikipedia.org/wiki/Blowfish_(cipher)\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class Blowfish {\n\n    //Initializing substitution boxes\n    String S[][] = {\n        {\n            \"d1310ba6\",\n            \"98dfb5ac\",\n            \"2ffd72db\",\n            \"d01adfb7\",\n            \"b8e1afed\",\n            \"6a267e96\",\n            \"ba7c9045\",\n            \"f12c7f99\",\n            \"24a19947\",\n            \"b3916cf7\",\n            \"0801f2e2\",\n            \"858efc16\",\n            \"636920d8\",\n            \"71574e69\",\n            \"a458fea3\",\n            \"f4933d7e\",\n            \"0d95748f\",\n            \"728eb658\",\n            \"718bcd58\",\n            \"82154aee\",\n            \"7b54a41d\",\n            \"c25a59b5\",\n            \"9c30d539\",\n            \"2af26013\",\n            \"c5d1b023\",\n            \"286085f0\",\n            \"ca417918\",\n            \"b8db38ef\",\n            \"8e79dcb0\",\n            \"603a180e\",\n            \"6c9e0e8b\",\n            \"b01e8a3e\",\n            \"d71577c1\",\n            \"bd314b27\",\n            \"78af2fda\",\n            \"55605c60\",\n            \"e65525f3\",\n            \"aa55ab94\",\n            \"57489862\",\n            \"63e81440\",\n            \"55ca396a\",\n            \"2aab10b6\",\n            \"b4cc5c34\",\n            \"1141e8ce\",\n            \"a15486af\",\n            \"7c72e993\",\n            \"b3ee1411\",\n            \"636fbc2a\",\n            \"2ba9c55d\",\n            \"741831f6\",\n            \"ce5c3e16\",\n            \"9b87931e\",\n            \"afd6ba33\",\n            \"6c24cf5c\",\n            \"7a325381\",\n            \"28958677\",\n            \"3b8f4898\",\n            \"6b4bb9af\",\n            \"c4bfe81b\",\n            \"66282193\",\n            \"61d809cc\",\n            \"fb21a991\",\n            \"487cac60\",\n            \"5dec8032\",\n            \"ef845d5d\",\n            \"e98575b1\",\n            \"dc262302\",\n            \"eb651b88\",\n            \"23893e81\",\n            \"d396acc5\",\n            \"0f6d6ff3\",\n            \"83f44239\",\n            \"2e0b4482\",\n            \"a4842004\",\n            \"69c8f04a\",\n            \"9e1f9b5e\",\n            \"21c66842\",\n            \"f6e96c9a\",\n            \"670c9c61\",\n            \"abd388f0\",\n            \"6a51a0d2\",\n            \"d8542f68\",\n            \"960fa728\",\n            \"ab5133a3\",\n            \"6eef0b6c\",\n            \"137a3be4\",\n            \"ba3bf050\",\n            \"7efb2a98\",\n            \"a1f1651d\",\n            \"39af0176\",\n            \"66ca593e\",\n            \"82430e88\",\n            \"8cee8619\",\n            \"456f9fb4\",\n            \"7d84a5c3\",\n            \"3b8b5ebe\",\n            \"e06f75d8\",\n            \"85c12073\",\n            \"401a449f\",\n            \"56c16aa6\",\n            \"4ed3aa62\",\n            \"363f7706\",\n            \"1bfedf72\",\n            \"429b023d\",\n            \"37d0d724\",\n            \"d00a1248\",\n            \"db0fead3\",\n            \"49f1c09b\",\n            \"075372c9\",\n            \"80991b7b\",\n            \"25d479d8\",\n            \"f6e8def7\",\n            \"e3fe501a\",\n            \"b6794c3b\",\n            \"976ce0bd\",\n            \"04c006ba\",\n            \"c1a94fb6\",\n            \"409f60c4\",\n            \"5e5c9ec2\",\n            \"196a2463\",\n            \"68fb6faf\",\n            \"3e6c53b5\",\n            \"1339b2eb\",\n            \"3b52ec6f\",\n            \"6dfc511f\",\n            \"9b30952c\",\n            \"cc814544\",\n            \"af5ebd09\",\n            \"bee3d004\",\n            \"de334afd\",\n            \"660f2807\",\n            \"192e4bb3\",\n            \"c0cba857\",\n            \"45c8740f\",\n            \"d20b5f39\",\n            \"b9d3fbdb\",\n            \"5579c0bd\",\n            \"1a60320a\",\n            \"d6a100c6\",\n            \"402c7279\",\n            \"679f25fe\",\n            \"fb1fa3cc\",\n            \"8ea5e9f8\",\n            \"db3222f8\",\n            \"3c7516df\",\n            \"fd616b15\",\n            \"2f501ec8\",\n            \"ad0552ab\",\n            \"323db5fa\",\n            \"fd238760\",\n            \"53317b48\",\n            \"3e00df82\",\n            \"9e5c57bb\",\n            \"ca6f8ca0\",\n            \"1a87562e\",\n            \"df1769db\",\n            \"d542a8f6\",\n            \"287effc3\",\n            \"ac6732c6\",\n            \"8c4f5573\",\n            \"695b27b0\",\n            \"bbca58c8\",\n            \"e1ffa35d\",\n            \"b8f011a0\",\n            \"10fa3d98\",\n            \"fd2183b8\",\n            \"4afcb56c\",\n            \"2dd1d35b\",\n            \"9a53e479\",\n            \"b6f84565\",\n            \"d28e49bc\",\n            \"4bfb9790\",\n            \"e1ddf2da\",\n            \"a4cb7e33\",\n            \"62fb1341\",\n            \"cee4c6e8\",\n            \"ef20cada\",\n            \"36774c01\",\n            \"d07e9efe\",\n            \"2bf11fb4\",\n            \"95dbda4d\",\n            \"ae909198\",\n            \"eaad8e71\",\n            \"6b93d5a0\",\n            \"d08ed1d0\",\n            \"afc725e0\",\n            \"8e3c5b2f\",\n            \"8e7594b7\",\n            \"8ff6e2fb\",\n            \"f2122b64\",\n            \"8888b812\",\n            \"900df01c\",\n            \"4fad5ea0\",\n            \"688fc31c\",\n            \"d1cff191\",\n            \"b3a8c1ad\",\n            \"2f2f2218\",\n            \"be0e1777\",\n            \"ea752dfe\",\n            \"8b021fa1\",\n            \"e5a0cc0f\",\n            \"b56f74e8\",\n            \"18acf3d6\",\n            \"ce89e299\",\n            \"b4a84fe0\",\n            \"fd13e0b7\",\n            \"7cc43b81\",\n            \"d2ada8d9\",\n            \"165fa266\",\n            \"80957705\",\n            \"93cc7314\",\n            \"211a1477\",\n            \"e6ad2065\",\n            \"77b5fa86\",\n            \"c75442f5\",\n            \"fb9d35cf\",\n            \"ebcdaf0c\",\n            \"7b3e89a0\",\n            \"d6411bd3\",\n            \"ae1e7e49\",\n            \"00250e2d\",\n            \"2071b35e\",\n            \"226800bb\",\n            \"57b8e0af\",\n            \"2464369b\",\n            \"f009b91e\",\n            \"5563911d\",\n            \"59dfa6aa\",\n            \"78c14389\",\n            \"d95a537f\",\n            \"207d5ba2\",\n            \"02e5b9c5\",\n            \"83260376\",\n            \"6295cfa9\",\n            \"11c81968\",\n            \"4e734a41\",\n            \"b3472dca\",\n            \"7b14a94a\",\n            \"1b510052\",\n            \"9a532915\",\n            \"d60f573f\",\n            \"bc9bc6e4\",\n            \"2b60a476\",\n            \"81e67400\",\n            \"08ba6fb5\",\n            \"571be91f\",\n            \"f296ec6b\",\n            \"2a0dd915\",\n            \"b6636521\",\n            \"e7b9f9b6\",\n            \"ff34052e\",\n            \"c5855664\",\n            \"53b02d5d\",\n            \"a99f8fa1\",\n            \"08ba4799\",\n            \"6e85076a\",\n        },\n        {\n            \"4b7a70e9\",\n            \"b5b32944\",\n            \"db75092e\",\n            \"c4192623\",\n            \"ad6ea6b0\",\n            \"49a7df7d\",\n            \"9cee60b8\",\n            \"8fedb266\",\n            \"ecaa8c71\",\n            \"699a17ff\",\n            \"5664526c\",\n            \"c2b19ee1\",\n            \"193602a5\",\n            \"75094c29\",\n            \"a0591340\",\n            \"e4183a3e\",\n            \"3f54989a\",\n            \"5b429d65\",\n            \"6b8fe4d6\",\n            \"99f73fd6\",\n            \"a1d29c07\",\n            \"efe830f5\",\n            \"4d2d38e6\",\n            \"f0255dc1\",\n            \"4cdd2086\",\n            \"8470eb26\",\n            \"6382e9c6\",\n            \"021ecc5e\",\n            \"09686b3f\",\n            \"3ebaefc9\",\n            \"3c971814\",\n            \"6b6a70a1\",\n            \"687f3584\",\n            \"52a0e286\",\n            \"b79c5305\",\n            \"aa500737\",\n            \"3e07841c\",\n            \"7fdeae5c\",\n            \"8e7d44ec\",\n            \"5716f2b8\",\n            \"b03ada37\",\n            \"f0500c0d\",\n            \"f01c1f04\",\n            \"0200b3ff\",\n            \"ae0cf51a\",\n            \"3cb574b2\",\n            \"25837a58\",\n            \"dc0921bd\",\n            \"d19113f9\",\n            \"7ca92ff6\",\n            \"94324773\",\n            \"22f54701\",\n            \"3ae5e581\",\n            \"37c2dadc\",\n            \"c8b57634\",\n            \"9af3dda7\",\n            \"a9446146\",\n            \"0fd0030e\",\n            \"ecc8c73e\",\n            \"a4751e41\",\n            \"e238cd99\",\n            \"3bea0e2f\",\n            \"3280bba1\",\n            \"183eb331\",\n            \"4e548b38\",\n            \"4f6db908\",\n            \"6f420d03\",\n            \"f60a04bf\",\n            \"2cb81290\",\n            \"24977c79\",\n            \"5679b072\",\n            \"bcaf89af\",\n            \"de9a771f\",\n            \"d9930810\",\n            \"b38bae12\",\n            \"dccf3f2e\",\n            \"5512721f\",\n            \"2e6b7124\",\n            \"501adde6\",\n            \"9f84cd87\",\n            \"7a584718\",\n            \"7408da17\",\n            \"bc9f9abc\",\n            \"e94b7d8c\",\n            \"ec7aec3a\",\n            \"db851dfa\",\n            \"63094366\",\n            \"c464c3d2\",\n            \"ef1c1847\",\n            \"3215d908\",\n            \"dd433b37\",\n            \"24c2ba16\",\n            \"12a14d43\",\n            \"2a65c451\",\n            \"50940002\",\n            \"133ae4dd\",\n            \"71dff89e\",\n            \"10314e55\",\n            \"81ac77d6\",\n            \"5f11199b\",\n            \"043556f1\",\n            \"d7a3c76b\",\n            \"3c11183b\",\n            \"5924a509\",\n            \"f28fe6ed\",\n            \"97f1fbfa\",\n            \"9ebabf2c\",\n            \"1e153c6e\",\n            \"86e34570\",\n            \"eae96fb1\",\n            \"860e5e0a\",\n            \"5a3e2ab3\",\n            \"771fe71c\",\n            \"4e3d06fa\",\n            \"2965dcb9\",\n            \"99e71d0f\",\n            \"803e89d6\",\n            \"5266c825\",\n            \"2e4cc978\",\n            \"9c10b36a\",\n            \"c6150eba\",\n            \"94e2ea78\",\n            \"a5fc3c53\",\n            \"1e0a2df4\",\n            \"f2f74ea7\",\n            \"361d2b3d\",\n            \"1939260f\",\n            \"19c27960\",\n            \"5223a708\",\n            \"f71312b6\",\n            \"ebadfe6e\",\n            \"eac31f66\",\n            \"e3bc4595\",\n            \"a67bc883\",\n            \"b17f37d1\",\n            \"018cff28\",\n            \"c332ddef\",\n            \"be6c5aa5\",\n            \"65582185\",\n            \"68ab9802\",\n            \"eecea50f\",\n            \"db2f953b\",\n            \"2aef7dad\",\n            \"5b6e2f84\",\n            \"1521b628\",\n            \"29076170\",\n            \"ecdd4775\",\n            \"619f1510\",\n            \"13cca830\",\n            \"eb61bd96\",\n            \"0334fe1e\",\n            \"aa0363cf\",\n            \"b5735c90\",\n            \"4c70a239\",\n            \"d59e9e0b\",\n            \"cbaade14\",\n            \"eecc86bc\",\n            \"60622ca7\",\n            \"9cab5cab\",\n            \"b2f3846e\",\n            \"648b1eaf\",\n            \"19bdf0ca\",\n            \"a02369b9\",\n            \"655abb50\",\n            \"40685a32\",\n            \"3c2ab4b3\",\n            \"319ee9d5\",\n            \"c021b8f7\",\n            \"9b540b19\",\n            \"875fa099\",\n            \"95f7997e\",\n            \"623d7da8\",\n            \"f837889a\",\n            \"97e32d77\",\n            \"11ed935f\",\n            \"16681281\",\n            \"0e358829\",\n            \"c7e61fd6\",\n            \"96dedfa1\",\n            \"7858ba99\",\n            \"57f584a5\",\n            \"1b227263\",\n            \"9b83c3ff\",\n            \"1ac24696\",\n            \"cdb30aeb\",\n            \"532e3054\",\n            \"8fd948e4\",\n            \"6dbc3128\",\n            \"58ebf2ef\",\n            \"34c6ffea\",\n            \"fe28ed61\",\n            \"ee7c3c73\",\n            \"5d4a14d9\",\n            \"e864b7e3\",\n            \"42105d14\",\n            \"203e13e0\",\n            \"45eee2b6\",\n            \"a3aaabea\",\n            \"db6c4f15\",\n            \"facb4fd0\",\n            \"c742f442\",\n            \"ef6abbb5\",\n            \"654f3b1d\",\n            \"41cd2105\",\n            \"d81e799e\",\n            \"86854dc7\",\n            \"e44b476a\",\n            \"3d816250\",\n            \"cf62a1f2\",\n            \"5b8d2646\",\n            \"fc8883a0\",\n            \"c1c7b6a3\",\n            \"7f1524c3\",\n            \"69cb7492\",\n            \"47848a0b\",\n            \"5692b285\",\n            \"095bbf00\",\n            \"ad19489d\",\n            \"1462b174\",\n            \"23820e00\",\n            \"58428d2a\",\n            \"0c55f5ea\",\n            \"1dadf43e\",\n            \"233f7061\",\n            \"3372f092\",\n            \"8d937e41\",\n            \"d65fecf1\",\n            \"6c223bdb\",\n            \"7cde3759\",\n            \"cbee7460\",\n            \"4085f2a7\",\n            \"ce77326e\",\n            \"a6078084\",\n            \"19f8509e\",\n            \"e8efd855\",\n            \"61d99735\",\n            \"a969a7aa\",\n            \"c50c06c2\",\n            \"5a04abfc\",\n            \"800bcadc\",\n            \"9e447a2e\",\n            \"c3453484\",\n            \"fdd56705\",\n            \"0e1e9ec9\",\n            \"db73dbd3\",\n            \"105588cd\",\n            \"675fda79\",\n            \"e3674340\",\n            \"c5c43465\",\n            \"713e38d8\",\n            \"3d28f89e\",\n            \"f16dff20\",\n            \"153e21e7\",\n            \"8fb03d4a\",\n            \"e6e39f2b\",\n            \"db83adf7\",\n        },\n        {\n            \"e93d5a68\",\n            \"948140f7\",\n            \"f64c261c\",\n            \"94692934\",\n            \"411520f7\",\n            \"7602d4f7\",\n            \"bcf46b2e\",\n            \"d4a20068\",\n            \"d4082471\",\n            \"3320f46a\",\n            \"43b7d4b7\",\n            \"500061af\",\n            \"1e39f62e\",\n            \"97244546\",\n            \"14214f74\",\n            \"bf8b8840\",\n            \"4d95fc1d\",\n            \"96b591af\",\n            \"70f4ddd3\",\n            \"66a02f45\",\n            \"bfbc09ec\",\n            \"03bd9785\",\n            \"7fac6dd0\",\n            \"31cb8504\",\n            \"96eb27b3\",\n            \"55fd3941\",\n            \"da2547e6\",\n            \"abca0a9a\",\n            \"28507825\",\n            \"530429f4\",\n            \"0a2c86da\",\n            \"e9b66dfb\",\n            \"68dc1462\",\n            \"d7486900\",\n            \"680ec0a4\",\n            \"27a18dee\",\n            \"4f3ffea2\",\n            \"e887ad8c\",\n            \"b58ce006\",\n            \"7af4d6b6\",\n            \"aace1e7c\",\n            \"d3375fec\",\n            \"ce78a399\",\n            \"406b2a42\",\n            \"20fe9e35\",\n            \"d9f385b9\",\n            \"ee39d7ab\",\n            \"3b124e8b\",\n            \"1dc9faf7\",\n            \"4b6d1856\",\n            \"26a36631\",\n            \"eae397b2\",\n            \"3a6efa74\",\n            \"dd5b4332\",\n            \"6841e7f7\",\n            \"ca7820fb\",\n            \"fb0af54e\",\n            \"d8feb397\",\n            \"454056ac\",\n            \"ba489527\",\n            \"55533a3a\",\n            \"20838d87\",\n            \"fe6ba9b7\",\n            \"d096954b\",\n            \"55a867bc\",\n            \"a1159a58\",\n            \"cca92963\",\n            \"99e1db33\",\n            \"a62a4a56\",\n            \"3f3125f9\",\n            \"5ef47e1c\",\n            \"9029317c\",\n            \"fdf8e802\",\n            \"04272f70\",\n            \"80bb155c\",\n            \"05282ce3\",\n            \"95c11548\",\n            \"e4c66d22\",\n            \"48c1133f\",\n            \"c70f86dc\",\n            \"07f9c9ee\",\n            \"41041f0f\",\n            \"404779a4\",\n            \"5d886e17\",\n            \"325f51eb\",\n            \"d59bc0d1\",\n            \"f2bcc18f\",\n            \"41113564\",\n            \"257b7834\",\n            \"602a9c60\",\n            \"dff8e8a3\",\n            \"1f636c1b\",\n            \"0e12b4c2\",\n            \"02e1329e\",\n            \"af664fd1\",\n            \"cad18115\",\n            \"6b2395e0\",\n            \"333e92e1\",\n            \"3b240b62\",\n            \"eebeb922\",\n            \"85b2a20e\",\n            \"e6ba0d99\",\n            \"de720c8c\",\n            \"2da2f728\",\n            \"d0127845\",\n            \"95b794fd\",\n            \"647d0862\",\n            \"e7ccf5f0\",\n            \"5449a36f\",\n            \"877d48fa\",\n            \"c39dfd27\",\n            \"f33e8d1e\",\n            \"0a476341\",\n            \"992eff74\",\n            \"3a6f6eab\",\n            \"f4f8fd37\",\n            \"a812dc60\",\n            \"a1ebddf8\",\n            \"991be14c\",\n            \"db6e6b0d\",\n            \"c67b5510\",\n            \"6d672c37\",\n            \"2765d43b\",\n            \"dcd0e804\",\n            \"f1290dc7\",\n            \"cc00ffa3\",\n            \"b5390f92\",\n            \"690fed0b\",\n            \"667b9ffb\",\n            \"cedb7d9c\",\n            \"a091cf0b\",\n            \"d9155ea3\",\n            \"bb132f88\",\n            \"515bad24\",\n            \"7b9479bf\",\n            \"763bd6eb\",\n            \"37392eb3\",\n            \"cc115979\",\n            \"8026e297\",\n            \"f42e312d\",\n            \"6842ada7\",\n            \"c66a2b3b\",\n            \"12754ccc\",\n            \"782ef11c\",\n            \"6a124237\",\n            \"b79251e7\",\n            \"06a1bbe6\",\n            \"4bfb6350\",\n            \"1a6b1018\",\n            \"11caedfa\",\n            \"3d25bdd8\",\n            \"e2e1c3c9\",\n            \"44421659\",\n            \"0a121386\",\n            \"d90cec6e\",\n            \"d5abea2a\",\n            \"64af674e\",\n            \"da86a85f\",\n            \"bebfe988\",\n            \"64e4c3fe\",\n            \"9dbc8057\",\n            \"f0f7c086\",\n            \"60787bf8\",\n            \"6003604d\",\n            \"d1fd8346\",\n            \"f6381fb0\",\n            \"7745ae04\",\n            \"d736fccc\",\n            \"83426b33\",\n            \"f01eab71\",\n            \"b0804187\",\n            \"3c005e5f\",\n            \"77a057be\",\n            \"bde8ae24\",\n            \"55464299\",\n            \"bf582e61\",\n            \"4e58f48f\",\n            \"f2ddfda2\",\n            \"f474ef38\",\n            \"8789bdc2\",\n            \"5366f9c3\",\n            \"c8b38e74\",\n            \"b475f255\",\n            \"46fcd9b9\",\n            \"7aeb2661\",\n            \"8b1ddf84\",\n            \"846a0e79\",\n            \"915f95e2\",\n            \"466e598e\",\n            \"20b45770\",\n            \"8cd55591\",\n            \"c902de4c\",\n            \"b90bace1\",\n            \"bb8205d0\",\n            \"11a86248\",\n            \"7574a99e\",\n            \"b77f19b6\",\n            \"e0a9dc09\",\n            \"662d09a1\",\n            \"c4324633\",\n            \"e85a1f02\",\n            \"09f0be8c\",\n            \"4a99a025\",\n            \"1d6efe10\",\n            \"1ab93d1d\",\n            \"0ba5a4df\",\n            \"a186f20f\",\n            \"2868f169\",\n            \"dcb7da83\",\n            \"573906fe\",\n            \"a1e2ce9b\",\n            \"4fcd7f52\",\n            \"50115e01\",\n            \"a70683fa\",\n            \"a002b5c4\",\n            \"0de6d027\",\n            \"9af88c27\",\n            \"773f8641\",\n            \"c3604c06\",\n            \"61a806b5\",\n            \"f0177a28\",\n            \"c0f586e0\",\n            \"006058aa\",\n            \"30dc7d62\",\n            \"11e69ed7\",\n            \"2338ea63\",\n            \"53c2dd94\",\n            \"c2c21634\",\n            \"bbcbee56\",\n            \"90bcb6de\",\n            \"ebfc7da1\",\n            \"ce591d76\",\n            \"6f05e409\",\n            \"4b7c0188\",\n            \"39720a3d\",\n            \"7c927c24\",\n            \"86e3725f\",\n            \"724d9db9\",\n            \"1ac15bb4\",\n            \"d39eb8fc\",\n            \"ed545578\",\n            \"08fca5b5\",\n            \"d83d7cd3\",\n            \"4dad0fc4\",\n            \"1e50ef5e\",\n            \"b161e6f8\",\n            \"a28514d9\",\n            \"6c51133c\",\n            \"6fd5c7e7\",\n            \"56e14ec4\",\n            \"362abfce\",\n            \"ddc6c837\",\n            \"d79a3234\",\n            \"92638212\",\n            \"670efa8e\",\n            \"406000e0\",\n        },\n        {\n            \"3a39ce37\",\n            \"d3faf5cf\",\n            \"abc27737\",\n            \"5ac52d1b\",\n            \"5cb0679e\",\n            \"4fa33742\",\n            \"d3822740\",\n            \"99bc9bbe\",\n            \"d5118e9d\",\n            \"bf0f7315\",\n            \"d62d1c7e\",\n            \"c700c47b\",\n            \"b78c1b6b\",\n            \"21a19045\",\n            \"b26eb1be\",\n            \"6a366eb4\",\n            \"5748ab2f\",\n            \"bc946e79\",\n            \"c6a376d2\",\n            \"6549c2c8\",\n            \"530ff8ee\",\n            \"468dde7d\",\n            \"d5730a1d\",\n            \"4cd04dc6\",\n            \"2939bbdb\",\n            \"a9ba4650\",\n            \"ac9526e8\",\n            \"be5ee304\",\n            \"a1fad5f0\",\n            \"6a2d519a\",\n            \"63ef8ce2\",\n            \"9a86ee22\",\n            \"c089c2b8\",\n            \"43242ef6\",\n            \"a51e03aa\",\n            \"9cf2d0a4\",\n            \"83c061ba\",\n            \"9be96a4d\",\n            \"8fe51550\",\n            \"ba645bd6\",\n            \"2826a2f9\",\n            \"a73a3ae1\",\n            \"4ba99586\",\n            \"ef5562e9\",\n            \"c72fefd3\",\n            \"f752f7da\",\n            \"3f046f69\",\n            \"77fa0a59\",\n            \"80e4a915\",\n            \"87b08601\",\n            \"9b09e6ad\",\n            \"3b3ee593\",\n            \"e990fd5a\",\n            \"9e34d797\",\n            \"2cf0b7d9\",\n            \"022b8b51\",\n            \"96d5ac3a\",\n            \"017da67d\",\n            \"d1cf3ed6\",\n            \"7c7d2d28\",\n            \"1f9f25cf\",\n            \"adf2b89b\",\n            \"5ad6b472\",\n            \"5a88f54c\",\n            \"e029ac71\",\n            \"e019a5e6\",\n            \"47b0acfd\",\n            \"ed93fa9b\",\n            \"e8d3c48d\",\n            \"283b57cc\",\n            \"f8d56629\",\n            \"79132e28\",\n            \"785f0191\",\n            \"ed756055\",\n            \"f7960e44\",\n            \"e3d35e8c\",\n            \"15056dd4\",\n            \"88f46dba\",\n            \"03a16125\",\n            \"0564f0bd\",\n            \"c3eb9e15\",\n            \"3c9057a2\",\n            \"97271aec\",\n            \"a93a072a\",\n            \"1b3f6d9b\",\n            \"1e6321f5\",\n            \"f59c66fb\",\n            \"26dcf319\",\n            \"7533d928\",\n            \"b155fdf5\",\n            \"03563482\",\n            \"8aba3cbb\",\n            \"28517711\",\n            \"c20ad9f8\",\n            \"abcc5167\",\n            \"ccad925f\",\n            \"4de81751\",\n            \"3830dc8e\",\n            \"379d5862\",\n            \"9320f991\",\n            \"ea7a90c2\",\n            \"fb3e7bce\",\n            \"5121ce64\",\n            \"774fbe32\",\n            \"a8b6e37e\",\n            \"c3293d46\",\n            \"48de5369\",\n            \"6413e680\",\n            \"a2ae0810\",\n            \"dd6db224\",\n            \"69852dfd\",\n            \"09072166\",\n            \"b39a460a\",\n            \"6445c0dd\",\n            \"586cdecf\",\n            \"1c20c8ae\",\n            \"5bbef7dd\",\n            \"1b588d40\",\n            \"ccd2017f\",\n            \"6bb4e3bb\",\n            \"dda26a7e\",\n            \"3a59ff45\",\n            \"3e350a44\",\n            \"bcb4cdd5\",\n            \"72eacea8\",\n            \"fa6484bb\",\n            \"8d6612ae\",\n            \"bf3c6f47\",\n            \"d29be463\",\n            \"542f5d9e\",\n            \"aec2771b\",\n            \"f64e6370\",\n            \"740e0d8d\",\n            \"e75b1357\",\n            \"f8721671\",\n            \"af537d5d\",\n            \"4040cb08\",\n            \"4eb4e2cc\",\n            \"34d2466a\",\n            \"0115af84\",\n            \"e1b00428\",\n            \"95983a1d\",\n            \"06b89fb4\",\n            \"ce6ea048\",\n            \"6f3f3b82\",\n            \"3520ab82\",\n            \"011a1d4b\",\n            \"277227f8\",\n            \"611560b1\",\n            \"e7933fdc\",\n            \"bb3a792b\",\n            \"344525bd\",\n            \"a08839e1\",\n            \"51ce794b\",\n            \"2f32c9b7\",\n            \"a01fbac9\",\n            \"e01cc87e\",\n            \"bcc7d1f6\",\n            \"cf0111c3\",\n            \"a1e8aac7\",\n            \"1a908749\",\n            \"d44fbd9a\",\n            \"d0dadecb\",\n            \"d50ada38\",\n            \"0339c32a\",\n            \"c6913667\",\n            \"8df9317c\",\n            \"e0b12b4f\",\n            \"f79e59b7\",\n            \"43f5bb3a\",\n            \"f2d519ff\",\n            \"27d9459c\",\n            \"bf97222c\",\n            \"15e6fc2a\",\n            \"0f91fc71\",\n            \"9b941525\",\n            \"fae59361\",\n            \"ceb69ceb\",\n            \"c2a86459\",\n            \"12baa8d1\",\n            \"b6c1075e\",\n            \"e3056a0c\",\n            \"10d25065\",\n            \"cb03a442\",\n            \"e0ec6e0e\",\n            \"1698db3b\",\n            \"4c98a0be\",\n            \"3278e964\",\n            \"9f1f9532\",\n            \"e0d392df\",\n            \"d3a0342b\",\n            \"8971f21e\",\n            \"1b0a7441\",\n            \"4ba3348c\",\n            \"c5be7120\",\n            \"c37632d8\",\n            \"df359f8d\",\n            \"9b992f2e\",\n            \"e60b6f47\",\n            \"0fe3f11d\",\n            \"e54cda54\",\n            \"1edad891\",\n            \"ce6279cf\",\n            \"cd3e7e6f\",\n            \"1618b166\",\n            \"fd2c1d05\",\n            \"848fd2c5\",\n            \"f6fb2299\",\n            \"f523f357\",\n            \"a6327623\",\n            \"93a83531\",\n            \"56cccd02\",\n            \"acf08162\",\n            \"5a75ebb5\",\n            \"6e163697\",\n            \"88d273cc\",\n            \"de966292\",\n            \"81b949d0\",\n            \"4c50901b\",\n            \"71c65614\",\n            \"e6c6c7bd\",\n            \"327a140a\",\n            \"45e1d006\",\n            \"c3f27b9a\",\n            \"c9aa53fd\",\n            \"62a80f00\",\n            \"bb25bfe2\",\n            \"35bdd2f6\",\n            \"71126905\",\n            \"b2040222\",\n            \"b6cbcf7c\",\n            \"cd769c2b\",\n            \"53113ec0\",\n            \"1640e3d3\",\n            \"38abbd60\",\n            \"2547adf0\",\n            \"ba38209c\",\n            \"f746ce76\",\n            \"77afa1c5\",\n            \"20756060\",\n            \"85cbfe4e\",\n            \"8ae88dd8\",\n            \"7aaaf9b0\",\n            \"4cf9aa7e\",\n            \"1948c25c\",\n            \"02fb8a8c\",\n            \"01c36ae4\",\n            \"d6ebe1f9\",\n            \"90d4f869\",\n            \"a65cdea0\",\n            \"3f09252d\",\n            \"c208e69f\",\n            \"b74e6132\",\n            \"ce77e25b\",\n            \"578fdfe3\",\n            \"3ac372e6\",\n        },\n    };\n\n    //Initializing subkeys with digits of pi\n    String P[] = {\n        \"243f6a88\",\n        \"85a308d3\",\n        \"13198a2e\",\n        \"03707344\",\n        \"a4093822\",\n        \"299f31d0\",\n        \"082efa98\",\n        \"ec4e6c89\",\n        \"452821e6\",\n        \"38d01377\",\n        \"be5466cf\",\n        \"34e90c6c\",\n        \"c0ac29b7\",\n        \"c97c50dd\",\n        \"3f84d5b5\",\n        \"b5470917\",\n        \"9216d5d9\",\n        \"8979fb1b\",\n    };\n\n    //Initializing modVal to 2^32\n    long modVal = 4294967296L;\n\n    /**\n     * This method returns binary representation of the hexadecimal number passed as parameter\n     *\n     * @param hex Number for which binary representation is required\n     * @return String object which is a binary representation of the hex number passed as parameter\n     */\n    private String hexToBin(String hex) {\n        String binary = \"\";\n        Long num;\n        String binary4B;\n        int n = hex.length();\n        for (int i = 0; i < n; i++) {\n            num = Long.parseUnsignedLong(hex.charAt(i) + \"\", 16);\n            binary4B = Long.toBinaryString(num);\n\n            binary4B = \"0000\" + binary4B;\n\n            binary4B = binary4B.substring(binary4B.length() - 4);\n            binary += binary4B;\n        }\n        return binary;\n    }\n\n    /**\n     * This method returns hexadecimal representation of the binary number passed as parameter\n     *\n     * @param binary Number for which hexadecimal representation is required\n     * @return String object which is a hexadecimal representation of the binary number passed as parameter\n     */\n    private String binToHex(String binary) {\n        long num = Long.parseUnsignedLong(binary, 2);\n        String hex = Long.toHexString(num);\n        while (hex.length() < (binary.length() / 4)) hex = \"0\" + hex;\n\n        return hex;\n    }\n\n    /**\n     * This method returns a string obtained by XOR-ing two strings of same length passed a method parameters\n     *\n     * @param String a and b are string objects which will be XORed and are to be of same length\n     * @return String object obtained by XOR operation on String a and String b\n     * */\n    private String xor(String a, String b) {\n        a = hexToBin(a);\n        b = hexToBin(b);\n        String ans = \"\";\n        for (int i = 0; i < a.length(); i++) ans +=\n            (char) (((a.charAt(i) - '0') ^ (b.charAt(i) - '0')) + '0');\n        ans = binToHex(ans);\n        return ans;\n    }\n\n    /**\n     * This method returns addition of two hexadecimal numbers passed as parameters and moded with 2^32\n     *\n     * @param String a and b are hexadecimal numbers\n     * @return String object which is a is addition that is then moded with 2^32 of hex numbers passed as parameters\n     */\n    private String addBin(String a, String b) {\n        String ans = \"\";\n        long n1 = Long.parseUnsignedLong(a, 16);\n        long n2 = Long.parseUnsignedLong(b, 16);\n        n1 = (n1 + n2) % modVal;\n        ans = Long.toHexString(n1);\n        ans = \"00000000\" + ans;\n        return ans.substring(ans.length() - 8);\n    }\n\n    /*F-function splits the 32-bit input into four 8-bit quarters \n\t and uses the quarters as input to the S-boxes. \n\t The S-boxes accept 8-bit input and produce 32-bit output. \n\t The outputs are added modulo 232 and XORed to produce the final 32-bit output \n\t*/\n    private String f(String plainText) {\n        String a[] = new String[4];\n        String ans = \"\";\n        for (int i = 0; i < 8; i += 2) {\n            //column number for S-box is a 8-bit value\n            long col = Long.parseUnsignedLong(\n                hexToBin(plainText.substring(i, i + 2)),\n                2\n            );\n            a[i / 2] = S[i / 2][(int) col];\n        }\n        ans = addBin(a[0], a[1]);\n        ans = xor(ans, a[2]);\n        ans = addBin(ans, a[3]);\n        return ans;\n    }\n\n    //generate subkeys\n    private void keyGenerate(String key) {\n        int j = 0;\n        for (int i = 0; i < P.length; i++) {\n            //XOR-ing 32-bit parts of the key with initial subkeys\n            P[i] = xor(P[i], key.substring(j, j + 8));\n\n            j = (j + 8) % key.length();\n        }\n    }\n\n    //round function\n    private String round(int time, String plainText) {\n        String left, right;\n        left = plainText.substring(0, 8);\n        right = plainText.substring(8, 16);\n        left = xor(left, P[time]);\n\n        //output from F function\n        String fOut = f(left);\n\n        right = xor(fOut, right);\n\n        //swap left and right\n        return right + left;\n    }\n\n    /**\n     * This method returns cipher text for the plaintext passed as the first parameter generated\n     * using the key passed as the second parameter\n     *\n     * @param String plainText is the text which is to be encrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String cipherText is the encrypted value\n     */\n    String encrypt(String plainText, String key) {\n        //generating key\n        keyGenerate(key);\n\n        for (int i = 0; i < 16; i++) plainText = round(i, plainText);\n\n        //postprocessing\n        String right = plainText.substring(0, 8);\n        String left = plainText.substring(8, 16);\n        right = xor(right, P[16]);\n        left = xor(left, P[17]);\n        return left + right;\n    }\n\n    /**\n     * This method returns plaintext for the ciphertext passed as the first parameter decoded\n     * using the key passed as the second parameter\n     *\n     * @param String ciphertext is the text which is to be decrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String plainText is the decrypted text\n     */\n    String decrypt(String cipherText, String key) {\n        //generating key\n        keyGenerate(key);\n\n        for (int i = 17; i > 1; i--) cipherText = round(i, cipherText);\n\n        //postprocessing\n        String right = cipherText.substring(0, 8);\n        String left = cipherText.substring(8, 16);\n        right = xor(right, P[1]);\n        left = xor(left, P[0]);\n        return left + right;\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass BlowfishTest {\n\n\tBlowfish blowfish = new Blowfish();\n\n\t@Test\n\tvoid testEncrypt() {\n\n\t\t//given\n\t\tString plainText = \"123456abcd132536\";\n\t\tString key = \"aabb09182736ccdd\";\n\t\tString expectedOutput = \"d748ec383d3405f7\";\n\t\t\n\t\t//when\n\t\tString cipherText = blowfish.encrypt(plainText, key);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedOutput, cipherText);\n\n\t}\n\t\n\t@Test\n\tvoid testDecrypt() {\n\t\t\n\t\t//given\n\t\tString cipherText = \"d748ec383d3405f7\";\n\t\tString key = \"aabb09182736ccdd\";\n\t\tString expectedOutput = \"123456abcd132536\";\n\t\t\n\t\t//when\n\t\tString plainText = blowfish.decrypt(cipherText, key);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedOutput, plainText);\n\n\t}\n\t\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass BlowfishTest {\n\n    Blowfish blowfish = new Blowfish();\n\n    @Test\n    void testEncrypt() {\n        //given\n        String plainText = \"123456abcd132536\";\n        String key = \"aabb09182736ccdd\";\n        String expectedOutput = \"d748ec383d3405f7\";\n\n        //when\n        String cipherText = blowfish.encrypt(plainText, key);\n\n        //then\n        assertEquals(expectedOutput, cipherText);\n    }\n\n    @Test\n    void testDecrypt() {\n        //given\n        String cipherText = \"d748ec383d3405f7\";\n        String key = \"aabb09182736ccdd\";\n        String expectedOutput = \"123456abcd132536\";\n\n        //when\n        String plainText = blowfish.decrypt(cipherText, key);\n\n        //then\n        assertEquals(expectedOutput, plainText);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Polybius.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/PolybiusTest.java",
        "product_old_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Polybius Cipher\n * Polybius is a substitution cipher method\n * It was invented by a greek philosopher that name is Polybius\n * Letters in alphabet takes place to two dimension table.\n * Encrypted text is created according to row and column in two dimension table\n * Decrypted text is generated by looking at the row and column respectively\n * Additionally, some letters in english alphabet deliberately throws such as U because U is very similar with V\n *\n * @author Hikmet \u00c7AKIR\n * @since 08-07-2022+03:00\n */\npublic class Polybius {\n\n    private static final char[][] key = {\n          //         0    1    2    3    4\n          /* 0 */  {'A', 'B', 'C', 'D', 'E'},\n          /* 1 */  {'F', 'G', 'H', 'I', 'J'},\n          /* 2 */  {'K', 'L', 'M', 'N', 'O'},\n          /* 3 */  {'P', 'Q', 'R', 'S', 'T'},\n          /* 4 */  {'V', 'W', 'X', 'Y', 'Z'}\n    };\n\n    private static String findLocationByCharacter(final char character) {\n        final StringBuilder location = new StringBuilder();\n        for (int i = 0; i < key.length; i++) {\n            for (int j = 0; j < key[i].length; j++) {\n                if (character == key[i][j]) {\n                    location.append(i).append(j);\n                    break;\n                }\n            }\n        }\n        return location.toString();\n    }\n\n    public static String encrypt(final String plaintext) {\n        final char[] chars = plaintext.toUpperCase().toCharArray();\n        final StringBuilder ciphertext = new StringBuilder();\n        for (char aChar : chars) {\n            String location = findLocationByCharacter(aChar);\n            ciphertext.append(location);\n        }\n        return ciphertext.toString();\n    }\n\n    public static String decrypt(final String ciphertext) {\n        final char[] chars = ciphertext.toCharArray();\n        final StringBuilder plaintext = new StringBuilder();\n        for(int i = 0; i < chars.length; i+=2) {\n            int pozitionX = Character.getNumericValue(chars[i]);\n            int pozitionY = Character.getNumericValue(chars[i + 1]);\n            plaintext.append(key[pozitionX][pozitionY]);\n        }\n        return plaintext.toString();\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Polybius Cipher\n * Polybius is a substitution cipher method\n * It was invented by a greek philosopher that name is Polybius\n * Letters in alphabet takes place to two dimension table.\n * Encrypted text is created according to row and column in two dimension table\n * Decrypted text is generated by looking at the row and column respectively\n * Additionally, some letters in english alphabet deliberately throws such as U because U is very similar with V\n *\n * @author Hikmet \u00c7AKIR\n * @since 08-07-2022+03:00\n */\npublic class Polybius {\n\n    private static final char[][] key = {\n        //         0    1    2    3    4\n        /* 0 */{ 'A', 'B', 'C', 'D', 'E' },\n        /* 1 */{ 'F', 'G', 'H', 'I', 'J' },\n        /* 2 */{ 'K', 'L', 'M', 'N', 'O' },\n        /* 3 */{ 'P', 'Q', 'R', 'S', 'T' },\n        /* 4 */{ 'V', 'W', 'X', 'Y', 'Z' },\n    };\n\n    private static String findLocationByCharacter(final char character) {\n        final StringBuilder location = new StringBuilder();\n        for (int i = 0; i < key.length; i++) {\n            for (int j = 0; j < key[i].length; j++) {\n                if (character == key[i][j]) {\n                    location.append(i).append(j);\n                    break;\n                }\n            }\n        }\n        return location.toString();\n    }\n\n    public static String encrypt(final String plaintext) {\n        final char[] chars = plaintext.toUpperCase().toCharArray();\n        final StringBuilder ciphertext = new StringBuilder();\n        for (char aChar : chars) {\n            String location = findLocationByCharacter(aChar);\n            ciphertext.append(location);\n        }\n        return ciphertext.toString();\n    }\n\n    public static String decrypt(final String ciphertext) {\n        final char[] chars = ciphertext.toCharArray();\n        final StringBuilder plaintext = new StringBuilder();\n        for (int i = 0; i < chars.length; i += 2) {\n            int pozitionX = Character.getNumericValue(chars[i]);\n            int pozitionY = Character.getNumericValue(chars[i + 1]);\n            plaintext.append(key[pozitionX][pozitionY]);\n        }\n        return plaintext.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class PolybiusTest {\n\n    @Test\n    void testEncrypt() {\n        // Given\n        String plaintext = \"HELLOWORLD\";\n\n        // When\n        String actual = Polybius.encrypt(plaintext);\n\n        // Then\n        assertEquals(\"12042121244124322103\", actual);\n    }\n\n    @Test\n    void testDecrypt() {\n        // Given\n        String ciphertext = \"12042121244124322103\";\n\n        // When\n        String actual = Polybius.decrypt(ciphertext);\n\n        // Then\n        assertEquals(\"HELLOWORLD\", actual);\n    }\n\n    @Test\n    void testIsTextTheSameAfterEncryptionAndDecryption() {\n        // Given\n        String plaintext = \"HELLOWORLD\";\n\n        // When\n        String encryptedText = Polybius.encrypt(plaintext);\n        String actual = Polybius.decrypt(encryptedText);\n\n        // Then\n        assertEquals(plaintext, actual);\n    }\n}",
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PolybiusTest {\n\n    @Test\n    void testEncrypt() {\n        // Given\n        String plaintext = \"HELLOWORLD\";\n\n        // When\n        String actual = Polybius.encrypt(plaintext);\n\n        // Then\n        assertEquals(\"12042121244124322103\", actual);\n    }\n\n    @Test\n    void testDecrypt() {\n        // Given\n        String ciphertext = \"12042121244124322103\";\n\n        // When\n        String actual = Polybius.decrypt(ciphertext);\n\n        // Then\n        assertEquals(\"HELLOWORLD\", actual);\n    }\n\n    @Test\n    void testIsTextTheSameAfterEncryptionAndDecryption() {\n        // Given\n        String plaintext = \"HELLOWORLD\";\n\n        // When\n        String encryptedText = Polybius.encrypt(plaintext);\n        String actual = Polybius.decrypt(encryptedText);\n\n        // Then\n        assertEquals(plaintext, actual);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/a5/LFSR.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/a5/LFSRTest.java",
        "product_old_content": "package com.thealgorithms.ciphers.a5;\n\nimport java.util.BitSet;\n\npublic class LFSR implements BaseLFSR {\n    private final BitSet register;\n    private final int length;\n    private final int clockBitIndex;\n    private final int[] tappingBitsIndices;\n\n    public LFSR( int length, int clockBitIndex, int[] tappingBitsIndices ) {\n        this.length = length;\n        this.clockBitIndex = clockBitIndex;\n        this.tappingBitsIndices = tappingBitsIndices;\n        register = new BitSet( length );\n    }\n\n    @Override\n    public void initialize( BitSet sessionKey, BitSet frameCounter ) {\n        register.clear();\n        clock( sessionKey, SESSION_KEY_LENGTH );\n        clock( frameCounter, FRAME_COUNTER_LENGTH );\n    }\n\n    private void clock( BitSet key, int keyLength ) {\n        // We start from reverse because LFSR 0 index is the left most bit\n        // while key 0 index is right most bit, so we reverse it\n        for ( int i = keyLength - 1; i >= 0; --i ) {\n            var newBit = key.get( i ) ^ xorTappingBits();\n            pushBit( newBit );\n        }\n    }\n\n    @Override\n    public boolean clock() {\n        return pushBit( xorTappingBits() );\n    }\n\n    public boolean getClockBit() {\n        return register.get( clockBitIndex );\n    }\n\n    public boolean get( int bitIndex ) {\n        return register.get( bitIndex );\n    }\n\n    public boolean getLastBit() {\n        return register.get( length - 1 );\n    }\n\n    private boolean xorTappingBits() {\n        boolean result = false;\n        for ( int i : tappingBitsIndices ) {\n            result ^= register.get( i );\n        }\n        return result;\n    }\n\n    private boolean pushBit( boolean bit ) {\n        boolean discardedBit = rightShift();\n        register.set( 0, bit );\n        return discardedBit;\n    }\n\n    private boolean rightShift() {\n        boolean discardedBit = get( length - 1 );\n        for ( int i = length - 1; i > 0; --i ) {\n            register.set( i, get( i - 1 ) );\n        }\n        register.set( 0, false );\n        return discardedBit;\n    }\n\n    @Override\n    public String toString() {\n        return register.toString();\n    }\n}",
        "product_new_content": "package com.thealgorithms.ciphers.a5;\n\nimport java.util.BitSet;\n\npublic class LFSR implements BaseLFSR {\n\n    private final BitSet register;\n    private final int length;\n    private final int clockBitIndex;\n    private final int[] tappingBitsIndices;\n\n    public LFSR(int length, int clockBitIndex, int[] tappingBitsIndices) {\n        this.length = length;\n        this.clockBitIndex = clockBitIndex;\n        this.tappingBitsIndices = tappingBitsIndices;\n        register = new BitSet(length);\n    }\n\n    @Override\n    public void initialize(BitSet sessionKey, BitSet frameCounter) {\n        register.clear();\n        clock(sessionKey, SESSION_KEY_LENGTH);\n        clock(frameCounter, FRAME_COUNTER_LENGTH);\n    }\n\n    private void clock(BitSet key, int keyLength) {\n        // We start from reverse because LFSR 0 index is the left most bit\n        // while key 0 index is right most bit, so we reverse it\n        for (int i = keyLength - 1; i >= 0; --i) {\n            var newBit = key.get(i) ^ xorTappingBits();\n            pushBit(newBit);\n        }\n    }\n\n    @Override\n    public boolean clock() {\n        return pushBit(xorTappingBits());\n    }\n\n    public boolean getClockBit() {\n        return register.get(clockBitIndex);\n    }\n\n    public boolean get(int bitIndex) {\n        return register.get(bitIndex);\n    }\n\n    public boolean getLastBit() {\n        return register.get(length - 1);\n    }\n\n    private boolean xorTappingBits() {\n        boolean result = false;\n        for (int i : tappingBitsIndices) {\n            result ^= register.get(i);\n        }\n        return result;\n    }\n\n    private boolean pushBit(boolean bit) {\n        boolean discardedBit = rightShift();\n        register.set(0, bit);\n        return discardedBit;\n    }\n\n    private boolean rightShift() {\n        boolean discardedBit = get(length - 1);\n        for (int i = length - 1; i > 0; --i) {\n            register.set(i, get(i - 1));\n        }\n        register.set(0, false);\n        return discardedBit;\n    }\n\n    @Override\n    public String toString() {\n        return register.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers.a5;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.BitSet;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\n// Basic tests for sanity check\nclass LFSRTest {\n    // Represents 0100 1110 0010 1111 0100 1101 0111 1100 0001 1110 1011 1000 1000 1011 0011 1010\n    // But we start reverse way because bitset starts from most right (1010)\n    byte[] sessionKeyBytes = { 58, (byte) 139, (byte) 184, 30, 124, 77, 47, 78 };\n\n    // Represents 11 1010 1011 0011 1100 1011\n    byte[] frameCounterBytes = { (byte) 203, (byte) 179, 58 };\n\n    @Test\n    void initialize() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        BitSet expected = new BitSet( 19 );\n        expected.set( 0 );\n        expected.set( 1 );\n        expected.set( 3 );\n        expected.set( 4 );\n        expected.set( 5 );\n        expected.set( 7 );\n        expected.set( 9 );\n        expected.set( 10 );\n        expected.set( 11 );\n        expected.set( 12 );\n        expected.set( 13 );\n        expected.set( 15 );\n        expected.set( 16 );\n        expected.set( 17 );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n        lfsr0.initialize( sessionKey, frameCounter );\n        assertEquals( expected.toString(), lfsr0.toString() );\n    }\n\n    @Test\n    void clock() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n        lfsr0.initialize( sessionKey, frameCounter );\n\n        BitSet expected = new BitSet( 19 );\n        expected.set( 0 );\n        expected.set( 1 );\n        expected.set( 2 );\n        expected.set( 4 );\n        expected.set( 5 );\n        expected.set( 6 );\n        expected.set( 8 );\n        expected.set( 10 );\n        expected.set( 11 );\n        expected.set( 12 );\n        expected.set( 13 );\n        expected.set( 14 );\n        expected.set( 16 );\n        expected.set( 17 );\n        expected.set( 18 );\n\n        lfsr0.clock();\n        assertEquals( expected.toString(), lfsr0.toString() );\n    }\n\n    @Test\n    void getClockBit() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n\n        assertFalse( lfsr0.getClockBit() );\n\n        lfsr0.initialize( sessionKey, frameCounter );\n\n        assertFalse( lfsr0.getClockBit() );\n    }\n}",
        "test_new_content": "package com.thealgorithms.ciphers.a5;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.util.BitSet;\nimport org.junit.jupiter.api.Test;\n\n// Basic tests for sanity check\nclass LFSRTest {\n\n    // Represents 0100 1110 0010 1111 0100 1101 0111 1100 0001 1110 1011 1000 1000 1011 0011 1010\n    // But we start reverse way because bitset starts from most right (1010)\n    byte[] sessionKeyBytes = {\n        58,\n        (byte) 139,\n        (byte) 184,\n        30,\n        124,\n        77,\n        47,\n        78,\n    };\n\n    // Represents 11 1010 1011 0011 1100 1011\n    byte[] frameCounterBytes = { (byte) 203, (byte) 179, 58 };\n\n    @Test\n    void initialize() {\n        BitSet sessionKey = BitSet.valueOf(sessionKeyBytes);\n        BitSet frameCounter = BitSet.valueOf(frameCounterBytes);\n\n        BitSet expected = new BitSet(19);\n        expected.set(0);\n        expected.set(1);\n        expected.set(3);\n        expected.set(4);\n        expected.set(5);\n        expected.set(7);\n        expected.set(9);\n        expected.set(10);\n        expected.set(11);\n        expected.set(12);\n        expected.set(13);\n        expected.set(15);\n        expected.set(16);\n        expected.set(17);\n\n        LFSR lfsr0 = new LFSR(19, 8, new int[] { 13, 16, 17, 18 });\n        lfsr0.initialize(sessionKey, frameCounter);\n        assertEquals(expected.toString(), lfsr0.toString());\n    }\n\n    @Test\n    void clock() {\n        BitSet sessionKey = BitSet.valueOf(sessionKeyBytes);\n        BitSet frameCounter = BitSet.valueOf(frameCounterBytes);\n\n        LFSR lfsr0 = new LFSR(19, 8, new int[] { 13, 16, 17, 18 });\n        lfsr0.initialize(sessionKey, frameCounter);\n\n        BitSet expected = new BitSet(19);\n        expected.set(0);\n        expected.set(1);\n        expected.set(2);\n        expected.set(4);\n        expected.set(5);\n        expected.set(6);\n        expected.set(8);\n        expected.set(10);\n        expected.set(11);\n        expected.set(12);\n        expected.set(13);\n        expected.set(14);\n        expected.set(16);\n        expected.set(17);\n        expected.set(18);\n\n        lfsr0.clock();\n        assertEquals(expected.toString(), lfsr0.toString());\n    }\n\n    @Test\n    void getClockBit() {\n        BitSet sessionKey = BitSet.valueOf(sessionKeyBytes);\n        BitSet frameCounter = BitSet.valueOf(frameCounterBytes);\n\n        LFSR lfsr0 = new LFSR(19, 8, new int[] { 13, 16, 17, 18 });\n\n        assertFalse(lfsr0.getClockBit());\n\n        lfsr0.initialize(sessionKey, frameCounter);\n\n        assertFalse(lfsr0.getClockBit());\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/bloomfilter/BloomFilter.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/bloomfilter/BloomFilterTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.bloomfilter;\n\n\nimport java.util.BitSet;\n\npublic class BloomFilter<T> {\n\n    private int numberOfHashFunctions;\n    private BitSet bitArray;\n    private Hash<T>[] hashFunctions;\n\n    public BloomFilter(int numberOfHashFunctions, int n) {\n        this.numberOfHashFunctions = numberOfHashFunctions;\n        hashFunctions = new Hash[numberOfHashFunctions];\n        bitArray = new BitSet(n);\n        insertHash();\n    }\n\n    private void insertHash() {\n        for (int i = 0; i < numberOfHashFunctions; i++) {\n            hashFunctions[i] = new Hash(i);\n        }\n    }\n\n    public void insert(T key) {\n        for (Hash<T> hash : hashFunctions){\n            int position = hash.compute(key) % bitArray.size();\n            bitArray.set(position);\n        }\n    }\n\n    public boolean contains(T key) {\n        for (Hash<T> hash : hashFunctions){\n            int position = hash.compute(key) % bitArray.size();\n            if (!bitArray.get(position)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private class Hash<T> {\n\n        int index;\n\n        public Hash(int index){\n            this.index = index;\n        }\n\n        public int compute(T key){\n            return index * asciiString(String.valueOf(key));\n        }\n\n        private int asciiString(String word){\n            int number = 0;\n            for (int i=0;i<word.length();i++){\n                number += word.charAt(i);\n            }\n            return number;\n        }\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.datastructures.bloomfilter;\n\nimport java.util.BitSet;\n\npublic class BloomFilter<T> {\n\n    private int numberOfHashFunctions;\n    private BitSet bitArray;\n    private Hash<T>[] hashFunctions;\n\n    public BloomFilter(int numberOfHashFunctions, int n) {\n        this.numberOfHashFunctions = numberOfHashFunctions;\n        hashFunctions = new Hash[numberOfHashFunctions];\n        bitArray = new BitSet(n);\n        insertHash();\n    }\n\n    private void insertHash() {\n        for (int i = 0; i < numberOfHashFunctions; i++) {\n            hashFunctions[i] = new Hash(i);\n        }\n    }\n\n    public void insert(T key) {\n        for (Hash<T> hash : hashFunctions) {\n            int position = hash.compute(key) % bitArray.size();\n            bitArray.set(position);\n        }\n    }\n\n    public boolean contains(T key) {\n        for (Hash<T> hash : hashFunctions) {\n            int position = hash.compute(key) % bitArray.size();\n            if (!bitArray.get(position)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private class Hash<T> {\n\n        int index;\n\n        public Hash(int index) {\n            this.index = index;\n        }\n\n        public int compute(T key) {\n            return index * asciiString(String.valueOf(key));\n        }\n\n        private int asciiString(String word) {\n            int number = 0;\n            for (int i = 0; i < word.length(); i++) {\n                number += word.charAt(i);\n            }\n            return number;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.bloomfilter;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n\npublic class BloomFilterTest {\n\n    @Test\n    public void test1(){\n        BloomFilter<Integer> bloomFilter = new BloomFilter<>(3,10);\n        bloomFilter.insert(3);\n        bloomFilter.insert(17);\n\n        Assertions.assertTrue(bloomFilter.contains(3));\n        Assertions.assertTrue(bloomFilter.contains(17));\n    }\n\n    @Test\n    public void test2(){\n        BloomFilter<String> bloomFilter = new BloomFilter<>(4,20);\n        bloomFilter.insert(\"omar\");\n        bloomFilter.insert(\"mahamid\");\n\n        Assertions.assertTrue(bloomFilter.contains(\"omar\"));\n        Assertions.assertTrue(bloomFilter.contains(\"mahamid\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.bloomfilter;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class BloomFilterTest {\n\n    @Test\n    public void test1() {\n        BloomFilter<Integer> bloomFilter = new BloomFilter<>(3, 10);\n        bloomFilter.insert(3);\n        bloomFilter.insert(17);\n\n        Assertions.assertTrue(bloomFilter.contains(3));\n        Assertions.assertTrue(bloomFilter.contains(17));\n    }\n\n    @Test\n    public void test2() {\n        BloomFilter<String> bloomFilter = new BloomFilter<>(4, 20);\n        bloomFilter.insert(\"omar\");\n        bloomFilter.insert(\"mahamid\");\n\n        Assertions.assertTrue(bloomFilter.contains(\"omar\"));\n        Assertions.assertTrue(bloomFilter.contains(\"mahamid\"));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/LFUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/LFUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Java program for LFU Cache (https://en.wikipedia.org/wiki/Least_frequently_used)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class LFUCache<K,V> {\n\n\tprivate class Node {\n\t\tprivate K key;\n\t\tprivate V value;\n\t\tprivate int frequency;\n\t\tprivate Node previous;\n\t\tprivate Node next;\n\n\t\tpublic Node(K key, V value, int frequency) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t\tthis.frequency = frequency;\n\t\t}\n\t}\n\n\tprivate Node head;\n\tprivate Node tail;\n\tprivate Map<K,Node> map = null;\n\tprivate Integer capacity;\n\tprivate static final int DEFAULT_CAPACITY = 100;\n\t\n\tpublic LFUCache() {\n\t\tthis.capacity = DEFAULT_CAPACITY;\n\t}\n\n\tpublic LFUCache(Integer capacity) {\n\t\tthis.capacity = capacity;\n\t\tthis.map = new HashMap<>();\n\t}\n\t\n    /**\n     * This method returns value present in the cache corresponding to the key passed as parameter\n     *\n     * @param <K> key for which value is to be retrieved \n     * @returns <V> object corresponding to the key passed as parameter, returns null if <K> key is not present in the cache\n     */\n\tpublic V get(K key) {\n\t\tif(this.map.get(key) == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tNode node = map.get(key);\n\t\tremoveNode(node);\n\t\tnode.frequency += 1;\n\t\taddNodeWithUpdatedFrequency(node);\n\n\t\treturn node.value;\n\t}\n\n    /**\n     * This method stores <K> key and <V> value in the cache\n     *\n     * @param <K> key which is to be stored in the cache\n     * @param <V> value which is to be stored in the cache \n     */\n\tpublic void put(K key, V value) {\n\t\tif(map.containsKey(key)) {\n\t\t\tNode node =  map.get(key);\n\t\t\tnode.value = value;\n\t\t\tnode.frequency += 1;\n\t\t\tremoveNode(node);\n\t\t\taddNodeWithUpdatedFrequency(node);\n\t\t}\n\t\telse {\n\t\t\tif(map.size() >= capacity) {\n\t\t\t\tmap.remove(this.head.key);\n\t\t\t\tremoveNode(head);\n\t\t\t}\n\t\t\tNode node = new Node(key,value,1);\n\t\t\taddNodeWithUpdatedFrequency(node);\n\t\t\tmap.put(key, node);\n\t\t}\n\t}\n\n    /**\n     * This method stores the node in the cache with updated frequency\n     *\n     * @param Node node which is to be updated in the cache \n     */\n\tprivate void addNodeWithUpdatedFrequency(Node node) {\n\t\tif(tail != null && head != null) {\n\t\t\tNode temp = this.head;\n\t\t\twhile(temp != null) {\n\t\t\t\tif(temp.frequency > node.frequency) {\n\t\t\t\t\tif(temp==head) {\n\t\t\t\t\t\tnode.next = temp;\n\t\t\t\t\t\ttemp.previous = node;\n\t\t\t\t\t\tthis.head = node;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnode.next = temp;\n\t\t\t\t\t\tnode.previous = temp.previous;\n\t\t\t\t\t\ttemp.previous.next = node;\n\t\t\t\t\t\tnode.previous = temp.previous;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttemp = temp.next;\n\t\t\t\t\tif(temp == null) {\n\t\t\t\t\t\ttail.next = node;\n\t\t\t\t\t\tnode.previous = tail;\n\t\t\t\t\t\tnode.next = null;\n\t\t\t\t\t\ttail = node;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttail = node;\n\t\t\thead = tail;\n\t\t}\n\t}\n\n    /**\n     * This method removes node from the cache \n     * \n     * @param Node node which is to be removed in the cache \n     */\n\tprivate void removeNode(Node node) {\n\t\tif(node.previous != null) {\n\t\t\tnode.previous.next = node.next;\n\t\t}\n\t\telse {\n\t\t\tthis.head = node.next;\n\t\t}\n\n\t\tif(node.next != null) {\n\t\t\tnode.next.previous = node.previous;\n\t\t}\n\t\telse {\n\t\t\tthis.tail = node.previous;\n\t\t}\t\t\n\t}\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Java program for LFU Cache (https://en.wikipedia.org/wiki/Least_frequently_used)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class LFUCache<K, V> {\n\n    private class Node {\n\n        private K key;\n        private V value;\n        private int frequency;\n        private Node previous;\n        private Node next;\n\n        public Node(K key, V value, int frequency) {\n            this.key = key;\n            this.value = value;\n            this.frequency = frequency;\n        }\n    }\n\n    private Node head;\n    private Node tail;\n    private Map<K, Node> map = null;\n    private Integer capacity;\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public LFUCache() {\n        this.capacity = DEFAULT_CAPACITY;\n    }\n\n    public LFUCache(Integer capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>();\n    }\n\n    /**\n     * This method returns value present in the cache corresponding to the key passed as parameter\n     *\n     * @param <K> key for which value is to be retrieved\n     * @returns <V> object corresponding to the key passed as parameter, returns null if <K> key is not present in the cache\n     */\n    public V get(K key) {\n        if (this.map.get(key) == null) {\n            return null;\n        }\n\n        Node node = map.get(key);\n        removeNode(node);\n        node.frequency += 1;\n        addNodeWithUpdatedFrequency(node);\n\n        return node.value;\n    }\n\n    /**\n     * This method stores <K> key and <V> value in the cache\n     *\n     * @param <K> key which is to be stored in the cache\n     * @param <V> value which is to be stored in the cache\n     */\n    public void put(K key, V value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            node.frequency += 1;\n            removeNode(node);\n            addNodeWithUpdatedFrequency(node);\n        } else {\n            if (map.size() >= capacity) {\n                map.remove(this.head.key);\n                removeNode(head);\n            }\n            Node node = new Node(key, value, 1);\n            addNodeWithUpdatedFrequency(node);\n            map.put(key, node);\n        }\n    }\n\n    /**\n     * This method stores the node in the cache with updated frequency\n     *\n     * @param Node node which is to be updated in the cache\n     */\n    private void addNodeWithUpdatedFrequency(Node node) {\n        if (tail != null && head != null) {\n            Node temp = this.head;\n            while (temp != null) {\n                if (temp.frequency > node.frequency) {\n                    if (temp == head) {\n                        node.next = temp;\n                        temp.previous = node;\n                        this.head = node;\n                        break;\n                    } else {\n                        node.next = temp;\n                        node.previous = temp.previous;\n                        temp.previous.next = node;\n                        node.previous = temp.previous;\n                        break;\n                    }\n                } else {\n                    temp = temp.next;\n                    if (temp == null) {\n                        tail.next = node;\n                        node.previous = tail;\n                        node.next = null;\n                        tail = node;\n                        break;\n                    }\n                }\n            }\n        } else {\n            tail = node;\n            head = tail;\n        }\n    }\n\n    /**\n     * This method removes node from the cache\n     *\n     * @param Node node which is to be removed in the cache\n     */\n    private void removeNode(Node node) {\n        if (node.previous != null) {\n            node.previous.next = node.next;\n        } else {\n            this.head = node.next;\n        }\n\n        if (node.next != null) {\n            node.next.previous = node.previous;\n        } else {\n            this.tail = node.previous;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LFUCacheTest {\n\n\t@Test\n\tvoid testLFUCacheWithIntegerValueShouldPass() {\n\n\t\tLFUCache<Integer, Integer> lfuCache = new LFUCache<>(5);\n\t\tlfuCache.put(1, 10);\n\t\tlfuCache.put(2, 20);\n\t\tlfuCache.put(3, 30);\n\t\tlfuCache.put(4, 40);\n\t\tlfuCache.put(5, 50);\n\n\t\t//get method call will increase frequency of key 1 by 1\n\t\tassertEquals(10, lfuCache.get(1));\n\n\t\t//this operation will remove value with key as 2\n\t\tlfuCache.put(6, 60);\n\n\t\t//will return null as value with key 2 is now evicted\n\t\tassertEquals(null, lfuCache.get(2));\n\n\t\t//should return 60\n\t\tassertEquals(60, lfuCache.get(6));\n\n\t\t//this operation will remove value with key as 3\n\t\tlfuCache.put(7, 70);\n\n\t\tassertEquals(null, lfuCache.get(2));\n\t\tassertEquals(70, lfuCache.get(7));\n\t}\n\n\t@Test\n\tvoid testLFUCacheWithStringValueShouldPass() {\n\n\t\tLFUCache<Integer, String> lfuCache = new LFUCache<>(5);\n\t\tlfuCache.put(1, \"Alpha\");\n\t\tlfuCache.put(2, \"Beta\");\n\t\tlfuCache.put(3, \"Gamma\");\n\t\tlfuCache.put(4, \"Delta\");\n\t\tlfuCache.put(5, \"Eplison\");\n\n\t\t//get method call will increase frequency of key 1 by 1\n\t\tassertEquals(\"Alpha\", lfuCache.get(1));\n\n\t\t//this operation will remove value with key as 2\n\t\tlfuCache.put(6, \"Digamma\");\n\n\t\t//will return null as value with key 2 is now evicted\n\t\tassertEquals(null, lfuCache.get(2));\n\n\t\t//should return string Digamma\n\t\tassertEquals(\"Digamma\", lfuCache.get(6));\n\n\t\t//this operation will remove value with key as 3\n\t\tlfuCache.put(7, \"Zeta\");\n\n\t\tassertEquals(null, lfuCache.get(2));\n\t\tassertEquals(\"Zeta\", lfuCache.get(7));\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LFUCacheTest {\n\n    @Test\n    void testLFUCacheWithIntegerValueShouldPass() {\n        LFUCache<Integer, Integer> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, 10);\n        lfuCache.put(2, 20);\n        lfuCache.put(3, 30);\n        lfuCache.put(4, 40);\n        lfuCache.put(5, 50);\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(10, lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, 60);\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return 60\n        assertEquals(60, lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, 70);\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(70, lfuCache.get(7));\n    }\n\n    @Test\n    void testLFUCacheWithStringValueShouldPass() {\n        LFUCache<Integer, String> lfuCache = new LFUCache<>(5);\n        lfuCache.put(1, \"Alpha\");\n        lfuCache.put(2, \"Beta\");\n        lfuCache.put(3, \"Gamma\");\n        lfuCache.put(4, \"Delta\");\n        lfuCache.put(5, \"Eplison\");\n\n        //get method call will increase frequency of key 1 by 1\n        assertEquals(\"Alpha\", lfuCache.get(1));\n\n        //this operation will remove value with key as 2\n        lfuCache.put(6, \"Digamma\");\n\n        //will return null as value with key 2 is now evicted\n        assertEquals(null, lfuCache.get(2));\n\n        //should return string Digamma\n        assertEquals(\"Digamma\", lfuCache.get(6));\n\n        //this operation will remove value with key as 3\n        lfuCache.put(7, \"Zeta\");\n\n        assertEquals(null, lfuCache.get(2));\n        assertEquals(\"Zeta\", lfuCache.get(7));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/LRUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/LRUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Least recently used (LRU)\n * <p>\n * Discards the least recently used items first. This algorithm requires keeping\n * track of what was used when, which is expensive if one wants to make sure the\n * algorithm always discards the least recently used item.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class LRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public LRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    public LRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        Entry<K, V> evicted = head;\n        head = evicted.getNextEntry();\n        head.setPreEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveNodeToLast(entry);\n        return entry.getValue();\n    }\n\n    private void moveNodeToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> existingEntry = data.get(key);\n            existingEntry.setValue(value);\n            moveNodeToLast(existingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Least recently used (LRU)\n * <p>\n * Discards the least recently used items first. This algorithm requires keeping\n * track of what was used when, which is expensive if one wants to make sure the\n * algorithm always discards the least recently used item.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class LRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public LRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    public LRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        Entry<K, V> evicted = head;\n        head = evicted.getNextEntry();\n        head.setPreEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveNodeToLast(entry);\n        return entry.getValue();\n    }\n\n    private void moveNodeToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> existingEntry = data.get(key);\n            existingEntry.setValue(value);\n            moveNodeToLast(existingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {}\n\n        public Entry(\n            Entry<I, J> preEntry,\n            Entry<I, J> nextEntry,\n            I key,\n            J value\n        ) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        LRUCache<Integer, Integer> lruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        LRUCache<String, String> lruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        LRUCache<Integer, Integer> lruCache = new LRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        LRUCache<String, String> lruCache = new LRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n\n        for (int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/MRUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/MRUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Most recently used (MRU)\n * <p>\n * In contrast to Least Recently Used (LRU), MRU discards the most recently used\n * items first.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Most_recently_used_(MRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class MRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public MRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        final Entry<K, V> evicted = this.tail;\n        tail = evicted.getPreEntry();\n        tail.setNextEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    public MRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveEntryToLast(entry);\n        return entry.getValue();\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> exitingEntry = data.get(key);\n            exitingEntry.setValue(value);\n            moveEntryToLast(exitingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    private void moveEntryToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Most recently used (MRU)\n * <p>\n * In contrast to Least Recently Used (LRU), MRU discards the most recently used\n * items first.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Most_recently_used_(MRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class MRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public MRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        final Entry<K, V> evicted = this.tail;\n        tail = evicted.getPreEntry();\n        tail.setNextEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    public MRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveEntryToLast(entry);\n        return entry.getValue();\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> exitingEntry = data.get(key);\n            exitingEntry.setValue(value);\n            moveEntryToLast(exitingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    private void moveEntryToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {}\n\n        public Entry(\n            Entry<I, J> preEntry,\n            Entry<I, J> nextEntry,\n            I key,\n            J value\n        ) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class MRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        MRUCache<Integer, Integer> lruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        MRUCache<String, String> lruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        MRUCache<Integer, Integer> lruCache = new MRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        MRUCache<String, String> lruCache = new MRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n\n        for (int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/HamiltonianCycle.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/HamiltonianCycleTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.graphs;\n\n/**\n * Java program for Hamiltonian Cycle (https://en.wikipedia.org/wiki/Hamiltonian_path)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class HamiltonianCycle {\n\n    private int V, pathCount;\n    private int[] cycle;\n    private int[][] graph;\n\n    /**\n     * Find hamiltonian cycle for given graph G(V,E)\n     * @param graph Adjacency matrix of a graph G(V, E) \n     * for which hamiltonian path is to be found\n     * @return Array containing hamiltonian cycle \n     * else returns 1D array with value -1.\n     */\n    public int[] findHamiltonianCycle(int[][] graph){\n        this.V = graph.length;\n        this.cycle = new int[this.V+1];\n\n        //Initialize path array with -1 value\n        for(int i=0 ; i<this.cycle.length ; i++) {\n            this.cycle[i] = -1;\n        }\n\n        this.graph = graph;        \n\n        this.cycle[0] = 0;\n        this.pathCount = 1;            \n        if(!isPathFound(0)) {\n            for(int i=0 ; i<this.cycle.length ; i++) {\n                this.cycle[i] = -1;\n            }\n        }\n        else {\n        \tthis.cycle[this.cycle.length-1] = this.cycle[0];\n        }\n        \n        return cycle;\n    }\n\n    /** function to find paths recursively\n     * Find paths recursively from given vertex\n     * @param vertex Vertex from which path is to be found\n     * @returns true if path is found false otherwise\n     */\n    public boolean isPathFound(int vertex) {\n        if (this.graph[vertex][0] == 1 && this.pathCount == this.V) {\n            return true;\n        }\n\n        /** all vertices selected but last vertex not linked to 0 **/\n        if (this.pathCount == this.V) {\n            return false;\n        }\n\n        for (int v = 0; v < this.V; v++){\n            /** if connected **/\n            if (this.graph[vertex][v] == 1 ){\n                /** add to path **/            \n                this.cycle[this.pathCount++] = v;    \n\n                /** remove connection **/            \n                this.graph[vertex][v] = 0;\n                this.graph[v][vertex] = 0;\n\n                /** if vertex not already selected  solve recursively **/\n                if (!isPresent(v)) {\n                    return isPathFound(v);\n                }\n\n                /** restore connection **/\n                this.graph[vertex][v] = 1;\n                this.graph[v][vertex] = 1;\n\n                /** remove path **/\n                this.cycle[--this.pathCount] = -1;\n            }\n        }\n        return false;\n    }    \n\n    /** function to check if path is already selected\n     * Check if path is already selected\n     * @param vertex Starting vertex \n     */\n    public boolean isPresent(int vertex){\n\n        for (int i = 0; i < pathCount - 1; i++) {\n            if (cycle[i] == vertex) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\n/**\n * Java program for Hamiltonian Cycle (https://en.wikipedia.org/wiki/Hamiltonian_path)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class HamiltonianCycle {\n\n    private int V, pathCount;\n    private int[] cycle;\n    private int[][] graph;\n\n    /**\n     * Find hamiltonian cycle for given graph G(V,E)\n     * @param graph Adjacency matrix of a graph G(V, E)\n     * for which hamiltonian path is to be found\n     * @return Array containing hamiltonian cycle\n     * else returns 1D array with value -1.\n     */\n    public int[] findHamiltonianCycle(int[][] graph) {\n        this.V = graph.length;\n        this.cycle = new int[this.V + 1];\n\n        //Initialize path array with -1 value\n        for (int i = 0; i < this.cycle.length; i++) {\n            this.cycle[i] = -1;\n        }\n\n        this.graph = graph;\n\n        this.cycle[0] = 0;\n        this.pathCount = 1;\n        if (!isPathFound(0)) {\n            for (int i = 0; i < this.cycle.length; i++) {\n                this.cycle[i] = -1;\n            }\n        } else {\n            this.cycle[this.cycle.length - 1] = this.cycle[0];\n        }\n\n        return cycle;\n    }\n\n    /** function to find paths recursively\n     * Find paths recursively from given vertex\n     * @param vertex Vertex from which path is to be found\n     * @returns true if path is found false otherwise\n     */\n    public boolean isPathFound(int vertex) {\n        if (this.graph[vertex][0] == 1 && this.pathCount == this.V) {\n            return true;\n        }\n\n        /** all vertices selected but last vertex not linked to 0 **/\n        if (this.pathCount == this.V) {\n            return false;\n        }\n\n        for (int v = 0; v < this.V; v++) {\n            /** if connected **/\n            if (this.graph[vertex][v] == 1) {\n                /** add to path **/\n                this.cycle[this.pathCount++] = v;\n\n                /** remove connection **/\n                this.graph[vertex][v] = 0;\n                this.graph[v][vertex] = 0;\n\n                /** if vertex not already selected  solve recursively **/\n                if (!isPresent(v)) {\n                    return isPathFound(v);\n                }\n\n                /** restore connection **/\n                this.graph[vertex][v] = 1;\n                this.graph[v][vertex] = 1;\n\n                /** remove path **/\n                this.cycle[--this.pathCount] = -1;\n            }\n        }\n        return false;\n    }\n\n    /** function to check if path is already selected\n     * Check if path is already selected\n     * @param vertex Starting vertex\n     */\n    public boolean isPresent(int vertex) {\n        for (int i = 0; i < pathCount - 1; i++) {\n            if (cycle[i] == vertex) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HamiltonianCycleTest {\n\n\tprivate HamiltonianCycle hamiltonianCycle = new HamiltonianCycle();\n\n\t@Test\n\tvoid testFindHamiltonianCycleShouldReturnHamiltonianCycle() {\n\t\tint[] expectedArray = {0,1,2,4,3,0};\n\t\tint[][] inputArray =  {\n\t\t\t\t{0, 1, 0, 1, 0},\n\t\t\t\t{1, 0, 1, 1, 1},\n\t\t\t\t{0, 1, 0, 0, 1},\n\t\t\t\t{1, 1, 0, 0, 1},\n\t\t\t\t{0, 1, 1, 1, 0}\n\t\t};\n\n\t\tassertArrayEquals(expectedArray, hamiltonianCycle.findHamiltonianCycle(inputArray));\n\t}\n\n\t@Test\n\tvoid testFindHamiltonianCycleShouldReturnInfinityArray() {\n\t\tint[] expectedArray = {-1,-1,-1,-1,-1,-1};\n\n\t\tint[][] inputArray =  {\n\t\t\t\t{0, 1, 0, 1, 0},\n\t\t\t\t{1, 0, 1, 1, 1},\n\t\t\t\t{0, 1, 0, 0, 1},\n\t\t\t\t{1, 1, 0, 0, 0},\n\t\t\t\t{0, 1, 1, 0, 0}\n\t\t};\n\n\t\tassertArrayEquals(expectedArray, hamiltonianCycle.findHamiltonianCycle(inputArray));\n\t}\n}",
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HamiltonianCycleTest {\n\n    private HamiltonianCycle hamiltonianCycle = new HamiltonianCycle();\n\n    @Test\n    void testFindHamiltonianCycleShouldReturnHamiltonianCycle() {\n        int[] expectedArray = { 0, 1, 2, 4, 3, 0 };\n        int[][] inputArray = {\n            { 0, 1, 0, 1, 0 },\n            { 1, 0, 1, 1, 1 },\n            { 0, 1, 0, 0, 1 },\n            { 1, 1, 0, 0, 1 },\n            { 0, 1, 1, 1, 0 },\n        };\n\n        assertArrayEquals(\n            expectedArray,\n            hamiltonianCycle.findHamiltonianCycle(inputArray)\n        );\n    }\n\n    @Test\n    void testFindHamiltonianCycleShouldReturnInfinityArray() {\n        int[] expectedArray = { -1, -1, -1, -1, -1, -1 };\n\n        int[][] inputArray = {\n            { 0, 1, 0, 1, 0 },\n            { 1, 0, 1, 1, 1 },\n            { 0, 1, 0, 0, 1 },\n            { 1, 1, 0, 0, 0 },\n            { 0, 1, 1, 0, 0 },\n        };\n\n        assertArrayEquals(\n            expectedArray,\n            hamiltonianCycle.findHamiltonianCycle(inputArray)\n        );\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\n\npublic class GenericHashMapUsingArrayList<K, V> {\n    ArrayList<LinkedList<Node>> buckets;\n    private float lf = 0.5f;\n    private int size;\n\n    public GenericHashMapUsingArrayList() {\n        buckets = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            buckets.add(new LinkedList<>());\n        }\n        size = 0;\n    }\n\n    public void put(K key, V value) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                node.val = value;\n                return;\n            }\n        }\n\n        nodes.add(new Node(key, value));\n        size++;\n\n        if ((float) size / buckets.size() > lf) {\n            reHash();\n        }\n    }\n\n    private void reHash() {\n        ArrayList<LinkedList<Node>> old = buckets;\n        buckets = new ArrayList<>();\n        size = 0;\n        for (int i = 0; i < old.size() * 2; i++) {\n            buckets.add(new LinkedList<>());\n        }\n        for (LinkedList<Node> nodes : buckets) {\n            for (Node node : nodes) {\n                put(node.key, node.val);\n            }\n        }\n    }\n\n    public V get(K key) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                return node.val;\n            }\n        }\n        return null;\n    }\n\n    public void remove(K key) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n\n        Node target = null;\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                target = node;\n                break;\n            }\n        }\n        nodes.remove(target);\n        size--;\n    }\n\n    public boolean containsKey(K key) {\n        return get(key) != null;\n    }\n\n    public int size() {\n        return this.size;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"{\");\n        for (LinkedList<Node> nodes : buckets) {\n            for (Node node : nodes) {\n                builder.append(node.key);\n                builder.append(\" : \");\n                builder.append(node.val);\n                builder.append(\", \");\n            }\n        }\n        builder.append(\"}\");\n        return builder.toString();\n    }\n\n    private class Node {\n        K key;\n        V val;\n\n        public Node(K key, V val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\n\npublic class GenericHashMapUsingArrayList<K, V> {\n\n    ArrayList<LinkedList<Node>> buckets;\n    private float lf = 0.5f;\n    private int size;\n\n    public GenericHashMapUsingArrayList() {\n        buckets = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            buckets.add(new LinkedList<>());\n        }\n        size = 0;\n    }\n\n    public void put(K key, V value) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                node.val = value;\n                return;\n            }\n        }\n\n        nodes.add(new Node(key, value));\n        size++;\n\n        if ((float) size / buckets.size() > lf) {\n            reHash();\n        }\n    }\n\n    private void reHash() {\n        ArrayList<LinkedList<Node>> old = buckets;\n        buckets = new ArrayList<>();\n        size = 0;\n        for (int i = 0; i < old.size() * 2; i++) {\n            buckets.add(new LinkedList<>());\n        }\n        for (LinkedList<Node> nodes : buckets) {\n            for (Node node : nodes) {\n                put(node.key, node.val);\n            }\n        }\n    }\n\n    public V get(K key) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                return node.val;\n            }\n        }\n        return null;\n    }\n\n    public void remove(K key) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n\n        Node target = null;\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                target = node;\n                break;\n            }\n        }\n        nodes.remove(target);\n        size--;\n    }\n\n    public boolean containsKey(K key) {\n        return get(key) != null;\n    }\n\n    public int size() {\n        return this.size;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"{\");\n        for (LinkedList<Node> nodes : buckets) {\n            for (Node node : nodes) {\n                builder.append(node.key);\n                builder.append(\" : \");\n                builder.append(node.val);\n                builder.append(\", \");\n            }\n        }\n        builder.append(\"}\");\n        return builder.toString();\n    }\n\n    private class Node {\n\n        K key;\n        V val;\n\n        public Node(K key, V val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass GenericHashMapUsingArrayListTest {\n    @Test\n    void testGenericHashmapWhichUsesArrayAndBothKeyAndValueAreStrings() {\n        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n        map.put(\"USA\", \"Washington DC\");\n        map.put(\"Nepal\", \"Kathmandu\");\n        map.put(\"India\", \"New Delhi\");\n        map.put(\"Australia\", \"Sydney\");\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(\"Kathmandu\", map.get(\"Nepal\"));\n        assertEquals(\"Sydney\", map.get(\"Australia\"));\n    }\n\n    @Test\n    void testGenericHashmapWhichUsesArrayAndKeyIsStringValueIsInteger() {\n        GenericHashMapUsingArrayList<String, Integer> map = new GenericHashMapUsingArrayList<>();\n        map.put(\"USA\", 87);\n        map.put(\"Nepal\", 25);\n        map.put(\"India\", 101);\n        map.put(\"Australia\", 99);\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(25, map.get(\"Nepal\"));\n        assertEquals(99, map.get(\"Australia\"));\n        map.remove(\"Nepal\");\n        assertFalse(map.containsKey(\"Nepal\"));\n    }\n\n    @Test\n    void testGenericHashmapWhichUsesArrayAndKeyIsIntegerValueIsString() {\n        GenericHashMapUsingArrayList<Integer, String> map = new GenericHashMapUsingArrayList<>();\n        map.put(101, \"Washington DC\");\n        map.put(34, \"Kathmandu\");\n        map.put(46, \"New Delhi\");\n        map.put(89, \"Sydney\");\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(\"Sydney\", map.get(89));\n        assertEquals(\"Washington DC\", map.get(101));\n        assertTrue(map.containsKey(46));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass GenericHashMapUsingArrayListTest {\n\n    @Test\n    void testGenericHashmapWhichUsesArrayAndBothKeyAndValueAreStrings() {\n        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n        map.put(\"USA\", \"Washington DC\");\n        map.put(\"Nepal\", \"Kathmandu\");\n        map.put(\"India\", \"New Delhi\");\n        map.put(\"Australia\", \"Sydney\");\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(\"Kathmandu\", map.get(\"Nepal\"));\n        assertEquals(\"Sydney\", map.get(\"Australia\"));\n    }\n\n    @Test\n    void testGenericHashmapWhichUsesArrayAndKeyIsStringValueIsInteger() {\n        GenericHashMapUsingArrayList<String, Integer> map = new GenericHashMapUsingArrayList<>();\n        map.put(\"USA\", 87);\n        map.put(\"Nepal\", 25);\n        map.put(\"India\", 101);\n        map.put(\"Australia\", 99);\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(25, map.get(\"Nepal\"));\n        assertEquals(99, map.get(\"Australia\"));\n        map.remove(\"Nepal\");\n        assertFalse(map.containsKey(\"Nepal\"));\n    }\n\n    @Test\n    void testGenericHashmapWhichUsesArrayAndKeyIsIntegerValueIsString() {\n        GenericHashMapUsingArrayList<Integer, String> map = new GenericHashMapUsingArrayList<>();\n        map.put(101, \"Washington DC\");\n        map.put(34, \"Kathmandu\");\n        map.put(46, \"New Delhi\");\n        map.put(89, \"Sydney\");\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(\"Sydney\", map.get(89));\n        assertEquals(\"Washington DC\", map.get(101));\n        assertTrue(map.containsKey(46));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/heaps/FibonacciHeapTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.heaps;\n\n\npublic class FibonacciHeap {\n\n    private static final double GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\n    private HeapNode min;\n    private static int totalLinks = 0;\n    private static int totalCuts = 0;\n    private int numOfTrees = 0;\n    private int numOfHeapNodes = 0;\n    private int markedHeapNoodesCounter = 0;\n\n    /*\n     * a constructor for an empty Heap\n     * set the min to be null\n     */\n    public FibonacciHeap() {\n        this.min = null;\n    }\n\n    /*\n     * a constructor for a Heap with one element\n     * set the min to be the HeapNode with the given key\n     * @pre key>=0\n     * @post empty == false\n     */\n    public FibonacciHeap(int key) {\n        this.min = new HeapNode(key);\n        this.numOfTrees++;\n        this.numOfHeapNodes++;\n    }\n\n    /*\n     * check if the heap is empty\n     * $ret == true - if the tree is empty\n     */\n    public boolean empty() {\n        return (this.min == null);\n    }\n\n    /**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */\n    public HeapNode insert(int key) {\n        HeapNode toInsert = new HeapNode(key);              //creates the node\n        if (this.empty()) {\n            this.min = toInsert;\n        } else { //tree is not empty\n            min.setNext(toInsert);\n            this.updateMin(toInsert);\n        }\n        this.numOfHeapNodes++;\n        this.numOfTrees++;\n        return toInsert;\n    }\n\n    /**\n     * Delete the node containing the minimum key in the heap\n     * updates new min\n     *\n     * @post (numOfnodes = = $prev numOfnodes - 1)\n     */\n    public void deleteMin() {\n        if (this.empty()) {\n            return;\n        }\n        if (this.numOfHeapNodes == 1) { //if there is only one tree\n            this.min = null;\n            this.numOfTrees--;\n            this.numOfHeapNodes--;\n            return;\n        }\n        //change all children's parent to null//\n        if (this.min.child != null) { //min has a child\n            HeapNode child = this.min.child;\n            HeapNode tmpChild = child;\n            child.parent = null;\n            while (child.next != tmpChild) {\n                child = child.next;\n                child.parent = null;\n            }\n        }\n        //delete the node//\n        if (this.numOfTrees > 1) {\n            (this.min.prev).next = this.min.next;\n            (this.min.next).prev = this.min.prev;\n            if (this.min.child != null) {\n                (this.min.prev).setNext(this.min.child);\n            }\n        } else { //this.numOfTrees = 1\n            this.min = this.min.child;\n        }\n        this.numOfHeapNodes--;\n        this.successiveLink(this.min.getNext());\n    }\n\n    /**\n     * Return the node of the heap whose key is minimal.\n     * $ret == null if (empty==true)\n     */\n    public HeapNode findMin() {\n        return this.min;\n    }\n\n    /**\n     * Meld the heap with heap2\n     *\n     * @pre heap2 != null\n     * @post (numOfnodes = = $prev numOfnodes + heap2.numOfnodes)\n     */\n    public void meld(FibonacciHeap heap2) {\n        if (heap2.empty()) {\n            return;\n        }\n        if (this.empty()) {\n            this.min = heap2.min;\n        } else {\n            this.min.setNext(heap2.min);\n            this.updateMin(heap2.min);\n        }\n        this.numOfTrees += heap2.numOfTrees;\n        this.numOfHeapNodes += heap2.numOfHeapNodes;\n    }\n\n    /**\n     * Return the number of elements in the heap\n     * $ret == 0 if heap is empty\n     */\n    public int size() {\n        return this.numOfHeapNodes;\n    }\n\n    /**\n     * Return a counters array, where the value of the i-th index is the number of trees with rank i in the heap.\n     * returns an empty array for an empty heap\n     */\n    public int[] countersRep() {\n        if (this.empty()) {\n            return new int[0];     ///return an empty array\n        }\n        int[] rankArray = new int[(int) Math.floor(Math.log(this.size()) / Math.log(GOLDEN_RATIO)) + 1];  //creates the array\n        rankArray[this.min.rank]++;\n        HeapNode curr = this.min.next;\n        while (curr != this.min) {\n            rankArray[curr.rank]++;\n            curr = curr.next;\n        }\n        return rankArray;\n    }\n\n    /**\n     * Deletes the node x from the heap (using decreaseKey(x) to -1)\n     *\n     * @pre heap contains x\n     * @post (numOfnodes = = $prev numOfnodes - 1)\n     */\n    public void delete(HeapNode x) {\n        this.decreaseKey(x, x.getKey() + 1);         //change key to be the minimal (-1)\n        this.deleteMin();                           //delete it\n    }\n\n    /**\n     * The function decreases the key of the node x by delta.\n     *\n     * @pre x.key >= delta (we don't realize it when calling from delete())\n     * @pre heap contains x\n     */\n    private void decreaseKey(HeapNode x, int delta) {\n        int newKey = x.getKey() - delta;\n        x.key = newKey;\n        if (x.isRoot()) {//no parent to x\n            this.updateMin(x);\n            return;\n        }\n        if (x.getKey() >= x.parent.getKey()) {\n            return;\n        } //we don't need to cut\n        HeapNode prevParent = x.parent;\n        this.cut(x);\n        this.cascadingCuts(prevParent);\n    }\n\n    /**\n     * returns the current potential of the heap, which is:\n     * Potential = #trees + 2*#markedNodes\n     */\n    public int potential() {\n        return numOfTrees + (2 * markedHeapNoodesCounter);\n    }\n\n    /**\n     * This static function returns the total number of link operations made during the run-time of the program.\n     * A link operation is the operation which gets as input two trees of the same rank, and generates a tree of\n     * rank bigger by one.\n     */\n    public static int totalLinks() {\n        return totalLinks;\n    }\n\n    /**\n     * This static function returns the total number of cut operations made during the run-time of the program.\n     * A cut operation is the operation which disconnects a subtree from its parent (during decreaseKey/delete methods).\n     */\n    public static int totalCuts() {\n        return totalCuts;\n    }\n\n    /*\n     * updates the min of the heap (if needed)\n     * @pre this.min == @param (posMin) if and only if (posMin.key < this.min.key)\n     */\n    private void updateMin(HeapNode posMin) {\n        if (posMin.getKey() < this.min.getKey()) {\n            this.min = posMin;\n        }\n    }\n\n    /*\n     * Recursively \"runs\" all the way up from @param (curr) and mark the nodes.\n     * stop the recursion if we had arrived to a marked node or to a root.\n     * if we arrived to a marked node, we cut it and continue recursively.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */\n    private void cascadingCuts(HeapNode curr) {\n        if (!curr.isMarked()) {                      //stop the recursion\n            curr.mark();\n            if (!curr.isRoot()) this.markedHeapNoodesCounter++;\n            return;\n        } else {\n            if (curr.isRoot()) {\n                return;\n            }\n            HeapNode prevParent = curr.parent;\n            this.cut(curr);\n            this.cascadingCuts(prevParent);\n        }\n    }\n\n    /*\n     * cut a node (and his \"subtree\") from his origin tree and connect it to the heap as a new tree.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */\n    private void cut(HeapNode curr) {\n        curr.parent.rank--;\n        if (curr.marked) {\n            this.markedHeapNoodesCounter--;\n            curr.marked = false;\n        }\n        if (curr.parent.child == curr) { //we should change the parent's child\n            if (curr.next == curr) { //curr do not have brothers\n                curr.parent.child = null;\n            } else {//curr have brothers\n                curr.parent.child = curr.next;\n            }\n        }\n        curr.prev.next = curr.next;\n        curr.next.prev = curr.prev;\n        curr.next = curr;\n        curr.prev = curr;\n        curr.parent = null;\n        this.min.setNext(curr);\n        this.updateMin(curr);\n        this.numOfTrees++;\n        totalCuts++;\n    }\n\n\n    /*\n     *\n     */\n    private void successiveLink(HeapNode curr) {\n        HeapNode[] buckets = this.toBuckets(curr);\n        this.min = this.fromBuckets(buckets);\n    }\n\n    /*\n     *\n     */\n    private HeapNode[] toBuckets(HeapNode curr) {\n        HeapNode[] buckets = new HeapNode[(int) Math.floor(Math.log(this.size()) / Math.log(GOLDEN_RATIO)) + 1];\n        curr.prev.next = null;\n        HeapNode tmpCurr;\n        while (curr != null) {\n            tmpCurr = curr;\n            curr = curr.next;\n            tmpCurr.next = tmpCurr;\n            tmpCurr.prev = tmpCurr;\n            while (buckets[tmpCurr.rank] != null) {\n                tmpCurr = this.link(tmpCurr, buckets[tmpCurr.rank]);\n                buckets[tmpCurr.rank - 1] = null;\n            }\n            buckets[tmpCurr.rank] = tmpCurr;\n        }\n        return buckets;\n    }\n\n    /*\n     *\n     */\n    private HeapNode fromBuckets(HeapNode[] buckets) {\n        HeapNode tmpMin = null;\n        this.numOfTrees = 0;\n        for (int i = 0; i < buckets.length; i++) {\n            if (buckets[i] != null) {\n                this.numOfTrees++;\n                if (tmpMin == null) {\n                    tmpMin = buckets[i];\n                    tmpMin.next = tmpMin;\n                    tmpMin.prev = tmpMin;\n                } else {\n                    tmpMin.setNext(buckets[i]);\n                    if (buckets[i].getKey() < tmpMin.getKey()) {\n                        tmpMin = buckets[i];\n                    }\n                }\n            }\n        }\n        return tmpMin;\n    }\n\n    /*\n     * link between two nodes (and their trees)\n     * defines the smaller node to be the parent\n     */\n    private HeapNode link(HeapNode c1, HeapNode c2) {\n        if (c1.getKey() > c2.getKey()) {\n            HeapNode c3 = c1;\n            c1 = c2;\n            c2 = c3;\n        }\n        if (c1.child == null) {\n            c1.child = c2;\n        } else {\n            c1.child.setNext(c2);\n        }\n        c2.parent = c1;\n        c1.rank++;\n        totalLinks++;\n        return c1;\n    }\n\n\n    /**\n     * public class HeapNode\n     * each HeapNode belongs to a heap (Inner class)\n     */\n    public class HeapNode {\n\n        public int key;\n        private int rank;\n        private boolean marked;\n        private HeapNode child;\n        private HeapNode next;\n        private HeapNode prev;\n        private HeapNode parent;\n\n        /*\n         * a constructor for a heapNode withe key @param (key)\n         * prev == next == this\n         * parent == child == null\n         */\n        public HeapNode(int key) {\n            this.key = key;\n            this.marked = false;\n            this.next = this;\n            this.prev = this;\n        }\n\n        /*\n         * returns the key of the node.\n         */\n        public int getKey() {\n            return this.key;\n        }\n\n\n        /*\n         * checks whether the node is marked\n         * $ret = true if one child has been cut\n         */\n        private boolean isMarked() {\n            return this.marked;\n        }\n\n        /*\n         * mark a node (after a child was cut)\n         * @inv root.mark() == false.\n         */\n        private void mark() {\n            if (this.isRoot()) {\n                return;\n            }  //check if the node is a root\n            this.marked = true;\n        }\n\n        /*\n         * add the node @param (newNext) to be between this and this.next\n         * works fine also if @param (newNext) does not \"stands\" alone\n         */\n        private void setNext(HeapNode newNext) {\n            HeapNode tmpNext = this.next;\n            this.next = newNext;\n            this.next.prev.next = tmpNext;\n            tmpNext.prev = newNext.prev;\n            this.next.prev = this;\n        }\n\n        /*\n         * returns the next node to this node\n         */\n        private HeapNode getNext() {\n            return this.next;\n        }\n\n        /*\n         * check if the node is a root\n         * root definition - this.parent == null (uppest in his tree)\n         */\n        private boolean isRoot() {\n            return (this.parent == null);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.heaps;\n\npublic class FibonacciHeap {\n\n    private static final double GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\n    private HeapNode min;\n    private static int totalLinks = 0;\n    private static int totalCuts = 0;\n    private int numOfTrees = 0;\n    private int numOfHeapNodes = 0;\n    private int markedHeapNoodesCounter = 0;\n\n    /*\n     * a constructor for an empty Heap\n     * set the min to be null\n     */\n    public FibonacciHeap() {\n        this.min = null;\n    }\n\n    /*\n     * a constructor for a Heap with one element\n     * set the min to be the HeapNode with the given key\n     * @pre key>=0\n     * @post empty == false\n     */\n    public FibonacciHeap(int key) {\n        this.min = new HeapNode(key);\n        this.numOfTrees++;\n        this.numOfHeapNodes++;\n    }\n\n    /*\n     * check if the heap is empty\n     * $ret == true - if the tree is empty\n     */\n    public boolean empty() {\n        return (this.min == null);\n    }\n\n    /**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */\n    public HeapNode insert(int key) {\n        HeapNode toInsert = new HeapNode(key); //creates the node\n        if (this.empty()) {\n            this.min = toInsert;\n        } else { //tree is not empty\n            min.setNext(toInsert);\n            this.updateMin(toInsert);\n        }\n        this.numOfHeapNodes++;\n        this.numOfTrees++;\n        return toInsert;\n    }\n\n    /**\n     * Delete the node containing the minimum key in the heap\n     * updates new min\n     *\n     * @post (numOfnodes = = $prev numOfnodes - 1)\n     */\n    public void deleteMin() {\n        if (this.empty()) {\n            return;\n        }\n        if (this.numOfHeapNodes == 1) { //if there is only one tree\n            this.min = null;\n            this.numOfTrees--;\n            this.numOfHeapNodes--;\n            return;\n        }\n        //change all children's parent to null//\n        if (this.min.child != null) { //min has a child\n            HeapNode child = this.min.child;\n            HeapNode tmpChild = child;\n            child.parent = null;\n            while (child.next != tmpChild) {\n                child = child.next;\n                child.parent = null;\n            }\n        }\n        //delete the node//\n        if (this.numOfTrees > 1) {\n            (this.min.prev).next = this.min.next;\n            (this.min.next).prev = this.min.prev;\n            if (this.min.child != null) {\n                (this.min.prev).setNext(this.min.child);\n            }\n        } else { //this.numOfTrees = 1\n            this.min = this.min.child;\n        }\n        this.numOfHeapNodes--;\n        this.successiveLink(this.min.getNext());\n    }\n\n    /**\n     * Return the node of the heap whose key is minimal.\n     * $ret == null if (empty==true)\n     */\n    public HeapNode findMin() {\n        return this.min;\n    }\n\n    /**\n     * Meld the heap with heap2\n     *\n     * @pre heap2 != null\n     * @post (numOfnodes = = $prev numOfnodes + heap2.numOfnodes)\n     */\n    public void meld(FibonacciHeap heap2) {\n        if (heap2.empty()) {\n            return;\n        }\n        if (this.empty()) {\n            this.min = heap2.min;\n        } else {\n            this.min.setNext(heap2.min);\n            this.updateMin(heap2.min);\n        }\n        this.numOfTrees += heap2.numOfTrees;\n        this.numOfHeapNodes += heap2.numOfHeapNodes;\n    }\n\n    /**\n     * Return the number of elements in the heap\n     * $ret == 0 if heap is empty\n     */\n    public int size() {\n        return this.numOfHeapNodes;\n    }\n\n    /**\n     * Return a counters array, where the value of the i-th index is the number of trees with rank i in the heap.\n     * returns an empty array for an empty heap\n     */\n    public int[] countersRep() {\n        if (this.empty()) {\n            return new int[0]; ///return an empty array\n        }\n        int[] rankArray = new int[(int) Math.floor(\n            Math.log(this.size()) / Math.log(GOLDEN_RATIO)\n        ) +\n        1]; //creates the array\n        rankArray[this.min.rank]++;\n        HeapNode curr = this.min.next;\n        while (curr != this.min) {\n            rankArray[curr.rank]++;\n            curr = curr.next;\n        }\n        return rankArray;\n    }\n\n    /**\n     * Deletes the node x from the heap (using decreaseKey(x) to -1)\n     *\n     * @pre heap contains x\n     * @post (numOfnodes = = $prev numOfnodes - 1)\n     */\n    public void delete(HeapNode x) {\n        this.decreaseKey(x, x.getKey() + 1); //change key to be the minimal (-1)\n        this.deleteMin(); //delete it\n    }\n\n    /**\n     * The function decreases the key of the node x by delta.\n     *\n     * @pre x.key >= delta (we don't realize it when calling from delete())\n     * @pre heap contains x\n     */\n    private void decreaseKey(HeapNode x, int delta) {\n        int newKey = x.getKey() - delta;\n        x.key = newKey;\n        if (x.isRoot()) { //no parent to x\n            this.updateMin(x);\n            return;\n        }\n        if (x.getKey() >= x.parent.getKey()) {\n            return;\n        } //we don't need to cut\n        HeapNode prevParent = x.parent;\n        this.cut(x);\n        this.cascadingCuts(prevParent);\n    }\n\n    /**\n     * returns the current potential of the heap, which is:\n     * Potential = #trees + 2*#markedNodes\n     */\n    public int potential() {\n        return numOfTrees + (2 * markedHeapNoodesCounter);\n    }\n\n    /**\n     * This static function returns the total number of link operations made during the run-time of the program.\n     * A link operation is the operation which gets as input two trees of the same rank, and generates a tree of\n     * rank bigger by one.\n     */\n    public static int totalLinks() {\n        return totalLinks;\n    }\n\n    /**\n     * This static function returns the total number of cut operations made during the run-time of the program.\n     * A cut operation is the operation which disconnects a subtree from its parent (during decreaseKey/delete methods).\n     */\n    public static int totalCuts() {\n        return totalCuts;\n    }\n\n    /*\n     * updates the min of the heap (if needed)\n     * @pre this.min == @param (posMin) if and only if (posMin.key < this.min.key)\n     */\n    private void updateMin(HeapNode posMin) {\n        if (posMin.getKey() < this.min.getKey()) {\n            this.min = posMin;\n        }\n    }\n\n    /*\n     * Recursively \"runs\" all the way up from @param (curr) and mark the nodes.\n     * stop the recursion if we had arrived to a marked node or to a root.\n     * if we arrived to a marked node, we cut it and continue recursively.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */\n    private void cascadingCuts(HeapNode curr) {\n        if (!curr.isMarked()) { //stop the recursion\n            curr.mark();\n            if (!curr.isRoot()) this.markedHeapNoodesCounter++;\n            return;\n        } else {\n            if (curr.isRoot()) {\n                return;\n            }\n            HeapNode prevParent = curr.parent;\n            this.cut(curr);\n            this.cascadingCuts(prevParent);\n        }\n    }\n\n    /*\n     * cut a node (and his \"subtree\") from his origin tree and connect it to the heap as a new tree.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */\n    private void cut(HeapNode curr) {\n        curr.parent.rank--;\n        if (curr.marked) {\n            this.markedHeapNoodesCounter--;\n            curr.marked = false;\n        }\n        if (curr.parent.child == curr) { //we should change the parent's child\n            if (curr.next == curr) { //curr do not have brothers\n                curr.parent.child = null;\n            } else { //curr have brothers\n                curr.parent.child = curr.next;\n            }\n        }\n        curr.prev.next = curr.next;\n        curr.next.prev = curr.prev;\n        curr.next = curr;\n        curr.prev = curr;\n        curr.parent = null;\n        this.min.setNext(curr);\n        this.updateMin(curr);\n        this.numOfTrees++;\n        totalCuts++;\n    }\n\n    /*\n     *\n     */\n    private void successiveLink(HeapNode curr) {\n        HeapNode[] buckets = this.toBuckets(curr);\n        this.min = this.fromBuckets(buckets);\n    }\n\n    /*\n     *\n     */\n    private HeapNode[] toBuckets(HeapNode curr) {\n        HeapNode[] buckets = new HeapNode[(int) Math.floor(\n            Math.log(this.size()) / Math.log(GOLDEN_RATIO)\n        ) +\n        1];\n        curr.prev.next = null;\n        HeapNode tmpCurr;\n        while (curr != null) {\n            tmpCurr = curr;\n            curr = curr.next;\n            tmpCurr.next = tmpCurr;\n            tmpCurr.prev = tmpCurr;\n            while (buckets[tmpCurr.rank] != null) {\n                tmpCurr = this.link(tmpCurr, buckets[tmpCurr.rank]);\n                buckets[tmpCurr.rank - 1] = null;\n            }\n            buckets[tmpCurr.rank] = tmpCurr;\n        }\n        return buckets;\n    }\n\n    /*\n     *\n     */\n    private HeapNode fromBuckets(HeapNode[] buckets) {\n        HeapNode tmpMin = null;\n        this.numOfTrees = 0;\n        for (int i = 0; i < buckets.length; i++) {\n            if (buckets[i] != null) {\n                this.numOfTrees++;\n                if (tmpMin == null) {\n                    tmpMin = buckets[i];\n                    tmpMin.next = tmpMin;\n                    tmpMin.prev = tmpMin;\n                } else {\n                    tmpMin.setNext(buckets[i]);\n                    if (buckets[i].getKey() < tmpMin.getKey()) {\n                        tmpMin = buckets[i];\n                    }\n                }\n            }\n        }\n        return tmpMin;\n    }\n\n    /*\n     * link between two nodes (and their trees)\n     * defines the smaller node to be the parent\n     */\n    private HeapNode link(HeapNode c1, HeapNode c2) {\n        if (c1.getKey() > c2.getKey()) {\n            HeapNode c3 = c1;\n            c1 = c2;\n            c2 = c3;\n        }\n        if (c1.child == null) {\n            c1.child = c2;\n        } else {\n            c1.child.setNext(c2);\n        }\n        c2.parent = c1;\n        c1.rank++;\n        totalLinks++;\n        return c1;\n    }\n\n    /**\n     * public class HeapNode\n     * each HeapNode belongs to a heap (Inner class)\n     */\n    public class HeapNode {\n\n        public int key;\n        private int rank;\n        private boolean marked;\n        private HeapNode child;\n        private HeapNode next;\n        private HeapNode prev;\n        private HeapNode parent;\n\n        /*\n         * a constructor for a heapNode withe key @param (key)\n         * prev == next == this\n         * parent == child == null\n         */\n        public HeapNode(int key) {\n            this.key = key;\n            this.marked = false;\n            this.next = this;\n            this.prev = this;\n        }\n\n        /*\n         * returns the key of the node.\n         */\n        public int getKey() {\n            return this.key;\n        }\n\n        /*\n         * checks whether the node is marked\n         * $ret = true if one child has been cut\n         */\n        private boolean isMarked() {\n            return this.marked;\n        }\n\n        /*\n         * mark a node (after a child was cut)\n         * @inv root.mark() == false.\n         */\n        private void mark() {\n            if (this.isRoot()) {\n                return;\n            } //check if the node is a root\n            this.marked = true;\n        }\n\n        /*\n         * add the node @param (newNext) to be between this and this.next\n         * works fine also if @param (newNext) does not \"stands\" alone\n         */\n        private void setNext(HeapNode newNext) {\n            HeapNode tmpNext = this.next;\n            this.next = newNext;\n            this.next.prev.next = tmpNext;\n            tmpNext.prev = newNext.prev;\n            this.next.prev = this;\n        }\n\n        /*\n         * returns the next node to this node\n         */\n        private HeapNode getNext() {\n            return this.next;\n        }\n\n        /*\n         * check if the node is a root\n         * root definition - this.parent == null (uppest in his tree)\n         */\n        private boolean isRoot() {\n            return (this.parent == null);\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class FibonacciHeapTest{\n\n    @Test\n    void testHeap(){\n        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n        fibonacciHeap.insert(5);\n        fibonacciHeap.insert(3);\n        fibonacciHeap.insert(1);\n        fibonacciHeap.insert(18);\n        fibonacciHeap.insert(33);\n\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 1);\n        fibonacciHeap.deleteMin();\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 3);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class FibonacciHeapTest {\n\n    @Test\n    void testHeap() {\n        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n        fibonacciHeap.insert(5);\n        fibonacciHeap.insert(3);\n        fibonacciHeap.insert(1);\n        fibonacciHeap.insert(18);\n        fibonacciHeap.insert(33);\n\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 1);\n        fibonacciHeap.deleteMin();\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 3);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/heaps/Heap.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/heaps/FibonacciHeapTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.heaps;\n\n/**\n * Interface common to heap data structures.<br>\n *\n * <p>\n * Heaps are tree-like data structures that allow storing elements in a specific\n * way. Each node corresponds to an element and has one parent node (except for\n * the root) and at most two children nodes. Every element contains a key, and\n * those keys indicate how the tree shall be built. For instance, for a\n * min-heap, the key of a node shall be greater than or equal to its parent's\n * and lower than or equal to its children's (the opposite rule applies to a\n * max-heap).\n *\n * <p>\n * All heap-related operations (inserting or deleting an element, extracting the\n * min or max) are performed in O(log n) time.\n *\n * @author Nicolas Renard\n */\npublic interface Heap {\n\n    /**\n     * @return the top element in the heap, the one with lowest key for min-heap\n     * or with the highest key for max-heap\n     * @throws EmptyHeapException if heap is empty\n     */\n    HeapElement getElement() throws EmptyHeapException;\n\n    /**\n     * Inserts an element in the heap. Adds it to then end and toggle it until\n     * it finds its right position.\n     *\n     * @param element an instance of the HeapElement class.\n     */\n    void insertElement(HeapElement element);\n\n    /**\n     * Delete an element in the heap.\n     *\n     * @param elementIndex int containing the position in the heap of the\n     * element to be deleted.\n     */\n    void deleteElement(int elementIndex);\n}",
        "product_new_content": "package com.thealgorithms.datastructures.heaps;\n\n/**\n * Interface common to heap data structures.<br>\n *\n * <p>\n * Heaps are tree-like data structures that allow storing elements in a specific\n * way. Each node corresponds to an element and has one parent node (except for\n * the root) and at most two children nodes. Every element contains a key, and\n * those keys indicate how the tree shall be built. For instance, for a\n * min-heap, the key of a node shall be greater than or equal to its parent's\n * and lower than or equal to its children's (the opposite rule applies to a\n * max-heap).\n *\n * <p>\n * All heap-related operations (inserting or deleting an element, extracting the\n * min or max) are performed in O(log n) time.\n *\n * @author Nicolas Renard\n */\npublic interface Heap {\n    /**\n     * @return the top element in the heap, the one with lowest key for min-heap\n     * or with the highest key for max-heap\n     * @throws EmptyHeapException if heap is empty\n     */\n    HeapElement getElement() throws EmptyHeapException;\n\n    /**\n     * Inserts an element in the heap. Adds it to then end and toggle it until\n     * it finds its right position.\n     *\n     * @param element an instance of the HeapElement class.\n     */\n    void insertElement(HeapElement element);\n\n    /**\n     * Delete an element in the heap.\n     *\n     * @param elementIndex int containing the position in the heap of the\n     * element to be deleted.\n     */\n    void deleteElement(int elementIndex);\n}",
        "test_old_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class FibonacciHeapTest{\n\n    @Test\n    void testHeap(){\n        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n        fibonacciHeap.insert(5);\n        fibonacciHeap.insert(3);\n        fibonacciHeap.insert(1);\n        fibonacciHeap.insert(18);\n        fibonacciHeap.insert(33);\n\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 1);\n        fibonacciHeap.deleteMin();\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 3);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class FibonacciHeapTest {\n\n    @Test\n    void testHeap() {\n        FibonacciHeap fibonacciHeap = new FibonacciHeap();\n        fibonacciHeap.insert(5);\n        fibonacciHeap.insert(3);\n        fibonacciHeap.insert(1);\n        fibonacciHeap.insert(18);\n        fibonacciHeap.insert(33);\n\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 1);\n        fibonacciHeap.deleteMin();\n        Assertions.assertEquals(fibonacciHeap.findMin().getKey(), 3);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SkipList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SkipListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            if (current.next(i) != null) {\n                current.next(i).setPrevious(i, current.previous(i));\n            }\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                .map(layer -> {\n                    StringBuilder acc = new StringBuilder();\n                    for (boolean b : layer) {\n                        if (b) {\n                            acc.append(\"[ ]\");\n                        } else {\n                            acc.append(\"---\");\n                        }\n                        acc.append(\" \");\n                    }\n                    return acc.toString();\n                })\n                .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1)\n                .mapToObj(i -> String.format(\"%3d\", i))\n                .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            if (current.next(i) != null) {\n                current.next(i).setPrevious(i, current.previous(i));\n            }\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers\n            .stream()\n            .map(layer -> {\n                StringBuilder acc = new StringBuilder();\n                for (boolean b : layer) {\n                    if (b) {\n                        acc.append(\"[ ]\");\n                    } else {\n                        acc.append(\"---\");\n                    }\n                    acc.append(\" \");\n                }\n                return acc.toString();\n            })\n            .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream\n            .range(0, sizeWithHeader - 1)\n            .mapToObj(i -> String.format(\"%3d\", i))\n            .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\n                    \"Probability should be from 0 to 1. But was: \" + probability\n                );\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(\n                Math.log10(expectedSize) / Math.log10(1 / probability)\n            );\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream.range(0, values.length)\n                .mapToObj(skipList::get)\n                .toArray(String[]::new);\n\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\nimport org.junit.jupiter.api.Test;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = { \"d\", \"b\", \"a\", \"c\" };\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream\n            .range(0, values.length)\n            .mapToObj(skipList::get)\n            .toArray(String[]::new);\n\n        assertArrayEquals(new String[] { \"a\", \"b\", \"c\", \"d\" }, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\n            \"a\",\n            \"b\",\n            \"c\",\n            \"d\",\n            \"e\",\n            \"f\",\n            \"g\",\n            \"h\",\n            \"i\",\n            \"j\",\n            \"k\",\n        };\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/KDTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/KDTreeTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/*\n * K-D Tree Implementation\n * Wikipedia: https://en.wikipedia.org/wiki/K-d_tree\n *\n * Author: Amir Hosseini (https://github.com/itsamirhn)\n *\n * */\n\npublic class KDTree {\n\n    private Node root;\n\n    private final int k; // Dimensions of the points\n\n    /**\n     * Constructor for empty KDTree\n     *\n     * @param k Number of dimensions\n     */\n    KDTree(int k) {\n        this.k = k;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     */\n    KDTree(Point[] points) {\n        if (points.length == 0) throw new IllegalArgumentException(\"Points array cannot be empty\");\n        this.k = points[0].getDimension();\n        for (Point point : points) if (point.getDimension() != k) throw new IllegalArgumentException(\"Points must have the same dimension\");\n        this.root = build(points, 0);\n    }\n\n    /**\n     * Builds the KDTree from the specified coordinates of the points\n     *\n     * @param pointsCoordinates Array of initial points coordinates\n     *\n     */\n    KDTree(int[][] pointsCoordinates) {\n        if (pointsCoordinates.length == 0) throw new IllegalArgumentException(\"Points array cannot be empty\");\n        this.k = pointsCoordinates[0].length;\n        Point[] points = Arrays.stream(pointsCoordinates)\n                .map(Point::new)\n                .toArray(Point[]::new);\n        for (Point point : points) if (point.getDimension() != k) throw new IllegalArgumentException(\"Points must have the same dimension\");\n        this.root = build(points, 0);\n    }\n\n    static class Point {\n        int[] coordinates;\n\n        public int getCoordinate(int i) {\n            return coordinates[i];\n        }\n\n        public int getDimension() {\n            return coordinates.length;\n        }\n\n        public Point(int[] coordinates) {\n            this.coordinates = coordinates;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Point other) {\n                if (other.getDimension() != this.getDimension()) return false;\n                return Arrays.equals(other.coordinates, this.coordinates);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(coordinates);\n        }\n\n        /**\n         * Find the comparable distance between two points (without SQRT)\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         *\n         * @return The comparable distance between the two points\n         */\n        static public int comparableDistance(Point p1, Point p2) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n\n        /**\n         * Find the comparable distance between two points with ignoring specified axis\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         * @param axis The axis to ignore\n         *\n         * @return The distance between the two points\n         */\n        static public int comparableDistanceExceptAxis(Point p1, Point p2, int axis) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                if (i == axis) continue;\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n    }\n\n\n    static class Node {\n        private Point point;\n        private int axis; // 0 for x, 1 for y, 2 for z, etc.\n\n        private Node left = null; // Left child\n        private Node right = null; // Right child\n\n        Node(Point point, int axis) {\n            this.point = point;\n            this.axis = axis;\n        }\n\n        public Point getPoint() {\n            return point;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n\n        public int getAxis() {\n            return axis;\n        }\n\n        /**\n         * Get the nearest child according to the specified point\n         *\n         * @param point The point to find the nearest child to\n         *\n         * @return The nearest child Node\n         */\n        public Node getNearChild(Point point) {\n            if (point.getCoordinate(axis) < this.point.getCoordinate(axis)) return left;\n            else return right;\n        }\n\n        /**\n         * Get the farthest child according to the specified point\n         *\n         * @param point The point to find the farthest child to\n         *\n         * @return The farthest child Node\n         */\n        public Node getFarChild(Point point) {\n            if (point.getCoordinate(axis) < this.point.getCoordinate(axis)) return right;\n            else return left;\n        }\n\n        /**\n         * Get the node axis coordinate of point\n         *\n         * @return The axis coordinate of the point\n         */\n        public int getAxisCoordinate() {\n            return point.getCoordinate(axis);\n        }\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node build(Point[] points, int depth) {\n        if (points.length == 0) return null;\n        int axis = depth % k;\n        if (points.length == 1) return new Node(points[0], axis);\n        Arrays.sort(points, Comparator.comparingInt(o -> o.getCoordinate(axis)));\n        int median = points.length >> 1;\n        Node node = new Node(points[median], axis);\n        node.left = build(Arrays.copyOfRange(points, 0, median), depth + 1);\n        node.right = build(Arrays.copyOfRange(points, median + 1, points.length), depth + 1);\n        return node;\n    }\n\n    /**\n     * Insert a point into the KDTree\n     *\n     * @param point The point to insert\n     *\n     */\n    public void insert(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\"Point has wrong dimension\");\n        root = insert(root, point, 0);\n    }\n\n    /**\n     * Insert a point into a subtree\n     *\n     * @param root The root of the subtree\n     * @param point The point to insert\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node insert(Node root, Point point, int depth) {\n        int axis = depth % k;\n        if (root == null) return new Node(point, axis);\n        if (point.getCoordinate(axis) < root.getAxisCoordinate()) root.left = insert(root.left, point, depth + 1);\n        else root.right = insert(root.right, point, depth + 1);\n\n        return root;\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in the KDTree\n     *\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\"Point has wrong dimension\");\n        return search(root, point);\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Node root, Point point) {\n        if (root == null) return Optional.empty();\n        if (root.point.equals(point)) return Optional.of(root);\n        return search(root.getNearChild(point), point);\n    }\n\n\n    /**\n     * Find a point with minimum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The point with minimum value in the specified axis\n     */\n    public Point findMin(int axis) {\n        return findMin(root, axis).point;\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The Node with minimum value in the specified axis of the point\n     */\n    public Node findMin(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.left == null) return root;\n            return findMin(root.left, axis);\n        } else {\n            Node left = findMin(root.left, axis);\n            Node right = findMin(root.right, axis);\n            Node[] candidates = {left, root, right};\n            return Arrays.stream(candidates)\n                        .filter(Objects::nonNull)\n                        .min(Comparator.comparingInt(a -> a.point.getCoordinate(axis))).orElse(null);\n        }\n    }\n\n\n    /**\n     * Find a point with maximum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The point with maximum value in the specified axis\n     */\n    public Point findMax(int axis) {\n        return findMax(root, axis).point;\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The Node with maximum value in the specified axis of the point\n     */\n    public Node findMax(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.right == null) return root;\n            return findMax(root.right, axis);\n        } else {\n            Node left = findMax(root.left, axis);\n            Node right = findMax(root.right, axis);\n            Node[] candidates = {left, root, right};\n            return Arrays.stream(candidates)\n                        .filter(Objects::nonNull)\n                        .max(Comparator.comparingInt(a -> a.point.getCoordinate(axis))).orElse(null);\n        }\n    }\n\n    /**\n     * Delete the node with the given point.\n     *\n     * @param point the point to delete\n     * */\n    public void delete(Point point) {\n        Node node = search(point).orElseThrow(() -> new IllegalArgumentException(\"Point not found\"));\n        root = delete(root, node);\n    }\n\n    /**\n     * Delete the specified node from a subtree.\n     *\n     * @param root The root of the subtree to delete from\n     * @param node The node to delete\n     *\n     * @return The new root of the subtree\n     */\n    private Node delete(Node root, Node node) {\n        if (root == null) return null;\n        if (root.equals(node)) {\n            if (root.right != null) {\n                Node min = findMin(root.right, root.getAxis());\n                root.point = min.point;\n                root.right = delete(root.right, min);\n            } else if (root.left != null) {\n                Node min = findMin(root.left, root.getAxis());\n                root.point = min.point;\n                root.left = delete(root.left, min);\n            } else return null;\n        }\n        if (root.getAxisCoordinate() < node.point.getCoordinate(root.getAxis())) root.left = delete(root.left, node);\n        else root.right = delete(root.right, node);\n        return root;\n    }\n\n    /**\n     * Finds the nearest point in the tree to the given point.\n     *\n     * @param point The point to find the nearest neighbor to.\n     * */\n    public Point findNearest(Point point) {\n        return findNearest(root, point, root).point;\n    }\n\n\n    /**\n     * Finds the nearest point in a subtree to the given point.\n     *\n     * @param root The root of the subtree to search in.\n     * @param point The point to find the nearest neighbor to.\n     * @param nearest The nearest neighbor found so far.\n     * */\n    private Node findNearest(Node root, Point point, Node nearest) {\n        if (root == null) return nearest;\n        if (root.point.equals(point)) return root;\n        int distance = Point.comparableDistance(root.point, point);\n        int distanceExceptAxis = Point.comparableDistanceExceptAxis(root.point, point, root.getAxis());\n        if (distance < Point.comparableDistance(nearest.point, point)) nearest = root;\n        nearest = findNearest(root.getNearChild(point), point, nearest);\n        if (distanceExceptAxis < Point.comparableDistance(nearest.point, point))\n            nearest = findNearest(root.getFarChild(point), point, nearest);\n        return nearest;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/*\n * K-D Tree Implementation\n * Wikipedia: https://en.wikipedia.org/wiki/K-d_tree\n *\n * Author: Amir Hosseini (https://github.com/itsamirhn)\n *\n * */\n\npublic class KDTree {\n\n    private Node root;\n\n    private final int k; // Dimensions of the points\n\n    /**\n     * Constructor for empty KDTree\n     *\n     * @param k Number of dimensions\n     */\n    KDTree(int k) {\n        this.k = k;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     */\n    KDTree(Point[] points) {\n        if (points.length == 0) throw new IllegalArgumentException(\n            \"Points array cannot be empty\"\n        );\n        this.k = points[0].getDimension();\n        for (Point point : points) if (\n            point.getDimension() != k\n        ) throw new IllegalArgumentException(\n            \"Points must have the same dimension\"\n        );\n        this.root = build(points, 0);\n    }\n\n    /**\n     * Builds the KDTree from the specified coordinates of the points\n     *\n     * @param pointsCoordinates Array of initial points coordinates\n     *\n     */\n    KDTree(int[][] pointsCoordinates) {\n        if (pointsCoordinates.length == 0) throw new IllegalArgumentException(\n            \"Points array cannot be empty\"\n        );\n        this.k = pointsCoordinates[0].length;\n        Point[] points = Arrays\n            .stream(pointsCoordinates)\n            .map(Point::new)\n            .toArray(Point[]::new);\n        for (Point point : points) if (\n            point.getDimension() != k\n        ) throw new IllegalArgumentException(\n            \"Points must have the same dimension\"\n        );\n        this.root = build(points, 0);\n    }\n\n    static class Point {\n\n        int[] coordinates;\n\n        public int getCoordinate(int i) {\n            return coordinates[i];\n        }\n\n        public int getDimension() {\n            return coordinates.length;\n        }\n\n        public Point(int[] coordinates) {\n            this.coordinates = coordinates;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Point other) {\n                if (other.getDimension() != this.getDimension()) return false;\n                return Arrays.equals(other.coordinates, this.coordinates);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(coordinates);\n        }\n\n        /**\n         * Find the comparable distance between two points (without SQRT)\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         *\n         * @return The comparable distance between the two points\n         */\n        public static int comparableDistance(Point p1, Point p2) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n\n        /**\n         * Find the comparable distance between two points with ignoring specified axis\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         * @param axis The axis to ignore\n         *\n         * @return The distance between the two points\n         */\n        public static int comparableDistanceExceptAxis(\n            Point p1,\n            Point p2,\n            int axis\n        ) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                if (i == axis) continue;\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n    }\n\n    static class Node {\n\n        private Point point;\n        private int axis; // 0 for x, 1 for y, 2 for z, etc.\n\n        private Node left = null; // Left child\n        private Node right = null; // Right child\n\n        Node(Point point, int axis) {\n            this.point = point;\n            this.axis = axis;\n        }\n\n        public Point getPoint() {\n            return point;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n\n        public int getAxis() {\n            return axis;\n        }\n\n        /**\n         * Get the nearest child according to the specified point\n         *\n         * @param point The point to find the nearest child to\n         *\n         * @return The nearest child Node\n         */\n        public Node getNearChild(Point point) {\n            if (\n                point.getCoordinate(axis) < this.point.getCoordinate(axis)\n            ) return left; else return right;\n        }\n\n        /**\n         * Get the farthest child according to the specified point\n         *\n         * @param point The point to find the farthest child to\n         *\n         * @return The farthest child Node\n         */\n        public Node getFarChild(Point point) {\n            if (\n                point.getCoordinate(axis) < this.point.getCoordinate(axis)\n            ) return right; else return left;\n        }\n\n        /**\n         * Get the node axis coordinate of point\n         *\n         * @return The axis coordinate of the point\n         */\n        public int getAxisCoordinate() {\n            return point.getCoordinate(axis);\n        }\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node build(Point[] points, int depth) {\n        if (points.length == 0) return null;\n        int axis = depth % k;\n        if (points.length == 1) return new Node(points[0], axis);\n        Arrays.sort(\n            points,\n            Comparator.comparingInt(o -> o.getCoordinate(axis))\n        );\n        int median = points.length >> 1;\n        Node node = new Node(points[median], axis);\n        node.left = build(Arrays.copyOfRange(points, 0, median), depth + 1);\n        node.right =\n            build(\n                Arrays.copyOfRange(points, median + 1, points.length),\n                depth + 1\n            );\n        return node;\n    }\n\n    /**\n     * Insert a point into the KDTree\n     *\n     * @param point The point to insert\n     *\n     */\n    public void insert(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\n            \"Point has wrong dimension\"\n        );\n        root = insert(root, point, 0);\n    }\n\n    /**\n     * Insert a point into a subtree\n     *\n     * @param root The root of the subtree\n     * @param point The point to insert\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node insert(Node root, Point point, int depth) {\n        int axis = depth % k;\n        if (root == null) return new Node(point, axis);\n        if (point.getCoordinate(axis) < root.getAxisCoordinate()) root.left =\n            insert(root.left, point, depth + 1); else root.right =\n            insert(root.right, point, depth + 1);\n\n        return root;\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in the KDTree\n     *\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\n            \"Point has wrong dimension\"\n        );\n        return search(root, point);\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Node root, Point point) {\n        if (root == null) return Optional.empty();\n        if (root.point.equals(point)) return Optional.of(root);\n        return search(root.getNearChild(point), point);\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The point with minimum value in the specified axis\n     */\n    public Point findMin(int axis) {\n        return findMin(root, axis).point;\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The Node with minimum value in the specified axis of the point\n     */\n    public Node findMin(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.left == null) return root;\n            return findMin(root.left, axis);\n        } else {\n            Node left = findMin(root.left, axis);\n            Node right = findMin(root.right, axis);\n            Node[] candidates = { left, root, right };\n            return Arrays\n                .stream(candidates)\n                .filter(Objects::nonNull)\n                .min(Comparator.comparingInt(a -> a.point.getCoordinate(axis)))\n                .orElse(null);\n        }\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The point with maximum value in the specified axis\n     */\n    public Point findMax(int axis) {\n        return findMax(root, axis).point;\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The Node with maximum value in the specified axis of the point\n     */\n    public Node findMax(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.right == null) return root;\n            return findMax(root.right, axis);\n        } else {\n            Node left = findMax(root.left, axis);\n            Node right = findMax(root.right, axis);\n            Node[] candidates = { left, root, right };\n            return Arrays\n                .stream(candidates)\n                .filter(Objects::nonNull)\n                .max(Comparator.comparingInt(a -> a.point.getCoordinate(axis)))\n                .orElse(null);\n        }\n    }\n\n    /**\n     * Delete the node with the given point.\n     *\n     * @param point the point to delete\n     * */\n    public void delete(Point point) {\n        Node node = search(point)\n            .orElseThrow(() -> new IllegalArgumentException(\"Point not found\"));\n        root = delete(root, node);\n    }\n\n    /**\n     * Delete the specified node from a subtree.\n     *\n     * @param root The root of the subtree to delete from\n     * @param node The node to delete\n     *\n     * @return The new root of the subtree\n     */\n    private Node delete(Node root, Node node) {\n        if (root == null) return null;\n        if (root.equals(node)) {\n            if (root.right != null) {\n                Node min = findMin(root.right, root.getAxis());\n                root.point = min.point;\n                root.right = delete(root.right, min);\n            } else if (root.left != null) {\n                Node min = findMin(root.left, root.getAxis());\n                root.point = min.point;\n                root.left = delete(root.left, min);\n            } else return null;\n        }\n        if (\n            root.getAxisCoordinate() < node.point.getCoordinate(root.getAxis())\n        ) root.left = delete(root.left, node); else root.right =\n            delete(root.right, node);\n        return root;\n    }\n\n    /**\n     * Finds the nearest point in the tree to the given point.\n     *\n     * @param point The point to find the nearest neighbor to.\n     * */\n    public Point findNearest(Point point) {\n        return findNearest(root, point, root).point;\n    }\n\n    /**\n     * Finds the nearest point in a subtree to the given point.\n     *\n     * @param root The root of the subtree to search in.\n     * @param point The point to find the nearest neighbor to.\n     * @param nearest The nearest neighbor found so far.\n     * */\n    private Node findNearest(Node root, Point point, Node nearest) {\n        if (root == null) return nearest;\n        if (root.point.equals(point)) return root;\n        int distance = Point.comparableDistance(root.point, point);\n        int distanceExceptAxis = Point.comparableDistanceExceptAxis(\n            root.point,\n            point,\n            root.getAxis()\n        );\n        if (distance < Point.comparableDistance(nearest.point, point)) nearest =\n            root;\n        nearest = findNearest(root.getNearChild(point), point, nearest);\n        if (\n            distanceExceptAxis < Point.comparableDistance(nearest.point, point)\n        ) nearest = findNearest(root.getFarChild(point), point, nearest);\n        return nearest;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class KDTreeTest {\n\n    KDTree.Point pointOf(int x, int y) {\n        return new KDTree.Point(new int[]{x, y});\n    }\n\n    @Test\n    void findMin() {\n        int[][] coordinates = {\n                {30, 40},\n                {5, 25},\n                {70, 70},\n                {10, 12},\n                {50, 30},\n                {35, 45}\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(5, kdTree.findMin(0).getCoordinate(0));\n        assertEquals(12, kdTree.findMin(1).getCoordinate(1));\n    }\n\n    @Test\n    void delete() {\n        int[][] coordinates = {\n                {30, 40},\n                {5, 25},\n                {70, 70},\n                {10, 12},\n                {50, 30},\n                {35, 45}\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        kdTree.delete(pointOf(30, 40));\n        assertEquals(35, kdTree.getRoot().getPoint().getCoordinate(0));\n        assertEquals(45, kdTree.getRoot().getPoint().getCoordinate(1));\n    }\n\n    @Test\n    void findNearest() {\n        int[][] coordinates = {\n                {2, 3},\n                {5, 4},\n                {9, 6},\n                {4, 7},\n                {8, 1},\n                {7, 2}\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(pointOf(7, 2), kdTree.findNearest(pointOf(7, 2)));\n        assertEquals(pointOf(8, 1), kdTree.findNearest(pointOf(8, 1)));\n        assertEquals(pointOf(2, 3), kdTree.findNearest(pointOf(1, 1)));\n        assertEquals(pointOf(5, 4), kdTree.findNearest(pointOf(5, 5)));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class KDTreeTest {\n\n    KDTree.Point pointOf(int x, int y) {\n        return new KDTree.Point(new int[] { x, y });\n    }\n\n    @Test\n    void findMin() {\n        int[][] coordinates = {\n            { 30, 40 },\n            { 5, 25 },\n            { 70, 70 },\n            { 10, 12 },\n            { 50, 30 },\n            { 35, 45 },\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(5, kdTree.findMin(0).getCoordinate(0));\n        assertEquals(12, kdTree.findMin(1).getCoordinate(1));\n    }\n\n    @Test\n    void delete() {\n        int[][] coordinates = {\n            { 30, 40 },\n            { 5, 25 },\n            { 70, 70 },\n            { 10, 12 },\n            { 50, 30 },\n            { 35, 45 },\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        kdTree.delete(pointOf(30, 40));\n        assertEquals(35, kdTree.getRoot().getPoint().getCoordinate(0));\n        assertEquals(45, kdTree.getRoot().getPoint().getCoordinate(1));\n    }\n\n    @Test\n    void findNearest() {\n        int[][] coordinates = {\n            { 2, 3 },\n            { 5, 4 },\n            { 9, 6 },\n            { 4, 7 },\n            { 8, 1 },\n            { 7, 2 },\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(pointOf(7, 2), kdTree.findNearest(pointOf(7, 2)));\n        assertEquals(pointOf(8, 1), kdTree.findNearest(pointOf(8, 1)));\n        assertEquals(pointOf(2, 3), kdTree.findNearest(pointOf(1, 1)));\n        assertEquals(pointOf(5, 4), kdTree.findNearest(pointOf(5, 5)));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/LazySegmentTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/LazySegmentTreeTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\npublic class LazySegmentTree {\n    /**\n     * Lazy Segment Tree\n     *\n     * @see\n     *\t<a href=\"https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/\">\n     */\n    static class Node {\n        private final int start, end; // start and end of the segment represented by this node\n        private int value; // value is the sum of all elements in the range [start, end)\n        private int lazy; // lazied value that should be added to children nodes\n        Node left, right; // left and right children\n        public Node(int start, int end, int value) {\n            this.start = start;\n            this.end = end;\n            this.value = value;\n            this.lazy = 0;\n            this.left = null;\n            this.right = null;\n        }\n\n        /** Update the value of this node with the given value diff.\n         *\n         * @param diff The value to add to every index of this node range.\n         */\n        public void applyUpdate(int diff) {\n            this.lazy += diff;\n            this.value += (this.end - this.start) * diff;\n        }\n\n        /** Shift the lazy value of this node to its children.\n         */\n        public void shift() {\n            if (lazy == 0) return;\n            if (this.left == null && this.right == null) return;\n            this.value += this.lazy;\n            if (this.left != null) this.left.applyUpdate(this.lazy);\n            if (this.right != null) this.right.applyUpdate(this.lazy);\n            this.lazy = 0;\n        }\n\n        /** Create a new node that is the sum of this node and the given node.\n         *\n         * @param left The left Node of merging\n         * @param right The right Node of merging\n         * @return The new Node.\n         */\n        static Node merge(Node left, Node right) {\n            if (left == null) return right;\n            if (right == null) return left;\n            Node result = new Node(left.start, right.end, left.value + right.value);\n            result.left = left;\n            result.right = right;\n            return result;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n    }\n\n    private final Node root;\n\n    /** Create a new LazySegmentTree with the given array.\n     *\n     * @param array The array to create the LazySegmentTree from.\n     */\n    public LazySegmentTree(int[] array) {\n        this.root = buildTree(array, 0, array.length);\n    }\n\n    /** Build a new LazySegmentTree from the given array in O(n) time.\n     *\n     * @param array The array to build the LazySegmentTree from.\n     * @param start The start index of the current node.\n     * @param end The end index of the current node.\n     * @return The root of the new LazySegmentTree.\n     */\n    private Node buildTree(int[] array, int start, int end) {\n        if (end - start < 2) return new Node(start, end, array[start]);\n        int mid = (start + end) >> 1;\n        Node left = buildTree(array, start, mid);\n        Node right = buildTree(array, mid, end);\n        return Node.merge(left, right);\n    }\n\n    /** Update the value of given range with the given value diff in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @param diff The value to add to every index of the range.\n     * @param curr The current node.\n     */\n    private void updateRange(int left, int right, int diff, Node curr) {\n        if (left <= curr.start && curr.end <= right) {\n            curr.applyUpdate(diff);\n            return;\n        }\n        if (left >= curr.end || right <= curr.start) return;\n        curr.shift();\n        updateRange(left, right, diff, curr.left);\n        updateRange(left, right, diff, curr.right);\n        Node merge = Node.merge(curr.left, curr.right);\n        curr.value = merge.value;\n    }\n\n    /** Get Node of given range in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @return The Node representing the sum of the given range.\n     */\n    private Node getRange(int left, int right, Node curr) {\n        if (left <= curr.start && curr.end <= right) return curr;\n        if (left >= curr.end || right <= curr.start) return null;\n        curr.shift();\n        return Node.merge(getRange(left, right, curr.left), getRange(left, right, curr.right));\n    }\n\n    public int getRange(int left, int right) {\n        Node result = getRange(left, right, root);\n        return result == null ? 0 : result.getValue();\n    }\n\n    public void updateRange(int left, int right, int diff) {\n        updateRange(left, right, diff, root);\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\npublic class LazySegmentTree {\n\n    /**\n     * Lazy Segment Tree\n     *\n     * @see\n     *\t<a href=\"https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/\">\n     */\n    static class Node {\n\n        private final int start, end; // start and end of the segment represented by this node\n        private int value; // value is the sum of all elements in the range [start, end)\n        private int lazy; // lazied value that should be added to children nodes\n        Node left, right; // left and right children\n\n        public Node(int start, int end, int value) {\n            this.start = start;\n            this.end = end;\n            this.value = value;\n            this.lazy = 0;\n            this.left = null;\n            this.right = null;\n        }\n\n        /** Update the value of this node with the given value diff.\n         *\n         * @param diff The value to add to every index of this node range.\n         */\n        public void applyUpdate(int diff) {\n            this.lazy += diff;\n            this.value += (this.end - this.start) * diff;\n        }\n\n        /** Shift the lazy value of this node to its children.\n         */\n        public void shift() {\n            if (lazy == 0) return;\n            if (this.left == null && this.right == null) return;\n            this.value += this.lazy;\n            if (this.left != null) this.left.applyUpdate(this.lazy);\n            if (this.right != null) this.right.applyUpdate(this.lazy);\n            this.lazy = 0;\n        }\n\n        /** Create a new node that is the sum of this node and the given node.\n         *\n         * @param left The left Node of merging\n         * @param right The right Node of merging\n         * @return The new Node.\n         */\n        static Node merge(Node left, Node right) {\n            if (left == null) return right;\n            if (right == null) return left;\n            Node result = new Node(\n                left.start,\n                right.end,\n                left.value + right.value\n            );\n            result.left = left;\n            result.right = right;\n            return result;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n    }\n\n    private final Node root;\n\n    /** Create a new LazySegmentTree with the given array.\n     *\n     * @param array The array to create the LazySegmentTree from.\n     */\n    public LazySegmentTree(int[] array) {\n        this.root = buildTree(array, 0, array.length);\n    }\n\n    /** Build a new LazySegmentTree from the given array in O(n) time.\n     *\n     * @param array The array to build the LazySegmentTree from.\n     * @param start The start index of the current node.\n     * @param end The end index of the current node.\n     * @return The root of the new LazySegmentTree.\n     */\n    private Node buildTree(int[] array, int start, int end) {\n        if (end - start < 2) return new Node(start, end, array[start]);\n        int mid = (start + end) >> 1;\n        Node left = buildTree(array, start, mid);\n        Node right = buildTree(array, mid, end);\n        return Node.merge(left, right);\n    }\n\n    /** Update the value of given range with the given value diff in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @param diff The value to add to every index of the range.\n     * @param curr The current node.\n     */\n    private void updateRange(int left, int right, int diff, Node curr) {\n        if (left <= curr.start && curr.end <= right) {\n            curr.applyUpdate(diff);\n            return;\n        }\n        if (left >= curr.end || right <= curr.start) return;\n        curr.shift();\n        updateRange(left, right, diff, curr.left);\n        updateRange(left, right, diff, curr.right);\n        Node merge = Node.merge(curr.left, curr.right);\n        curr.value = merge.value;\n    }\n\n    /** Get Node of given range in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @return The Node representing the sum of the given range.\n     */\n    private Node getRange(int left, int right, Node curr) {\n        if (left <= curr.start && curr.end <= right) return curr;\n        if (left >= curr.end || right <= curr.start) return null;\n        curr.shift();\n        return Node.merge(\n            getRange(left, right, curr.left),\n            getRange(left, right, curr.right)\n        );\n    }\n\n    public int getRange(int left, int right) {\n        Node result = getRange(left, right, root);\n        return result == null ? 0 : result.getValue();\n    }\n\n    public void updateRange(int left, int right, int diff) {\n        updateRange(left, right, diff, root);\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++) for (int j = i + 1; j < 10; j++) {\n            lazySegmentTree.updateRange(i, j, 1);\n            assertEquals(j - i, lazySegmentTree.getRange(i, j));\n            lazySegmentTree.updateRange(i, j, -1);\n            assertEquals(0, lazySegmentTree.getRange(i, j));\n        }\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++) for (int j = i + 1; j < 10; j++) {\n            lazySegmentTree.updateRange(i, j, 1);\n            assertEquals(j - i, lazySegmentTree.getRange(i, j));\n            lazySegmentTree.updateRange(i, j, -1);\n            assertEquals(0, lazySegmentTree.getRange(i, j));\n        }\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/SegmentTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/LazySegmentTreeTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\npublic class SegmentTree {\n\n    private int seg_t[];\n    private int n;\n    private int arr[];\n\n    /* Constructor which takes the size of the array and the array as a parameter*/\n    public SegmentTree(int n, int arr[]) {\n        this.n = n;\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n        int seg_size = 2 * (int) Math.pow(2, x) - 1;\n\n        this.seg_t = new int[seg_size];\n        this.arr = arr;\n        this.n = n;\n        constructTree(arr, 0, n - 1, 0);\n    }\n\n    /* A function which will create the segment tree*/\n    public int constructTree(int[] arr, int start, int end, int index) {\n        if (start == end) {\n            this.seg_t[index] = arr[start];\n            return arr[start];\n        }\n\n        int mid = start + (end - start) / 2;\n        this.seg_t[index] = constructTree(arr, start, mid, index * 2 + 1)\n                + constructTree(arr, mid + 1, end, index * 2 + 2);\n        return this.seg_t[index];\n    }\n\n    /* A function which will update the value at a index i. This will be called by the\n    update function internally*/\n    private void updateTree(int start, int end, int index, int diff, int seg_index) {\n        if (index < start || index > end) {\n            return;\n        }\n\n        this.seg_t[seg_index] += diff;\n        if (start != end) {\n            int mid = start + (end - start) / 2;\n            updateTree(start, mid, index, diff, seg_index * 2 + 1);\n            updateTree(mid + 1, end, index, diff, seg_index * 2 + 2);\n        }\n    }\n\n    /* A function to update the value at a particular index*/\n    public void update(int index, int value) {\n        if (index < 0 || index > n) {\n            return;\n        }\n\n        int diff = value - arr[index];\n        arr[index] = value;\n        updateTree(0, n - 1, index, diff, 0);\n    }\n\n    /* A function to get the sum of the elements from index l to index r. This will be called internally*/\n    private int getSumTree(int start, int end, int q_start, int q_end, int seg_index) {\n        if (q_start <= start && q_end >= end) {\n            return this.seg_t[seg_index];\n        }\n\n        if (q_start > end || q_end < start) {\n            return 0;\n        }\n\n        int mid = start + (end - start) / 2;\n        return getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) + getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2);\n    }\n\n    /* A function to query the sum of the subarray [start...end]*/\n    public int getSum(int start, int end) {\n        if (start < 0 || end > n || start > end) {\n            return 0;\n        }\n        return getSumTree(0, n - 1, start, end, 0);\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\npublic class SegmentTree {\n\n    private int seg_t[];\n    private int n;\n    private int arr[];\n\n    /* Constructor which takes the size of the array and the array as a parameter*/\n    public SegmentTree(int n, int arr[]) {\n        this.n = n;\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n        int seg_size = 2 * (int) Math.pow(2, x) - 1;\n\n        this.seg_t = new int[seg_size];\n        this.arr = arr;\n        this.n = n;\n        constructTree(arr, 0, n - 1, 0);\n    }\n\n    /* A function which will create the segment tree*/\n    public int constructTree(int[] arr, int start, int end, int index) {\n        if (start == end) {\n            this.seg_t[index] = arr[start];\n            return arr[start];\n        }\n\n        int mid = start + (end - start) / 2;\n        this.seg_t[index] =\n            constructTree(arr, start, mid, index * 2 + 1) +\n            constructTree(arr, mid + 1, end, index * 2 + 2);\n        return this.seg_t[index];\n    }\n\n    /* A function which will update the value at a index i. This will be called by the\n    update function internally*/\n    private void updateTree(\n        int start,\n        int end,\n        int index,\n        int diff,\n        int seg_index\n    ) {\n        if (index < start || index > end) {\n            return;\n        }\n\n        this.seg_t[seg_index] += diff;\n        if (start != end) {\n            int mid = start + (end - start) / 2;\n            updateTree(start, mid, index, diff, seg_index * 2 + 1);\n            updateTree(mid + 1, end, index, diff, seg_index * 2 + 2);\n        }\n    }\n\n    /* A function to update the value at a particular index*/\n    public void update(int index, int value) {\n        if (index < 0 || index > n) {\n            return;\n        }\n\n        int diff = value - arr[index];\n        arr[index] = value;\n        updateTree(0, n - 1, index, diff, 0);\n    }\n\n    /* A function to get the sum of the elements from index l to index r. This will be called internally*/\n    private int getSumTree(\n        int start,\n        int end,\n        int q_start,\n        int q_end,\n        int seg_index\n    ) {\n        if (q_start <= start && q_end >= end) {\n            return this.seg_t[seg_index];\n        }\n\n        if (q_start > end || q_end < start) {\n            return 0;\n        }\n\n        int mid = start + (end - start) / 2;\n        return (\n            getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) +\n            getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2)\n        );\n    }\n\n    /* A function to query the sum of the subarray [start...end]*/\n    public int getSum(int start, int end) {\n        if (start < 0 || end > n || start > end) {\n            return 0;\n        }\n        return getSumTree(0, n - 1, start, end, 0);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++) for (int j = i + 1; j < 10; j++) {\n            lazySegmentTree.updateRange(i, j, 1);\n            assertEquals(j - i, lazySegmentTree.getRange(i, j));\n            lazySegmentTree.updateRange(i, j, -1);\n            assertEquals(0, lazySegmentTree.getRange(i, j));\n        }\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++) for (int j = i + 1; j < 10; j++) {\n            lazySegmentTree.updateRange(i, j, 1);\n            assertEquals(j - i, lazySegmentTree.getRange(i, j));\n            lazySegmentTree.updateRange(i, j, -1);\n            assertEquals(0, lazySegmentTree.getRange(i, j));\n        }\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ADTFraction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ADTFractionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic record ADTFraction(int numerator, int denominator) {\n\n    /**\n     * Initializes a newly created {@code ADTFraction} object so that it represents\n     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.\n     *\n     * @param numerator   The fraction numerator\n     * @param denominator The fraction denominator\n     */\n    public ADTFraction {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be 0\");\n        }\n    }\n\n    /**\n     * Add two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to add\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction plus(ADTFraction fraction) {\n        var numerator = this.denominator * fraction.numerator + this.numerator * fraction.denominator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n\n    }\n\n    /**\n     * Multiply fraction by a number.\n     *\n     * @param number the number to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(int number) {\n        return times(new ADTFraction(number, 1));\n    }\n\n    /**\n     * Multiply two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(ADTFraction fraction) {\n        var numerator = this.numerator * fraction.numerator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Generates the reciprocal of the fraction.\n     *\n     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched\n     */\n    public ADTFraction reciprocal() {\n        return new ADTFraction(this.denominator, this.numerator);\n    }\n\n    /**\n     * Calculates the result of the fraction.\n     *\n     * @return The numerical result of the division between {@code numerator} and {@code denominator}\n     */\n    public float value() {\n        return (float) this.numerator / this.denominator;\n    }\n\n    /**\n     * Returns a string representation of this {@code ADTFraction} in the format\n     * {@code numerator}/{@code denominator}.\n     *\n     * @return A string representation of this {@code ADTFraction}\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%d/%d\", this.numerator, this.denominator);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic record ADTFraction(int numerator, int denominator) {\n    /**\n     * Initializes a newly created {@code ADTFraction} object so that it represents\n     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.\n     *\n     * @param numerator   The fraction numerator\n     * @param denominator The fraction denominator\n     */\n    public ADTFraction {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be 0\");\n        }\n    }\n\n    /**\n     * Add two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to add\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction plus(ADTFraction fraction) {\n        var numerator =\n            this.denominator *\n            fraction.numerator +\n            this.numerator *\n            fraction.denominator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Multiply fraction by a number.\n     *\n     * @param number the number to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(int number) {\n        return times(new ADTFraction(number, 1));\n    }\n\n    /**\n     * Multiply two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(ADTFraction fraction) {\n        var numerator = this.numerator * fraction.numerator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Generates the reciprocal of the fraction.\n     *\n     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched\n     */\n    public ADTFraction reciprocal() {\n        return new ADTFraction(this.denominator, this.numerator);\n    }\n\n    /**\n     * Calculates the result of the fraction.\n     *\n     * @return The numerical result of the division between {@code numerator} and {@code denominator}\n     */\n    public float value() {\n        return (float) this.numerator / this.denominator;\n    }\n\n    /**\n     * Returns a string representation of this {@code ADTFraction} in the format\n     * {@code numerator}/{@code denominator}.\n     *\n     * @return A string representation of this {@code ADTFraction}\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%d/%d\", this.numerator, this.denominator);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class ADTFractionTest {\n\n    private final ADTFraction fraction1 = new ADTFraction(3, 5);\n    private final ADTFraction fraction2 = new ADTFraction(7, 8);\n\n    @Test\n    void testConstructorWithDenominatorEqualToZero() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> new ADTFraction(1, 0));\n        assertEquals(\"Denominator cannot be 0\", exception.getMessage());\n    }\n\n    @Test\n    public void testPlus() {\n        assertEquals(new ADTFraction(59, 40), fraction1.plus(fraction2));\n    }\n\n    @Test\n    public void testTimes() {\n        assertEquals(new ADTFraction(12, 5), fraction1.times(4));\n        assertEquals(new ADTFraction(21, 40), fraction1.times(fraction2));\n    }\n\n    @Test\n    public void testReciprocal() {\n        assertEquals(new ADTFraction(5, 3), fraction1.reciprocal());\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(0.6F, fraction1.value());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        ADTFraction fraction3 = new ADTFraction(3, 5);\n        assertTrue(fraction1.equals(fraction3) && fraction3.equals(fraction1));\n        assertEquals(fraction1.hashCode(), fraction3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"3/5\", fraction1.toString());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ADTFractionTest {\n\n    private final ADTFraction fraction1 = new ADTFraction(3, 5);\n    private final ADTFraction fraction2 = new ADTFraction(7, 8);\n\n    @Test\n    void testConstructorWithDenominatorEqualToZero() {\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> new ADTFraction(1, 0)\n        );\n        assertEquals(\"Denominator cannot be 0\", exception.getMessage());\n    }\n\n    @Test\n    public void testPlus() {\n        assertEquals(new ADTFraction(59, 40), fraction1.plus(fraction2));\n    }\n\n    @Test\n    public void testTimes() {\n        assertEquals(new ADTFraction(12, 5), fraction1.times(4));\n        assertEquals(new ADTFraction(21, 40), fraction1.times(fraction2));\n    }\n\n    @Test\n    public void testReciprocal() {\n        assertEquals(new ADTFraction(5, 3), fraction1.reciprocal());\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(0.6F, fraction1.value());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        ADTFraction fraction3 = new ADTFraction(3, 5);\n        assertTrue(fraction1.equals(fraction3) && fraction3.equals(fraction1));\n        assertEquals(fraction1.hashCode(), fraction3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"3/5\", fraction1.toString());\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMax {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute max value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute max value\n     */\n    public static int getMaxValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMaxWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays.stream(numbers)\n                .skip(1)\n                .filter(number -> Math.abs(number) > Math.abs(absMaxWrapper.value))\n                .forEach(number -> absMaxWrapper.value = number);\n\n        return absMaxWrapper.value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMax {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute max value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute max value\n     */\n    public static int getMaxValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMaxWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays\n            .stream(numbers)\n            .skip(1)\n            .filter(number -> Math.abs(number) > Math.abs(absMaxWrapper.value))\n            .forEach(number -> absMaxWrapper.value = number);\n\n        return absMaxWrapper.value;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class AbsoluteMaxTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(16, AbsoluteMax.getMaxValue(-2, 0, 16));\n        assertEquals(-10, AbsoluteMax.getMaxValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMaxValueWithNoArguments() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> AbsoluteMax.getMaxValue());\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMaxTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(16, AbsoluteMax.getMaxValue(-2, 0, 16));\n        assertEquals(-10, AbsoluteMax.getMaxValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMaxValueWithNoArguments() {\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> AbsoluteMax.getMaxValue()\n        );\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMin {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute min value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute min value\n     */\n    public static int getMinValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMinWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays.stream(numbers)\n                .skip(1)\n                .filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value))\n                .forEach(number -> absMinWrapper.value = number);\n\n        return absMinWrapper.value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMin {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute min value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute min value\n     */\n    public static int getMinValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMinWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays\n            .stream(numbers)\n            .skip(1)\n            .filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value))\n            .forEach(number -> absMinWrapper.value = number);\n\n        return absMinWrapper.value;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class AbsoluteMinTest {\n\n    @Test\n    void testGetMinValue() {\n        assertEquals(0, AbsoluteMin.getMinValue(4, 0, 16));\n        assertEquals(-2, AbsoluteMin.getMinValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMinValueWithNoArguments() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> AbsoluteMin.getMinValue());\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AbsoluteMinTest {\n\n    @Test\n    void testGetMinValue() {\n        assertEquals(0, AbsoluteMin.getMinValue(4, 0, 16));\n        assertEquals(-2, AbsoluteMin.getMinValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMinValueWithNoArguments() {\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> AbsoluteMin.getMinValue()\n        );\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AliquotSum.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AliquotSumTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    /**\n     * Finds the aliquot sum of an integer number.\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotValue(int number) {\n        var sumWrapper = new Object() {\n            int value = 0;\n        };\n\n        IntStream.iterate(1, i -> ++i)\n                .limit(number / 2)\n                .filter(i -> number % i == 0)\n                .forEach(i -> sumWrapper.value += i);\n\n        return sumWrapper.value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    /**\n     * Finds the aliquot sum of an integer number.\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotValue(int number) {\n        var sumWrapper = new Object() {\n            int value = 0;\n        };\n\n        IntStream\n            .iterate(1, i -> ++i)\n            .limit(number / 2)\n            .filter(i -> number % i == 0)\n            .forEach(i -> sumWrapper.value += i);\n\n        return sumWrapper.value;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AliquotSumTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(0, AliquotSum.getAliquotValue(1));\n        assertEquals(6, AliquotSum.getAliquotValue(6));\n        assertEquals(9, AliquotSum.getAliquotValue(15));\n        assertEquals(1, AliquotSum.getAliquotValue(19));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AliquotSumTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(0, AliquotSum.getAliquotValue(1));\n        assertEquals(6, AliquotSum.getAliquotValue(6));\n        assertEquals(9, AliquotSum.getAliquotValue(15));\n        assertEquals(1, AliquotSum.getAliquotValue(19));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AmicableNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AmicableNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Amicable numbers are two different numbers so related that the sum of the\n * proper divisors of each is equal to the other number. (A proper divisor of a\n * number is a positive factor of that number other than the number itself. For\n * example, the proper divisors of 6 are 1, 2, and 3.) A pair of amicable\n * numbers constitutes an aliquot sequence of period 2. It is unknown if there\n * are infinitely many pairs of amicable numbers. *\n *\n * <p>\n * link: https://en.wikipedia.org/wiki/Amicable_numbers *\n *\n * <p>\n * Simple Example : (220,284) 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110\n * } <- Sum = 284\n * 284 is divisible by -> 1,2,4,71,142 and the Sum of that is. Yes right you\n * probably expected it 220\n */\npublic class AmicableNumber {\n\n    public static void main(String[] args) {\n\n        AmicableNumber.findAllInRange(1, 3000);\n        /* Res -> Int Range of 1 till 3000there are 3Amicable_numbers These are  1: = ( 220,284)\t2: = ( 1184,1210)\n    3: = ( 2620,2924) So it worked\t*/\n\n    }\n\n    /**\n     * @param startValue\n     * @param stopValue\n     * @return\n     */\n    static void findAllInRange(int startValue, int stopValue) {\n\n        /* the 2 for loops are to avoid to double check tuple. For example (200,100) and (100,200) is the same calculation\n     * also to avoid is to check the number with it self. a number with itself is always a AmicableNumber\n     * */\n        StringBuilder res = new StringBuilder();\n        int countofRes = 0;\n\n        for (int i = startValue; i < stopValue; i++) {\n            for (int j = i + 1; j <= stopValue; j++) {\n                if (isAmicableNumber(i, j)) {\n                    countofRes++;\n                    res.append(\"\" + countofRes + \": = ( \" + i + \",\" + j + \")\" + \"\\t\");\n                }\n            }\n        }\n        res.insert(\n                0,\n                \"Int Range of \"\n                + startValue\n                + \" till \"\n                + stopValue\n                + \" there are \"\n                + countofRes\n                + \" Amicable_numbers.These are \\n \");\n        System.out.println(res.toString());\n    }\n\n    /**\n     * Check if {@code numberOne and numberTwo } are AmicableNumbers or not\n     *\n     * @param numberOne numberTwo\n     * @return {@code true} if {@code numberOne numberTwo} isAmicableNumbers\n     * otherwise false\n     */\n    static boolean isAmicableNumber(int numberOne, int numberTwo) {\n\n        return ((recursiveCalcOfDividerSum(numberOne, numberOne) == numberTwo\n                && numberOne == recursiveCalcOfDividerSum(numberTwo, numberTwo)));\n    }\n\n    /**\n     * calculated in recursive calls the Sum of all the Dividers beside it self\n     *\n     * @param number div = the next to test dividely by using the modulo\n     * operator\n     * @return sum of all the dividers\n     */\n    static int recursiveCalcOfDividerSum(int number, int div) {\n\n        if (div == 1) {\n            return 0;\n        } else if (number % --div == 0) {\n            return recursiveCalcOfDividerSum(number, div) + div;\n        } else {\n            return recursiveCalcOfDividerSum(number, div);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Amicable numbers are two different numbers so related that the sum of the\n * proper divisors of each is equal to the other number. (A proper divisor of a\n * number is a positive factor of that number other than the number itself. For\n * example, the proper divisors of 6 are 1, 2, and 3.) A pair of amicable\n * numbers constitutes an aliquot sequence of period 2. It is unknown if there\n * are infinitely many pairs of amicable numbers. *\n *\n * <p>\n * link: https://en.wikipedia.org/wiki/Amicable_numbers *\n *\n * <p>\n * Simple Example : (220,284) 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110\n * } <- Sum = 284\n * 284 is divisible by -> 1,2,4,71,142 and the Sum of that is. Yes right you\n * probably expected it 220\n */\npublic class AmicableNumber {\n\n    public static void main(String[] args) {\n        AmicableNumber.findAllInRange(1, 3000);\n        /* Res -> Int Range of 1 till 3000there are 3Amicable_numbers These are  1: = ( 220,284)\t2: = ( 1184,1210)\n    3: = ( 2620,2924) So it worked\t*/\n\n    }\n\n    /**\n     * @param startValue\n     * @param stopValue\n     * @return\n     */\n    static void findAllInRange(int startValue, int stopValue) {\n        /* the 2 for loops are to avoid to double check tuple. For example (200,100) and (100,200) is the same calculation\n         * also to avoid is to check the number with it self. a number with itself is always a AmicableNumber\n         * */\n        StringBuilder res = new StringBuilder();\n        int countofRes = 0;\n\n        for (int i = startValue; i < stopValue; i++) {\n            for (int j = i + 1; j <= stopValue; j++) {\n                if (isAmicableNumber(i, j)) {\n                    countofRes++;\n                    res.append(\n                        \"\" + countofRes + \": = ( \" + i + \",\" + j + \")\" + \"\\t\"\n                    );\n                }\n            }\n        }\n        res.insert(\n            0,\n            \"Int Range of \" +\n            startValue +\n            \" till \" +\n            stopValue +\n            \" there are \" +\n            countofRes +\n            \" Amicable_numbers.These are \\n \"\n        );\n        System.out.println(res.toString());\n    }\n\n    /**\n     * Check if {@code numberOne and numberTwo } are AmicableNumbers or not\n     *\n     * @param numberOne numberTwo\n     * @return {@code true} if {@code numberOne numberTwo} isAmicableNumbers\n     * otherwise false\n     */\n    static boolean isAmicableNumber(int numberOne, int numberTwo) {\n        return (\n            (\n                recursiveCalcOfDividerSum(numberOne, numberOne) == numberTwo &&\n                numberOne == recursiveCalcOfDividerSum(numberTwo, numberTwo)\n            )\n        );\n    }\n\n    /**\n     * calculated in recursive calls the Sum of all the Dividers beside it self\n     *\n     * @param number div = the next to test dividely by using the modulo\n     * operator\n     * @return sum of all the dividers\n     */\n    static int recursiveCalcOfDividerSum(int number, int div) {\n        if (div == 1) {\n            return 0;\n        } else if (number % --div == 0) {\n            return recursiveCalcOfDividerSum(number, div) + div;\n        } else {\n            return recursiveCalcOfDividerSum(number, div);\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class AmicableNumberTest {\n\n    @Test\n    void testAmicableNumber() {\n        assertThat(AmicableNumber.isAmicableNumber(220, 284)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(1184, 1210)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(2620, 2924)).isTrue();\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AmicableNumberTest {\n\n    @Test\n    void testAmicableNumber() {\n        assertThat(AmicableNumber.isAmicableNumber(220, 284)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(1184, 1210)).isTrue();\n        assertThat(AmicableNumber.isAmicableNumber(2620, 2924)).isTrue();\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AutomorphicNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AutomorphicNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\nimport java.io.*;\n\npublic class AutomorphicNumber {\n\n    //returns True if the number is a Automorphic number and False if it is not an Automorphic number\n    public static boolean isAutomorphic(int n) {\n        int m, c, r, p, k;\n        c = 0;\n        /**\n         * m = Temporary variable to store a copy of the number entered by the\n         * user. n = The number entered by the user c = Count the digits of the\n         * number entered by user. p = To calculate the square of the number. k\n         * = Support variable to count the digits of the number\n         */\n        double s;\n        m = n;\n        p = m * m; //Calculating square of the number\n        do {\n            k = n / 10;\n            c = c + 1; //Counting the digits of the number entered by user.\n            n = k;\n        } while (n != 0);\n        s = Math.pow(10, c);\n        r = p % (int) s;\n        if (m == r) //Checking if the original number entered is present at the end of the square\n        {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Method to check if number is Automorphic Number or Not 1) Input - Enter a\n     * Number: 25 Output - It is an Automorphic Number. 2) Input - Enter a\n     * Number: 7 Output - It is not an Automorphic Number.\n     */\n    public static void main(String args[]) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter a Number: \");\n        int n = Integer.parseInt(br.readLine());\n        if (isAutomorphic(n)) {\n            System.out.println(\"It is an Automorphic Number.\");\n        } else {\n            System.out.println(\"It is not an Automorphic Number.\");\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * A number is said to be an Automorphic, if it is present in the last digit(s)\n * of its square. Example- Let the number be 25, its square is 625. Since,\n * 25(The input number) is present in the last two digits of its square(625), it\n * is an Automorphic Number.\n */\nimport java.io.*;\n\npublic class AutomorphicNumber {\n\n    //returns True if the number is a Automorphic number and False if it is not an Automorphic number\n    public static boolean isAutomorphic(int n) {\n        int m, c, r, p, k;\n        c = 0;\n        /**\n         * m = Temporary variable to store a copy of the number entered by the\n         * user. n = The number entered by the user c = Count the digits of the\n         * number entered by user. p = To calculate the square of the number. k\n         * = Support variable to count the digits of the number\n         */\n        double s;\n        m = n;\n        p = m * m; //Calculating square of the number\n        do {\n            k = n / 10;\n            c = c + 1; //Counting the digits of the number entered by user.\n            n = k;\n        } while (n != 0);\n        s = Math.pow(10, c);\n        r = p % (int) s;\n        if (m == r) { //Checking if the original number entered is present at the end of the square\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Method to check if number is Automorphic Number or Not 1) Input - Enter a\n     * Number: 25 Output - It is an Automorphic Number. 2) Input - Enter a\n     * Number: 7 Output - It is not an Automorphic Number.\n     */\n    public static void main(String args[]) throws IOException {\n        BufferedReader br = new BufferedReader(\n            new InputStreamReader(System.in)\n        );\n        System.out.println(\"Enter a Number: \");\n        int n = Integer.parseInt(br.readLine());\n        if (isAutomorphic(n)) {\n            System.out.println(\"It is an Automorphic Number.\");\n        } else {\n            System.out.println(\"It is not an Automorphic Number.\");\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class AutomorphicNumberTest{\n\n    @Test\n    void testAutomorphicNumber(){\n        assertThat(AutomorphicNumber.isAutomorphic(625)).isTrue();\n        assertThat(AutomorphicNumber.isAutomorphic(144)).isFalse();\n        assertThat(AutomorphicNumber.isAutomorphic(9376)).isTrue();\n        assertThat(AutomorphicNumber.isAutomorphic(169)).isFalse();\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AutomorphicNumberTest {\n\n    @Test\n    void testAutomorphicNumber() {\n        assertThat(AutomorphicNumber.isAutomorphic(625)).isTrue();\n        assertThat(AutomorphicNumber.isAutomorphic(144)).isFalse();\n        assertThat(AutomorphicNumber.isAutomorphic(9376)).isTrue();\n        assertThat(AutomorphicNumber.isAutomorphic(169)).isFalse();\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Average.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AverageTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Calculate average of a list of numbers\n */\npublic class Average {\n\n    private static final double SMALL_VALUE = 0.00001f;\n\n    public static void main(String[] args) {\n        assert Math.abs(average(new double[]{3, 6, 9, 12, 15, 18, 21}) - 12) < SMALL_VALUE;\n        assert Math.abs(average(new double[]{5, 10, 15, 20, 25, 30, 35}) - 20) < SMALL_VALUE;\n        assert Math.abs(average(new double[]{1, 2, 3, 4, 5, 6, 7, 8}) - 4.5) < SMALL_VALUE;\n        int[] array = {2, 4, 10};\n        assert average(array) == 5;\n    }\n\n    /**\n     * Calculate average of a list of numbers\n     *\n     * @param numbers array to store numbers\n     * @return mean of given numbers\n     */\n    public static double average(double[] numbers) {\n        double sum = 0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        return sum / numbers.length;\n    }\n\n    /**\n     * find average value of int array\n     *\n     * @param array the array contains element and the sum does not excess long\n     * value limit\n     * @return average value\n     */\n    public static int average(int[] array) {\n        long sum = 0;\n        for (int i = 0; i < array.length; ++i) {\n            sum += array[i];\n        }\n        return (int) (sum / array.length);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Calculate average of a list of numbers\n */\npublic class Average {\n\n    private static final double SMALL_VALUE = 0.00001f;\n\n    public static void main(String[] args) {\n        assert Math.abs(\n            average(new double[] { 3, 6, 9, 12, 15, 18, 21 }) - 12\n        ) <\n        SMALL_VALUE;\n        assert Math.abs(\n            average(new double[] { 5, 10, 15, 20, 25, 30, 35 }) - 20\n        ) <\n        SMALL_VALUE;\n        assert Math.abs(\n            average(new double[] { 1, 2, 3, 4, 5, 6, 7, 8 }) - 4.5\n        ) <\n        SMALL_VALUE;\n        int[] array = { 2, 4, 10 };\n        assert average(array) == 5;\n    }\n\n    /**\n     * Calculate average of a list of numbers\n     *\n     * @param numbers array to store numbers\n     * @return mean of given numbers\n     */\n    public static double average(double[] numbers) {\n        double sum = 0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        return sum / numbers.length;\n    }\n\n    /**\n     * find average value of int array\n     *\n     * @param array the array contains element and the sum does not excess long\n     * value limit\n     * @return average value\n     */\n    public static int average(int[] array) {\n        long sum = 0;\n        for (int i = 0; i < array.length; ++i) {\n            sum += array[i];\n        }\n        return (int) (sum / array.length);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n\npublic class AverageTest {\n    double [] numbers = {3, 6, 9, 12, 15, 18, 21};\n    @Test\n    public void testAverage() {\n        \n        Assertions.assertEquals(12, Average.average(numbers));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class AverageTest {\n\n    double[] numbers = { 3, 6, 9, 12, 15, 18, 21 };\n\n    @Test\n    public void testAverage() {\n        Assertions.assertEquals(12, Average.average(numbers));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/BinomialCoefficient.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/BinomialCoefficientTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Binomial Cofficients\n * Binomial Cofficients: A binomial cofficient C(n,k) gives number ways\n * in which k objects can be chosen from n objects.\n * Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class BinomialCoefficient {\n\n    /**\n     * This method returns the number of ways in which k objects can be chosen from n objects\n     *\n     * @param totalObjects    Total number of objects\n     * @param numberOfObjects Number of objects to be chosen from total_objects\n     * @return number of ways in which no_of_objects objects can be chosen from total_objects objects\n     */\n\n    public static int binomialCoefficient(int totalObjects, int numberOfObjects) {\n\n        // Base Case\n        if (numberOfObjects > totalObjects) {\n            return 0;\n        }\n\n        // Base Case\n        if (numberOfObjects == 0 || numberOfObjects == totalObjects) {\n            return 1;\n        }\n\n        // Recursive Call\n        return binomialCoefficient(totalObjects - 1, numberOfObjects - 1)\n                + binomialCoefficient(totalObjects - 1, numberOfObjects);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Binomial Cofficients\n * Binomial Cofficients: A binomial cofficient C(n,k) gives number ways\n * in which k objects can be chosen from n objects.\n * Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class BinomialCoefficient {\n\n    /**\n     * This method returns the number of ways in which k objects can be chosen from n objects\n     *\n     * @param totalObjects    Total number of objects\n     * @param numberOfObjects Number of objects to be chosen from total_objects\n     * @return number of ways in which no_of_objects objects can be chosen from total_objects objects\n     */\n\n    public static int binomialCoefficient(\n        int totalObjects,\n        int numberOfObjects\n    ) {\n        // Base Case\n        if (numberOfObjects > totalObjects) {\n            return 0;\n        }\n\n        // Base Case\n        if (numberOfObjects == 0 || numberOfObjects == totalObjects) {\n            return 1;\n        }\n\n        // Recursive Call\n        return (\n            binomialCoefficient(totalObjects - 1, numberOfObjects - 1) +\n            binomialCoefficient(totalObjects - 1, numberOfObjects)\n        );\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BinomialCoefficientTest {\n\n    @Test\n    void testBinomialCoefficient() {\n\n        assertEquals(190, BinomialCoefficient.binomialCoefficient(20, 2));\n        assertEquals(792, BinomialCoefficient.binomialCoefficient(12, 5));\n        assertEquals(84, BinomialCoefficient.binomialCoefficient(9, 3));\n        assertEquals(1, BinomialCoefficient.binomialCoefficient(17, 17));\n\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BinomialCoefficientTest {\n\n    @Test\n    void testBinomialCoefficient() {\n        assertEquals(190, BinomialCoefficient.binomialCoefficient(20, 2));\n        assertEquals(792, BinomialCoefficient.binomialCoefficient(12, 5));\n        assertEquals(84, BinomialCoefficient.binomialCoefficient(9, 3));\n        assertEquals(1, BinomialCoefficient.binomialCoefficient(17, 17));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DigitalRoot.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DigitalRootTest.java",
        "product_old_content": "/** Author : Suraj Kumar Modi\n * https://github.com/skmodi649\n */\n/** You are given a number n. You need to find the digital root of n.\n * DigitalRoot of a number is the recursive sum of its digits until we get a single digit number.\n *\n * Test Case 1:\n * Input:\n * n = 1\n * Output:  1\n * Explanation: Digital root of 1 is 1\n *\n * Test Case 2:\n * Input:\n * n = 99999\n * Output: 9\n * Explanation: Sum of digits of 99999 is 45\n * which is not a single digit number, hence\n * sum of digit of 45 is 9 which is a single\n * digit number.\n */\n/** Algorithm :\n * Step 1 : Define a method digitalRoot(int n)\n * Step 2 : Define another method single(int n)\n * Step 3 : digitalRoot(int n) method takes output of single(int n) as input\n * if(single(int n) <= 9)\n * return single(n)\n * else\n * return digitalRoot(single(n))\n * Step 4 : single(int n) calculates the sum of digits of number n recursively\n * if(n<=9)\n * return n;\n * else\n * return (n%10) + (n/10)\n * Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and print the result\n */\npackage com.thealgorithms.maths;\n\nclass DigitalRoot {\n\n    public static int digitalRoot(int n) {\n        if (single(n) <= 9) // If n is already single digit than simply call single method and return the value\n        {\n            return single(n);\n        } else {\n            return digitalRoot(single(n));\n        }\n    }\n\n    // This function is used for finding the sum of digits of number\n    public static int single(int n) {\n        if (n <= 9) // if n becomes less than 10 than return n\n        {\n            return n;\n        } else {\n            return (n % 10) + single(n / 10);                     // n % 10 for extracting digits one by one\n        }\n    }                                                             // n / 10 is the number obtainded after removing the digit one by one  \n    // Sum of digits is stored in the Stack memory and then finally returned\n\n}\n\n/**\n * Time Complexity : O((Number of Digits)^2) Auxiliary Space Complexity :\n * O(Number of Digits) Constraints : 1 <= n <= 10^7\n */",
        "product_new_content": "/** Author : Suraj Kumar Modi\n * https://github.com/skmodi649\n */\n/** You are given a number n. You need to find the digital root of n.\n * DigitalRoot of a number is the recursive sum of its digits until we get a single digit number.\n *\n * Test Case 1:\n * Input:\n * n = 1\n * Output:  1\n * Explanation: Digital root of 1 is 1\n *\n * Test Case 2:\n * Input:\n * n = 99999\n * Output: 9\n * Explanation: Sum of digits of 99999 is 45\n * which is not a single digit number, hence\n * sum of digit of 45 is 9 which is a single\n * digit number.\n */\n/** Algorithm :\n * Step 1 : Define a method digitalRoot(int n)\n * Step 2 : Define another method single(int n)\n * Step 3 : digitalRoot(int n) method takes output of single(int n) as input\n * if(single(int n) <= 9)\n * return single(n)\n * else\n * return digitalRoot(single(n))\n * Step 4 : single(int n) calculates the sum of digits of number n recursively\n * if(n<=9)\n * return n;\n * else\n * return (n%10) + (n/10)\n * Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and print the result\n */\npackage com.thealgorithms.maths;\n\nclass DigitalRoot {\n\n    public static int digitalRoot(int n) {\n        if (single(n) <= 9) { // If n is already single digit than simply call single method and return the value\n            return single(n);\n        } else {\n            return digitalRoot(single(n));\n        }\n    }\n\n    // This function is used for finding the sum of digits of number\n    public static int single(int n) {\n        if (n <= 9) { // if n becomes less than 10 than return n\n            return n;\n        } else {\n            return (n % 10) + single(n / 10); // n % 10 for extracting digits one by one\n        }\n    } // n / 10 is the number obtainded after removing the digit one by one\n    // Sum of digits is stored in the Stack memory and then finally returned\n\n}\n/**\n * Time Complexity : O((Number of Digits)^2) Auxiliary Space Complexity :\n * O(Number of Digits) Constraints : 1 <= n <= 10^7\n */",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DigitalRootTest {\n\n    @Test\n    void testDigitalroot() {\n\n        assertEquals(4, DigitalRoot.digitalRoot(4));\n        assertEquals(9, DigitalRoot.digitalRoot(9));\n        assertEquals(4, DigitalRoot.digitalRoot(49));\n        assertEquals(6, DigitalRoot.digitalRoot(78));\n        assertEquals(4, DigitalRoot.digitalRoot(1228));\n        assertEquals(5, DigitalRoot.digitalRoot(71348));\n        \n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DigitalRootTest {\n\n    @Test\n    void testDigitalroot() {\n        assertEquals(4, DigitalRoot.digitalRoot(4));\n        assertEquals(9, DigitalRoot.digitalRoot(9));\n        assertEquals(4, DigitalRoot.digitalRoot(49));\n        assertEquals(6, DigitalRoot.digitalRoot(78));\n        assertEquals(4, DigitalRoot.digitalRoot(1228));\n        assertEquals(5, DigitalRoot.digitalRoot(71348));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DistanceFormula.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DistanceFormulaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class DistanceFormula {\n\tpublic static double euclideanDistance(double x1, double y1, double x2, double y2) {\n\t\tdouble dX = Math.pow(x2 - x1, 2);\n\t\tdouble dY = Math.pow(y2 - x1, 2);\n\t\tdouble d = Math.sqrt(dX + dY);\n\t\treturn d;\n\t}\n\n\tpublic static double manhattanDistance(double x1, double y1, double x2, double y2) {\n\t\tdouble d = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\t\treturn d;\n\t}\n\n\tpublic static int hammingDistance(int[] b1, int[] b2) {\n\t\tint d = 0;\n\n\t\tif (b1.length != b2.length) {\n\t\t\treturn -1; // error, both array must be have the same length\n\t\t}\n\n\t\tfor (int i = 0; i < b1.length; i++) {\n\t\t\td += Math.abs(b1[i] - b2[i]);\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tpublic static double minkowskiDistance(double[] p1, double[] p2, int p) {\n\t\tdouble d = 0;\n\t\tdouble distance = 0.0;\n\n\t\tif (p1.length != p2.length) {\n\t\t\treturn -1; // error, both array must be have the same length\n\t\t}\n\n\t\tfor (int i = 0; i < p1.length; i++) {\n\t\t\tdistance += Math.abs(Math.pow(p1[i] - p2[i], p));\n\t\t}\n\n\t\tdistance = Math.pow(distance, (double) 1 / p);\n\t\td = distance;\n\t\treturn d;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class DistanceFormula {\n\n    public static double euclideanDistance(\n        double x1,\n        double y1,\n        double x2,\n        double y2\n    ) {\n        double dX = Math.pow(x2 - x1, 2);\n        double dY = Math.pow(y2 - x1, 2);\n        double d = Math.sqrt(dX + dY);\n        return d;\n    }\n\n    public static double manhattanDistance(\n        double x1,\n        double y1,\n        double x2,\n        double y2\n    ) {\n        double d = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n        return d;\n    }\n\n    public static int hammingDistance(int[] b1, int[] b2) {\n        int d = 0;\n\n        if (b1.length != b2.length) {\n            return -1; // error, both array must be have the same length\n        }\n\n        for (int i = 0; i < b1.length; i++) {\n            d += Math.abs(b1[i] - b2[i]);\n        }\n\n        return d;\n    }\n\n    public static double minkowskiDistance(double[] p1, double[] p2, int p) {\n        double d = 0;\n        double distance = 0.0;\n\n        if (p1.length != p2.length) {\n            return -1; // error, both array must be have the same length\n        }\n\n        for (int i = 0; i < p1.length; i++) {\n            distance += Math.abs(Math.pow(p1[i] - p2[i], p));\n        }\n\n        distance = Math.pow(distance, (double) 1 / p);\n        d = distance;\n        return d;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DistanceFormulaTest {\n\t@Test\n\tvoid euclideanTest1() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(1, 1, 2, 2), 1.4142135623730951);\n\t}\n\n\t@Test\n\tvoid euclideanTest2() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(1, 3, 8, 0), 7.0710678118654755);\n\t}\n\n\t@Test\n\tvoid euclideanTest3() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(2.4, 9.1, 55.1, 100), 110.91911467371168);\n\t}\n\n\t@Test\n\tvoid euclideanTest4() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(1000, 13, 20000, 84), 19022.067605809836);\n\t}\n\n\t@Test\n\tpublic void manhattantest1() {\n\t\tassertEquals(DistanceFormula.manhattanDistance(1, 2, 3, 4), 4);\n\t}\n\n\t@Test\n\tpublic void manhattantest2() {\n\t\tassertEquals(DistanceFormula.manhattanDistance(6.5, 8.4, 20.1, 13.6), 18.8);\n\t}\n\n\t@Test\n\tpublic void manhattanTest3() {\n\t\tassertEquals(DistanceFormula.manhattanDistance(10.112, 50, 8, 25.67), 26.442);\n\t}\n\n\t@Test\n\tpublic void hammingTest1() {\n\t\tint[] array1 = { 1, 1, 1, 1 };\n\t\tint[] array2 = { 0, 0, 0, 0 };\n\t\tassertEquals(DistanceFormula.hammingDistance(array1, array2), 4);\n\t}\n\n\t@Test\n\tpublic void hammingTest2() {\n\t\tint[] array1 = { 1, 1, 1, 1 };\n\t\tint[] array2 = { 1, 1, 1, 1 };\n\t\tassertEquals(DistanceFormula.hammingDistance(array1, array2), 0);\n\t}\n\n\t@Test\n\tpublic void hammingTest3() {\n\t\tint[] array1 = { 1, 0, 0, 1, 1, 0, 1, 1, 0 };\n\t\tint[] array2 = { 0, 1, 0, 0, 1, 1, 1, 0, 0 };\n\t\tassertEquals(DistanceFormula.hammingDistance(array1, array2), 5);\n\t}\n\n\t@Test\n\tpublic void minkowskiTest1() {\n\t\tdouble[] array1 = { 1, 3, 8, 5 };\n\t\tdouble[] array2 = { 4, 2, 6, 9 };\n\t\tassertEquals(DistanceFormula.minkowskiDistance(array1, array2, 1), 10);\n\t}\n\n\t@Test\n\tpublic void minkowskiTest2() {\n\t\tdouble[] array1 = { 1, 3, 8, 5 };\n\t\tdouble[] array2 = { 4, 2, 6, 9 };\n\t\tassertEquals(DistanceFormula.minkowskiDistance(array1, array2, 2), 5.477225575051661);\n\t}\n\n\t@Test\n\tpublic void minkowskiTest3() {\n\t\tdouble[] array1 = { 1, 3, 8, 5 };\n\t\tdouble[] array2 = { 4, 2, 6, 9 };\n\t\tassertEquals(DistanceFormula.minkowskiDistance(array1, array2, 3), 4.641588833612778);\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DistanceFormulaTest {\n\n    @Test\n    void euclideanTest1() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(1, 1, 2, 2),\n            1.4142135623730951\n        );\n    }\n\n    @Test\n    void euclideanTest2() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(1, 3, 8, 0),\n            7.0710678118654755\n        );\n    }\n\n    @Test\n    void euclideanTest3() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(2.4, 9.1, 55.1, 100),\n            110.91911467371168\n        );\n    }\n\n    @Test\n    void euclideanTest4() {\n        Assertions.assertEquals(\n            DistanceFormula.euclideanDistance(1000, 13, 20000, 84),\n            19022.067605809836\n        );\n    }\n\n    @Test\n    public void manhattantest1() {\n        assertEquals(DistanceFormula.manhattanDistance(1, 2, 3, 4), 4);\n    }\n\n    @Test\n    public void manhattantest2() {\n        assertEquals(\n            DistanceFormula.manhattanDistance(6.5, 8.4, 20.1, 13.6),\n            18.8\n        );\n    }\n\n    @Test\n    public void manhattanTest3() {\n        assertEquals(\n            DistanceFormula.manhattanDistance(10.112, 50, 8, 25.67),\n            26.442\n        );\n    }\n\n    @Test\n    public void hammingTest1() {\n        int[] array1 = { 1, 1, 1, 1 };\n        int[] array2 = { 0, 0, 0, 0 };\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 4);\n    }\n\n    @Test\n    public void hammingTest2() {\n        int[] array1 = { 1, 1, 1, 1 };\n        int[] array2 = { 1, 1, 1, 1 };\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 0);\n    }\n\n    @Test\n    public void hammingTest3() {\n        int[] array1 = { 1, 0, 0, 1, 1, 0, 1, 1, 0 };\n        int[] array2 = { 0, 1, 0, 0, 1, 1, 1, 0, 0 };\n        assertEquals(DistanceFormula.hammingDistance(array1, array2), 5);\n    }\n\n    @Test\n    public void minkowskiTest1() {\n        double[] array1 = { 1, 3, 8, 5 };\n        double[] array2 = { 4, 2, 6, 9 };\n        assertEquals(DistanceFormula.minkowskiDistance(array1, array2, 1), 10);\n    }\n\n    @Test\n    public void minkowskiTest2() {\n        double[] array1 = { 1, 3, 8, 5 };\n        double[] array2 = { 4, 2, 6, 9 };\n        assertEquals(\n            DistanceFormula.minkowskiDistance(array1, array2, 2),\n            5.477225575051661\n        );\n    }\n\n    @Test\n    public void minkowskiTest3() {\n        double[] array1 = { 1, 3, 8, 5 };\n        double[] array2 = { 4, 2, 6, 9 };\n        assertEquals(\n            DistanceFormula.minkowskiDistance(array1, array2, 3),\n            4.641588833612778\n        );\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FFT.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FFTTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            double d = z.abs() * z.abs();\n            d = (double)Math.round(d * 1000000000d) / 1000000000d;\n            temp.real = (this.real * z.real + this.img * z.img) / (d);\n            temp.img = (this.img * z.real - this.real * z.img) / (d);\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */\n    public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n        int log2N = findLog2(N);\n        x = fftBitReversal(N,log2N,x);\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n        x = inverseFFT(N,inverse,x);\n        return x;\n    }\n\n    /* Find the log2(N) */\n    public static int findLog2(int N){\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n        return log2N;\n    }\n\n    /* Swap the values of the signal with bit-reversal method */\n    public static ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x){\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n        return x;\n    }\n\n    /* Divide by N if we want the inverse FFT */\n    public static ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x ){\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n        return x;\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            double d = z.abs() * z.abs();\n            d = (double) Math.round(d * 1000000000d) / 1000000000d;\n            temp.real = (this.real * z.real + this.img * z.img) / (d);\n            temp.img = (this.img * z.real - this.real * z.img) / (d);\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */\n    public static ArrayList<Complex> fft(\n        ArrayList<Complex> x,\n        boolean inverse\n    ) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n        int log2N = findLog2(N);\n        x = fftBitReversal(N, log2N, x);\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n        x = inverseFFT(N, inverse, x);\n        return x;\n    }\n\n    /* Find the log2(N) */\n    public static int findLog2(int N) {\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n        return log2N;\n    }\n\n    /* Swap the values of the signal with bit-reversal method */\n    public static ArrayList<Complex> fftBitReversal(\n        int N,\n        int log2N,\n        ArrayList<Complex> x\n    ) {\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n        return x;\n    }\n\n    /* Divide by N if we want the inverse FFT */\n    public static ArrayList<Complex> inverseFFT(\n        int N,\n        boolean inverse,\n        ArrayList<Complex> x\n    ) {\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n        return x;\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass FFTTest {\n\n    // Testing the simple function getReal\n    @Test\n    void getRealtest()\n    {\n        FFT.Complex complex = new FFT.Complex(1.0,1.0);\n        assertEquals(1.0,complex.getReal());\n    }\n\n    // Testing the simple function getImaginary\n    @Test\n    void getImaginaryTest()\n    {\n        FFT.Complex complex = new FFT.Complex();\n        assertEquals(0.0,complex.getImaginary());\n    }\n\n    // Testing the function add, assertEqual test\n    @Test\n    void addTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(1.0,1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0,2.0);\n        double add = complex1.add(complex2).getReal();\n        assertEquals(3.0,add);\n    }\n\n    // Testing the function add, assertNotEqual test\n    @Test\n    void addFalseTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(1.0,1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0,2.0);\n        double add = complex1.add(complex2).getReal();\n        assertNotEquals(2.0,add);\n    }\n\n    // Testing the function substract, assertEqual test\n    @Test\n    void subtractTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,1.0);\n        double sub = complex1.subtract(complex2).getReal();\n        assertEquals(1.0,sub);\n    }\n\n    // Testing the function multiply complex, assertEqual test\n    @Test\n    void multiplyWithComplexTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,1.0);\n        double multiReal = complex1.multiply(complex2).getReal();\n        double multiImg = complex1.multiply(complex2).getImaginary();\n        assertEquals(0.0,multiReal);\n        assertEquals(4.0,multiImg);\n    }\n\n    // Testing the function multiply scalar, assertEqual test\n    @Test\n    void multiplyWithScalarTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n\n        double multiReal = complex1.multiply(2).getReal();\n        double multiImg = complex1.multiply(3).getImaginary();\n        assertEquals(4.0,multiReal);\n        assertEquals(6.0,multiImg);\n    }\n\n    // Testing the function conjugate, assertEqual test\n    @Test\n    void conjugateTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        double conReal = complex1.conjugate().getReal();\n        double conImg = complex1.conjugate().getImaginary();\n        assertEquals(2.0,conReal);\n        assertEquals(-2.0,conImg);\n    }\n\n    // Testing the function abs, assertEqual test\n    @Test\n    void abs()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,3.0);\n        double abs = complex1.abs();\n        assertEquals(Math.sqrt(13),abs);\n    }\n\n    // Testing the function divide complex, assertEqual test.\n    @Test\n    void divideWithComplexTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,2.0);\n        double divReal = complex1.divide(complex2).getReal();\n        double divImg = complex1.divide(complex2).getImaginary();\n        assertEquals(1.2,divReal);\n        assertEquals(-0.4,divImg);\n    }\n\n    // Testing the function divide scalar, assertEqual test.\n    @Test\n    void divideWithScalarTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        double divReal = complex1.divide(2).getReal();\n        double divImg = complex1.divide(2).getImaginary();\n        assertEquals(1,divReal);\n        assertEquals(1,divImg);\n    }\n\n    // Testing the function fft, assertEqual test.\n    // https://scistatcalc.blogspot.com/2013/12/fft-calculator.html used this link to\n    // ensure the result\n    @Test\n    void fft()\n    {\n        ArrayList<FFT.Complex> arr = new ArrayList<FFT.Complex>();\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,3.0);\n        FFT.Complex complex3 = new FFT.Complex(3.0,1.0);\n        FFT.Complex complex4 = new FFT.Complex(2.0,2.0);\n\n        arr.add(complex1);\n        arr.add(complex2);\n        arr.add(complex3);\n        arr.add(complex4);\n        arr = FFT.fft(arr,false);\n        double realV1= arr.get(0).getReal();\n        double realV2= arr.get(2).getReal();\n        double imgV1 = arr.get(0).getImaginary();\n        double imgV2 = arr.get(2).getImaginary();\n        assertEquals(8.0,realV1);\n        assertEquals(2.0,realV2);\n        assertEquals(8.0, imgV1);\n        assertEquals(-2.0,imgV2);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\n\nclass FFTTest {\n\n    // Testing the simple function getReal\n    @Test\n    void getRealtest() {\n        FFT.Complex complex = new FFT.Complex(1.0, 1.0);\n        assertEquals(1.0, complex.getReal());\n    }\n\n    // Testing the simple function getImaginary\n    @Test\n    void getImaginaryTest() {\n        FFT.Complex complex = new FFT.Complex();\n        assertEquals(0.0, complex.getImaginary());\n    }\n\n    // Testing the function add, assertEqual test\n    @Test\n    void addTest() {\n        FFT.Complex complex1 = new FFT.Complex(1.0, 1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0, 2.0);\n        double add = complex1.add(complex2).getReal();\n        assertEquals(3.0, add);\n    }\n\n    // Testing the function add, assertNotEqual test\n    @Test\n    void addFalseTest() {\n        FFT.Complex complex1 = new FFT.Complex(1.0, 1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0, 2.0);\n        double add = complex1.add(complex2).getReal();\n        assertNotEquals(2.0, add);\n    }\n\n    // Testing the function substract, assertEqual test\n    @Test\n    void subtractTest() {\n        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0, 1.0);\n        double sub = complex1.subtract(complex2).getReal();\n        assertEquals(1.0, sub);\n    }\n\n    // Testing the function multiply complex, assertEqual test\n    @Test\n    void multiplyWithComplexTest() {\n        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0, 1.0);\n        double multiReal = complex1.multiply(complex2).getReal();\n        double multiImg = complex1.multiply(complex2).getImaginary();\n        assertEquals(0.0, multiReal);\n        assertEquals(4.0, multiImg);\n    }\n\n    // Testing the function multiply scalar, assertEqual test\n    @Test\n    void multiplyWithScalarTest() {\n        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);\n\n        double multiReal = complex1.multiply(2).getReal();\n        double multiImg = complex1.multiply(3).getImaginary();\n        assertEquals(4.0, multiReal);\n        assertEquals(6.0, multiImg);\n    }\n\n    // Testing the function conjugate, assertEqual test\n    @Test\n    void conjugateTest() {\n        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);\n        double conReal = complex1.conjugate().getReal();\n        double conImg = complex1.conjugate().getImaginary();\n        assertEquals(2.0, conReal);\n        assertEquals(-2.0, conImg);\n    }\n\n    // Testing the function abs, assertEqual test\n    @Test\n    void abs() {\n        FFT.Complex complex1 = new FFT.Complex(2.0, 3.0);\n        double abs = complex1.abs();\n        assertEquals(Math.sqrt(13), abs);\n    }\n\n    // Testing the function divide complex, assertEqual test.\n    @Test\n    void divideWithComplexTest() {\n        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0, 2.0);\n        double divReal = complex1.divide(complex2).getReal();\n        double divImg = complex1.divide(complex2).getImaginary();\n        assertEquals(1.2, divReal);\n        assertEquals(-0.4, divImg);\n    }\n\n    // Testing the function divide scalar, assertEqual test.\n    @Test\n    void divideWithScalarTest() {\n        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);\n        double divReal = complex1.divide(2).getReal();\n        double divImg = complex1.divide(2).getImaginary();\n        assertEquals(1, divReal);\n        assertEquals(1, divImg);\n    }\n\n    // Testing the function fft, assertEqual test.\n    // https://scistatcalc.blogspot.com/2013/12/fft-calculator.html used this link to\n    // ensure the result\n    @Test\n    void fft() {\n        ArrayList<FFT.Complex> arr = new ArrayList<FFT.Complex>();\n        FFT.Complex complex1 = new FFT.Complex(2.0, 2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0, 3.0);\n        FFT.Complex complex3 = new FFT.Complex(3.0, 1.0);\n        FFT.Complex complex4 = new FFT.Complex(2.0, 2.0);\n\n        arr.add(complex1);\n        arr.add(complex2);\n        arr.add(complex3);\n        arr.add(complex4);\n        arr = FFT.fft(arr, false);\n        double realV1 = arr.get(0).getReal();\n        double realV2 = arr.get(2).getReal();\n        double imgV1 = arr.get(0).getImaginary();\n        double imgV2 = arr.get(2).getImaginary();\n        assertEquals(8.0, realV1);\n        assertEquals(2.0, realV2);\n        assertEquals(8.0, imgV1);\n        assertEquals(-2.0, imgV2);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Factorial.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FactorialTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class Factorial {\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        assert factorial(0) == 1;\n        assert factorial(1) == 1;\n        assert factorial(5) == 120;\n        assert factorial(10) == 3628800;\n    }\n\n    /**\n     * Calculate factorial N using iteration\n     *\n     * @param n the number\n     * @return the factorial of {@code n}\n     */\n    public static long factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"number is negative\");\n        }\n        long factorial = 1;\n        for (int i = 1; i <= n; factorial *= i, ++i)\n      ;\n        return factorial;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class Factorial {\n\n    /* Driver Code */\n    public static void main(String[] args) {\n        assert factorial(0) == 1;\n        assert factorial(1) == 1;\n        assert factorial(5) == 120;\n        assert factorial(10) == 3628800;\n    }\n\n    /**\n     * Calculate factorial N using iteration\n     *\n     * @param n the number\n     * @return the factorial of {@code n}\n     */\n    public static long factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"number is negative\");\n        }\n        long factorial = 1;\n        for (int i = 1; i <= n; factorial *= i, ++i);\n        return factorial;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\n\npublic class FactorialTest {\n\n    @Test\n    public void test() {\n        Factorial fact = new Factorial();\n        assertEquals(120,fact.factorial(5));\n }\n\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FactorialTest {\n\n    @Test\n    public void test() {\n        Factorial fact = new Factorial();\n        assertEquals(120, fact.factorial(5));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FastInverseSqrt.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FastInverseSqrtTests.java",
        "product_old_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n\n/** Program description - To find out the inverse square root of the given number*/\n\n/** Wikipedia Link - https://en.wikipedia.org/wiki/Fast_inverse_square_root */\n\n\npackage com.thealgorithms.maths;\n\npublic class FastInverseSqrt {\n    public static boolean inverseSqrt(float number) {\n        float x = number;\n        float xhalf = 0.5f * x;\n        int i = Float.floatToIntBits(x);\n        i = 0x5f3759df - (i >> 1);\n        x = Float.intBitsToFloat(i);\n        x = x * (1.5f - xhalf * x * x);\n        return x == (float)((float)1/(float)Math.sqrt(number));\n    }\n    \n    /**\n     * Returns the inverse square root of the given number upto 6 - 8 decimal places.\n     * calculates the inverse square root of the given number and returns true if calculated answer matches with given answer else returns false\n     */\n\n    \n    public static boolean inverseSqrt(double number) {\n        double x = number;\n        double xhalf = 0.5d * x;\n        long i = Double.doubleToLongBits(x);\n        i = 0x5fe6ec85e7de30daL - (i >> 1);\n        x = Double.longBitsToDouble(i);\n        for (int it = 0; it < 4; it++) {\n            x = x * (1.5d - xhalf * x * x);\n        }\n        x *= number;\n        return x == 1/Math.sqrt(number);\n    }\n    /**\n     * Returns the inverse square root of the given number upto 14 - 16 decimal places.\n     * calculates the inverse square root of the given number and returns true if calculated answer matches with given answer else returns false\n     */\n}\n\n\n/**\n     * OUTPUT :\n     * Input - number = 4522\n     * Output: it calculates the inverse squareroot of a number and returns true with it matches the given answer else returns false.\n     * 1st approach Time Complexity : O(1)\n     * Auxiliary Space Complexity : O(1)\n     * Input - number = 4522\n     * Output: it calculates the inverse squareroot of a number and returns true with it matches the given answer else returns false.\n     * 2nd approach Time Complexity : O(1)\n     * Auxiliary Space Complexity : O(1)\n     */",
        "product_new_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** Program description - To find out the inverse square root of the given number*/\n\n/** Wikipedia Link - https://en.wikipedia.org/wiki/Fast_inverse_square_root */\n\npackage com.thealgorithms.maths;\n\npublic class FastInverseSqrt {\n\n    public static boolean inverseSqrt(float number) {\n        float x = number;\n        float xhalf = 0.5f * x;\n        int i = Float.floatToIntBits(x);\n        i = 0x5f3759df - (i >> 1);\n        x = Float.intBitsToFloat(i);\n        x = x * (1.5f - xhalf * x * x);\n        return x == (float) ((float) 1 / (float) Math.sqrt(number));\n    }\n\n    /**\n     * Returns the inverse square root of the given number upto 6 - 8 decimal places.\n     * calculates the inverse square root of the given number and returns true if calculated answer matches with given answer else returns false\n     */\n\n    public static boolean inverseSqrt(double number) {\n        double x = number;\n        double xhalf = 0.5d * x;\n        long i = Double.doubleToLongBits(x);\n        i = 0x5fe6ec85e7de30daL - (i >> 1);\n        x = Double.longBitsToDouble(i);\n        for (int it = 0; it < 4; it++) {\n            x = x * (1.5d - xhalf * x * x);\n        }\n        x *= number;\n        return x == 1 / Math.sqrt(number);\n    }\n    /**\n     * Returns the inverse square root of the given number upto 14 - 16 decimal places.\n     * calculates the inverse square root of the given number and returns true if calculated answer matches with given answer else returns false\n     */\n}\n/**\n * OUTPUT :\n * Input - number = 4522\n * Output: it calculates the inverse squareroot of a number and returns true with it matches the given answer else returns false.\n * 1st approach Time Complexity : O(1)\n * Auxiliary Space Complexity : O(1)\n * Input - number = 4522\n * Output: it calculates the inverse squareroot of a number and returns true with it matches the given answer else returns false.\n * 2nd approach Time Complexity : O(1)\n * Auxiliary Space Complexity : O(1)\n */",
        "test_old_content": "package com.thealgorithms.maths;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\n\npublic class FastInverseSqrtTests {\n    @Test\n\tvoid testForOneElement() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1332));\n        // calls for the 2nd inverse method\n    }\n\t@Test\n\tvoid testForsecond() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1332f));\n        // calls for the 1st inverse method\n\t}\n\n\t@Test\n\tvoid testForThird() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1));\n\t}\n    \n\t@Test\n\tvoid testForFourth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1f));\n\t}\n\n\t@Test\n\tvoid testForFifth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(4522));\n\t}\n    \n\t@Test\n\tvoid testForSixth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(4522f));\n\t}\n\n\t@Test\n\tvoid testForSeventh() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(21));\n    }\n\n\t@Test\n\tvoid testForEighth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(21f));\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FastInverseSqrtTests {\n\n    @Test\n    void testForOneElement() {\n        assertFalse(FastInverseSqrt.inverseSqrt(1332));\n        // calls for the 2nd inverse method\n    }\n\n    @Test\n    void testForsecond() {\n        assertFalse(FastInverseSqrt.inverseSqrt(1332f));\n        // calls for the 1st inverse method\n    }\n\n    @Test\n    void testForThird() {\n        assertFalse(FastInverseSqrt.inverseSqrt(1));\n    }\n\n    @Test\n    void testForFourth() {\n        assertFalse(FastInverseSqrt.inverseSqrt(1f));\n    }\n\n    @Test\n    void testForFifth() {\n        assertFalse(FastInverseSqrt.inverseSqrt(4522));\n    }\n\n    @Test\n    void testForSixth() {\n        assertFalse(FastInverseSqrt.inverseSqrt(4522f));\n    }\n\n    @Test\n    void testForSeventh() {\n        assertFalse(FastInverseSqrt.inverseSqrt(21));\n    }\n\n    @Test\n    void testForEighth() {\n        assertFalse(FastInverseSqrt.inverseSqrt(21f));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/GCD.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GCDTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * get greatest common divisor in array\n     *\n     * @param number contains number\n     * @return gcd\n     */\n    public static int gcd(int[] number) {\n        int result = number[0];\n        for (int i = 1; i < number.length; i++) // call gcd function (input two value)\n        {\n            result = gcd(result, number[i]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = {4, 16, 32};\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\"gcd(40,24)=%d gcd(24,40)=%d%n\", gcd(40, 24), gcd(24, 40)); // => 8\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * get greatest common divisor in array\n     *\n     * @param number contains number\n     * @return gcd\n     */\n    public static int gcd(int[] number) {\n        int result = number[0];\n        for (int i = 1; i < number.length; i++) { // call gcd function (input two value)\n            result = gcd(result, number[i]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n    @Test\n    void test1() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-1,0));\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(10, -2));\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-5, -3));\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-1, 0)\n        );\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(10, -2)\n        );\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-5, -3)\n        );\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Gaussian.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GaussianTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\n\npublic class Gaussian {\n\n    public static ArrayList<Double> gaussian(int mat_size, ArrayList<Double> matrix) {\n        ArrayList<Double> answerArray = new ArrayList<Double>();\n        int i, j = 0;\n\n        double[][] mat = new double[mat_size + 1][mat_size + 1];\n        double[][] x = new double[mat_size][mat_size + 1];\n\n        // Values from arraylist to matrix\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                mat[i][j] = matrix.get(i);\n            }\n        }\n\n        mat = gaussianElimination(mat_size, i, mat);\n        answerArray = valueOfGaussian(mat_size, x, mat);\n        return answerArray;\n    }\n\n    // Perform Gaussian elimination\n    public static double[][] gaussianElimination(int mat_size, int i, double[][] mat) {\n        int step = 0;\n        for (step = 0; step < mat_size - 1; step++) {\n            for (i = step; i < mat_size - 1; i++) {\n                double a = (mat[i + 1][step] / mat[step][step]);\n\n                for (int j = step; j <= mat_size; j++) {\n                    mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);\n                }\n            }\n        }\n        return mat;\n    }\n\n    // calculate the x_1, x_2,... values of the gaussian and save it in an arraylist.\n    public static ArrayList<Double> valueOfGaussian(int mat_size, double[][] x, double[][] mat) {\n        ArrayList<Double> answerArray = new ArrayList<Double>();\n        int i, j;\n\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                x[i][j] = mat[i][j];\n            }\n        }\n\n        for (i = mat_size - 1; i >= 0; i--) {\n            double sum = 0;\n            for (j = mat_size - 1; j > i; j--) {\n                x[i][j] = x[j][j] * x[i][j];\n                sum = x[i][j] + sum;\n            }\n            if (x[i][i] == 0) {\n                x[i][i] = 0;\n            } else {\n                x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);\n            }\n            answerArray.add(x[i][j]);\n        }\n        return answerArray;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\n\npublic class Gaussian {\n\n    public static ArrayList<Double> gaussian(\n        int mat_size,\n        ArrayList<Double> matrix\n    ) {\n        ArrayList<Double> answerArray = new ArrayList<Double>();\n        int i, j = 0;\n\n        double[][] mat = new double[mat_size + 1][mat_size + 1];\n        double[][] x = new double[mat_size][mat_size + 1];\n\n        // Values from arraylist to matrix\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                mat[i][j] = matrix.get(i);\n            }\n        }\n\n        mat = gaussianElimination(mat_size, i, mat);\n        answerArray = valueOfGaussian(mat_size, x, mat);\n        return answerArray;\n    }\n\n    // Perform Gaussian elimination\n    public static double[][] gaussianElimination(\n        int mat_size,\n        int i,\n        double[][] mat\n    ) {\n        int step = 0;\n        for (step = 0; step < mat_size - 1; step++) {\n            for (i = step; i < mat_size - 1; i++) {\n                double a = (mat[i + 1][step] / mat[step][step]);\n\n                for (int j = step; j <= mat_size; j++) {\n                    mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);\n                }\n            }\n        }\n        return mat;\n    }\n\n    // calculate the x_1, x_2,... values of the gaussian and save it in an arraylist.\n    public static ArrayList<Double> valueOfGaussian(\n        int mat_size,\n        double[][] x,\n        double[][] mat\n    ) {\n        ArrayList<Double> answerArray = new ArrayList<Double>();\n        int i, j;\n\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                x[i][j] = mat[i][j];\n            }\n        }\n\n        for (i = mat_size - 1; i >= 0; i--) {\n            double sum = 0;\n            for (j = mat_size - 1; j > i; j--) {\n                x[i][j] = x[j][j] * x[i][j];\n                sum = x[i][j] + sum;\n            }\n            if (x[i][i] == 0) {\n                x[i][i] = 0;\n            } else {\n                x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);\n            }\n            answerArray.add(x[i][j]);\n        }\n        return answerArray;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\n\nimport static com.thealgorithms.maths.Gaussian.gaussian;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class GaussianTest {\n\n    // easy pass test for the whole class. Matrix of 2*3.\n    @Test\n    void passTest1()\n    {\n        ArrayList<Double> list = new ArrayList<Double>();\n        ArrayList<Double> gaussian = new ArrayList<Double>();\n        ArrayList<Double> answer = new ArrayList<Double>();\n        answer.add(0.0);\n        answer.add(1.0);\n\n        int matrixSize = 2;\n        list.add(1.0);\n        list.add(1.0);\n        list.add(1.0);\n        list.add(2.0);\n        list.add(1.0);\n        list.add(1.0);\n        gaussian=gaussian(matrixSize,list);\n\n        assertEquals(answer,gaussian);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static com.thealgorithms.maths.Gaussian.gaussian;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\n\npublic class GaussianTest {\n\n    // easy pass test for the whole class. Matrix of 2*3.\n    @Test\n    void passTest1() {\n        ArrayList<Double> list = new ArrayList<Double>();\n        ArrayList<Double> gaussian = new ArrayList<Double>();\n        ArrayList<Double> answer = new ArrayList<Double>();\n        answer.add(0.0);\n        answer.add(1.0);\n\n        int matrixSize = 2;\n        list.add(1.0);\n        list.add(1.0);\n        list.add(1.0);\n        list.add(2.0);\n        list.add(1.0);\n        list.add(1.0);\n        gaussian = gaussian(matrixSize, list);\n\n        assertEquals(answer, gaussian);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/HeronsFormula.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/HeronsFormulaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of a triangle using only side lengths\n */\n\npublic class HeronsFormula {\n\t\n\tpublic static double Herons(int s1, int s2, int s3)\n\t{\n\t\tdouble a = s1;\n\t\tdouble b = s2;\n\t\tdouble c = s3;\n\t\tdouble s = (a + b + c)/2.0;\n\t\tdouble area = 0;\n\t\tarea = Math.sqrt((s)*(s-a)*(s-b)*(s-c));\n\t\treturn area;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of a triangle using only side lengths\n */\n\npublic class HeronsFormula {\n\n    public static double Herons(int s1, int s2, int s3) {\n        double a = s1;\n        double b = s2;\n        double c = s3;\n        double s = (a + b + c) / 2.0;\n        double area = 0;\n        area = Math.sqrt((s) * (s - a) * (s - b) * (s - c));\n        return area;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class HeronsFormulaTest {\n\t\t@Test\n\t\tvoid test1()\n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(3,4,5), 6.0);\n\t\t}\n\t\t@Test\n\t\tvoid test2() \n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(24,30,18), 216.0);\n\t\t}\n\t\t@Test\n\t\tvoid test3()\n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(1,1,1), 0.4330127018922193);\n\t\t}\n\t\t@Test\n\t\tvoid test4()\n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(4,5,8), 8.181534085976786);\n\t\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class HeronsFormulaTest {\n\n    @Test\n    void test1() {\n        Assertions.assertEquals(HeronsFormula.Herons(3, 4, 5), 6.0);\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertEquals(HeronsFormula.Herons(24, 30, 18), 216.0);\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertEquals(\n            HeronsFormula.Herons(1, 1, 1),\n            0.4330127018922193\n        );\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(\n            HeronsFormula.Herons(4, 5, 8),\n            8.181534085976786\n        );\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/JosephusProblem.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/JosephusProblemTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n     /** There are n friends that are playing a game. The friends are sitting in a circle and are    numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\n    */\n\n    /** The rules of the game are as follows:\n\n        1.Start at the 1st friend.\n        2.Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\n        3.The last friend you counted leaves the circle and loses the game.\n        4.If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\n        5.Else, the last friend in the circle wins the game.\n\n        @author Kunal\n    */\n\npublic class JosephusProblem {\n\n    /**\n     * Find the Winner of the Circular Game.\n     *\n     * @param number of friends, n, and an integer k\n     * @return return the winner of the game\n     */\n\n    public static int findTheWinner(int n, int k) {\n        return winner(n, k) + 1;\n    }\n    \n    public static int winner(int n, int k){\n        if (n == 1){\n            return 0;\n        }\n        return (winner(n -1, k) + k) % n;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/** There are n friends that are playing a game. The friends are sitting in a circle and are    numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\n */\n\n/** The rules of the game are as follows:\n\n        1.Start at the 1st friend.\n        2.Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\n        3.The last friend you counted leaves the circle and loses the game.\n        4.If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\n        5.Else, the last friend in the circle wins the game.\n\n        @author Kunal\n    */\n\npublic class JosephusProblem {\n\n    /**\n     * Find the Winner of the Circular Game.\n     *\n     * @param number of friends, n, and an integer k\n     * @return return the winner of the game\n     */\n\n    public static int findTheWinner(int n, int k) {\n        return winner(n, k) + 1;\n    }\n\n    public static int winner(int n, int k) {\n        if (n == 1) {\n            return 0;\n        }\n        return (winner(n - 1, k) + k) % n;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class JosephusProblemTest {\n\n    @Test\n    void testJosephusProblem(){\n        assertEquals(3, JosephusProblem.findTheWinner(5,2));\n        assertEquals(5, JosephusProblem.findTheWinner(6,4));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class JosephusProblemTest {\n\n    @Test\n    void testJosephusProblem() {\n        assertEquals(3, JosephusProblem.findTheWinner(5, 2));\n        assertEquals(5, JosephusProblem.findTheWinner(6, 4));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/KaprekarNumbers.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/KaprekarNumbersTest.java",
        "product_old_content": "package com.thealgorithms.maths;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n\t/* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n\t// Provides a list of kaprekarNumber in a range\n\tpublic static ArrayList<Long> kaprekarNumberInRange(long start, long end) throws Exception {\n\t\tlong n = end-start;\n\t\tif (n <0) throw new Exception(\"Invalid range\");\n\t\tArrayList<Long> list = new ArrayList<>();\n\n\t\tfor (long i = start; i <= end; i++) {\n\t\t\tif (isKaprekarNumber(i)) list.add(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t// Checks whether a given number is Kaprekar Number or not\n\tpublic static boolean isKaprekarNumber(long num) {\n\t\tString number = Long.toString(num);\n\t\tBigInteger originalNumber = new BigInteger(number);\n\t\tBigInteger numberSquared = originalNumber.multiply(originalNumber);\n\t\tif(number.length() == numberSquared.toString().length()){\n\t\t\treturn number.equals(numberSquared.toString());\n\t\t}\n\t\telse{\n\t\t\tBigInteger leftDigits1 = new BigInteger(\"0\");\n\t\t\tBigInteger leftDigits2;\n\t\t\tif(numberSquared.toString().contains(\"0\")){\n\t\t\t\tleftDigits1 = new BigInteger(\n\t\t\t\t\t\tnumberSquared.toString().\n\t\t\t\t\t\t\t\tsubstring(0, numberSquared.toString().indexOf(\"0\")\n\t\t\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tleftDigits2 = new BigInteger(\n\t\t\t\t\tnumberSquared.toString()\n\t\t\t\t\t\t\t.substring(0, (numberSquared.toString().length() - number.length()))\n\t\t\t);\n\t\t\tBigInteger rightDigits = new BigInteger(numberSquared.toString().substring(numberSquared.toString().length() - number.length()));\n\t\t\tString x = leftDigits1.add(rightDigits).toString();\n\t\t\tString y = leftDigits2.add(rightDigits).toString();\n\t\t\treturn (number.equals(x)) || (number.equals(y));\n\t\t}\t\t\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n    /* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n    // Provides a list of kaprekarNumber in a range\n    public static ArrayList<Long> kaprekarNumberInRange(long start, long end)\n        throws Exception {\n        long n = end - start;\n        if (n < 0) throw new Exception(\"Invalid range\");\n        ArrayList<Long> list = new ArrayList<>();\n\n        for (long i = start; i <= end; i++) {\n            if (isKaprekarNumber(i)) list.add(i);\n        }\n\n        return list;\n    }\n\n    // Checks whether a given number is Kaprekar Number or not\n    public static boolean isKaprekarNumber(long num) {\n        String number = Long.toString(num);\n        BigInteger originalNumber = new BigInteger(number);\n        BigInteger numberSquared = originalNumber.multiply(originalNumber);\n        if (number.length() == numberSquared.toString().length()) {\n            return number.equals(numberSquared.toString());\n        } else {\n            BigInteger leftDigits1 = new BigInteger(\"0\");\n            BigInteger leftDigits2;\n            if (numberSquared.toString().contains(\"0\")) {\n                leftDigits1 =\n                    new BigInteger(\n                        numberSquared\n                            .toString()\n                            .substring(0, numberSquared.toString().indexOf(\"0\"))\n                    );\n            }\n            leftDigits2 =\n                new BigInteger(\n                    numberSquared\n                        .toString()\n                        .substring(\n                            0,\n                            (\n                                numberSquared.toString().length() -\n                                number.length()\n                            )\n                        )\n                );\n            BigInteger rightDigits = new BigInteger(\n                numberSquared\n                    .toString()\n                    .substring(\n                        numberSquared.toString().length() - number.length()\n                    )\n            );\n            String x = leftDigits1.add(rightDigits).toString();\n            String y = leftDigits2.add(rightDigits).toString();\n            return (number.equals(x)) || (number.equals(y));\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KaprekarNumbersTest {\n\n\t@Test\n\tvoid testFor1() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(1));\n\t}\n\n\t@Test\n\tvoid testFor45() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(45));\n\t}\n\n\t@Test\n\tvoid testFor297() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(297));\n\t}\n\n\t@Test\n\tvoid testFor2223() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n\t}\n\n\t@Test\n\tvoid testFor857143() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n\t}\n\n\n\t@Test\n\tvoid testFor3() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(3));\n\t}\n\n\t@Test\n\tvoid testFor26() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(26));\n\t}\n\n\t@Test\n\tvoid testFor98() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(98));\n\t}\n\n\t@Test\n\tvoid testForRangeOfNumber() { try {\n\t\tArrayList<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(1,100000);\n\t\tlong[] allTheNumbers = {1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4950, 5050, 7272, 7777, 9999, 17344, 22222, 77778, 82656, 95121, 99999};\n\t\tfor (long i:allTheNumbers) {\n\t\t\tassert rangedNumbers.contains(i);\n\t\t}\n\t} catch (Exception e) {\n\t\tassert false;\n\t}\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\n\npublic class KaprekarNumbersTest {\n\n    @Test\n    void testFor1() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(1));\n    }\n\n    @Test\n    void testFor45() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(45));\n    }\n\n    @Test\n    void testFor297() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(297));\n    }\n\n    @Test\n    void testFor2223() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n    }\n\n    @Test\n    void testFor857143() {\n        assertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n    }\n\n    @Test\n    void testFor3() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(3));\n    }\n\n    @Test\n    void testFor26() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(26));\n    }\n\n    @Test\n    void testFor98() {\n        assertFalse(KaprekarNumbers.isKaprekarNumber(98));\n    }\n\n    @Test\n    void testForRangeOfNumber() {\n        try {\n            ArrayList<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(\n                1,\n                100000\n            );\n            long[] allTheNumbers = {\n                1,\n                9,\n                45,\n                55,\n                99,\n                297,\n                703,\n                999,\n                2223,\n                2728,\n                4950,\n                5050,\n                7272,\n                7777,\n                9999,\n                17344,\n                22222,\n                77778,\n                82656,\n                95121,\n                99999,\n            };\n            for (long i : allTheNumbers) {\n                assert rangedNumbers.contains(i);\n            }\n        } catch (Exception e) {\n            assert false;\n        }\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LeastCommonMultiple.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LeastCommonMultipleTest.java",
        "product_old_content": "package com.thealgorithms.maths;\nimport java.util.*;\n/**\n * Is a common mathematics concept to find the smallest value number \n * that can be divide using either number without having the remainder. \n * https://maticschool.blogspot.com/2013/11/find-least-common-multiple-lcm.html\n * @author LauKinHoong\n */\n\npublic class LeastCommonMultiple {\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner(System.in);\n        System.out.println(\"Please enter first number >> \");\n        int num1 = input.nextInt();\n        System.out.println(\"Please enter second number >> \");\n        int num2 = input.nextInt();\n        System.out.println(\"The least common multiple of two numbers is >> \" + lcm(num1,num2));\n\n\t}\n\t\n    /*\n     * get least common multiple from two number\n     */\n\tpublic static int lcm (int num1, int num2){\n        int high, num3;\n        int cmv = 0;\n        /*\n         * value selection for the numerator\n         */\n        if (num1 > num2){\n            high = num3 = num1;\n        }\n        else{\n            high = num3 = num2;\n        }\n\n        while(num1 != 0){\n            if(high % num1 == 0 && high % num2 == 0){\n                cmv = high;\n                break;\n            }\n            high += num3;\n        }\n        return cmv;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.*;\n\n/**\n * Is a common mathematics concept to find the smallest value number\n * that can be divide using either number without having the remainder.\n * https://maticschool.blogspot.com/2013/11/find-least-common-multiple-lcm.html\n * @author LauKinHoong\n */\n\npublic class LeastCommonMultiple {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Please enter first number >> \");\n        int num1 = input.nextInt();\n        System.out.println(\"Please enter second number >> \");\n        int num2 = input.nextInt();\n        System.out.println(\n            \"The least common multiple of two numbers is >> \" + lcm(num1, num2)\n        );\n    }\n\n    /*\n     * get least common multiple from two number\n     */\n    public static int lcm(int num1, int num2) {\n        int high, num3;\n        int cmv = 0;\n        /*\n         * value selection for the numerator\n         */\n        if (num1 > num2) {\n            high = num3 = num1;\n        } else {\n            high = num3 = num2;\n        }\n\n        while (num1 != 0) {\n            if (high % num1 == 0 && high % num2 == 0) {\n                cmv = high;\n                break;\n            }\n            high += num3;\n        }\n        return cmv;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeastCommonMultipleTest {\n    /*\n\t * Test for first number greater than second number\n\t */\n\t@Test\n\tpublic void testForFirst() {\n\t\tint result = LeastCommonMultiple.lcm(6,8);\n\t\tint expected = 24;\n\t\tAssertions.assertEquals(result, expected);\n\t}\n\n\t/*\n\t * Test for second number greater than first number\n\t */\n\t@Test\n\tpublic void testForSecond() {\n\t\tint result = LeastCommonMultiple.lcm(8,6);\n\t\tint expected = 24;\n\t\tAssertions.assertEquals(result, expected);\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeastCommonMultipleTest {\n\n    /*\n     * Test for first number greater than second number\n     */\n    @Test\n    public void testForFirst() {\n        int result = LeastCommonMultiple.lcm(6, 8);\n        int expected = 24;\n        Assertions.assertEquals(result, expected);\n    }\n\n    /*\n     * Test for second number greater than first number\n     */\n    @Test\n    public void testForSecond() {\n        int result = LeastCommonMultiple.lcm(8, 6);\n        int expected = 24;\n        Assertions.assertEquals(result, expected);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LiouvilleLambdaFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LiouvilleLambdaFunctionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for liouville lambda function\n * For any positive integer n, define \u03bb(n) as the sum of the primitive nth roots of unity. \n * It has values in {\u22121, 1} depending on the factorization of n into prime factors:\n *   \u03bb(n) = +1 if n is a positive integer with an even number of prime factors.\n *   \u03bb(n) = \u22121 if n is a positive integer with an odd number of prime factors.\n * Wikipedia: https://en.wikipedia.org/wiki/Liouville_function\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class LiouvilleLambdaFunction {\n\n\t/**\n\t * This method returns \u03bb(n) of given number n\n\t *\n\t * @param number Integer value which \u03bb(n) is to be calculated \n\t * @return  1 when number has even number of prime factors\n\t *         -1 when number has odd number of prime factors\n\t * @throws IllegalArgumentException when number is negative\n\t */\n\tstatic int liouvilleLambda(int number) {\n\t\tif(number <= 0) {\n\t\t\t//throw exception when number is less than or is zero\n\t\t\tthrow new IllegalArgumentException(\"Number must be greater than zero.\");\n\t\t}\n\n\t\t//return 1 if size of prime factor list is even, -1 otherwise\n\t\treturn PrimeFactorization.pfactors(number).size() % 2 == 0 ? 1 : -1;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for liouville lambda function\n * For any positive integer n, define \u03bb(n) as the sum of the primitive nth roots of unity.\n * It has values in {\u22121, 1} depending on the factorization of n into prime factors:\n *   \u03bb(n) = +1 if n is a positive integer with an even number of prime factors.\n *   \u03bb(n) = \u22121 if n is a positive integer with an odd number of prime factors.\n * Wikipedia: https://en.wikipedia.org/wiki/Liouville_function\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class LiouvilleLambdaFunction {\n\n    /**\n     * This method returns \u03bb(n) of given number n\n     *\n     * @param number Integer value which \u03bb(n) is to be calculated\n     * @return  1 when number has even number of prime factors\n     *         -1 when number has odd number of prime factors\n     * @throws IllegalArgumentException when number is negative\n     */\n    static int liouvilleLambda(int number) {\n        if (number <= 0) {\n            //throw exception when number is less than or is zero\n            throw new IllegalArgumentException(\n                \"Number must be greater than zero.\"\n            );\n        }\n\n        //return 1 if size of prime factor list is even, -1 otherwise\n        return PrimeFactorization.pfactors(number).size() % 2 == 0 ? 1 : -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass LiouvilleLambdaFunctionTest {\n\n\t@Test\n\tvoid testLiouvilleLambdaMustThrowExceptionIfNumberIsZero() {\n\t\t//given\n\t\tint number = 0;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tLiouvilleLambdaFunction.liouvilleLambda(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustThrowExceptionIfNumberIsNegative() {\n\t\t//given\n\t\tint number = -1;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tLiouvilleLambdaFunction.liouvilleLambda(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustReturnNegativeOne() {\n\t\t//given\n\t\tint number = 11;\n\t\tint expectedOutput = -1;\n\n\t\t//when\n\t\tint actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n\t\t//then\n\t\tassertEquals(expectedOutput, actualOutput);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustReturnPositiveOne() {\n\t\t//given\n\t\tint number = 10;\n\t\tint expectedOutput = 1;\n\n\t\t//when\n\t\tint actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n\t\t//then\n\t\tassertEquals(expectedOutput, actualOutput);\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass LiouvilleLambdaFunctionTest {\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsZero() {\n        //given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                LiouvilleLambdaFunction.liouvilleLambda(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsNegative() {\n        //given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                LiouvilleLambdaFunction.liouvilleLambda(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnNegativeOne() {\n        //given\n        int number = 11;\n        int expectedOutput = -1;\n\n        //when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        //then\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnPositiveOne() {\n        //given\n        int number = 10;\n        int expectedOutput = 1;\n\n        //when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        //then\n        assertEquals(expectedOutput, actualOutput);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/MobiusFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MobiusFunctionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for mobius function\n * For any positive integer n, define \u03bc(n) as the sum of the primitive nth roots of unity. \n * It has values in {\u22121, 0, 1} depending on the factorization of n into prime factors:\n *   \u03bc(n) = +1 if n is a square-free positive integer with an even number of prime factors.\n *   \u03bc(n) = \u22121 if n is a square-free positive integer with an odd number of prime factors.\n *   \u03bc(n) = 0 if n has a squared prime factor.\n * Wikipedia: https://en.wikipedia.org/wiki/M%C3%B6bius_function\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\npublic class MobiusFunction {\n\n\t/**\n\t * This method returns \u03bc(n) of given number n\n\t *\n\t * @param number Integer value which \u03bc(n) is to be calculated \n\t * @return  1 when number is less than or equals 1 \n\t *            or number has even number of prime factors\n\t *          0 when number has repeated prime factor\n\t *         -1 when number has odd number of prime factors\n\t */\n\tstatic int mobius(int number) {\n\n\t\tif(number <= 0) {\n\t\t\t//throw exception when number is less than or is zero\n\t\t\tthrow new IllegalArgumentException(\"Number must be greater than zero.\");\n\t\t}\n\n\t\tif(number == 1) {\n\t\t\t//return 1 if number passed is less or is 1\n\t\t\treturn 1;\n\t\t}\n\n\t\tint primeFactorCount=0;\n\n\t\tfor(int i = 1; i <= number; i++) {\n\t\t\t//find prime factors of number\n\t\t\tif(number % i == 0 && PrimeCheck.isPrime(i)) {\n\t\t\t\t//check if number is divisible by square of prime factor\n\t\t\t\tif(number % (i*i) == 0) { \n\t\t\t\t\t//if number is divisible by square of prime factor\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/*increment primeFactorCount by 1 \n\t\t\t\tif number is not divisible by square of found prime factor*/\n\t\t\t\tprimeFactorCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn (primeFactorCount % 2 == 0) ? 1 : -1;\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for mobius function\n * For any positive integer n, define \u03bc(n) as the sum of the primitive nth roots of unity.\n * It has values in {\u22121, 0, 1} depending on the factorization of n into prime factors:\n *   \u03bc(n) = +1 if n is a square-free positive integer with an even number of prime factors.\n *   \u03bc(n) = \u22121 if n is a square-free positive integer with an odd number of prime factors.\n *   \u03bc(n) = 0 if n has a squared prime factor.\n * Wikipedia: https://en.wikipedia.org/wiki/M%C3%B6bius_function\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\npublic class MobiusFunction {\n\n    /**\n     * This method returns \u03bc(n) of given number n\n     *\n     * @param number Integer value which \u03bc(n) is to be calculated\n     * @return  1 when number is less than or equals 1\n     *            or number has even number of prime factors\n     *          0 when number has repeated prime factor\n     *         -1 when number has odd number of prime factors\n     */\n    static int mobius(int number) {\n        if (number <= 0) {\n            //throw exception when number is less than or is zero\n            throw new IllegalArgumentException(\n                \"Number must be greater than zero.\"\n            );\n        }\n\n        if (number == 1) {\n            //return 1 if number passed is less or is 1\n            return 1;\n        }\n\n        int primeFactorCount = 0;\n\n        for (int i = 1; i <= number; i++) {\n            //find prime factors of number\n            if (number % i == 0 && PrimeCheck.isPrime(i)) {\n                //check if number is divisible by square of prime factor\n                if (number % (i * i) == 0) {\n                    //if number is divisible by square of prime factor\n                    return 0;\n                }\n                /*increment primeFactorCount by 1 \n\t\t\t\tif number is not divisible by square of found prime factor*/\n                primeFactorCount++;\n            }\n        }\n\n        return (primeFactorCount % 2 == 0) ? 1 : -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass MobiusFunctionTest {\n\n\t@Test\n\tvoid testMobiusForZero() {\n\t\t//given\n\t\tint number = 0;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tMobiusFunction.mobius(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testMobiusForNegativeNumber() {\n\t\t//given\n\t\tint number = -1;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tMobiusFunction.mobius(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testMobiusFunction(){\n\t\tint[] expectedResultArray = {\n\t\t\t\t1, -1, -1, 0, -1, 1, -1, 0, 0, 1, -1, 0, -1, 1, 1, 0, -1, 0, -1, 0, 1, 1, -1, 0, \n\t\t\t\t0, 1, 0, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 0, 1, -1, 0, 0, \n\t\t\t\t0, 1, 0, -1, 0, 1, 0, 1, 1, -1, 0, -1, 1, 0, 0, 1, -1, -1, 0, 1, -1, -1, 0, -1, 1, \n\t\t\t\t0, 0, 1, -1, -1, 0, 0, 1, -1, 0, 1, 1, 1, 0, -1, 0, 1, 0, 1, 1, 1, 0, -1, 0, 0, 0\n\t\t};\n\n\t\tfor(int i = 1; i <= 100; i++) {\n\n\t\t\t//given\n\t\t\tint expectedValue = expectedResultArray[i-1];\n\n\t\t\t//when\n\t\t\tint actualValue = MobiusFunction.mobius(i);\n\n\t\t\t//then\n\t\t\tassertEquals(expectedValue,actualValue);\n\t\t}\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass MobiusFunctionTest {\n\n    @Test\n    void testMobiusForZero() {\n        //given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                MobiusFunction.mobius(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testMobiusForNegativeNumber() {\n        //given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                MobiusFunction.mobius(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testMobiusFunction() {\n        int[] expectedResultArray = {\n            1,\n            -1,\n            -1,\n            0,\n            -1,\n            1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            -1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            -1,\n            0,\n            1,\n            1,\n            -1,\n            0,\n            0,\n            1,\n            0,\n            0,\n            -1,\n            -1,\n            -1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            1,\n            1,\n            0,\n            -1,\n            -1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0,\n            -1,\n            0,\n            1,\n            0,\n            1,\n            1,\n            -1,\n            0,\n            -1,\n            1,\n            0,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            -1,\n            1,\n            0,\n            0,\n            1,\n            -1,\n            -1,\n            0,\n            0,\n            1,\n            -1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            1,\n            0,\n            1,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            0,\n            0,\n        };\n\n        for (int i = 1; i <= 100; i++) {\n            //given\n            int expectedValue = expectedResultArray[i - 1];\n\n            //when\n            int actualValue = MobiusFunction.mobius(i);\n\n            //then\n            assertEquals(expectedValue, actualValue);\n        }\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PascalTriangle.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PascalTriangleTest.java",
        "product_old_content": "package com.thealgorithms.maths;\npublic class PascalTriangle {\n    /**\n     *In mathematics, Pascal's triangle is a triangular array of the binomial coefficients that arises\n     * in probability theory, combinatorics, and algebra. In much of the Western world, it is named after\n     * the French mathematician Blaise Pascal, although other mathematicians studied it centuries before\n     * him in India, Persia, China, Germany, and Italy.\n     *\n     * The rows of Pascal's triangle are conventionally enumerated starting with row n=0 at the top (the 0th row).\n     * The entries in each row are numbered from the left beginning with k=0 and are usually staggered relative\n     * to the numbers in the adjacent rows. The triangle may be constructed in the following manner:\n     * In row 0 (the topmost row), there is a unique nonzero entry 1. Each entry of each subsequent row is\n     * constructed by adding the number above and to the left with the number above and to the right, treating\n     * blank entries as 0. For example, the initial number in the first (or any other) row is 1 (the sum of 0 and 1),\n     * whereas the numbers 1 and 3 in the third row are added to produce the number 4 in the fourth row. *\n     *\n     *<p>\n     *     link:-https://en.wikipedia.org/wiki/Pascal%27s_triangle\n     *\n     * <p>\n     *     Example:-\n     *                  1\n     *                1   1\n     *              1   2   1\n     *            1   3   3   1\n     *          1   4   6   4   1\n     *        1   5  10   10  5   1\n     *      1   6  15  20   15  6   1\n     *    1   7  21  35   35  21  7   1\n     *  1   8  28  56  70   56   28  8   1\n     *\n     */\n\n        public static int[][] pascal(int n)\n    {\n        /**\n         * @param arr  An auxiliary array to store generated pascal triangle values\n         * @return\n         */\n        int[][] arr = new int[n][n];\n        /**\n         * @param line Iterate through every line and print integer(s) in it\n         * @param i Represents the column number of the element we are currently on\n         */\n        for (int line = 0; line < n; line++)\n        {\n            /**\n             *  @Every line has number of integers equal to line number\n             */\n            for (int i = 0; i <= line; i++)\n            {\n                // First and last values in every row are 1\n                if (line == i || i == 0)\n                    arr[line][i] = 1;\n                    // The rest elements are sum of values just above and left of above\n                else\n                    arr[line][i] = arr[line-1][i-1] + arr[line-1][i];\n            }\n        }\n        \n        return arr;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class PascalTriangle {\n\n    /**\n     *In mathematics, Pascal's triangle is a triangular array of the binomial coefficients that arises\n     * in probability theory, combinatorics, and algebra. In much of the Western world, it is named after\n     * the French mathematician Blaise Pascal, although other mathematicians studied it centuries before\n     * him in India, Persia, China, Germany, and Italy.\n     *\n     * The rows of Pascal's triangle are conventionally enumerated starting with row n=0 at the top (the 0th row).\n     * The entries in each row are numbered from the left beginning with k=0 and are usually staggered relative\n     * to the numbers in the adjacent rows. The triangle may be constructed in the following manner:\n     * In row 0 (the topmost row), there is a unique nonzero entry 1. Each entry of each subsequent row is\n     * constructed by adding the number above and to the left with the number above and to the right, treating\n     * blank entries as 0. For example, the initial number in the first (or any other) row is 1 (the sum of 0 and 1),\n     * whereas the numbers 1 and 3 in the third row are added to produce the number 4 in the fourth row. *\n     *\n     *<p>\n     *     link:-https://en.wikipedia.org/wiki/Pascal%27s_triangle\n     *\n     * <p>\n     *     Example:-\n     *                  1\n     *                1   1\n     *              1   2   1\n     *            1   3   3   1\n     *          1   4   6   4   1\n     *        1   5  10   10  5   1\n     *      1   6  15  20   15  6   1\n     *    1   7  21  35   35  21  7   1\n     *  1   8  28  56  70   56   28  8   1\n     *\n     */\n\n    public static int[][] pascal(int n) {\n        /**\n         * @param arr  An auxiliary array to store generated pascal triangle values\n         * @return\n         */\n        int[][] arr = new int[n][n];\n        /**\n         * @param line Iterate through every line and print integer(s) in it\n         * @param i Represents the column number of the element we are currently on\n         */\n        for (int line = 0; line < n; line++) {\n            /**\n             *  @Every line has number of integers equal to line number\n             */\n            for (int i = 0; i <= line; i++) {\n                // First and last values in every row are 1\n                if (line == i || i == 0) arr[line][i] = 1;\n                // The rest elements are sum of values just above and left of above\n                else arr[line][i] = arr[line - 1][i - 1] + arr[line - 1][i];\n            }\n        }\n\n        return arr;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PascalTriangleTest {\n\n    @Test\n    void testForOne() {\n        int[][] result = PascalTriangle.pascal(1);\n        int[][] expected = {{1}};\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForTwo() {\n        int[][] result = PascalTriangle.pascal(2);\n        int[][] expected = {{1, 0}, {1, 1}};\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForFive() {\n        int[][] result = PascalTriangle.pascal(5);\n        int[][] expected = {{1, 0, 0, 0, 0},\n                {1, 1, 0, 0, 0},\n                {1, 2, 1, 0, 0},\n                {1, 3, 3, 1, 0},\n                {1, 4, 6, 4, 1}\n        };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForEight() {\n        int[][] result = PascalTriangle.pascal(8);\n        int[][] expected = {{1, 0, 0, 0, 0, 0, 0, 0},\n                {1, 1, 0, 0, 0, 0, 0, 0},\n                {1, 2, 1, 0, 0, 0, 0, 0},\n                {1, 3, 3, 1, 0, 0, 0, 0},\n                {1, 4, 6, 4, 1, 0, 0, 0},\n                {1, 5, 10, 10, 5, 1, 0, 0},\n                {1, 6, 15, 20, 15, 6, 1, 0},\n                {1, 7, 21, 35, 35, 21, 7, 1}\n        };\n        assertArrayEquals(expected, result);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass PascalTriangleTest {\n\n    @Test\n    void testForOne() {\n        int[][] result = PascalTriangle.pascal(1);\n        int[][] expected = { { 1 } };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForTwo() {\n        int[][] result = PascalTriangle.pascal(2);\n        int[][] expected = { { 1, 0 }, { 1, 1 } };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForFive() {\n        int[][] result = PascalTriangle.pascal(5);\n        int[][] expected = {\n            { 1, 0, 0, 0, 0 },\n            { 1, 1, 0, 0, 0 },\n            { 1, 2, 1, 0, 0 },\n            { 1, 3, 3, 1, 0 },\n            { 1, 4, 6, 4, 1 },\n        };\n        assertArrayEquals(result, expected);\n    }\n\n    @Test\n    void testForEight() {\n        int[][] result = PascalTriangle.pascal(8);\n        int[][] expected = {\n            { 1, 0, 0, 0, 0, 0, 0, 0 },\n            { 1, 1, 0, 0, 0, 0, 0, 0 },\n            { 1, 2, 1, 0, 0, 0, 0, 0 },\n            { 1, 3, 3, 1, 0, 0, 0, 0 },\n            { 1, 4, 6, 4, 1, 0, 0, 0 },\n            { 1, 5, 10, 10, 5, 1, 0, 0 },\n            { 1, 6, 15, 20, 15, 6, 1, 0 },\n            { 1, 7, 21, 35, 35, 21, 7, 1 },\n        };\n        assertArrayEquals(expected, result);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PollardRho.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PollardRhoTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for pollard rho algorithm\n * The algorithm is used to factorize a number n = pq,\n * where p is a non-trivial factor. \n * Pollard's rho algorithm is an algorithm for integer factorization\n * and it takes as its inputs n, the integer to be factored; \n * and g(x), a polynomial in x computed modulo n.\n * In the original algorithm, g(x) = ((x ^ 2) \u2212 1) mod n,\n * but nowadays it is more common to use g(x) = ((x ^ 2) + 1 ) mod n. \n * The output is either a non-trivial factor of n, or failure.\n * It performs the following steps:\n *     x \u2190 2\n *     y \u2190 2\n *     d \u2190 1\n\n *     while d = 1:\n *         x \u2190 g(x)\n *         y \u2190 g(g(y))\n *         d \u2190 gcd(|x - y|, n)\n\n *     if d = n: \n *         return failure\n *     else:\n *         return d\n\n * Here x and y corresponds to xi and xj in the previous section. \n * Note that this algorithm may fail to find a nontrivial factor even when n is composite.\n * In that case, the method can be tried again, using a starting value other than 2 or a different g(x)\n * \n * Wikipedia: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\npublic class PollardRho {\n\t\n\t/**\n\t * This method returns a polynomial in x computed modulo n\n\t *\n\t * @param base Integer base of the polynomial\n\t * @param modulus Integer is value which is to be used to perform modulo operation over the polynomial \n\t * @return Integer (((base * base) - 1) % modulus)\n\t */\n\tstatic int g(int base,int modulus) {\n\t\treturn ((base * base) - 1) % modulus;\n\t}\n\t\n\t/**\n\t * This method returns a non-trivial factor of given integer number  \n\t *\n\t * @param number Integer is a integer value whose non-trivial factor is to be found\n\t * @return Integer non-trivial factor of number\n\t * @throws RuntimeException object if GCD of given number cannot be found\n\t */\n\tstatic int pollardRho(int number) {\n\t\tint x = 2, y = 2, d = 1;\n\t\twhile(d == 1) {\n\t\t\t//tortoise move\n\t\t\tx = g(x, number);\n\t\t\t\n\t\t\t//hare move\n\t\t\ty = g(g(y, number), number);\n\t\t\t\n\t\t\t//check GCD of |x-y| and number\n\t\t\td = GCD.gcd(Math.abs(x - y), number);\n\t\t}\n\t\tif(d == number) {\n\t\t\tthrow new RuntimeException(\"GCD cannot be found.\");\n\t\t}\n\t\treturn d;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for pollard rho algorithm\n * The algorithm is used to factorize a number n = pq,\n * where p is a non-trivial factor. \n * Pollard's rho algorithm is an algorithm for integer factorization\n * and it takes as its inputs n, the integer to be factored; \n * and g(x), a polynomial in x computed modulo n.\n * In the original algorithm, g(x) = ((x ^ 2) \u2212 1) mod n,\n * but nowadays it is more common to use g(x) = ((x ^ 2) + 1 ) mod n. \n * The output is either a non-trivial factor of n, or failure.\n * It performs the following steps:\n *     x \u2190 2\n *     y \u2190 2\n *     d \u2190 1\n\n *     while d = 1:\n *         x \u2190 g(x)\n *         y \u2190 g(g(y))\n *         d \u2190 gcd(|x - y|, n)\n\n *     if d = n: \n *         return failure\n *     else:\n *         return d\n\n * Here x and y corresponds to xi and xj in the previous section. \n * Note that this algorithm may fail to find a nontrivial factor even when n is composite.\n * In that case, the method can be tried again, using a starting value other than 2 or a different g(x)\n * \n * Wikipedia: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\npublic class PollardRho {\n\n    /**\n     * This method returns a polynomial in x computed modulo n\n     *\n     * @param base Integer base of the polynomial\n     * @param modulus Integer is value which is to be used to perform modulo operation over the polynomial\n     * @return Integer (((base * base) - 1) % modulus)\n     */\n    static int g(int base, int modulus) {\n        return ((base * base) - 1) % modulus;\n    }\n\n    /**\n     * This method returns a non-trivial factor of given integer number\n     *\n     * @param number Integer is a integer value whose non-trivial factor is to be found\n     * @return Integer non-trivial factor of number\n     * @throws RuntimeException object if GCD of given number cannot be found\n     */\n    static int pollardRho(int number) {\n        int x = 2, y = 2, d = 1;\n        while (d == 1) {\n            //tortoise move\n            x = g(x, number);\n\n            //hare move\n            y = g(g(y, number), number);\n\n            //check GCD of |x-y| and number\n            d = GCD.gcd(Math.abs(x - y), number);\n        }\n        if (d == number) {\n            throw new RuntimeException(\"GCD cannot be found.\");\n        }\n        return d;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass PollardRhoTest {\n\n\t@Test\n\tvoid testPollardRhoForNumber315MustReturn5() {\n\t\t//given\n\t\tint number = 315;\n\t\tint expectedResult = 5;\n\n\t\t//when\n\t\tint actualResult = PollardRho.pollardRho(number);\n\n\t\t//then\n\t\tassertEquals(expectedResult, actualResult);\n\t}\n\n\t@Test\n\tvoid testPollardRhoForNumber187MustReturn11() {\n\t\t//given\n\t\tint number = 187;\n\t\tint expectedResult = 11;\n\n\t\t//when\n\t\tint actualResult = PollardRho.pollardRho(number);\n\n\t\t//then\n\t\tassertEquals(expectedResult, actualResult);\n\t}\n\n\t@Test\n\tvoid testPollardRhoForNumber239MustThrowException() {\n\t\t//given\n\t\tint number = 239;\n\t\tString expectedMessage = \"GCD cannot be found.\";\n\n\t\t//when\n\t\tException exception = assertThrows(RuntimeException.class, () -> {\n\t\t\tPollardRho.pollardRho(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass PollardRhoTest {\n\n    @Test\n    void testPollardRhoForNumber315MustReturn5() {\n        //given\n        int number = 315;\n        int expectedResult = 5;\n\n        //when\n        int actualResult = PollardRho.pollardRho(number);\n\n        //then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber187MustReturn11() {\n        //given\n        int number = 187;\n        int expectedResult = 11;\n\n        //when\n        int actualResult = PollardRho.pollardRho(number);\n\n        //then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber239MustThrowException() {\n        //given\n        int number = 239;\n        String expectedMessage = \"GCD cannot be found.\";\n\n        //when\n        Exception exception = assertThrows(\n            RuntimeException.class,\n            () -> {\n                PollardRho.pollardRho(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PrimeCheck.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PrimeCheckTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Scanner;\n\npublic class PrimeCheck {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"Enter a number: \");\n        int n = scanner.nextInt();\n        if (isPrime(n)) {\n            System.out.println(\"algo1 verify that \" + n + \" is a prime number\");\n        } else {\n            System.out.println(\"algo1 verify that \" + n + \" is not a prime number\");\n        }\n\n        if (fermatPrimeChecking(n, 20)) {\n            System.out.println(\"algo2 verify that \" + n + \" is a prime number\");\n        } else {\n            System.out.println(\"algo2 verify that \" + n + \" is not a prime number\");\n        }\n        scanner.close();\n    }\n\n    /**\n     * *\n     * Checks if a number is prime or not\n     *\n     * @param n the number\n     * @return {@code true} if {@code n} is prime\n     */\n    public static boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n < 2 || n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * *\n     * Checks if a number is prime or not\n     *\n     * @param n the number\n     * @return {@code true} if {@code n} is prime\n     */\n    public static boolean fermatPrimeChecking(int n, int iteration){\n      long a;\n      int up = n - 2, down = 2;\n      for(int i=0;i<iteration;i++){\n        a = (long)Math.floor(Math.random()*(up - down + 1) + down);\n        if(modPow(a,n-1,n) != 1){\n          return false;\n        }\n      }\n      return true;\n    }\n\n\n    /**\n     * *\n     * @param a basis\n     * @param b exponent\n     * @param c modulo\n     * @return (a^b) mod c\n     */\n    private static long modPow(long a, long b, long c){\n        long res = 1;\n        for (int i = 0; i < b; i++)\n        {\n            res *= a;\n            res %= c;\n        }\n        return res % c;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Scanner;\n\npublic class PrimeCheck {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"Enter a number: \");\n        int n = scanner.nextInt();\n        if (isPrime(n)) {\n            System.out.println(\"algo1 verify that \" + n + \" is a prime number\");\n        } else {\n            System.out.println(\n                \"algo1 verify that \" + n + \" is not a prime number\"\n            );\n        }\n\n        if (fermatPrimeChecking(n, 20)) {\n            System.out.println(\"algo2 verify that \" + n + \" is a prime number\");\n        } else {\n            System.out.println(\n                \"algo2 verify that \" + n + \" is not a prime number\"\n            );\n        }\n        scanner.close();\n    }\n\n    /**\n     * *\n     * Checks if a number is prime or not\n     *\n     * @param n the number\n     * @return {@code true} if {@code n} is prime\n     */\n    public static boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n < 2 || n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * *\n     * Checks if a number is prime or not\n     *\n     * @param n the number\n     * @return {@code true} if {@code n} is prime\n     */\n    public static boolean fermatPrimeChecking(int n, int iteration) {\n        long a;\n        int up = n - 2, down = 2;\n        for (int i = 0; i < iteration; i++) {\n            a = (long) Math.floor(Math.random() * (up - down + 1) + down);\n            if (modPow(a, n - 1, n) != 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * *\n     * @param a basis\n     * @param b exponent\n     * @param c modulo\n     * @return (a^b) mod c\n     */\n    private static long modPow(long a, long b, long c) {\n        long res = 1;\n        for (int i = 0; i < b; i++) {\n            res *= a;\n            res %= c;\n        }\n        return res % c;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PrimeCheckTest {\n    @Test\n    void test1() {\n        Assertions.assertTrue(PrimeCheck.isPrime(2));\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertFalse(PrimeCheck.isPrime(-1));\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertFalse(PrimeCheck.isPrime(4));\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertTrue(PrimeCheck.isPrime(5));\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertFalse(PrimeCheck.isPrime(15));\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertTrue(PrimeCheck.isPrime(11));\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertFalse(PrimeCheck.isPrime(49));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PrimeCheckTest {\n\n    @Test\n    void test1() {\n        Assertions.assertTrue(PrimeCheck.isPrime(2));\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertFalse(PrimeCheck.isPrime(-1));\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertFalse(PrimeCheck.isPrime(4));\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertTrue(PrimeCheck.isPrime(5));\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertFalse(PrimeCheck.isPrime(15));\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertTrue(PrimeCheck.isPrime(11));\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertFalse(PrimeCheck.isPrime(49));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PrimeFactorization.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PrimeFactorizationTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Authors: \n * (1) Aitor Fidalgo S\u00e1nchez (https://github.com/aitorfi) \n * (2) Akshay Dubey (https://github.com/itsAkshayDubey)\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PrimeFactorization {\n\n\tpublic static List<Integer> pfactors(int n) {\n\t\t\n\t\tList<Integer> primeFactors = new ArrayList<>();\n\n\t\tif (n == 0) {\n\t\t\treturn primeFactors;\n\t\t}\n\n\t\twhile (n % 2 == 0) {\n\t\t\tprimeFactors.add(2);\n\t\t\tn /= 2;\n\t\t}\n\n\t\tfor (int i = 3; i <= Math.sqrt(n); i += 2) {\n\t\t\twhile (n % i == 0) {\n\t\t\t\tprimeFactors.add(i);\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\n\t\tif (n > 2) {\n\t\t\tprimeFactors.add(n);\n\t\t}\n\t\treturn primeFactors;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Authors:\n * (1) Aitor Fidalgo S\u00e1nchez (https://github.com/aitorfi)\n * (2) Akshay Dubey (https://github.com/itsAkshayDubey)\n */\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PrimeFactorization {\n\n    public static List<Integer> pfactors(int n) {\n        List<Integer> primeFactors = new ArrayList<>();\n\n        if (n == 0) {\n            return primeFactors;\n        }\n\n        while (n % 2 == 0) {\n            primeFactors.add(2);\n            n /= 2;\n        }\n\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                primeFactors.add(i);\n                n /= i;\n            }\n        }\n\n        if (n > 2) {\n            primeFactors.add(n);\n        }\n        return primeFactors;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nclass PrimeFactorizationTest {\n\n\t@Test\n\tvoid testpFactorsMustReturnEmptyList() {\n\t\t//given\n\t\tint n = 0; \n\t\t\n\t\t//then\n\t\tassertTrue(PrimeFactorization.pfactors(n).isEmpty());\n\t}\n\t\n\t@Test\n\tvoid testpFactorsMustReturnNonEmptyList() {\n\t\t//given\n\t\tint n = 198;\n\t\tint expectedListSize = 4;\n\t\t\n\t\t//when\n\t\tList<Integer> actualResultList = PrimeFactorization.pfactors(n);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedListSize, actualResultList.size());\n\t\tassertEquals(2, actualResultList.get(0));\n\t\tassertEquals(3, actualResultList.get(1));\n\t\tassertEquals(3, actualResultList.get(2));\n\t\tassertEquals(11, actualResultList.get(3));\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\nclass PrimeFactorizationTest {\n\n    @Test\n    void testpFactorsMustReturnEmptyList() {\n        //given\n        int n = 0;\n\n        //then\n        assertTrue(PrimeFactorization.pfactors(n).isEmpty());\n    }\n\n    @Test\n    void testpFactorsMustReturnNonEmptyList() {\n        //given\n        int n = 198;\n        int expectedListSize = 4;\n\n        //when\n        List<Integer> actualResultList = PrimeFactorization.pfactors(n);\n\n        //then\n        assertEquals(expectedListSize, actualResultList.size());\n        assertEquals(2, actualResultList.get(0));\n        assertEquals(3, actualResultList.get(1));\n        assertEquals(3, actualResultList.get(2));\n        assertEquals(11, actualResultList.get(3));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PronicNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PronicNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Pronic Number\n * Pronic Number: A number n is a pronic number if\n * it is equal to product of two consecutive numbers m and m+1.\n * Wikipedia: https://en.wikipedia.org/wiki/Pronic_number\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class PronicNumber {\n\n\t/**\n     * This method checks if the given number is pronic number or non-pronic number\n     *\n     * @param input_number Integer value which is to be checked if is a pronic number or not \n     * @return true if input number is a pronic number, false otherwise\n     */\n\tstatic boolean isPronic(int input_number) {\n\t\t\n\t\t//Iterating from 0 to input_number\n\t\tfor(int i = 0; i <= input_number; i++) {\n\t\t\t\n\t\t\t//Checking if product of i and (i+1) is equals input_number\n\t\t\tif(i * (i+1) == input_number && i != input_number) {\n\t\t\t\t\n\t\t\t\t//return true if product of i and (i+1) is equals input_number\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t//return false if product of i and (i+1) for all values from 0 to input_number is not equals input_number\n\t\treturn false;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Pronic Number\n * Pronic Number: A number n is a pronic number if\n * it is equal to product of two consecutive numbers m and m+1.\n * Wikipedia: https://en.wikipedia.org/wiki/Pronic_number\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class PronicNumber {\n\n    /**\n     * This method checks if the given number is pronic number or non-pronic number\n     *\n     * @param input_number Integer value which is to be checked if is a pronic number or not\n     * @return true if input number is a pronic number, false otherwise\n     */\n    static boolean isPronic(int input_number) {\n        //Iterating from 0 to input_number\n        for (int i = 0; i <= input_number; i++) {\n            //Checking if product of i and (i+1) is equals input_number\n            if (i * (i + 1) == input_number && i != input_number) {\n                //return true if product of i and (i+1) is equals input_number\n                return true;\n            }\n        }\n\n        //return false if product of i and (i+1) for all values from 0 to input_number is not equals input_number\n        return false;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PronicNumberTest {\n\n    @Test\n    void testForPronicNumber() {\n\n        //given\n        int number = 30;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n        \n        //then\n        assertTrue(result);\n    }\n\n    @Test\n    void testForNonPronicNumber() {\n        \n        //given\n        int number = 21;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n        \n        //then\n        assertFalse(result);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PronicNumberTest {\n\n    @Test\n    void testForPronicNumber() {\n        //given\n        int number = 30;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n\n        //then\n        assertTrue(result);\n    }\n\n    @Test\n    void testForNonPronicNumber() {\n        //given\n        int number = 21;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n\n        //then\n        assertFalse(result);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/StandardDeviation.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/StandardDeviationTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class StandardDeviation {\n\t\n  public static double stdDev(double[] data)\n\t{\n\t\tdouble var = 0;\n\t\tdouble avg = 0;\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t{\n\t\t\tavg += data[i];\n\t\t}\n\t\tavg /= data.length;\n\t\tfor (int j = 0; j < data.length; j++)\n\t\t{\n\t\t\tvar += Math.pow((data[j] - avg), 2);\n\t\t}\n\t\tvar /= data.length;\n\t\treturn Math.sqrt(var);\n\t}\n  \n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class StandardDeviation {\n\n    public static double stdDev(double[] data) {\n        double var = 0;\n        double avg = 0;\n        for (int i = 0; i < data.length; i++) {\n            avg += data[i];\n        }\n        avg /= data.length;\n        for (int j = 0; j < data.length; j++) {\n            var += Math.pow((data[j] - avg), 2);\n        }\n        var /= data.length;\n        return Math.sqrt(var);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StandardDeviationTest{\n  @Test\n  void test1()\n  {\n    double[] t1 = new double[]{1,1,1,1,1};\n    Assertions.assertEquals(StandardDeviation.stdDev(t1), 0.0);\n  }\n  @Test\n  void test2()\n  {\n    double[] t2 = new double[]{1,2,3,4,5,6,7,8,9,10};\n    Assertions.assertEquals(StandardDeviation.stdDev(t2), 2.8722813232690143);\n  }\n  @Test\n  void test3()\n  {\n    double[] t3= new double[]{1.1, 8.5, 20.3, 2.4, 6.2};\n    Assertions.assertEquals(StandardDeviation.stdDev(t3), 6.8308125431752265);\n  }\n  @Test\n  void test4()\n  {\n    double[] t4 = new double[]{3.14, 2.22222, 9.89898989, 100.00045, 56.7};\n     Assertions.assertEquals(StandardDeviation.stdDev(t4), 38.506117353865775);\n  }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StandardDeviationTest {\n\n    @Test\n    void test1() {\n        double[] t1 = new double[] { 1, 1, 1, 1, 1 };\n        Assertions.assertEquals(StandardDeviation.stdDev(t1), 0.0);\n    }\n\n    @Test\n    void test2() {\n        double[] t2 = new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        Assertions.assertEquals(\n            StandardDeviation.stdDev(t2),\n            2.8722813232690143\n        );\n    }\n\n    @Test\n    void test3() {\n        double[] t3 = new double[] { 1.1, 8.5, 20.3, 2.4, 6.2 };\n        Assertions.assertEquals(\n            StandardDeviation.stdDev(t3),\n            6.8308125431752265\n        );\n    }\n\n    @Test\n    void test4() {\n        double[] t4 = new double[] {\n            3.14,\n            2.22222,\n            9.89898989,\n            100.00045,\n            56.7,\n        };\n        Assertions.assertEquals(\n            StandardDeviation.stdDev(t4),\n            38.506117353865775\n        );\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/StandardScore.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/StandardScoreTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class StandardScore {\n\tpublic static double zScore(double num, double mean, double stdDev)\n\t{\n\t\tdouble z = (num - mean)/stdDev;\n\t\treturn z;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class StandardScore {\n\n    public static double zScore(double num, double mean, double stdDev) {\n        double z = (num - mean) / stdDev;\n        return z;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StandardScoreTest{\n  @Test\n  void test1()\n  {\n    Assertions.assertEquals(StandardScore.zScore(2, 0, 5), 0.4);\n  }\n  @Test\n  void test2()\n  {\n    Assertions.assertEquals(StandardScore.zScore(1, 1, 1), 0.0);\n  }\n  @Test\n  void test3()\n  {\n    Assertions.assertEquals(StandardScore.zScore(2.5, 1.8, 0.7), 1.0);\n  }\n  @Test\n  void test4()\n  {\n    Assertions.assertEquals(StandardScore.zScore(8.9, 3, 4.2), 1.4047619047619049);\n  }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StandardScoreTest {\n\n    @Test\n    void test1() {\n        Assertions.assertEquals(StandardScore.zScore(2, 0, 5), 0.4);\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertEquals(StandardScore.zScore(1, 1, 1), 0.0);\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertEquals(StandardScore.zScore(2.5, 1.8, 0.7), 1.0);\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(\n            StandardScore.zScore(8.9, 3, 4.2),\n            1.4047619047619049\n        );\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/SumOfDigits.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/SumOfDigitsTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class SumOfDigits {\n\n    public static void main(String[] args) {\n        assert sumOfDigits(-123) == 6 && sumOfDigitsRecursion(-123) == 6 && sumOfDigitsFast(-123) == 6;\n\n        assert sumOfDigits(0) == 0 && sumOfDigitsRecursion(0) == 0 && sumOfDigitsFast(0) == 0;\n\n        assert sumOfDigits(12345) == 15\n                && sumOfDigitsRecursion(12345) == 15\n                && sumOfDigitsFast(12345) == 15;\n    }\n\n    /**\n     * Calculate the sum of digits of a number\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigits(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        int sum = 0;\n        while (number != 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Calculate the sum of digits of a number using recursion\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsRecursion(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        return number < 10 ? number : number % 10 + sumOfDigitsRecursion(number / 10);\n    }\n\n    /**\n     * Calculate the sum of digits of a number using char array\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsFast(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        char[] digits = (number + \"\").toCharArray();\n        int sum = 0;\n        for (int i = 0; i < digits.length; ++i) {\n            sum += digits[i] - '0';\n        }\n        return sum;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class SumOfDigits {\n\n    public static void main(String[] args) {\n        assert sumOfDigits(-123) == 6 &&\n        sumOfDigitsRecursion(-123) == 6 &&\n        sumOfDigitsFast(-123) == 6;\n\n        assert sumOfDigits(0) == 0 &&\n        sumOfDigitsRecursion(0) == 0 &&\n        sumOfDigitsFast(0) == 0;\n\n        assert sumOfDigits(12345) == 15 &&\n        sumOfDigitsRecursion(12345) == 15 &&\n        sumOfDigitsFast(12345) == 15;\n    }\n\n    /**\n     * Calculate the sum of digits of a number\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigits(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        int sum = 0;\n        while (number != 0) {\n            sum += number % 10;\n            number /= 10;\n        }\n        return sum;\n    }\n\n    /**\n     * Calculate the sum of digits of a number using recursion\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsRecursion(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        return number < 10\n            ? number\n            : number % 10 + sumOfDigitsRecursion(number / 10);\n    }\n\n    /**\n     * Calculate the sum of digits of a number using char array\n     *\n     * @param number the number contains digits\n     * @return sum of digits of given {@code number}\n     */\n    public static int sumOfDigitsFast(int number) {\n        number = number < 0 ? -number : number;\n        /* calculate abs value */\n        char[] digits = (number + \"\").toCharArray();\n        int sum = 0;\n        for (int i = 0; i < digits.length; ++i) {\n            sum += digits[i] - '0';\n        }\n        return sum;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SumOfDigitsTest {\n\n    SumOfDigits SoD = new SumOfDigits();\n\n    @Test\n    void testZero() {\n        assertEquals(0, SoD.sumOfDigits(0));\n        assertEquals(0, SoD.sumOfDigitsRecursion(0));\n        assertEquals(0, SoD.sumOfDigitsFast(0));\n    }\n\n    @Test\n    void testPositive() {\n        assertEquals(15, SoD.sumOfDigits(12345));\n        assertEquals(15, SoD.sumOfDigitsRecursion(12345));\n        assertEquals(15, SoD.sumOfDigitsFast(12345));\n    }\n\n    @Test\n    void testNegative() {\n        assertEquals(6, SoD.sumOfDigits(-123));\n        assertEquals(6, SoD.sumOfDigitsRecursion(-123));\n        assertEquals(6, SoD.sumOfDigitsFast(-123));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SumOfDigitsTest {\n\n    SumOfDigits SoD = new SumOfDigits();\n\n    @Test\n    void testZero() {\n        assertEquals(0, SoD.sumOfDigits(0));\n        assertEquals(0, SoD.sumOfDigitsRecursion(0));\n        assertEquals(0, SoD.sumOfDigitsFast(0));\n    }\n\n    @Test\n    void testPositive() {\n        assertEquals(15, SoD.sumOfDigits(12345));\n        assertEquals(15, SoD.sumOfDigitsRecursion(12345));\n        assertEquals(15, SoD.sumOfDigitsFast(12345));\n    }\n\n    @Test\n    void testNegative() {\n        assertEquals(6, SoD.sumOfDigits(-123));\n        assertEquals(6, SoD.sumOfDigitsRecursion(-123));\n        assertEquals(6, SoD.sumOfDigitsFast(-123));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/others/ArrayLeftRotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/ArrayLeftRotationTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\n/*\n * A left rotation operation on an array\n * shifts each of the array's elements\n * given integer n unit to the left.\n * \n * @author sangin-lee \n */\n\npublic class ArrayLeftRotation {\n\n\t/*\n\t * Returns the result of left rotation of given array arr and integer n\n\t * \n\t * @param arr : int[] given array\n\t * \n\t * @param n : int given integer\n\t * \n\t * @return : int[] result of left rotation\n\t */\n\tpublic static int[] rotateLeft(int[] arr, int n) {\n\t\tint size = arr.length;\n\t\tint[] dst = new int[size];\n\t\tn = n % size;\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tdst[i] = arr[n];\n\t\t\tn = (n + 1) % size;\n\t\t}\n\t\treturn dst;\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.others;\n\n/*\n * A left rotation operation on an array\n * shifts each of the array's elements\n * given integer n unit to the left.\n *\n * @author sangin-lee\n */\n\npublic class ArrayLeftRotation {\n\n    /*\n     * Returns the result of left rotation of given array arr and integer n\n     *\n     * @param arr : int[] given array\n     *\n     * @param n : int given integer\n     *\n     * @return : int[] result of left rotation\n     */\n    public static int[] rotateLeft(int[] arr, int n) {\n        int size = arr.length;\n        int[] dst = new int[size];\n        n = n % size;\n        for (int i = 0; i < size; i++) {\n            dst[i] = arr[n];\n            n = (n + 1) % size;\n        }\n        return dst;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ArrayLeftRotationTest {\n\n\t@Test\n\tvoid testForOneElement() {\n\t\tint[] arr = {3};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 3);\n\t\tassertArrayEquals(arr, result);\n\t}\n\n\t@Test\n\tvoid testForZeroStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 0);\n\t\tassertArrayEquals(arr, result);\n\t}\n\n\t@Test\n\tvoid testForEqualSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 5);\n\t\tassertArrayEquals(arr, result);\n\t}\n\n\t@Test\n\tvoid testForLowerSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 2;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\n\t@Test\n\tvoid testForHigherSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 7;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass ArrayLeftRotationTest {\n\n    @Test\n    void testForOneElement() {\n        int[] arr = { 3 };\n        int[] result = ArrayLeftRotation.rotateLeft(arr, 3);\n        assertArrayEquals(arr, result);\n    }\n\n    @Test\n    void testForZeroStep() {\n        int[] arr = { 3, 1, 5, 8, 6 };\n        int[] result = ArrayLeftRotation.rotateLeft(arr, 0);\n        assertArrayEquals(arr, result);\n    }\n\n    @Test\n    void testForEqualSizeStep() {\n        int[] arr = { 3, 1, 5, 8, 6 };\n        int[] result = ArrayLeftRotation.rotateLeft(arr, 5);\n        assertArrayEquals(arr, result);\n    }\n\n    @Test\n    void testForLowerSizeStep() {\n        int[] arr = { 3, 1, 5, 8, 6 };\n        int n = 2;\n        int[] expected = { 5, 8, 6, 3, 1 };\n        int[] result = ArrayLeftRotation.rotateLeft(arr, n);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    void testForHigherSizeStep() {\n        int[] arr = { 3, 1, 5, 8, 6 };\n        int n = 7;\n        int[] expected = { 5, 8, 6, 3, 1 };\n        int[] result = ArrayLeftRotation.rotateLeft(arr, n);\n        assertArrayEquals(expected, result);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/others/PasswordGen.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/PasswordGenTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Creates a random password from ASCII letters Given password length bounds\n *\n * @author AKS1996\n * @date 2017.10.25\n */\nclass PasswordGen {\n\n    public static void main(String args[]) {\n        String password = generatePassword(8, 16);\n        System.out.print(\"Password: \" + password);\n    }\n\n    static String generatePassword(int min_length, int max_length) {\n        Random random = new Random();\n\n        String upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        String lower = \"abcdefghijklmnopqrstuvwxyz\";\n        String numbers = \"0123456789\";\n        String specialChars = \"!@#$%^&*(){}?\";\n\n        String allChars = upper + lower + numbers + specialChars;\n\n        List<Character> letters = new ArrayList<Character>();\n        for (char c : allChars.toCharArray()) {\n            letters.add(c);\n        }\n\n        // Inbuilt method to randomly shuffle a elements of a list\n        Collections.shuffle(letters);\n        StringBuilder password = new StringBuilder();\n\n        // Note that size of the password is also random\n        for (int i = random.nextInt(max_length - min_length) + min_length; i > 0; --i) {\n            password.append(letters.get(random.nextInt(letters.size())));\n        }\n\n        return password.toString();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Creates a random password from ASCII letters Given password length bounds\n *\n * @author AKS1996\n * @date 2017.10.25\n */\nclass PasswordGen {\n\n    public static void main(String args[]) {\n        String password = generatePassword(8, 16);\n        System.out.print(\"Password: \" + password);\n    }\n\n    static String generatePassword(int min_length, int max_length) {\n        Random random = new Random();\n\n        String upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        String lower = \"abcdefghijklmnopqrstuvwxyz\";\n        String numbers = \"0123456789\";\n        String specialChars = \"!@#$%^&*(){}?\";\n\n        String allChars = upper + lower + numbers + specialChars;\n\n        List<Character> letters = new ArrayList<Character>();\n        for (char c : allChars.toCharArray()) {\n            letters.add(c);\n        }\n\n        // Inbuilt method to randomly shuffle a elements of a list\n        Collections.shuffle(letters);\n        StringBuilder password = new StringBuilder();\n\n        // Note that size of the password is also random\n        for (\n            int i = random.nextInt(max_length - min_length) + min_length;\n            i > 0;\n            --i\n        ) {\n            password.append(letters.get(random.nextInt(letters.size())));\n        }\n\n        return password.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n\npublic class PasswordGenTest {\n    @Test \n    public void failGenerationWithSameMinMaxLengthTest() {\n        int length = 10;\n        assertThrows(IllegalArgumentException.class, ()-> {\n            PasswordGen.generatePassword(length, length);\n        });\n    }\n\n    @Test\n    public void generateOneCharacterPassword() {\n        String tempPassword = PasswordGen.generatePassword(1, 2);\n        assertTrue(tempPassword.length()==1);\n    }\n\n    @Test\n    public void failGenerationWithMinLengthSmallerThanMaxLengthTest() {\n        int minLength = 10;\n        int maxLength = 5;\n        assertThrows(IllegalArgumentException.class, ()-> {\n            PasswordGen.generatePassword(minLength, maxLength);\n        });\n    }\n\n    @Test\n    public void generatePasswordNonEmptyTest() {\n        String tempPassword = PasswordGen.generatePassword(8, 16);\n        assertTrue(tempPassword.length()!=0);\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PasswordGenTest {\n\n    @Test\n    public void failGenerationWithSameMinMaxLengthTest() {\n        int length = 10;\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                PasswordGen.generatePassword(length, length);\n            }\n        );\n    }\n\n    @Test\n    public void generateOneCharacterPassword() {\n        String tempPassword = PasswordGen.generatePassword(1, 2);\n        assertTrue(tempPassword.length() == 1);\n    }\n\n    @Test\n    public void failGenerationWithMinLengthSmallerThanMaxLengthTest() {\n        int minLength = 10;\n        int maxLength = 5;\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                PasswordGen.generatePassword(minLength, maxLength);\n            }\n        );\n    }\n\n    @Test\n    public void generatePasswordNonEmptyTest() {\n        String tempPassword = PasswordGen.generatePassword(8, 16);\n        assertTrue(tempPassword.length() != 0);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/others/cn/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/cn/HammingDistanceTest.java",
        "product_old_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n\n\n    public int getHammingDistanceBetweenBits(String senderBits, String receiverBits) {\n\n        if(senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\"Sender and Receiver bits should be same\");\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for(int i = 0; i < senderData.length; i++){\n           totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if(totalErrorBitCount == 0){\n            System.out.println(\"No Error bit in data segments\");\n        } else{\n            System.out.println(\"Total Error bit count \"+totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n    public int getHammingDistanceBetweenBits(\n        String senderBits,\n        String receiverBits\n    ) {\n        if (senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\n                \"Sender and Receiver bits should be same\"\n            );\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < senderData.length; i++) {\n            totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if (totalErrorBitCount == 0) {\n            System.out.println(\"No Error bit in data segments\");\n        } else {\n            System.out.println(\"Total Error bit count \" + totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n     void initialize(){\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits(){\n         String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n/*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength(){\n       String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n\n    @Test\n    public void checkForSameBits(){\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits(){\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits(){\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () ->{\n            int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n\n    }\n\n    @Test\n    public void checkForLongDataBitsSame(){\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n\n\n}",
        "test_new_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n    void initialize() {\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits() {\n        String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        String senderBits = \"10010101101010000100110100\", receiverBits =\n            \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                int answer = hd.getHammingDistanceBetweenBits(\n                    senderBits,\n                    receiverBits\n                );\n            }\n        );\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String senderBits = \"10010101101010000100110100\", receiverBits =\n            \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/others/countSetBits.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/countSetBitsTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\npublic class countSetBits {\n    /** \n     * The below algorithm is called as Brian Kernighan's algorithm \n     * We can use Brian Kernighan\u2019s algorithm to improve the above naive algorithm\u2019s performance. The idea is to only consider the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the next rightmost bit.\n\n        The expression n & (n-1) can be used to turn off the rightmost set bit of a number n. This works as the expression n-1 flips all the bits after the rightmost set bit of n, including the rightmost set bit itself. Therefore, n & (n-1) results in the last bit flipped of n.\n\n        For example, consider number 52, which is 00110100 in binary, and has a total 3 bits set.\n\n        1st iteration of the loop: n = 52\n        \n        00110100    &               (n)\n        00110011                    (n-1)\n        ~~~~~~~~\n        00110000\n        \n        \n        2nd iteration of the loop: n = 48\n        \n        00110000    &               (n)\n        00101111                    (n-1)\n        ~~~~~~~~\n        00100000\n        \n        \n        3rd iteration of the loop: n = 32\n        \n        00100000    &               (n)\n        00011111                    (n-1)\n        ~~~~~~~~\n        00000000                    (n = 0)\n        \n     * @param num takes Long number whose number of set bit is to be found\n     * @return the count of set bits in the binary equivalent\n    */\n    public long countsetBits(long num){\n        long cnt=0;\n        while(num>0){\n            cnt++;\n            num&=(num-1);\n        }\n        return cnt;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\npublic class countSetBits {\n\n    /** \n     * The below algorithm is called as Brian Kernighan's algorithm \n     * We can use Brian Kernighan\u2019s algorithm to improve the above naive algorithm\u2019s performance. The idea is to only consider the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the next rightmost bit.\n\n        The expression n & (n-1) can be used to turn off the rightmost set bit of a number n. This works as the expression n-1 flips all the bits after the rightmost set bit of n, including the rightmost set bit itself. Therefore, n & (n-1) results in the last bit flipped of n.\n\n        For example, consider number 52, which is 00110100 in binary, and has a total 3 bits set.\n\n        1st iteration of the loop: n = 52\n        \n        00110100    &               (n)\n        00110011                    (n-1)\n        ~~~~~~~~\n        00110000\n        \n        \n        2nd iteration of the loop: n = 48\n        \n        00110000    &               (n)\n        00101111                    (n-1)\n        ~~~~~~~~\n        00100000\n        \n        \n        3rd iteration of the loop: n = 32\n        \n        00100000    &               (n)\n        00011111                    (n-1)\n        ~~~~~~~~\n        00000000                    (n = 0)\n        \n     * @param num takes Long number whose number of set bit is to be found\n     * @return the count of set bits in the binary equivalent\n    */\n    public long countsetBits(long num) {\n        long cnt = 0;\n        while (num > 0) {\n            cnt++;\n            num &= (num - 1);\n        }\n        return cnt;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class countSetBitsTest {\n    @Test\n    void testSetBits(){\n        countSetBits csb= new countSetBits();\n        assertEquals(1L,csb.countsetBits(16));\n        assertEquals(4, csb.countsetBits(15));\n        assertEquals(5, csb.countsetBits(10000));\n        assertEquals(5, csb.countsetBits(31));\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class countSetBitsTest {\n\n    @Test\n    void testSetBits() {\n        countSetBits csb = new countSetBits();\n        assertEquals(1L, csb.countsetBits(16));\n        assertEquals(4, csb.countsetBits(15));\n        assertEquals(5, csb.countsetBits(10000));\n        assertEquals(5, csb.countsetBits(31));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BinarySearch2dArrayTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(T array[], T key, int left, int right) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers\n                = IntStream.generate(() -> r.nextInt(maxElement))\n                        .limit(size)\n                        .sorted()\n                        .boxed()\n                        .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.println(\n                format(\n                        \"Should be found: %d. Found %d at index %d. An array length %d\",\n                        shouldBeFound, integers[atIndex], atIndex, size));\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.println(\n                format(\n                        \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport static java.lang.String.format;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n        T array[],\n        T key,\n        int left,\n        int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.println(\n            format(\n                \"Should be found: %d. Found %d at index %d. An array length %d\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n            )\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.println(\n            format(\n                \"Found by system method at an index: %d. Is equal: %b\",\n                toCheck,\n                toCheck == atIndex\n            )\n        );\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0,0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2,2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1,-1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 1, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 1, 3 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 0, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 0, 0 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 2, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 2, 2 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { -1, -1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch2dArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BinarySearch2dArrayTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n/*\nTo apply this method, the provided array must be strictly sorted. In this method, two pointers, one at 0th row\n& the other at the last row are taken & the searching is done on the basis of the middle element of the middle column.\nIf that element is equal to target, its coordinates are returned, else if it is smaller than the target, the rows above\nthat element are ignored (because the elements above it will also be smaller than the target), else that element is\ngreater than the target, then the rows below it are ignored.\n */\npublic class BinarySearch2dArray\n{\n    static int[] BinarySearch(int[][] arr, int target){\n\n        int rowCount = arr.length, colCount = arr[0].length;\n\n        if (rowCount == 1){\n            return binarySearch(arr, target, 0, 0, colCount);\n        }\n\n        int startRow = 0, endRow = rowCount - 1, midCol = colCount/2;\n\n        while (startRow < endRow - 1){\n\n            int midRow = startRow + (endRow - startRow) / 2;    //getting the index of middle row\n\n            if (arr[midRow][midCol] == target){\n                return new int[] {midRow, midCol};\n            }\n            else if (arr[midRow][midCol] < target)\n                startRow = midRow;\n            else\n                endRow = midRow;\n        }\n            /*\n            if the above search fails to find the target element, these conditions will be used to find the target\n            element, which further uses the binary search algorithm in the places which were left unexplored.\n             */\n        if (arr[startRow][midCol] == target)\n            return new int[] {startRow, midCol};\n\n        if (arr[endRow][midCol] == target)\n            return new int[] {endRow, midCol};\n\n        if (target <= arr[startRow][midCol-1])\n            return binarySearch(arr, target, startRow, 0, midCol-1);\n\n        if (target >= arr[startRow][midCol+1] && target <= arr[startRow][colCount-1])\n            return binarySearch(arr,target, startRow, midCol+1, colCount-1);\n\n        if (target <= arr[endRow][midCol-1])\n            return binarySearch(arr, target, endRow, 0, midCol-1);\n\n        else\n            return binarySearch(arr,target, endRow, midCol+1, colCount-1);\n    }\n\n    static int[] binarySearch(int[][] arr, int target, int row, int colStart, int colEnd){\n\n        while (colStart <= colEnd){\n\n            int midIndex = colStart + (colEnd - colStart) / 2;\n\n            if (arr[row][midIndex] == target)\n                return new int[] {row, midIndex};\n\n            else if (arr[row][midIndex] < target)\n                colStart = midIndex + 1;\n            else\n                colEnd = midIndex - 1;\n        }\n\n        return new int[] {-1, -1};\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\n/*\nTo apply this method, the provided array must be strictly sorted. In this method, two pointers, one at 0th row\n& the other at the last row are taken & the searching is done on the basis of the middle element of the middle column.\nIf that element is equal to target, its coordinates are returned, else if it is smaller than the target, the rows above\nthat element are ignored (because the elements above it will also be smaller than the target), else that element is\ngreater than the target, then the rows below it are ignored.\n */\npublic class BinarySearch2dArray {\n\n    static int[] BinarySearch(int[][] arr, int target) {\n        int rowCount = arr.length, colCount = arr[0].length;\n\n        if (rowCount == 1) {\n            return binarySearch(arr, target, 0, 0, colCount);\n        }\n\n        int startRow = 0, endRow = rowCount - 1, midCol = colCount / 2;\n\n        while (startRow < endRow - 1) {\n            int midRow = startRow + (endRow - startRow) / 2; //getting the index of middle row\n\n            if (arr[midRow][midCol] == target) {\n                return new int[] { midRow, midCol };\n            } else if (arr[midRow][midCol] < target) startRow =\n                midRow; else endRow = midRow;\n        }\n        /*\n            if the above search fails to find the target element, these conditions will be used to find the target\n            element, which further uses the binary search algorithm in the places which were left unexplored.\n             */\n        if (arr[startRow][midCol] == target) return new int[] {\n            startRow,\n            midCol,\n        };\n\n        if (arr[endRow][midCol] == target) return new int[] { endRow, midCol };\n\n        if (target <= arr[startRow][midCol - 1]) return binarySearch(\n            arr,\n            target,\n            startRow,\n            0,\n            midCol - 1\n        );\n\n        if (\n            target >= arr[startRow][midCol + 1] &&\n            target <= arr[startRow][colCount - 1]\n        ) return binarySearch(arr, target, startRow, midCol + 1, colCount - 1);\n\n        if (target <= arr[endRow][midCol - 1]) return binarySearch(\n            arr,\n            target,\n            endRow,\n            0,\n            midCol - 1\n        ); else return binarySearch(\n            arr,\n            target,\n            endRow,\n            midCol + 1,\n            colCount - 1\n        );\n    }\n\n    static int[] binarySearch(\n        int[][] arr,\n        int target,\n        int row,\n        int colStart,\n        int colEnd\n    ) {\n        while (colStart <= colEnd) {\n            int midIndex = colStart + (colEnd - colStart) / 2;\n\n            if (arr[row][midIndex] == target) return new int[] {\n                row,\n                midIndex,\n            }; else if (arr[row][midIndex] < target) colStart =\n                midIndex + 1; else colEnd = midIndex - 1;\n        }\n\n        return new int[] { -1, -1 };\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0,0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2,2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1,-1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 1, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 1, 3 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 0, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 0, 0 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 2, 1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { 2, 2 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = { -1, -1 };\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/searches/KMPSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/KMPSearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nclass KMPSearch {\n    int KMPSearch(String pat, String txt)\n    {\n        int M = pat.length();\n        int N = txt.length();\n \n        // create lps[] that will hold the longest\n        // prefix suffix values for pattern\n        int lps[] = new int[M];\n        int j = 0; // index for pat[]\n \n        // Preprocess the pattern (calculate lps[]\n        // array)\n        computeLPSArray(pat, M, lps);\n \n        int i = 0; // index for txt[]\n        while ((N - i) >= (M - j)) {\n            if (pat.charAt(j) == txt.charAt(i)) {\n                j++;\n                i++;\n            }\n            if (j == M) {\n                System.out.println(\"Found pattern \"\n                                + \"at index \" + (i - j));\n                int index = (i - j);\n                j = lps[j - 1];\n                return index;\n        \n            }\n \n            // mismatch after j matches\n            else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n                // Do not match lps[0..lps[j-1]] characters,\n                // they will match anyway\n                if (j != 0)\n                    j = lps[j - 1];\n                else\n                    i = i + 1;\n            }\n        }\n        System.out.println(\"No pattern found\");\n\t\treturn -1;\n    }\n \n    void computeLPSArray(String pat, int M, int lps[])\n    {\n        // length of the previous longest prefix suffix\n        int len = 0;\n        int i = 1;\n        lps[0] = 0; // lps[0] is always 0\n \n        // the loop calculates lps[i] for i = 1 to M-1\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else // (pat[i] != pat[len])\n            {\n                // This is tricky. Consider the example.\n                // AAACAAAA and i = 7. The idea is similar\n                // to search step.\n                if (len != 0) {\n                    len = lps[len - 1];\n \n                    // Also, note that we do not increment\n                    // i here\n                }\n                else // if (len == 0)\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n \n\n}\n// This code has been contributed by Amit Khandelwal.",
        "product_new_content": "package com.thealgorithms.searches;\n\nclass KMPSearch {\n\n    int KMPSearch(String pat, String txt) {\n        int M = pat.length();\n        int N = txt.length();\n\n        // create lps[] that will hold the longest\n        // prefix suffix values for pattern\n        int lps[] = new int[M];\n        int j = 0; // index for pat[]\n\n        // Preprocess the pattern (calculate lps[]\n        // array)\n        computeLPSArray(pat, M, lps);\n\n        int i = 0; // index for txt[]\n        while ((N - i) >= (M - j)) {\n            if (pat.charAt(j) == txt.charAt(i)) {\n                j++;\n                i++;\n            }\n            if (j == M) {\n                System.out.println(\"Found pattern \" + \"at index \" + (i - j));\n                int index = (i - j);\n                j = lps[j - 1];\n                return index;\n            }\n            // mismatch after j matches\n            else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n                // Do not match lps[0..lps[j-1]] characters,\n                // they will match anyway\n                if (j != 0) j = lps[j - 1]; else i = i + 1;\n            }\n        }\n        System.out.println(\"No pattern found\");\n        return -1;\n    }\n\n    void computeLPSArray(String pat, int M, int lps[]) {\n        // length of the previous longest prefix suffix\n        int len = 0;\n        int i = 1;\n        lps[0] = 0; // lps[0] is always 0\n\n        // the loop calculates lps[i] for i = 1 to M-1\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else { // (pat[i] != pat[len])\n                // This is tricky. Consider the example.\n                // AAACAAAA and i = 7. The idea is similar\n                // to search step.\n                if (len != 0) {\n                    len = lps[len - 1];\n                    // Also, note that we do not increment\n                    // i here\n                } else { // if (len == 0)\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n}\n// This code has been contributed by Amit Khandelwal.",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass KMPSearchTest {\n    \n    @Test\n    // valid test case\n    public void KMPSearchTestLast() {\n    \tString txt = \"ABABDABACDABABCABAB\";\n        String pat = \"ABABCABAB\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 10);\n    \t\n    }\n    \n    @Test\n    // valid test case\n    public void KMPSearchTestFront() {\n    \tString txt = \"AAAAABAAABA\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 0);\n    \t\n    }\n    \n    @Test\n    // valid test case\n    public void KMPSearchTestMiddle() {\n    \tString txt = \"AAACAAAAAC\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 4);\n    \t\n    }\n    @Test\n    // valid test case\n    public void KMPSearchTestNotFound() {\n    \tString txt = \"AAABAAAA\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 4);\n    \t\n    }\n    @Test\n    // not valid test case\n    public void KMPSearchTest4() {\n    \tString txt = \"AABAAA\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, -1);\n    \t\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass KMPSearchTest {\n\n    @Test\n    // valid test case\n    public void KMPSearchTestLast() {\n        String txt = \"ABABDABACDABABCABAB\";\n        String pat = \"ABABCABAB\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 10);\n    }\n\n    @Test\n    // valid test case\n    public void KMPSearchTestFront() {\n        String txt = \"AAAAABAAABA\";\n        String pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 0);\n    }\n\n    @Test\n    // valid test case\n    public void KMPSearchTestMiddle() {\n        String txt = \"AAACAAAAAC\";\n        String pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 4);\n    }\n\n    @Test\n    // valid test case\n    public void KMPSearchTestNotFound() {\n        String txt = \"AAABAAAA\";\n        String pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 4);\n    }\n\n    @Test\n    // not valid test case\n    public void KMPSearchTest4() {\n        String txt = \"AABAAA\";\n        String pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, -1);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/searches/QuickSelect.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/QuickSelectTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/**\n * An implementation of the Quickselect algorithm as described\n * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>.\n */\npublic final class QuickSelect {\n\n    /**\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\n     * be at index n if the list was sorted.\n     * <p>\n     * Calling this function might change the order of elements in {@code list}.\n     *\n     * @param list the list of elements\n     * @param n    the index\n     * @param <T>  the type of list elements\n     * @return the n-th largest element in the list\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\n     *                                   the number of elements in the list\n     * @throws IllegalArgumentException  if the list is empty\n     * @throws NullPointerException      if {@code list} is null\n     */\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\n        Objects.requireNonNull(list, \"The list of elements must not be null.\");\n\n        if (list.size() == 0) {\n            String msg = \"The list of elements must not be empty.\";\n            throw new IllegalArgumentException(msg);\n        }\n\n        if (n < 0) {\n            String msg = \"The index must not be negative.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        if (n >= list.size()) {\n            String msg = \"The index must be less than the number of elements.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        int index = selectIndex(list, n);\n        return list.get(index);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {\n        return selectIndex(list, 0, list.size() - 1, n);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n            List<T> list,\n            int left,\n            int right,\n            int n\n    ) {\n        while (true) {\n            if (left == right)\n                return left;\n            int pivotIndex = pivot(list, left, right);\n            pivotIndex = partition(list, left, right, pivotIndex, n);\n            if (n == pivotIndex) {\n                return n;\n            } else if (n < pivotIndex) {\n                right = pivotIndex - 1;\n            } else {\n                left = pivotIndex + 1;\n            }\n        }\n    }\n\n    private static <T extends Comparable<T>> int partition(\n            List<T> list,\n            int left,\n            int right,\n            int pivotIndex,\n            int n\n    ) {\n        T pivotValue = list.get(pivotIndex);\n        Collections.swap(list, pivotIndex, right);\n        int storeIndex = left;\n\n        for (int i = left; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) < 0) {\n                Collections.swap(list, storeIndex, i);\n                storeIndex++;\n            }\n        }\n\n        int storeIndexEq = storeIndex;\n\n        for (int i = storeIndex; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) == 0) {\n                Collections.swap(list, storeIndexEq, i);\n                storeIndexEq++;\n            }\n        }\n\n        Collections.swap(list, right, storeIndexEq);\n\n        return (n < storeIndex)\n                ? storeIndex\n                : Math.min(n, storeIndexEq);\n    }\n\n    private static <T extends Comparable<T>> int pivot(\n            List<T> list,\n            int left,\n            int right\n    ) {\n        if (right - left < 5) {\n            return partition5(list, left, right);\n        }\n\n        for (int i = left; i < right; i += 5) {\n            int subRight = i + 4;\n            if (subRight > right) {\n                subRight = right;\n            }\n            int median5 = partition5(list, i, subRight);\n            int rightIndex = left + (i - left) / 5;\n            Collections.swap(list, median5, rightIndex);\n        }\n\n        int mid = (right - left) / 10 + left + 1;\n        int rightIndex = left + (right - left) / 5;\n        return selectIndex(list, left, rightIndex, mid);\n    }\n\n    private static <T extends Comparable<T>> int partition5(\n            List<T> list,\n            int left,\n            int right\n    ) {\n        List<T> ts = list.subList(left, right);\n        ts.sort(Comparator.naturalOrder());\n        return (left + right) >>> 1;\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/**\n * An implementation of the Quickselect algorithm as described\n * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>.\n */\npublic final class QuickSelect {\n\n    /**\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\n     * be at index n if the list was sorted.\n     * <p>\n     * Calling this function might change the order of elements in {@code list}.\n     *\n     * @param list the list of elements\n     * @param n    the index\n     * @param <T>  the type of list elements\n     * @return the n-th largest element in the list\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\n     *                                   the number of elements in the list\n     * @throws IllegalArgumentException  if the list is empty\n     * @throws NullPointerException      if {@code list} is null\n     */\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\n        Objects.requireNonNull(list, \"The list of elements must not be null.\");\n\n        if (list.size() == 0) {\n            String msg = \"The list of elements must not be empty.\";\n            throw new IllegalArgumentException(msg);\n        }\n\n        if (n < 0) {\n            String msg = \"The index must not be negative.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        if (n >= list.size()) {\n            String msg = \"The index must be less than the number of elements.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        int index = selectIndex(list, n);\n        return list.get(index);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n        List<T> list,\n        int n\n    ) {\n        return selectIndex(list, 0, list.size() - 1, n);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n        List<T> list,\n        int left,\n        int right,\n        int n\n    ) {\n        while (true) {\n            if (left == right) return left;\n            int pivotIndex = pivot(list, left, right);\n            pivotIndex = partition(list, left, right, pivotIndex, n);\n            if (n == pivotIndex) {\n                return n;\n            } else if (n < pivotIndex) {\n                right = pivotIndex - 1;\n            } else {\n                left = pivotIndex + 1;\n            }\n        }\n    }\n\n    private static <T extends Comparable<T>> int partition(\n        List<T> list,\n        int left,\n        int right,\n        int pivotIndex,\n        int n\n    ) {\n        T pivotValue = list.get(pivotIndex);\n        Collections.swap(list, pivotIndex, right);\n        int storeIndex = left;\n\n        for (int i = left; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) < 0) {\n                Collections.swap(list, storeIndex, i);\n                storeIndex++;\n            }\n        }\n\n        int storeIndexEq = storeIndex;\n\n        for (int i = storeIndex; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) == 0) {\n                Collections.swap(list, storeIndexEq, i);\n                storeIndexEq++;\n            }\n        }\n\n        Collections.swap(list, right, storeIndexEq);\n\n        return (n < storeIndex) ? storeIndex : Math.min(n, storeIndexEq);\n    }\n\n    private static <T extends Comparable<T>> int pivot(\n        List<T> list,\n        int left,\n        int right\n    ) {\n        if (right - left < 5) {\n            return partition5(list, left, right);\n        }\n\n        for (int i = left; i < right; i += 5) {\n            int subRight = i + 4;\n            if (subRight > right) {\n                subRight = right;\n            }\n            int median5 = partition5(list, i, subRight);\n            int rightIndex = left + (i - left) / 5;\n            Collections.swap(list, median5, rightIndex);\n        }\n\n        int mid = (right - left) / 10 + left + 1;\n        int rightIndex = left + (right - left) / 5;\n        return selectIndex(list, left, rightIndex, mid);\n    }\n\n    private static <T extends Comparable<T>> int partition5(\n        List<T> list,\n        int left,\n        int right\n    ) {\n        List<T> ts = list.subList(left, right);\n        ts.sort(Comparator.naturalOrder());\n        return (left + right) >>> 1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass QuickSelectTest {\n    @Test\n    void quickSelectMinimumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int minimum = QuickSelect.select(elements, 0);\n        assertEquals(42, minimum);\n    }\n\n    @Test\n    void quickSelectMinimumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n\n        assertEquals(42, minimum1);\n        assertEquals(42, minimum2);\n    }\n\n    @Test\n    void quickSelectMinimumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n        int minimum3 = QuickSelect.select(elements3, 0);\n\n        assertEquals(1, minimum1);\n        assertEquals(1, minimum2);\n        assertEquals(1, minimum3);\n    }\n\n    @Test\n    void quickSelectMinimumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, 0);\n        int expected = elements.stream().min(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMaximumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int maximum = QuickSelect.select(elements, 0);\n        assertEquals(42, maximum);\n    }\n\n    @Test\n    void quickSelectMaximumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int maximum1 = QuickSelect.select(elements1, 1);\n        int maximum2 = QuickSelect.select(elements2, 1);\n\n        assertEquals(90, maximum1);\n        assertEquals(90, maximum2);\n    }\n\n    @Test\n    void quickSelectMaximumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int maximum1 = QuickSelect.select(elements1, 2);\n        int maximum2 = QuickSelect.select(elements2, 2);\n        int maximum3 = QuickSelect.select(elements3, 2);\n\n        assertEquals(3, maximum1);\n        assertEquals(3, maximum2);\n        assertEquals(3, maximum3);\n    }\n\n    @Test\n    void quickSelectMaximumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, NUM_RND_ELEMENTS - 1);\n        int expected = elements.stream().max(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMedianOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int median = QuickSelect.select(elements, 0);\n        assertEquals(42, median);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int median1 = QuickSelect.select(elements1, 1);\n        int median2 = QuickSelect.select(elements2, 1);\n        int median3 = QuickSelect.select(elements3, 1);\n\n        assertEquals(2, median1);\n        assertEquals(2, median2);\n        assertEquals(2, median3);\n    }\n\n    @Test\n    void quickSelectMedianOfManyElements() {\n        int medianIndex = NUM_RND_ELEMENTS / 2;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, medianIndex);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(medianIndex), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 2);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(2), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOfManyElements() {\n        int percentile30th = NUM_RND_ELEMENTS / 10 * 3;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile30th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile30th), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 6);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(6), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOfManyElements() {\n        int percentile70th = NUM_RND_ELEMENTS / 10 * 7;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile70th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile70th), actual);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeCharacters() {\n        List<Character> elements = Arrays.asList('X', 'Z', 'Y');\n        char actual = QuickSelect.select(elements, 1);\n        assertEquals(actual, 'Y');\n    }\n\n    @Test\n    void quickSelectMedianOfManyCharacters() {\n        List<Character> elements = generateRandomCharacters(NUM_RND_ELEMENTS);\n        char actual = QuickSelect.select(elements, NUM_RND_ELEMENTS / 30);\n\n        List<Character> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(NUM_RND_ELEMENTS / 30), actual);\n    }\n\n    @Test\n    void quickSelectNullList() {\n        NullPointerException exception = assertThrows(\n                NullPointerException.class,\n                () -> QuickSelect.select(null, 0)\n        );\n        String expectedMsg = \"The list of elements must not be null.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectEmptyList() {\n        List<String> objects = Collections.emptyList();\n        IllegalArgumentException exception = assertThrows(\n                IllegalArgumentException.class,\n                () -> QuickSelect.select(objects, 0)\n        );\n        String expectedMsg = \"The list of elements must not be empty.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfLeftBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n                IndexOutOfBoundsException.class,\n                () -> QuickSelect.select(Collections.singletonList(1), -1)\n        );\n        String expectedMsg = \"The index must not be negative.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfRightBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n                IndexOutOfBoundsException.class,\n                () -> QuickSelect.select(Collections.singletonList(1), 1)\n        );\n        String expectedMsg = \"The index must be less than the number of elements.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    private static final int NUM_RND_ELEMENTS = 99;\n    private static final Random RANDOM = new Random(42);\n    private static final int ASCII_A = 0x41;\n    private static final int ASCII_Z = 0x5A;\n\n    private static List<Integer> generateRandomIntegers(int n) {\n        return RANDOM.ints(n).boxed().collect(Collectors.toList());\n    }\n\n    private static List<Character> generateRandomCharacters(int n) {\n        return RANDOM.ints(n, ASCII_A, ASCII_Z)\n                .mapToObj(i -> (char) i)\n                .collect(Collectors.toList());\n    }\n\n    private static <T extends Comparable<T>> List<T> getSortedCopyOfList(List<T> list) {\n        return list.stream().sorted().collect(Collectors.toList());\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport org.junit.jupiter.api.Test;\n\nclass QuickSelectTest {\n\n    @Test\n    void quickSelectMinimumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int minimum = QuickSelect.select(elements, 0);\n        assertEquals(42, minimum);\n    }\n\n    @Test\n    void quickSelectMinimumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n\n        assertEquals(42, minimum1);\n        assertEquals(42, minimum2);\n    }\n\n    @Test\n    void quickSelectMinimumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n        int minimum3 = QuickSelect.select(elements3, 0);\n\n        assertEquals(1, minimum1);\n        assertEquals(1, minimum2);\n        assertEquals(1, minimum3);\n    }\n\n    @Test\n    void quickSelectMinimumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, 0);\n        int expected = elements.stream().min(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMaximumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int maximum = QuickSelect.select(elements, 0);\n        assertEquals(42, maximum);\n    }\n\n    @Test\n    void quickSelectMaximumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int maximum1 = QuickSelect.select(elements1, 1);\n        int maximum2 = QuickSelect.select(elements2, 1);\n\n        assertEquals(90, maximum1);\n        assertEquals(90, maximum2);\n    }\n\n    @Test\n    void quickSelectMaximumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int maximum1 = QuickSelect.select(elements1, 2);\n        int maximum2 = QuickSelect.select(elements2, 2);\n        int maximum3 = QuickSelect.select(elements3, 2);\n\n        assertEquals(3, maximum1);\n        assertEquals(3, maximum2);\n        assertEquals(3, maximum3);\n    }\n\n    @Test\n    void quickSelectMaximumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, NUM_RND_ELEMENTS - 1);\n        int expected = elements.stream().max(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMedianOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int median = QuickSelect.select(elements, 0);\n        assertEquals(42, median);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int median1 = QuickSelect.select(elements1, 1);\n        int median2 = QuickSelect.select(elements2, 1);\n        int median3 = QuickSelect.select(elements3, 1);\n\n        assertEquals(2, median1);\n        assertEquals(2, median2);\n        assertEquals(2, median3);\n    }\n\n    @Test\n    void quickSelectMedianOfManyElements() {\n        int medianIndex = NUM_RND_ELEMENTS / 2;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, medianIndex);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(medianIndex), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 2);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(2), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOfManyElements() {\n        int percentile30th = NUM_RND_ELEMENTS / 10 * 3;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile30th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile30th), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 6);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(6), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOfManyElements() {\n        int percentile70th = NUM_RND_ELEMENTS / 10 * 7;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile70th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile70th), actual);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeCharacters() {\n        List<Character> elements = Arrays.asList('X', 'Z', 'Y');\n        char actual = QuickSelect.select(elements, 1);\n        assertEquals(actual, 'Y');\n    }\n\n    @Test\n    void quickSelectMedianOfManyCharacters() {\n        List<Character> elements = generateRandomCharacters(NUM_RND_ELEMENTS);\n        char actual = QuickSelect.select(elements, NUM_RND_ELEMENTS / 30);\n\n        List<Character> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(NUM_RND_ELEMENTS / 30), actual);\n    }\n\n    @Test\n    void quickSelectNullList() {\n        NullPointerException exception = assertThrows(\n            NullPointerException.class,\n            () -> QuickSelect.select(null, 0)\n        );\n        String expectedMsg = \"The list of elements must not be null.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectEmptyList() {\n        List<String> objects = Collections.emptyList();\n        IllegalArgumentException exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> QuickSelect.select(objects, 0)\n        );\n        String expectedMsg = \"The list of elements must not be empty.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfLeftBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n            IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), -1)\n        );\n        String expectedMsg = \"The index must not be negative.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfRightBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n            IndexOutOfBoundsException.class,\n            () -> QuickSelect.select(Collections.singletonList(1), 1)\n        );\n        String expectedMsg =\n            \"The index must be less than the number of elements.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    private static final int NUM_RND_ELEMENTS = 99;\n    private static final Random RANDOM = new Random(42);\n    private static final int ASCII_A = 0x41;\n    private static final int ASCII_Z = 0x5A;\n\n    private static List<Integer> generateRandomIntegers(int n) {\n        return RANDOM.ints(n).boxed().collect(Collectors.toList());\n    }\n\n    private static List<Character> generateRandomCharacters(int n) {\n        return RANDOM\n            .ints(n, ASCII_A, ASCII_Z)\n            .mapToObj(i -> (char) i)\n            .collect(Collectors.toList());\n    }\n\n    private static <T extends Comparable<T>> List<T> getSortedCopyOfList(\n        List<T> list\n    ) {\n        return list.stream().sorted().collect(Collectors.toList());\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RabinKarpAlgorithm.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RabinKarpAlgorithmTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n// Following program is a Java implementation \n// of Rabin Karp Algorithm given in the CLRS book\n  \npublic class RabinKarpAlgorithm\n{\n    // d is the number of characters in the input alphabet\n    public final static int d = 256;\n      \n    /* pat -> pattern\n        txt -> text\n        q -> A prime number\n    */\n    public int search(String pat, String txt, int q)\n    {\n    \tint index = -1; //note: -1 here represent not found, it is not an index\n        int M = pat.length();\n        int N = txt.length();\n        int i, j;\n        int p = 0; // hash value for pattern\n        int t = 0; // hash value for txt\n        int h = 1;\n      \n        // The value of h would be \"pow(d, M-1)%q\"\n        for (i = 0; i < M-1; i++)\n            h = (h*d)%q;\n      \n        // Calculate the hash value of pattern and first\n        // window of text\n        for (i = 0; i < M; i++)\n        {\n            p = (d*p + pat.charAt(i))%q;\n            t = (d*t + txt.charAt(i))%q;\n        }\n      \n        // Slide the pattern over text one by one\n        for (i = 0; i <= N - M; i++)\n        {\n      \n            // Check the hash values of current window of text\n            // and pattern. If the hash values match then only\n            // check for characters one by one\n            if ( p == t )\n            {\n                /* Check for characters one by one */\n                for (j = 0; j < M; j++)\n                {\n                    if (txt.charAt(i+j) != pat.charAt(j))\n                        break;\n                }\n      \n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]\n                if (j == M) {\n                    System.out.println(\"Pattern found at index \" + i);\n                    index= i;\n                    return index ;\n                }\n            }\n      \n            // Calculate hash value for next window of text: Remove\n            // leading digit, add trailing digit\n            if ( i < N-M )\n            {\n                t = (d*(t - txt.charAt(i)*h) + txt.charAt(i+M))%q;\n      \n                // We might get negative value of t, converting it\n                // to positive\n                if (t < 0)\n                t = (t + q);\n            }\n        }\n        return index; // return -1 if pattern does not found\n    }\n      \n}\n  \n// This code is contributed by nuclode",
        "product_new_content": "package com.thealgorithms.searches;\n\n// Following program is a Java implementation\n// of Rabin Karp Algorithm given in the CLRS book\n\npublic class RabinKarpAlgorithm {\n\n    // d is the number of characters in the input alphabet\n    public static final int d = 256;\n\n    /* pat -> pattern\n        txt -> text\n        q -> A prime number\n    */\n    public int search(String pat, String txt, int q) {\n        int index = -1; //note: -1 here represent not found, it is not an index\n        int M = pat.length();\n        int N = txt.length();\n        int i, j;\n        int p = 0; // hash value for pattern\n        int t = 0; // hash value for txt\n        int h = 1;\n\n        // The value of h would be \"pow(d, M-1)%q\"\n        for (i = 0; i < M - 1; i++) h = (h * d) % q;\n\n        // Calculate the hash value of pattern and first\n        // window of text\n        for (i = 0; i < M; i++) {\n            p = (d * p + pat.charAt(i)) % q;\n            t = (d * t + txt.charAt(i)) % q;\n        }\n\n        // Slide the pattern over text one by one\n        for (i = 0; i <= N - M; i++) {\n            // Check the hash values of current window of text\n            // and pattern. If the hash values match then only\n            // check for characters one by one\n            if (p == t) {\n                /* Check for characters one by one */\n                for (j = 0; j < M; j++) {\n                    if (txt.charAt(i + j) != pat.charAt(j)) break;\n                }\n\n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]\n                if (j == M) {\n                    System.out.println(\"Pattern found at index \" + i);\n                    index = i;\n                    return index;\n                }\n            }\n\n            // Calculate hash value for next window of text: Remove\n            // leading digit, add trailing digit\n            if (i < N - M) {\n                t = (d * (t - txt.charAt(i) * h) + txt.charAt(i + M)) % q;\n\n                // We might get negative value of t, converting it\n                // to positive\n                if (t < 0) t = (t + q);\n            }\n        }\n        return index; // return -1 if pattern does not found\n    }\n}\n// This code is contributed by nuclode",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass RabinKarpAlgorithmTest {\n\n\t\n\tRabinKarpAlgorithm RKA= new RabinKarpAlgorithm();\n\tint q= 101;\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestExample() {\n        String txt = \"This is an example for rabin karp algorithmn\";\n        String pat = \"algorithmn\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value,34);\n    }\n    \n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestFront() {\n        String txt = \"AAABBDDG\";\n        String pat = \"AAA\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 0);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestMiddle() {\n        String txt = \"AAABBCCBB\";\n        String pat = \"BBCC\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 3);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestLast() {\n        String txt = \"AAAABBBBCCC\";\n        String pat = \"CCC\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 8);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestNotFound() {\n        String txt = \"ABCBCBCAAB\";\n        String pat = \"AADB\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, -1);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass RabinKarpAlgorithmTest {\n\n    RabinKarpAlgorithm RKA = new RabinKarpAlgorithm();\n    int q = 101;\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestExample() {\n        String txt = \"This is an example for rabin karp algorithmn\";\n        String pat = \"algorithmn\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 34);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestFront() {\n        String txt = \"AAABBDDG\";\n        String pat = \"AAA\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 0);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestMiddle() {\n        String txt = \"AAABBCCBB\";\n        String pat = \"BBCC\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 3);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestLast() {\n        String txt = \"AAAABBBBCCC\";\n        String pat = \"CCC\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 8);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestNotFound() {\n        String txt = \"ABCBCBCAAB\";\n        String pat = \"AADB\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, -1);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BinaryInsertionSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BinaryInsertionSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\npublic class BinaryInsertionSort{\n   \n\n \n    // Binary Insertion Sort method   \n    public int[] binaryInsertSort(int[] array){\n       \n        for(int i = 1; i < array.length; i++){\n           \n        \tint temp=array[i];\n            int low = 0;            \n            int high = i - 1;  \n           \n            while(low <= high){                \n                int mid = (low + high) / 2;                \n                if(temp < array[mid]){                    \n                    high = mid - 1;                \n                }else{                    \n                    low = mid + 1;\n                }       \n            }\n           \n            for(int j = i; j >= low + 1; j--){            \n                array[j] = array[j - 1];                                                      \n            }       \n           \n            array[low] = temp;       \n        }   \n        return array;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\npublic class BinaryInsertionSort {\n\n    // Binary Insertion Sort method\n    public int[] binaryInsertSort(int[] array) {\n        for (int i = 1; i < array.length; i++) {\n            int temp = array[i];\n            int low = 0;\n            int high = i - 1;\n\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (temp < array[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            }\n\n            for (int j = i; j >= low + 1; j--) {\n                array[j] = array[j - 1];\n            }\n\n            array[low] = temp;\n        }\n        return array;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\n\nclass BinaryInsertionSortTest {\n\tBinaryInsertionSort BIS= new BinaryInsertionSort();\n\t\n    @Test\n    // valid test case\n    public void BinaryInsertionSortTestNonDuplicate() {\n    \tint[] array = {1,0,2,5,3,4,9,8,10,6,7};\t\n    \tint [] expResult= {0,1,2,3,4,5,6,7,8,9,10};\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult,actResult);\n    }\n\n    @Test\n    public void BinaryInsertionSortTestDuplicate() {\n    \tint[] array = {1,1,1,5,9,8,7,2,6};\t\n    \tint [] expResult= {1,1,1,2,5,6,7,8,9};\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult,actResult);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass BinaryInsertionSortTest {\n\n    BinaryInsertionSort BIS = new BinaryInsertionSort();\n\n    @Test\n    // valid test case\n    public void BinaryInsertionSortTestNonDuplicate() {\n        int[] array = { 1, 0, 2, 5, 3, 4, 9, 8, 10, 6, 7 };\n        int[] expResult = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    public void BinaryInsertionSortTestDuplicate() {\n        int[] array = { 1, 1, 1, 5, 9, 8, 7, 2, 6 };\n        int[] expResult = { 1, 1, 1, 2, 5, 6, 7, 8, 9 };\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult, actResult);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/DutchNationalFlagSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DutchNationalFlagSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * The Dutch National Flag Sort sorts a sequence of values into three permutations which are defined by a value given\n * as the indented middle.\n * First permutation: values less than middle.\n * Second permutation: values equal middle.\n * Third permutation: values greater than middle.\n * If no indented middle is given, this implementation will use a value from the given Array.\n * This value is the one positioned in the arrays' middle if the arrays' length is odd.\n * If the arrays' length is even, the value left to the middle will be used.\n * More information and Pseudocode: https://en.wikipedia.org/wiki/Dutch_national_flag_problem\n */\npublic class DutchNationalFlagSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return dutch_national_flag_sort(unsorted, unsorted[(int) Math.ceil((unsorted.length)/2.0) -1]);\n    }\n\n    public <T extends Comparable<T>> T[] sort(T[] unsorted, T intendedMiddle) {\n        return dutch_national_flag_sort(unsorted, intendedMiddle);\n    }\n\n    private <T extends Comparable<T>> T[] dutch_national_flag_sort(T[] arr, T intendedMiddle){\n        int i = 0;\n        int j = 0;\n        int k = arr.length - 1;\n\n        while( j <= k){\n            if ( 0 > arr[j].compareTo(intendedMiddle)){\n                SortUtils.swap(arr, i, j);\n                j++;\n                i++;\n            } else if (0 < arr[j].compareTo(intendedMiddle)){\n                SortUtils.swap(arr, j, k);\n                k--;\n            } else {\n                j++;\n            }\n        }\n       return arr;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * The Dutch National Flag Sort sorts a sequence of values into three permutations which are defined by a value given\n * as the indented middle.\n * First permutation: values less than middle.\n * Second permutation: values equal middle.\n * Third permutation: values greater than middle.\n * If no indented middle is given, this implementation will use a value from the given Array.\n * This value is the one positioned in the arrays' middle if the arrays' length is odd.\n * If the arrays' length is even, the value left to the middle will be used.\n * More information and Pseudocode: https://en.wikipedia.org/wiki/Dutch_national_flag_problem\n */\npublic class DutchNationalFlagSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return dutch_national_flag_sort(\n            unsorted,\n            unsorted[(int) Math.ceil((unsorted.length) / 2.0) - 1]\n        );\n    }\n\n    public <T extends Comparable<T>> T[] sort(T[] unsorted, T intendedMiddle) {\n        return dutch_national_flag_sort(unsorted, intendedMiddle);\n    }\n\n    private <T extends Comparable<T>> T[] dutch_national_flag_sort(\n        T[] arr,\n        T intendedMiddle\n    ) {\n        int i = 0;\n        int j = 0;\n        int k = arr.length - 1;\n\n        while (j <= k) {\n            if (0 > arr[j].compareTo(intendedMiddle)) {\n                SortUtils.swap(arr, i, j);\n                j++;\n                i++;\n            } else if (0 < arr[j].compareTo(intendedMiddle)) {\n                SortUtils.swap(arr, j, k);\n                k--;\n            } else {\n                j++;\n            }\n        }\n        return arr;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DutchNationalFlagSortTest {\n    @Test\n    /*\n      1 will be used as intended middle.\n      Partitions on the result array: [ smaller than 1 , equal 1, greater than 1]\n     */\n    void DNFSTestOdd() {\n        Integer[] integers = {1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 1, 4, 3};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      3 will be used as intended middle.\n      Partitions on the result array: [ smaller than 3 , equal 3, greater than 3]\n     */\n    void DNFSTestEven() {\n        Integer[] integers = {8, 1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 1, 3, 4, 8};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestEvenStrings() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\", \"e\"};\n        String[] stringsResult = {\"a\", \"b\", \"s\", \"e\", \"e\", \"d\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestOddStrings() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\"};\n        String[] stringsResult = {\"a\", \"b\", \"s\", \"e\", \"d\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      0 will be used as intended middle.\n      Partitions on the result array: [ smaller than 0 , equal 0, greater than 0]\n     */\n    void DNFSTestOddMidGiven() {\n        Integer[] integers = {1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 4, 3, 1};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 0);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      4 will be used as intended middle.\n      Partitions on the result array: [ smaller than 4 , equal 4, greater than 4]\n     */\n    void DNFSTestEvenMidGiven() {\n        Integer[] integers = {8, 1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 3, 1, 4, 8};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 4);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"s\" will be used as intended middle.\n      Partitions on the result array: [ smaller than s , equal s, greater than s]\n     */\n    void DNFSTestEvenStringsMidGiven() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\", \"e\"};\n        String[] stringsResult = {\"a\", \"d\", \"b\", \"e\", \"e\", \"s\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"s\");\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"e\" will be used as intended middle.\n      Partitions on the result array: [ smaller than e , equal e, greater than e]\n     */\n    void DNFSTestOddStringsMidGiven() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\"};\n        String[] stringsResult = {\"a\", \"d\", \"b\", \"e\", \"s\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"e\");\n        assertArrayEquals(strings, stringsResult);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DutchNationalFlagSortTest {\n\n    @Test\n    /*\n      1 will be used as intended middle.\n      Partitions on the result array: [ smaller than 1 , equal 1, greater than 1]\n     */\n    void DNFSTestOdd() {\n        Integer[] integers = { 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 1, 4, 3 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      3 will be used as intended middle.\n      Partitions on the result array: [ smaller than 3 , equal 3, greater than 3]\n     */\n    void DNFSTestEven() {\n        Integer[] integers = { 8, 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 1, 3, 4, 8 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestEvenStrings() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\", \"e\" };\n        String[] stringsResult = { \"a\", \"b\", \"s\", \"e\", \"e\", \"d\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestOddStrings() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\" };\n        String[] stringsResult = { \"a\", \"b\", \"s\", \"e\", \"d\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      0 will be used as intended middle.\n      Partitions on the result array: [ smaller than 0 , equal 0, greater than 0]\n     */\n    void DNFSTestOddMidGiven() {\n        Integer[] integers = { 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 4, 3, 1 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 0);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      4 will be used as intended middle.\n      Partitions on the result array: [ smaller than 4 , equal 4, greater than 4]\n     */\n    void DNFSTestEvenMidGiven() {\n        Integer[] integers = { 8, 1, 3, 1, 4, 0 };\n        Integer[] integersResult = { 0, 1, 3, 1, 4, 8 };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 4);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"s\" will be used as intended middle.\n      Partitions on the result array: [ smaller than s , equal s, greater than s]\n     */\n    void DNFSTestEvenStringsMidGiven() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\", \"e\" };\n        String[] stringsResult = { \"a\", \"d\", \"b\", \"e\", \"e\", \"s\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"s\");\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"e\" will be used as intended middle.\n      Partitions on the result array: [ smaller than e , equal e, greater than e]\n     */\n    void DNFSTestOddStringsMidGiven() {\n        String[] strings = { \"a\", \"d\", \"b\", \"s\", \"e\" };\n        String[] stringsResult = { \"a\", \"d\", \"b\", \"e\", \"s\" };\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"e\");\n        assertArrayEquals(strings, stringsResult);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/InsertionSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BinaryInsertionSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nclass InsertionSort implements SortAlgorithm {\n\n    /**\n     * Generic insertion sort algorithm in increasing order.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1; i < array.length; i++) {\n            T insertValue = array[i];\n            int j;\n            for (j = i - 1; j >= 0 && less(insertValue, array[j]); j--) {\n                array[j + 1] = array[j];\n            }\n            if (j != i - 1) {\n                array[j + 1] = insertValue;\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        InsertionSort sort = new InsertionSort();\n        sort.sort(integers);\n        print(integers);\n        /* [1, 4, 6, 9, 12, 23, 54, 78, 231] */\n\n        String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        sort.sort(strings);\n        print(strings);\n        /* [a, b, c, d, e] */\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nclass InsertionSort implements SortAlgorithm {\n\n    /**\n     * Generic insertion sort algorithm in increasing order.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1; i < array.length; i++) {\n            T insertValue = array[i];\n            int j;\n            for (j = i - 1; j >= 0 && less(insertValue, array[j]); j--) {\n                array[j + 1] = array[j];\n            }\n            if (j != i - 1) {\n                array[j + 1] = insertValue;\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Integer[] integers = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        InsertionSort sort = new InsertionSort();\n        sort.sort(integers);\n        print(integers);\n        /* [1, 4, 6, 9, 12, 23, 54, 78, 231] */\n\n        String[] strings = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        sort.sort(strings);\n        print(strings);\n        /* [a, b, c, d, e] */\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\n\nclass BinaryInsertionSortTest {\n\tBinaryInsertionSort BIS= new BinaryInsertionSort();\n\t\n    @Test\n    // valid test case\n    public void BinaryInsertionSortTestNonDuplicate() {\n    \tint[] array = {1,0,2,5,3,4,9,8,10,6,7};\t\n    \tint [] expResult= {0,1,2,3,4,5,6,7,8,9,10};\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult,actResult);\n    }\n\n    @Test\n    public void BinaryInsertionSortTestDuplicate() {\n    \tint[] array = {1,1,1,5,9,8,7,2,6};\t\n    \tint [] expResult= {1,1,1,2,5,6,7,8,9};\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult,actResult);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass BinaryInsertionSortTest {\n\n    BinaryInsertionSort BIS = new BinaryInsertionSort();\n\n    @Test\n    // valid test case\n    public void BinaryInsertionSortTestNonDuplicate() {\n        int[] array = { 1, 0, 2, 5, 3, 4, 9, 8, 10, 6, 7 };\n        int[] expResult = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult, actResult);\n    }\n\n    @Test\n    public void BinaryInsertionSortTestDuplicate() {\n        int[] array = { 1, 1, 1, 5, 9, 8, 7, 2, 6 };\n        int[] expResult = { 1, 1, 1, 2, 5, 6, 7, 8, 9 };\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult, actResult);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/QuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/QuickSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Ramdomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(\n        T[] array,\n        int left,\n        int right\n    ) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Ramdomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n * @see QuickSort\n */\nclass QuickSortTest {\n\t\n\tprivate QuickSort quickSort = new QuickSort();\n\n\t@Test\n\tvoid quickSortEmptyArrayShouldPass()\n\t{\n\t    Integer[] array = {};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortSingleValueArrayShouldPass()\n\t{\n\t    Integer[] array = {7};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {7};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortWithIntegerArrayShouldPass()\n\t{\n\t    Integer[] array = {49,4,36,9,144,1};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {1,4,9,36,49,144};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortForArrayWithNegativeValuesShouldPass()\n\t{\n\t    Integer[] array = {49,-36,-144,-49,1,9};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {-144,-49,-36,1,9,49};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortForArrayWithDuplicateValuesShouldPass()\n\t{\n\t    Integer[] array = {36,1,49,1,4,9};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {1,1,4,9,36,49};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\t\n\t@Test\n\tvoid quickSortWithStringArrayShouldPass()\n\t{\n\t    String[] array = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n\t    String[] sorted = quickSort.sort(array);\n\t    String[] expected = {\"a\",\"b\",\"c\",\"d\",\"e\"};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\t\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n * @see QuickSort\n */\nclass QuickSortTest {\n\n    private QuickSort quickSort = new QuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = quickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = { 7 };\n        Integer[] sorted = quickSort.sort(array);\n        Integer[] expected = { 7 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = { 49, 4, 36, 9, 144, 1 };\n        Integer[] sorted = quickSort.sort(array);\n        Integer[] expected = { 1, 4, 9, 36, 49, 144 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = { 49, -36, -144, -49, 1, 9 };\n        Integer[] sorted = quickSort.sort(array);\n        Integer[] expected = { -144, -49, -36, 1, 9, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = { 36, 1, 49, 1, 4, 9 };\n        Integer[] sorted = quickSort.sort(array);\n        Integer[] expected = { 1, 1, 4, 9, 36, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        String[] sorted = quickSort.sort(array);\n        String[] expected = { \"a\", \"b\", \"c\", \"d\", \"e\" };\n        assertArrayEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SelectionSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SelectionSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\npublic class SelectionSort implements SortAlgorithm {\n\n    /**\n     * Generic selection sort algorithm in increasing order.\n     *\n     * @param arr the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[minIndex].compareTo(arr[j]) > 0) {\n                    minIndex = j;\n                }\n            }\n            if (minIndex != i) {\n                T temp = arr[i];\n                arr[i] = arr[minIndex];\n                arr[minIndex] = temp;\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n\n        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        SelectionSort selectionSort = new SelectionSort();\n        Integer[] sorted = selectionSort.sort(arr);\n        for (int i = 0; i < sorted.length - 1; ++i) {\n            assert sorted[i] <= sorted[i + 1];\n        }\n\n        String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        String[] sortedStrings = selectionSort.sort(strings);\n        for (int i = 0; i < sortedStrings.length - 1; ++i) {\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\npublic class SelectionSort implements SortAlgorithm {\n\n    /**\n     * Generic selection sort algorithm in increasing order.\n     *\n     * @param arr the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[minIndex].compareTo(arr[j]) > 0) {\n                    minIndex = j;\n                }\n            }\n            if (minIndex != i) {\n                T temp = arr[i];\n                arr[i] = arr[minIndex];\n                arr[minIndex] = temp;\n            }\n        }\n        return arr;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Integer[] arr = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        SelectionSort selectionSort = new SelectionSort();\n        Integer[] sorted = selectionSort.sort(arr);\n        for (int i = 0; i < sorted.length - 1; ++i) {\n            assert sorted[i] <= sorted[i + 1];\n        }\n\n        String[] strings = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        String[] sortedStrings = selectionSort.sort(strings);\n        for (int i = 0; i < sortedStrings.length - 1; ++i) {\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SelectionSortTest {\n\n    @Test\n    // valid test case\n    void IntegerArrTest() {\n        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new Integer[]{1, 4, 6, 9, 12, 23, 54, 78, 231}, selectionSort.sort(arr));\n    }\n\n    @Test\n    // valid test case\n    void StringArrTest() {\n        String[] arr = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"d\", \"e\"}, selectionSort.sort(arr));\n    }\n\n    @Test\n    // invalid test case\n    void emptyArrTest() {\n        Integer[] arr = {};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new Integer[]{}, selectionSort.sort(arr));\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SelectionSortTest {\n\n    @Test\n    // valid test case\n    void IntegerArrTest() {\n        Integer[] arr = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(\n            new Integer[] { 1, 4, 6, 9, 12, 23, 54, 78, 231 },\n            selectionSort.sort(arr)\n        );\n    }\n\n    @Test\n    // valid test case\n    void StringArrTest() {\n        String[] arr = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(\n            new String[] { \"a\", \"b\", \"c\", \"d\", \"e\" },\n            selectionSort.sort(arr)\n        );\n    }\n\n    @Test\n    // invalid test case\n    void emptyArrTest() {\n        Integer[] arr = {};\n        SelectionSort selectionSort = new SelectionSort();\n\n        assertArrayEquals(new Integer[] {}, selectionSort.sort(arr));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/StrandSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/StrandSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n \npublic class StrandSort{\n\t// note: the input list is destroyed\n\tpublic static <E extends Comparable<? super E>> \n\tLinkedList<E> strandSort(LinkedList<E> list){\n\t\tif(list.size() <= 1) return list;\n \n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(list.size() > 0){\n\t\t\tLinkedList<E> sorted = new LinkedList<E>();\n\t\t\tsorted.add(list.removeFirst()); //same as remove() or remove(0)\n\t\t\tfor(Iterator<E> it = list.iterator(); it.hasNext(); ){\n\t\t\t\tE elem = it.next();\n\t\t\t\tif(sorted.peekLast().compareTo(elem) <= 0){\n\t\t\t\t\tsorted.addLast(elem); //same as add(elem) or add(0, elem)\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = merge(sorted, result);\n\t\t}\n\t\treturn result;\n\t}\n \n\tprivate static <E extends Comparable<? super E>>\n\tLinkedList<E> merge(LinkedList<E> left, LinkedList<E> right){\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(!left.isEmpty() && !right.isEmpty()){\n\t\t\t//change the direction of this comparison to change the direction of the sort\n\t\t\tif(left.peek().compareTo(right.peek()) <= 0)\n\t\t\t\tresult.add(left.remove());\n\t\t\telse\n\t\t\t\tresult.add(right.remove());\n\t\t}\n\t\tresult.addAll(left);\n\t\tresult.addAll(right);\n\t\treturn result;\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class StrandSort {\n\n    // note: the input list is destroyed\n    public static <E extends Comparable<? super E>> LinkedList<E> strandSort(\n        LinkedList<E> list\n    ) {\n        if (list.size() <= 1) return list;\n\n        LinkedList<E> result = new LinkedList<E>();\n        while (list.size() > 0) {\n            LinkedList<E> sorted = new LinkedList<E>();\n            sorted.add(list.removeFirst()); //same as remove() or remove(0)\n            for (Iterator<E> it = list.iterator(); it.hasNext();) {\n                E elem = it.next();\n                if (sorted.peekLast().compareTo(elem) <= 0) {\n                    sorted.addLast(elem); //same as add(elem) or add(0, elem)\n                    it.remove();\n                }\n            }\n            result = merge(sorted, result);\n        }\n        return result;\n    }\n\n    private static <E extends Comparable<? super E>> LinkedList<E> merge(\n        LinkedList<E> left,\n        LinkedList<E> right\n    ) {\n        LinkedList<E> result = new LinkedList<E>();\n        while (!left.isEmpty() && !right.isEmpty()) {\n            //change the direction of this comparison to change the direction of the sort\n            if (left.peek().compareTo(right.peek()) <= 0) result.add(\n                left.remove()\n            ); else result.add(right.remove());\n        }\n        result.addAll(left);\n        result.addAll(right);\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\n\n\nclass StrandSortTest {\n\t@Test\n\t// valid test case\n\tpublic void StrandSortNonDuplicateTest() {\n\t\tint[] expectedArray = { 1, 2, 3, 4, 5 };\n\t\tLinkedList<Integer> actualList = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(3, 1, 2, 4, 5)));\n\t\tint[] actualArray = new int[actualList.size()];\n\t\tfor (int i = 0; i < actualList.size(); i++) {\n\t\t\tactualArray[i] = actualList.get(i);\n\t\t}\n\t\tassertArrayEquals(expectedArray, actualArray);\n\n\t}\n\n\t@Test\n\t// valid test case\n\tpublic void StrandSortDuplicateTest() {\n\t\tint[] expectedArray = { 2, 2, 2, 5, 7 };\n\t\tLinkedList<Integer> actualList = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(7, 2, 2, 2, 5)));\n\t\tint[] actualArray = new int[actualList.size()];\n\t\tfor (int i = 0; i < actualList.size(); i++) {\n\t\t\tactualArray[i] = actualList.get(i);\n\t\t}\n\t\tassertArrayEquals(expectedArray, actualArray);\n\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass StrandSortTest {\n\n    @Test\n    // valid test case\n    public void StrandSortNonDuplicateTest() {\n        int[] expectedArray = { 1, 2, 3, 4, 5 };\n        LinkedList<Integer> actualList = StrandSort.strandSort(\n            new LinkedList<Integer>(Arrays.asList(3, 1, 2, 4, 5))\n        );\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n\n    @Test\n    // valid test case\n    public void StrandSortDuplicateTest() {\n        int[] expectedArray = { 2, 2, 2, 5, 7 };\n        LinkedList<Integer> actualList = StrandSort.strandSort(\n            new LinkedList<Integer>(Arrays.asList(7, 2, 2, 2, 5))\n        );\n        int[] actualArray = new int[actualList.size()];\n        for (int i = 0; i < actualList.size(); i++) {\n            actualArray[i] = actualList.get(i);\n        }\n        assertArrayEquals(expectedArray, actualArray);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/TopologicalSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/TopologicalSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.*;\n\n/**\n * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into\n * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is\n * performed, yielding no back-edges.\n *\n * https://en.wikipedia.org/wiki/Topological_sorting\n *\n * @author Jonathan Taylor (https://github.com/Jtmonument)\n * Based on Introduction to Algorithms 3rd Edition\n */\npublic class TopologicalSort {\n\n     /*\n     * Enum to represent the colors for the depth first search\n     * */\n    private enum Color {\n        WHITE, GRAY, BLACK\n    }\n\n     /*\n     * Class to represent vertices\n     * */\n    private static class Vertex {\n        /*\n        * Name of vertex\n        * */\n        public final String label;\n\n        /*\n        * Weight of vertex\n        * (more accurately defined as the time that a vertex has begun a visit in DFS)\n        * */\n        public int weight;\n\n        /*\n        * The time that the vertex has finished a visit in DFS\n        * */\n        public int finished;\n\n        /*\n        * \u03c0 parent of the vertex\n        * */\n        public Vertex predecessor;\n\n        /*\n        * Represents the category of visit in DFS\n        * */\n        public Color color = Color.WHITE;\n\n        /*\n        * The array of names of descendant vertices\n        * */\n        public final ArrayList<String> next = new ArrayList<>();\n\n        public Vertex(String label) {\n            this.label = label;\n        }\n     }\n\n     /*\n     * Graph class uses the adjacency list representation\n     * */\n    static class Graph {\n\n        /*\n         * Adjacency list representation\n         * */\n        private final HashMap<String, Vertex> adj = new LinkedHashMap<>();\n\n        /*\n         * Function to add an edge to the graph\n         * */\n        public void addEdge(String label, String... next) {\n            adj.put(label, new Vertex(label));\n            if (!next[0].isEmpty())\n                Collections.addAll(adj.get(label).next, next);\n        }\n    }\n\n    static class BackEdgeException extends RuntimeException {\n\n        public BackEdgeException(String backEdge) {\n            super(\"This graph contains a cycle. No linear ordering is possible. \" + backEdge);\n        }\n\n    }\n\n    /*\n     * Time variable in DFS\n     * */\n    private static int time;\n\n    /*\n     * Depth First Search\n     *\n     * DFS(G)\n     *   for each vertex u \u2208 G.V\n     *       u.color = WHITE\n     *       u.\u03c0 = NIL\n     *   time = 0\n     *   for each vertex u \u2208 G.V\n     *   if u.color == WHITE\n     *       DFS-VISIT(G, u)\n     *\n     * Performed in \u0398(V + E) time\n     * */\n    public static LinkedList<String> sort(Graph graph) {\n        LinkedList<String> list = new LinkedList<>();\n        graph.adj.forEach((name, vertex) -> {\n            if (vertex.color == Color.WHITE) {\n                list.addFirst(sort(graph, vertex, list));\n            }\n        });\n        return list;\n    }\n\n    /*\n     * Depth First Search Visit\n     *\n     * DFS-Visit(G, u)\n     *   time = time + 1\n     *   u.d = time\n     *   u.color = GRAY\n     *   for each v \u2208 G.Adj[u]\n     *       if v.color == WHITE\n     *           v.\u03c0 = u\n     *           DFS-Visit(G, u)\n     *   u.color = BLACK\n     *   time = time + 1\n     *   u.f = time\n     * */\n    private static String sort(Graph graph, Vertex u, LinkedList<String> list) {\n        time++;\n        u.weight = time;\n        u.color = Color.GRAY;\n        graph.adj.get(u.label).next.forEach(label -> {\n            if (graph.adj.get(label).color == Color.WHITE) {\n                graph.adj.get(label).predecessor = u;\n                list.addFirst(sort(graph, graph.adj.get(label), list));\n            } else if (graph.adj.get(label).color == Color.GRAY) {\n                /*\n                 * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v\n                 * in a depth first tree. If v.d \u2264 u.d < u.f \u2264 v.f\n                 *\n                 * In many cases, we will not know u.f, but v.color denotes the type of edge\n                 * */\n                throw new BackEdgeException(\"Back edge: \" + u.label + \" -> \" + label);\n            }\n        });\n        u.color = Color.BLACK;\n        time++;\n        u.finished = time;\n        return u.label;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.*;\n\n/**\n * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into\n * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is\n * performed, yielding no back-edges.\n *\n * https://en.wikipedia.org/wiki/Topological_sorting\n *\n * @author Jonathan Taylor (https://github.com/Jtmonument)\n * Based on Introduction to Algorithms 3rd Edition\n */\npublic class TopologicalSort {\n\n    /*\n     * Enum to represent the colors for the depth first search\n     * */\n    private enum Color {\n        WHITE,\n        GRAY,\n        BLACK,\n    }\n\n    /*\n     * Class to represent vertices\n     * */\n    private static class Vertex {\n\n        /*\n         * Name of vertex\n         * */\n        public final String label;\n\n        /*\n         * Weight of vertex\n         * (more accurately defined as the time that a vertex has begun a visit in DFS)\n         * */\n        public int weight;\n\n        /*\n         * The time that the vertex has finished a visit in DFS\n         * */\n        public int finished;\n\n        /*\n         * \u03c0 parent of the vertex\n         * */\n        public Vertex predecessor;\n\n        /*\n         * Represents the category of visit in DFS\n         * */\n        public Color color = Color.WHITE;\n\n        /*\n         * The array of names of descendant vertices\n         * */\n        public final ArrayList<String> next = new ArrayList<>();\n\n        public Vertex(String label) {\n            this.label = label;\n        }\n    }\n\n    /*\n     * Graph class uses the adjacency list representation\n     * */\n    static class Graph {\n\n        /*\n         * Adjacency list representation\n         * */\n        private final HashMap<String, Vertex> adj = new LinkedHashMap<>();\n\n        /*\n         * Function to add an edge to the graph\n         * */\n        public void addEdge(String label, String... next) {\n            adj.put(label, new Vertex(label));\n            if (!next[0].isEmpty()) Collections.addAll(\n                adj.get(label).next,\n                next\n            );\n        }\n    }\n\n    static class BackEdgeException extends RuntimeException {\n\n        public BackEdgeException(String backEdge) {\n            super(\n                \"This graph contains a cycle. No linear ordering is possible. \" +\n                backEdge\n            );\n        }\n    }\n\n    /*\n     * Time variable in DFS\n     * */\n    private static int time;\n\n    /*\n     * Depth First Search\n     *\n     * DFS(G)\n     *   for each vertex u \u2208 G.V\n     *       u.color = WHITE\n     *       u.\u03c0 = NIL\n     *   time = 0\n     *   for each vertex u \u2208 G.V\n     *   if u.color == WHITE\n     *       DFS-VISIT(G, u)\n     *\n     * Performed in \u0398(V + E) time\n     * */\n    public static LinkedList<String> sort(Graph graph) {\n        LinkedList<String> list = new LinkedList<>();\n        graph.adj.forEach((name, vertex) -> {\n            if (vertex.color == Color.WHITE) {\n                list.addFirst(sort(graph, vertex, list));\n            }\n        });\n        return list;\n    }\n\n    /*\n     * Depth First Search Visit\n     *\n     * DFS-Visit(G, u)\n     *   time = time + 1\n     *   u.d = time\n     *   u.color = GRAY\n     *   for each v \u2208 G.Adj[u]\n     *       if v.color == WHITE\n     *           v.\u03c0 = u\n     *           DFS-Visit(G, u)\n     *   u.color = BLACK\n     *   time = time + 1\n     *   u.f = time\n     * */\n    private static String sort(Graph graph, Vertex u, LinkedList<String> list) {\n        time++;\n        u.weight = time;\n        u.color = Color.GRAY;\n        graph.adj\n            .get(u.label)\n            .next.forEach(label -> {\n                if (graph.adj.get(label).color == Color.WHITE) {\n                    graph.adj.get(label).predecessor = u;\n                    list.addFirst(sort(graph, graph.adj.get(label), list));\n                } else if (graph.adj.get(label).color == Color.GRAY) {\n                    /*\n                     * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v\n                     * in a depth first tree. If v.d \u2264 u.d < u.f \u2264 v.f\n                     *\n                     * In many cases, we will not know u.f, but v.color denotes the type of edge\n                     * */\n                    throw new BackEdgeException(\n                        \"Back edge: \" + u.label + \" -> \" + label\n                    );\n                }\n            });\n        u.color = Color.BLACK;\n        time++;\n        u.finished = time;\n        return u.label;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport com.thealgorithms.sorts.TopologicalSort.Graph;\nimport com.thealgorithms.sorts.TopologicalSort.BackEdgeException;\n\nimport java.util.LinkedList;\n\nclass TopologicalSortTest {\n    @Test\n    void successTest() {\n        /*\n         * Professor Bumstead example DAG. Each directed edge means that garment u must be put on\n         * before garment v.\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"shirt\", \"tie\", \"belt\");\n        graph.addEdge(\"tie\", \"jacket\");\n        graph.addEdge(\"belt\", \"jacket\");\n        graph.addEdge(\"watch\", \"\");\n        graph.addEdge(\"undershorts\", \"pants\", \"shoes\");\n        graph.addEdge(\"shoes\", \"\");\n        graph.addEdge(\"socks\", \"shoes\");\n        graph.addEdge(\"jacket\",\"\");\n        graph.addEdge(\"pants\", \"belt\", \"shoes\");\n        LinkedList<String> expected = new LinkedList<>();\n        expected.add(\"socks\");\n        expected.add(\"undershorts\");\n        expected.add(\"pants\");\n        expected.add(\"shoes\");\n        expected.add(\"watch\");\n        expected.add(\"shirt\");\n        expected.add(\"belt\");\n        expected.add(\"tie\");\n        expected.add(\"jacket\");\n        assertIterableEquals(expected, TopologicalSort.sort(graph));\n    }\n\n    @Test\n    public void failureTest() {\n\n        /*\n        * Graph example from Geeks For Geeks\n        * https://www.geeksforgeeks.org/tree-back-edge-and-cross-edges-in-dfs-of-graph/\n        * */\n        Graph graph = new Graph();\n        graph.addEdge(\"1\", \"2\", \"3\", \"8\");\n        graph.addEdge(\"2\", \"4\");\n        graph.addEdge(\"3\", \"5\");\n        graph.addEdge(\"4\", \"6\");\n        graph.addEdge(\"5\", \"4\", \"7\", \"8\");\n        graph.addEdge(\"6\", \"2\");\n        graph.addEdge(\"7\", \"\");\n        graph.addEdge(\"8\", \"\");\n        Exception exception = assertThrows(BackEdgeException.class, () -> TopologicalSort.sort(graph));\n        String expected = \"This graph contains a cycle. No linear ordering is possible. \" +\n                \"Back edge: 6 -> 2\";\n        assertEquals(exception.getMessage(), expected);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.sorts.TopologicalSort.BackEdgeException;\nimport com.thealgorithms.sorts.TopologicalSort.Graph;\nimport java.util.LinkedList;\nimport org.junit.jupiter.api.Test;\n\nclass TopologicalSortTest {\n\n    @Test\n    void successTest() {\n        /*\n         * Professor Bumstead example DAG. Each directed edge means that garment u must be put on\n         * before garment v.\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"shirt\", \"tie\", \"belt\");\n        graph.addEdge(\"tie\", \"jacket\");\n        graph.addEdge(\"belt\", \"jacket\");\n        graph.addEdge(\"watch\", \"\");\n        graph.addEdge(\"undershorts\", \"pants\", \"shoes\");\n        graph.addEdge(\"shoes\", \"\");\n        graph.addEdge(\"socks\", \"shoes\");\n        graph.addEdge(\"jacket\", \"\");\n        graph.addEdge(\"pants\", \"belt\", \"shoes\");\n        LinkedList<String> expected = new LinkedList<>();\n        expected.add(\"socks\");\n        expected.add(\"undershorts\");\n        expected.add(\"pants\");\n        expected.add(\"shoes\");\n        expected.add(\"watch\");\n        expected.add(\"shirt\");\n        expected.add(\"belt\");\n        expected.add(\"tie\");\n        expected.add(\"jacket\");\n        assertIterableEquals(expected, TopologicalSort.sort(graph));\n    }\n\n    @Test\n    public void failureTest() {\n        /*\n         * Graph example from Geeks For Geeks\n         * https://www.geeksforgeeks.org/tree-back-edge-and-cross-edges-in-dfs-of-graph/\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"1\", \"2\", \"3\", \"8\");\n        graph.addEdge(\"2\", \"4\");\n        graph.addEdge(\"3\", \"5\");\n        graph.addEdge(\"4\", \"6\");\n        graph.addEdge(\"5\", \"4\", \"7\", \"8\");\n        graph.addEdge(\"6\", \"2\");\n        graph.addEdge(\"7\", \"\");\n        graph.addEdge(\"8\", \"\");\n        Exception exception = assertThrows(\n            BackEdgeException.class,\n            () -> TopologicalSort.sort(graph)\n        );\n        String expected =\n            \"This graph contains a cycle. No linear ordering is possible. \" +\n            \"Back edge: 6 -> 2\";\n        assertEquals(exception.getMessage(), expected);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/WiggleSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/WiggleSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport java.util.Arrays;\n\nimport static com.thealgorithms.maths.Ceil.ceil;\nimport static com.thealgorithms.maths.Floor.floor;\nimport static com.thealgorithms.searches.QuickSelect.select;\n\n/**\n * A wiggle sort implementation based on John L.s' answer in\n * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity\n * Also have a look at: https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity?noredirect=1&lq=1\n * Not all arrays are wiggle-sortable. This algorithm will find some obviously not wiggle-sortable arrays and throw an error,\n * but there are some exceptions that won't be caught, for example [1, 2, 2].\n */\npublic class WiggleSort implements SortAlgorithm {\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return wiggleSort(unsorted);\n    }\n\n    private int mapIndex(int index, int n) {\n        return ((2 * index + 1) % (n | 1));\n    }\n\n    /**\n     * Modified Dutch National Flag Sort. See also: sorts/DutchNationalFlagSort\n     *\n     * @param sortThis array to sort into group \"greater\", \"equal\" and \"smaller\" than median\n     * @param median   defines the groups\n     * @param <T>      extends interface Comparable\n     */\n    private <T extends Comparable<T>> void triColorSort(T[] sortThis, T median) {\n        int n = sortThis.length;\n        int i = 0;\n        int j = 0;\n        int k = n - 1;\n        while (j <= k) {\n            if (0 < sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n));\n                i++;\n                j++;\n            } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n));\n                k--;\n            } else {\n                j++;\n            }\n        }\n    }\n\n    private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) {\n        // find the median using quickSelect (if the result isn't in the array, use the next greater value)\n        T median;\n\n        median = select(Arrays.<T>asList(sortThis), (int) floor(sortThis.length / 2.0));\n\n        int numMedians = 0;\n\n        for (T sortThi : sortThis) {\n            if (0 == sortThi.compareTo(median)) {\n                numMedians++;\n            }\n        }\n        // added condition preventing off-by-one errors for odd arrays.\n        // https://cs.stackexchange.com/questions/150886/how-to-find-wiggle-sortable-arrays-did-i-misunderstand-john-l-s-answer?noredirect=1&lq=1\n        if (sortThis.length % 2 == 1 && numMedians == ceil(sortThis.length / 2.0)) {\n            T smallestValue = select(Arrays.asList(sortThis), 0);\n            if (!(0 == smallestValue.compareTo(median))) {\n                throw new IllegalArgumentException(\"For odd Arrays if the median appears ceil(n/2) times, \" +\n                        \"the median has to be the smallest values in the array.\");\n            }\n        }\n        if (numMedians > ceil(sortThis.length / 2.0)) {\n            throw new IllegalArgumentException(\"No more than half the number of values may be the same.\");\n\n        }\n\n        triColorSort(sortThis, median);\n        return sortThis;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.maths.Ceil.ceil;\nimport static com.thealgorithms.maths.Floor.floor;\nimport static com.thealgorithms.searches.QuickSelect.select;\n\nimport java.util.Arrays;\n\n/**\n * A wiggle sort implementation based on John L.s' answer in\n * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity\n * Also have a look at: https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity?noredirect=1&lq=1\n * Not all arrays are wiggle-sortable. This algorithm will find some obviously not wiggle-sortable arrays and throw an error,\n * but there are some exceptions that won't be caught, for example [1, 2, 2].\n */\npublic class WiggleSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return wiggleSort(unsorted);\n    }\n\n    private int mapIndex(int index, int n) {\n        return ((2 * index + 1) % (n | 1));\n    }\n\n    /**\n     * Modified Dutch National Flag Sort. See also: sorts/DutchNationalFlagSort\n     *\n     * @param sortThis array to sort into group \"greater\", \"equal\" and \"smaller\" than median\n     * @param median   defines the groups\n     * @param <T>      extends interface Comparable\n     */\n    private <T extends Comparable<T>> void triColorSort(\n        T[] sortThis,\n        T median\n    ) {\n        int n = sortThis.length;\n        int i = 0;\n        int j = 0;\n        int k = n - 1;\n        while (j <= k) {\n            if (0 < sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n));\n                i++;\n                j++;\n            } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n));\n                k--;\n            } else {\n                j++;\n            }\n        }\n    }\n\n    private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) {\n        // find the median using quickSelect (if the result isn't in the array, use the next greater value)\n        T median;\n\n        median =\n            select(\n                Arrays.<T>asList(sortThis),\n                (int) floor(sortThis.length / 2.0)\n            );\n\n        int numMedians = 0;\n\n        for (T sortThi : sortThis) {\n            if (0 == sortThi.compareTo(median)) {\n                numMedians++;\n            }\n        }\n        // added condition preventing off-by-one errors for odd arrays.\n        // https://cs.stackexchange.com/questions/150886/how-to-find-wiggle-sortable-arrays-did-i-misunderstand-john-l-s-answer?noredirect=1&lq=1\n        if (\n            sortThis.length % 2 == 1 &&\n            numMedians == ceil(sortThis.length / 2.0)\n        ) {\n            T smallestValue = select(Arrays.asList(sortThis), 0);\n            if (!(0 == smallestValue.compareTo(median))) {\n                throw new IllegalArgumentException(\n                    \"For odd Arrays if the median appears ceil(n/2) times, \" +\n                    \"the median has to be the smallest values in the array.\"\n                );\n            }\n        }\n        if (numMedians > ceil(sortThis.length / 2.0)) {\n            throw new IllegalArgumentException(\n                \"No more than half the number of values may be the same.\"\n            );\n        }\n\n        triColorSort(sortThis, median);\n        return sortThis;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\n\npublic class WiggleSortTest {\n    @Test\n    void WiggleTestNumbersEven(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 3, 4};\n        Integer[] result = {1, 4, 2, 3};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOdd(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 3, 4, 5};\n        Integer[] result = {3, 5, 1, 4, 2};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n\n    }\n\n    @Test\n    void WiggleTestNumbersOddDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {7, 2, 2, 2, 5};\n        Integer[] result = {2, 7, 2, 5, 2};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddMultipleDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 1, 2, 2, 5};\n        Integer[] result = {2, 5, 1, 2, 1};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenMultipleDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 1, 2, 2, 2, 5};\n        Integer[] result = {2, 5, 1, 2, 1, 2};\n        wiggleSort.sort(values);\n        System.out.println(Arrays.toString(values));\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 4, 4};\n        Integer[] result = {1, 4, 2, 4};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestStrings(){\n        WiggleSort wiggleSort = new WiggleSort();\n        String[] values = {\"a\", \"b\", \"d\", \"c\"};\n        String[] result = {\"a\", \"d\", \"b\", \"c\"};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.Test;\n\npublic class WiggleSortTest {\n\n    @Test\n    void WiggleTestNumbersEven() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 2, 3, 4 };\n        Integer[] result = { 1, 4, 2, 3 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOdd() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 2, 3, 4, 5 };\n        Integer[] result = { 3, 5, 1, 4, 2 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 7, 2, 2, 2, 5 };\n        Integer[] result = { 2, 7, 2, 5, 2 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddMultipleDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 1, 2, 2, 5 };\n        Integer[] result = { 2, 5, 1, 2, 1 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenMultipleDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 1, 2, 2, 2, 5 };\n        Integer[] result = { 2, 5, 1, 2, 1, 2 };\n        wiggleSort.sort(values);\n        System.out.println(Arrays.toString(values));\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenDuplicates() {\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = { 1, 2, 4, 4 };\n        Integer[] result = { 1, 4, 2, 4 };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestStrings() {\n        WiggleSort wiggleSort = new WiggleSort();\n        String[] values = { \"a\", \"b\", \"d\", \"c\" };\n        String[] result = { \"a\", \"d\", \"b\", \"c\" };\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Alphabetical.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/AlphabeticalTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Alphabetical order is a system whereby character strings are placed in order\n * based on the position of the characters in the conventional ordering of an\n * alphabet. Wikipedia: https://en.wikipedia.org/wiki/Alphabetical_order\n */\nclass Alphabetical {\n\n    public static void main(String[] args) {\n        assert !isAlphabetical(\"123abc\");\n        assert isAlphabetical(\"aBC\");\n        assert isAlphabetical(\"abc\");\n        assert !isAlphabetical(\"xyzabc\");\n        assert isAlphabetical(\"abcxyz\");\n    }\n\n    /**\n     * Check if a string is alphabetical order or not\n     *\n     * @param s a string\n     * @return {@code true} if given string is alphabetical order, otherwise\n     * {@code false}\n     */\n    public static boolean isAlphabetical(String s) {\n        s = s.toLowerCase();\n        for (int i = 0; i < s.length() - 1; ++i) {\n            if (!Character.isLetter(s.charAt(i)) || !(s.charAt(i) <= s.charAt(i + 1))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Alphabetical order is a system whereby character strings are placed in order\n * based on the position of the characters in the conventional ordering of an\n * alphabet. Wikipedia: https://en.wikipedia.org/wiki/Alphabetical_order\n */\nclass Alphabetical {\n\n    public static void main(String[] args) {\n        assert !isAlphabetical(\"123abc\");\n        assert isAlphabetical(\"aBC\");\n        assert isAlphabetical(\"abc\");\n        assert !isAlphabetical(\"xyzabc\");\n        assert isAlphabetical(\"abcxyz\");\n    }\n\n    /**\n     * Check if a string is alphabetical order or not\n     *\n     * @param s a string\n     * @return {@code true} if given string is alphabetical order, otherwise\n     * {@code false}\n     */\n    public static boolean isAlphabetical(String s) {\n        s = s.toLowerCase();\n        for (int i = 0; i < s.length() - 1; ++i) {\n            if (\n                !Character.isLetter(s.charAt(i)) ||\n                !(s.charAt(i) <= s.charAt(i + 1))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n\npublic class AlphabeticalTest {\n    @Test\n    public void isAlphabetical() {\n        // expected to be true\n        String input1 = \"abcdefghijklmno\";\n        String input2 = \"abcdxxxyzzzz\";\n        String input3 = \"fpw\";\n\n        // expected to be false\n        String input4 = \"123a\";\n        String input5 = \"abcABC\";\n        String input6 = \"abcdefghikjlmno\";\n\n        assertTrue(Alphabetical.isAlphabetical(input1));\n        assertTrue(Alphabetical.isAlphabetical(input2));\n        assertTrue(Alphabetical.isAlphabetical(input3));\n\n        assertFalse(Alphabetical.isAlphabetical(input4));\n        assertFalse(Alphabetical.isAlphabetical(input5));\n        assertFalse(Alphabetical.isAlphabetical(input6));\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AlphabeticalTest {\n\n    @Test\n    public void isAlphabetical() {\n        // expected to be true\n        String input1 = \"abcdefghijklmno\";\n        String input2 = \"abcdxxxyzzzz\";\n        String input3 = \"fpw\";\n\n        // expected to be false\n        String input4 = \"123a\";\n        String input5 = \"abcABC\";\n        String input6 = \"abcdefghikjlmno\";\n\n        assertTrue(Alphabetical.isAlphabetical(input1));\n        assertTrue(Alphabetical.isAlphabetical(input2));\n        assertTrue(Alphabetical.isAlphabetical(input3));\n\n        assertFalse(Alphabetical.isAlphabetical(input4));\n        assertFalse(Alphabetical.isAlphabetical(input5));\n        assertFalse(Alphabetical.isAlphabetical(input6));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/HammingDistanceTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/* In information theory, the Hamming distance between two strings of equal length \nis the number of positions at which the corresponding symbols are different. \nhttps://en.wikipedia.org/wiki/Hamming_distance\n*/\npublic class HammingDistance {\n\n    /**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */\n    public static int calculateHammingDistance(String s1, String s2) throws Exception {\n        if (s1.length() != s2.length()) {\n            throw new Exception(\"String lengths must be equal\");\n        }\n        \n        int stringLength = s1.length();\n        int counter = 0;\n        \n        for (int i = 0; i < stringLength; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/* In information theory, the Hamming distance between two strings of equal length \nis the number of positions at which the corresponding symbols are different. \nhttps://en.wikipedia.org/wiki/Hamming_distance\n*/\npublic class HammingDistance {\n\n    /**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */\n    public static int calculateHammingDistance(String s1, String s2)\n        throws Exception {\n        if (s1.length() != s2.length()) {\n            throw new Exception(\"String lengths must be equal\");\n        }\n\n        int stringLength = s1.length();\n        int counter = 0;\n\n        for (int i = 0; i < stringLength; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class HammingDistanceTest {\n    @Test\n    void testHammingDistance() throws Exception {\n        assertEquals(HammingDistance.calculateHammingDistance(\"\", \"\"), 0);\n        assertEquals(HammingDistance.calculateHammingDistance(\"java\", \"java\"), 0);\n        assertEquals(HammingDistance.calculateHammingDistance(\"karolin\", \"kathrin\"), 3);\n        assertEquals(HammingDistance.calculateHammingDistance(\"kathrin\", \"kerstin\"), 4);\n        assertEquals(HammingDistance.calculateHammingDistance(\"00000\", \"11111\"), 5);\n    }\n\n    @Test\n    void testNotEqualStringLengths() {\n        Exception exception = assertThrows(Exception.class, () -> HammingDistance.calculateHammingDistance(\"ab\", \"abc\"));\n        assertEquals(\"String lengths must be equal\", exception.getMessage());\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    @Test\n    void testHammingDistance() throws Exception {\n        assertEquals(HammingDistance.calculateHammingDistance(\"\", \"\"), 0);\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"java\", \"java\"),\n            0\n        );\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"karolin\", \"kathrin\"),\n            3\n        );\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"kathrin\", \"kerstin\"),\n            4\n        );\n        assertEquals(\n            HammingDistance.calculateHammingDistance(\"00000\", \"11111\"),\n            5\n        );\n    }\n\n    @Test\n    void testNotEqualStringLengths() {\n        Exception exception = assertThrows(\n            Exception.class,\n            () -> HammingDistance.calculateHammingDistance(\"ab\", \"abc\")\n        );\n        assertEquals(\"String lengths must be equal\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Isomorphic.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/IsomorphicTest.java",
        "product_old_content": "package com.thealgorithms.strings;\nimport java.util.*;\n\npublic class Isomorphic {\n  public static boolean checkStrings(String s, String t) {\n    if(s.length() != t.length()){\n        return false;\n    }\n\n    // To mark the characters of string using MAP\n    // character of first string as KEY and another as VALUE\n    // now check occurence by keeping the track with SET data structure\n    Map<Character, Character> characterMap = new HashMap<Character, Character>();\n    Set<Character> trackUinqueCharacter = new HashSet<Character>();\n    \n    for(int i=0; i<s.length(); i++){\n        if(characterMap.containsKey(s.charAt(i))){\n            if(t.charAt(i) != characterMap.get(s.charAt(i))){\n                return false;\n            }\n        }\n        else{\n            if(trackUinqueCharacter.contains(t.charAt(i))){\n                return false;\n            }\n            \n            characterMap.put(s.charAt(i), t.charAt(i));\n        }\n        trackUinqueCharacter.add(t.charAt(i));\n    }\n    return true;\n  }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.*;\n\npublic class Isomorphic {\n\n    public static boolean checkStrings(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n\n        // To mark the characters of string using MAP\n        // character of first string as KEY and another as VALUE\n        // now check occurence by keeping the track with SET data structure\n        Map<Character, Character> characterMap = new HashMap<Character, Character>();\n        Set<Character> trackUinqueCharacter = new HashSet<Character>();\n\n        for (int i = 0; i < s.length(); i++) {\n            if (characterMap.containsKey(s.charAt(i))) {\n                if (t.charAt(i) != characterMap.get(s.charAt(i))) {\n                    return false;\n                }\n            } else {\n                if (trackUinqueCharacter.contains(t.charAt(i))) {\n                    return false;\n                }\n\n                characterMap.put(s.charAt(i), t.charAt(i));\n            }\n            trackUinqueCharacter.add(t.charAt(i));\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\n\npublic class IsomorphicTest {\n\n    @Test\n    public static void main(String[] args) {\n\n    String str1 = \"abbbbaac\";\n    String str2 = \"kffffkkd\";\n\n    String str3 = \"xyxyxy\";\n    String str4 = \"bnbnbn\";\n\n    String str5 = \"ghjknnmm\";\n    String str6 = \"wertpopo\";\n\n    String str7 = \"aaammmnnn\";\n    String str8 = \"ggghhhbbj\";\n\n    Isomorphic isomorphic = new Isomorphic();\n\n    assertTrue(isomorphic.checkStrings(str1, str2));\n    assertTrue(isomorphic.checkStrings(str3, str4));\n    assertFalse(isomorphic.checkStrings(str5, str6));\n    assertFalse(isomorphic.checkStrings(str7, str8));\n  }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\npublic class IsomorphicTest {\n\n    @Test\n    public static void main(String[] args) {\n        String str1 = \"abbbbaac\";\n        String str2 = \"kffffkkd\";\n\n        String str3 = \"xyxyxy\";\n        String str4 = \"bnbnbn\";\n\n        String str5 = \"ghjknnmm\";\n        String str6 = \"wertpopo\";\n\n        String str7 = \"aaammmnnn\";\n        String str8 = \"ggghhhbbj\";\n\n        Isomorphic isomorphic = new Isomorphic();\n\n        assertTrue(isomorphic.checkStrings(str1, str2));\n        assertTrue(isomorphic.checkStrings(str3, str4));\n        assertFalse(isomorphic.checkStrings(str5, str6));\n        assertFalse(isomorphic.checkStrings(str7, str8));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Palindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PalindromeTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] palindromes = {null, \"\", \"aba\", \"123321\"};\n        for (String s : palindromes) {\n            assert isPalindrome(s) && isPalindromeRecursion(s) && isPalindrome1(s);\n        }\n\n        String[] notPalindromes = {\"abb\", \"abc\", \"abc123\"};\n        for (String s : notPalindromes) {\n            assert !isPalindrome(s) && !isPalindromeRecursion(s) && !isPalindrome1(s);\n        }\n    }\n\n    /**\n     * Check if a string is palindrome string or not\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return (s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString());\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindrome(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not another way\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome1(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Palindrome\n */\nclass Palindrome {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] palindromes = { null, \"\", \"aba\", \"123321\" };\n        for (String s : palindromes) {\n            assert isPalindrome(s) &&\n            isPalindromeRecursion(s) &&\n            isPalindrome1(s);\n        }\n\n        String[] notPalindromes = { \"abb\", \"abc\", \"abc123\" };\n        for (String s : notPalindromes) {\n            assert !isPalindrome(s) &&\n            !isPalindromeRecursion(s) &&\n            !isPalindrome1(s);\n        }\n    }\n\n    /**\n     * Check if a string is palindrome string or not\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome(String s) {\n        return (\n            (s == null || s.length() <= 1) ||\n            s.equals(new StringBuilder(s).reverse().toString())\n        );\n    }\n\n    /**\n     * Check if a string is palindrome string or not using recursion\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindromeRecursion(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n\n        if (s.charAt(0) != s.charAt(s.length() - 1)) {\n            return false;\n        }\n\n        return isPalindrome(s.substring(1, s.length() - 1));\n    }\n\n    /**\n     * Check if a string is palindrome string or not another way\n     *\n     * @param s a string to check\n     * @return {@code true} if given string is palindrome, otherwise\n     * {@code false}\n     */\n    public static boolean isPalindrome1(String s) {\n        if (s == null || s.length() <= 1) {\n            return true;\n        }\n        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n            if (s.charAt(i) != s.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n    @Test\n    public void palindrome() {\n        String input1 = \"kayak\";\n        String input2 = \"kayaks\";\n        Assertions.assertTrue(Palindrome.isPalindrome(input1));\n        Assertions.assertFalse(Palindrome.isPalindrome(input2));\n        Assertions.assertTrue(Palindrome.isPalindromeRecursion(input1));\n        Assertions.assertFalse(Palindrome.isPalindromeRecursion(input2));\n        Assertions.assertTrue(Palindrome.isPalindrome1(input1));\n        Assertions.assertFalse(Palindrome.isPalindrome1(input2));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class PalindromeTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"kayak\";\n        String input2 = \"kayaks\";\n        Assertions.assertTrue(Palindrome.isPalindrome(input1));\n        Assertions.assertFalse(Palindrome.isPalindrome(input2));\n        Assertions.assertTrue(Palindrome.isPalindromeRecursion(input1));\n        Assertions.assertFalse(Palindrome.isPalindromeRecursion(input2));\n        Assertions.assertTrue(Palindrome.isPalindrome1(input1));\n        Assertions.assertFalse(Palindrome.isPalindrome1(input2));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Upper.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/UpperTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\npublic class Upper {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"};\n        for (String s : strings) {\n            assert toUpperCase(s).equals(s.toUpperCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to uppercase.\n     */\n    public static String toUpperCase(String s) {\n        if (s == null || \"\".equals(s)) {\n            return s;\n        }\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {\n                values[i] = Character.toUpperCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\npublic class Upper {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = { \"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\" };\n        for (String s : strings) {\n            assert toUpperCase(s).equals(s.toUpperCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to uppercase.\n     */\n    public static String toUpperCase(String s) {\n        if (s == null || \"\".equals(s)) {\n            return s;\n        }\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (\n                Character.isLetter(values[i]) &&\n                Character.isLowerCase(values[i])\n            ) {\n                values[i] = Character.toUpperCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class UpperTest {\n    @Test\n    public void toUpperCase() {\n        String input1 = \"hello world\";\n        String input2 = \"hElLo WoRlD\";\n        String input3 = \"HELLO WORLD\";\n        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input1));\n        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input2));\n        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input3));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class UpperTest {\n\n    @Test\n    public void toUpperCase() {\n        String input1 = \"hello world\";\n        String input2 = \"hElLo WoRlD\";\n        String input3 = \"HELLO WORLD\";\n        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input1));\n        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input2));\n        assertEquals(\"HELLO WORLD\", Upper.toUpperCase(input3));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/longestNonRepeativeSubstring.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/longestNonRepeativeSubstringTest.java",
        "product_old_content": "package com.thealgorithms.strings ;\nimport java.util.HashMap ;\nclass longestNonRepeativeSubstring {\n\n    public static int lengthOfLongestSubstring(String s) {\n    \n        int max = 0 , start = 0 , i = 0 ;\n        HashMap< Character , Integer > map = new HashMap<>() ;\n    \n        while ( i < s.length() ) {\n\n            char temp = s.charAt( i ) ;\n\n            // adding key to map if not present\n            if ( ! map.containsKey( temp ) )\n                map.put( temp , 0 ) ;\n\n            // checking if the first value is the dublicate value\n            else if ( s.charAt( start ) == temp )\n                start++ ;\n\n            // checking if the previous value is dublicate value\n            else if ( s.charAt( i - 1 )  == temp ) {\n                if ( max < map.size() ) max = map.size() ;\n                map = new HashMap<>() ;\n                start = i ;\n                i-- ;\n            }\n\n            // last possible place where dublicate value can be is between start and i\n            else {\n                if ( max < map.size() ) max = map.size() ;\n                while ( s.charAt( start ) != temp ) {\n                    map.remove( s.charAt( start ) ) ;\n                    start++ ;\n                }\n                start++ ;\n            }\n\n            i++ ;\n\n        }\n        if ( max < map.size() ) max = map.size() ;\n        return max ;\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.HashMap;\n\nclass longestNonRepeativeSubstring {\n\n    public static int lengthOfLongestSubstring(String s) {\n        int max = 0, start = 0, i = 0;\n        HashMap<Character, Integer> map = new HashMap<>();\n\n        while (i < s.length()) {\n            char temp = s.charAt(i);\n\n            // adding key to map if not present\n            if (!map.containsKey(temp)) map.put(temp, 0);\n            // checking if the first value is the dublicate value\n            else if (s.charAt(start) == temp) start++;\n            // checking if the previous value is dublicate value\n            else if (s.charAt(i - 1) == temp) {\n                if (max < map.size()) max = map.size();\n                map = new HashMap<>();\n                start = i;\n                i--;\n            }\n            // last possible place where dublicate value can be is between start and i\n            else {\n                if (max < map.size()) max = map.size();\n                while (s.charAt(start) != temp) {\n                    map.remove(s.charAt(start));\n                    start++;\n                }\n                start++;\n            }\n\n            i++;\n        }\n        if (max < map.size()) max = map.size();\n        return max;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class longestNonRepeativeSubstringTest {\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorld\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals( longestNonRepeativeSubstring.lengthOfLongestSubstring( input1 ) , 5 ) ;\n        Assertions.assertEquals( longestNonRepeativeSubstring.lengthOfLongestSubstring( input2 ) , 9 ) ;\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class longestNonRepeativeSubstringTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorld\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals(\n            longestNonRepeativeSubstring.lengthOfLongestSubstring(input1),\n            5\n        );\n        Assertions.assertEquals(\n            longestNonRepeativeSubstring.lengthOfLongestSubstring(input2),\n            9\n        );\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/zigZagPattern/zigZagPattern.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/zigZagPattern/zigZagPatternTest.java",
        "product_old_content": "package com.thealgorithms.strings.zigZagPattern;\nclass zigZagPattern {\n\n    public static String encode(String s, int numRows) {\n        if ( numRows < 2 || s.length() < numRows ) return s ;\n        int start = 0 , index = 0 , height = 1 , depth = numRows ;\n        char[] zigZagedArray = new char[ s.length() ] ;\n        while ( depth != 0 ) {\n            int pointer = start , height_space = 2 + ( ( height - 2 ) * 2 ) , depth_space = 2 + ( ( depth - 2 ) * 2 ) ;\n            boolean bool = true ;\n            while ( pointer < s.length() ) {\n                zigZagedArray[index++] = s.charAt( pointer ) ;\n                if ( height_space == 0 ) pointer += depth_space ;\n                else if ( depth_space == 0 ) pointer += height_space ;\n                else if ( bool ) {\n                    pointer += depth_space ;\n                    bool = false ;\n                } else {\n                    pointer += height_space ;\n                    bool = true ;\n                }\n            }\n            height++ ;\n            depth-- ;\n            start++ ;\n        }\n        return new String( zigZagedArray ) ;\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.strings.zigZagPattern;\n\nclass zigZagPattern {\n\n    public static String encode(String s, int numRows) {\n        if (numRows < 2 || s.length() < numRows) return s;\n        int start = 0, index = 0, height = 1, depth = numRows;\n        char[] zigZagedArray = new char[s.length()];\n        while (depth != 0) {\n            int pointer = start, height_space =\n                2 + ((height - 2) * 2), depth_space = 2 + ((depth - 2) * 2);\n            boolean bool = true;\n            while (pointer < s.length()) {\n                zigZagedArray[index++] = s.charAt(pointer);\n                if (height_space == 0) pointer += depth_space; else if (\n                    depth_space == 0\n                ) pointer += height_space; else if (bool) {\n                    pointer += depth_space;\n                    bool = false;\n                } else {\n                    pointer += height_space;\n                    bool = true;\n                }\n            }\n            height++;\n            depth--;\n            start++;\n        }\n        return new String(zigZagedArray);\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings.zigZagPattern;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class zigZagPatternTest {\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorldFromJava\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals( zigZagPattern.encode( input1 , 4 ) , \"HooeWrrmalolFJvlda\" ) ;\n        Assertions.assertEquals( zigZagPattern.encode( input2 , 4 ) , \"jAaLgasPrmgaaevIrgmnnuaoig\" ) ;\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings.zigZagPattern;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class zigZagPatternTest {\n\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorldFromJava\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals(\n            zigZagPattern.encode(input1, 4),\n            \"HooeWrrmalolFJvlda\"\n        );\n        Assertions.assertEquals(\n            zigZagPattern.encode(input2, 4),\n            \"jAaLgasPrmgaaevIrgmnnuaoig\"\n        );\n    }\n}"
    },
    {
        "product_commit": "e4eb99ff189e6ec9db1640fbca1b875d36daa9b0",
        "test_commit": "e4eb99ff189e6ec9db1640fbca1b875d36daa9b0",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/a5/LFSR.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/a5/LFSRTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.ciphers.a5;\n\nimport java.util.BitSet;\n\npublic class LFSR implements BaseLFSR {\n    private final BitSet register;\n    private final int length;\n    private final int clockBitIndex;\n    private final int[] tappingBitsIndices;\n\n    public LFSR( int length, int clockBitIndex, int[] tappingBitsIndices ) {\n        this.length = length;\n        this.clockBitIndex = clockBitIndex;\n        this.tappingBitsIndices = tappingBitsIndices;\n        register = new BitSet( length );\n    }\n\n    @Override\n    public void initialize( BitSet sessionKey, BitSet frameCounter ) {\n        register.clear();\n        clock( sessionKey, SESSION_KEY_LENGTH );\n        clock( frameCounter, FRAME_COUNTER_LENGTH );\n    }\n\n    private void clock( BitSet key, int keyLength ) {\n        // We start from reverse because LFSR 0 index is the left most bit\n        // while key 0 index is right most bit, so we reverse it\n        for ( int i = keyLength - 1; i >= 0; --i ) {\n            var newBit = key.get( i ) ^ xorTappingBits();\n            pushBit( newBit );\n        }\n    }\n\n    @Override\n    public boolean clock() {\n        return pushBit( xorTappingBits() );\n    }\n\n    public boolean getClockBit() {\n        return register.get( clockBitIndex );\n    }\n\n    public boolean get( int bitIndex ) {\n        return register.get( bitIndex );\n    }\n\n    public boolean getLastBit() {\n        return register.get( length - 1 );\n    }\n\n    private boolean xorTappingBits() {\n        boolean result = false;\n        for ( int i : tappingBitsIndices ) {\n            result ^= register.get( i );\n        }\n        return result;\n    }\n\n    private boolean pushBit( boolean bit ) {\n        boolean discardedBit = rightShift();\n        register.set( 0, bit );\n        return discardedBit;\n    }\n\n    private boolean rightShift() {\n        boolean discardedBit = get( length - 1 );\n        for ( int i = length - 1; i > 0; --i ) {\n            register.set( i, get( i - 1 ) );\n        }\n        register.set( 0, false );\n        return discardedBit;\n    }\n\n    @Override\n    public String toString() {\n        return register.toString();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers.a5;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.BitSet;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\n// Basic tests for sanity check\nclass LFSRTest {\n    // Represents 0100 1110 0010 1111 0100 1101 0111 1100 0001 1110 1011 1000 1000 1011 0011 1010\n    // But we start reverse way because bitset starts from most right (1010)\n    byte[] sessionKeyBytes = { 58, (byte) 139, (byte) 184, 30, 124, 77, 47, 78 };\n\n    // Represents 11 1010 1011 0011 1100 1011\n    byte[] frameCounterBytes = { (byte) 203, (byte) 179, 58 };\n\n    @Test\n    void initialize() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        BitSet expected = new BitSet( 19 );\n        expected.set( 0 );\n        expected.set( 1 );\n        expected.set( 3 );\n        expected.set( 4 );\n        expected.set( 5 );\n        expected.set( 7 );\n        expected.set( 9 );\n        expected.set( 10 );\n        expected.set( 11 );\n        expected.set( 12 );\n        expected.set( 13 );\n        expected.set( 15 );\n        expected.set( 16 );\n        expected.set( 17 );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n        lfsr0.initialize( sessionKey, frameCounter );\n        assertEquals( expected.toString(), lfsr0.toString() );\n    }\n\n    @Test\n    void clock() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n        lfsr0.initialize( sessionKey, frameCounter );\n\n        BitSet expected = new BitSet( 19 );\n        expected.set( 0 );\n        expected.set( 1 );\n        expected.set( 2 );\n        expected.set( 4 );\n        expected.set( 5 );\n        expected.set( 6 );\n        expected.set( 8 );\n        expected.set( 10 );\n        expected.set( 11 );\n        expected.set( 12 );\n        expected.set( 13 );\n        expected.set( 14 );\n        expected.set( 16 );\n        expected.set( 17 );\n        expected.set( 18 );\n\n        lfsr0.clock();\n        assertEquals( expected.toString(), lfsr0.toString() );\n    }\n\n    @Test\n    void getClockBit() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n\n        assertFalse( lfsr0.getClockBit() );\n\n        lfsr0.initialize( sessionKey, frameCounter );\n\n        assertFalse( lfsr0.getClockBit() );\n    }\n}"
    },
    {
        "product_commit": "8ca571d8870b20f1a15ca355bf612385291b9c5c",
        "test_commit": "8ca571d8870b20f1a15ca355bf612385291b9c5c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/CollatzConjecture.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/CollatzConjectureTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * <a href=\"https://en.wikipedia.org/wiki/Collatz_conjecture\">...</a>\n */\npublic class CollatzConjecture {\n\n    /**\n     * Calculate the next number of the sequence.\n     *\n     * @param n current number of the sequence\n     * @return next number of the sequence\n     */\n    public int nextNumber(final int n) {\n        if (n % 2 == 0) {\n            return n / 2;\n        }\n        return 3 * n + 1;\n    }\n\n    /**\n     * Calculate the Collatz sequence of any natural number.\n     *\n     * @param firstNumber starting number of the sequence\n     * @return sequence of the Collatz Conjecture\n     */\n    public List<Integer> collatzConjecture(int firstNumber) {\n        if (firstNumber < 1) {\n            throw new IllegalArgumentException(\"Must be a natural number\");\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        result.add(firstNumber);\n        while (firstNumber != 1) {\n            result.add(nextNumber(firstNumber));\n            firstNumber = nextNumber(firstNumber);\n        }\n        return result;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CollatzConjectureTest {\n\n    static CollatzConjecture cConjecture;\n\n    @BeforeAll\n    static void setUp() {\n        cConjecture = new CollatzConjecture();\n    }\n\n    @Test\n    void nextNumberFromEvenNumber() {\n        assertEquals(25, cConjecture.nextNumber(50));\n    }\n\n    @Test\n    void nextNumberFromOddNumber() {\n        assertEquals(154, cConjecture.nextNumber(51));\n    }\n\n    @Test\n    void collatzConjecture() {\n        final List<Integer> expected = List.of(35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1);\n        assertIterableEquals(expected, cConjecture.collatzConjecture(35));\n    }\n\n    @Test\n    void sequenceOfNotNaturalFirstNumber() {\n        assertThrows(IllegalArgumentException.class, () -> cConjecture.collatzConjecture(0));\n        assertThrows(IllegalArgumentException.class, () -> cConjecture.collatzConjecture(-1));\n    }\n}"
    },
    {
        "product_commit": "ea8e0463ef83293b32a6820f64173073e557596e",
        "test_commit": "ea8e0463ef83293b32a6820f64173073e557596e",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LiouvilleLambdaFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LiouvilleLambdaFunctionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for liouville lambda function\n * For any positive integer n, define \u03bb(n) as the sum of the primitive nth roots of unity. \n * It has values in {\u22121, 1} depending on the factorization of n into prime factors:\n *   \u03bb(n) = +1 if n is a positive integer with an even number of prime factors.\n *   \u03bb(n) = \u22121 if n is a positive integer with an odd number of prime factors.\n * Wikipedia: https://en.wikipedia.org/wiki/Liouville_function\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class LiouvilleLambdaFunction {\n\n\t/**\n\t * This method returns \u03bb(n) of given number n\n\t *\n\t * @param number Integer value which \u03bb(n) is to be calculated \n\t * @return  1 when number has even number of prime factors\n\t *         -1 when number has odd number of prime factors\n\t * @throws IllegalArgumentException when number is negative\n\t */\n\tstatic int liouvilleLambda(int number) {\n\t\tif(number <= 0) {\n\t\t\t//throw exception when number is less than or is zero\n\t\t\tthrow new IllegalArgumentException(\"Number must be greater than zero.\");\n\t\t}\n\n\t\t//return 1 if size of prime factor list is even, -1 otherwise\n\t\treturn PrimeFactorization.pfactors(number).size() % 2 == 0 ? 1 : -1;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass LiouvilleLambdaFunctionTest {\n\n\t@Test\n\tvoid testLiouvilleLambdaMustThrowExceptionIfNumberIsZero() {\n\t\t//given\n\t\tint number = 0;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tLiouvilleLambdaFunction.liouvilleLambda(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustThrowExceptionIfNumberIsNegative() {\n\t\t//given\n\t\tint number = -1;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tLiouvilleLambdaFunction.liouvilleLambda(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustReturnNegativeOne() {\n\t\t//given\n\t\tint number = 11;\n\t\tint expectedOutput = -1;\n\n\t\t//when\n\t\tint actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n\t\t//then\n\t\tassertEquals(expectedOutput, actualOutput);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustReturnPositiveOne() {\n\t\t//given\n\t\tint number = 10;\n\t\tint expectedOutput = 1;\n\n\t\t//when\n\t\tint actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n\t\t//then\n\t\tassertEquals(expectedOutput, actualOutput);\n\t}\n}"
    },
    {
        "product_commit": "2fbb1d64029b6a842cc1d70cdfaed3800d69bf03",
        "test_commit": "2fbb1d64029b6a842cc1d70cdfaed3800d69bf03",
        "product_file_path": "src/main/java/com/thealgorithms/others/cn/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/cn/HammingDistanceTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n\n\n    public int getHammingDistanceBetweenBits(String senderBits, String receiverBits) {\n\n        if(senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\"Sender and Receiver bits should be same\");\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for(int i = 0; i < senderData.length; i++){\n           totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if(totalErrorBitCount == 0){\n            System.out.println(\"No Error bit in data segments\");\n        } else{\n            System.out.println(\"Total Error bit count \"+totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n     void initialize(){\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits(){\n         String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n/*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength(){\n       String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n\n    @Test\n    public void checkForSameBits(){\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits(){\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits(){\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () ->{\n            int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n\n    }\n\n    @Test\n    public void checkForLongDataBitsSame(){\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n\n\n}"
    },
    {
        "product_commit": "07a5531f1a7b22782c2ca899550c7a6f52154343",
        "test_commit": "07a5531f1a7b22782c2ca899550c7a6f52154343",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PrimeFactorization.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PrimeFactorizationTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Scanner;\n\npublic class PrimeFactorization {\n\n    public static void main(String[] args) {\n        System.out.println(\"## all prime factors ##\");\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter a number: \");\n        int n = scanner.nextInt();\n        System.out.print((\"printing factors of \" + n + \" : \"));\n        pfactors(n);\n        scanner.close();\n    }\n\n    public static void pfactors(int n) {\n\n        while (n % 2 == 0) {\n            System.out.print(2 + \" \");\n            n /= 2;\n        }\n\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                System.out.print(i + \" \");\n                n /= i;\n            }\n        }\n\n        if (n > 2) {\n            System.out.print(n);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Authors: \n * (1) Aitor Fidalgo S\u00e1nchez (https://github.com/aitorfi) \n * (2) Akshay Dubey (https://github.com/itsAkshayDubey)\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PrimeFactorization {\n\n\tpublic static List<Integer> pfactors(int n) {\n\t\t\n\t\tList<Integer> primeFactors = new ArrayList<>();\n\n\t\tif (n == 0) {\n\t\t\treturn primeFactors;\n\t\t}\n\n\t\twhile (n % 2 == 0) {\n\t\t\tprimeFactors.add(2);\n\t\t\tn /= 2;\n\t\t}\n\n\t\tfor (int i = 3; i <= Math.sqrt(n); i += 2) {\n\t\t\twhile (n % i == 0) {\n\t\t\t\tprimeFactors.add(i);\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\n\t\tif (n > 2) {\n\t\t\tprimeFactors.add(n);\n\t\t}\n\t\treturn primeFactors;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nclass PrimeFactorizationTest {\n\n\t@Test\n\tvoid testpFactorsMustReturnEmptyList() {\n\t\t//given\n\t\tint n = 0; \n\t\t\n\t\t//then\n\t\tassertTrue(PrimeFactorization.pfactors(n).isEmpty());\n\t}\n\t\n\t@Test\n\tvoid testpFactorsMustReturnNonEmptyList() {\n\t\t//given\n\t\tint n = 198;\n\t\tint expectedListSize = 4;\n\t\t\n\t\t//when\n\t\tList<Integer> actualResultList = PrimeFactorization.pfactors(n);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedListSize, actualResultList.size());\n\t\tassertEquals(2, actualResultList.get(0));\n\t\tassertEquals(3, actualResultList.get(1));\n\t\tassertEquals(3, actualResultList.get(2));\n\t\tassertEquals(11, actualResultList.get(3));\n\t}\n}"
    },
    {
        "product_commit": "d56eaa58af12ea54c4db7a974074c19f886bc332",
        "test_commit": "d56eaa58af12ea54c4db7a974074c19f886bc332",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/LRUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/LRUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Least recently used (LRU)\n * <p>\n * Discards the least recently used items first. This algorithm requires keeping\n * track of what was used when, which is expensive if one wants to make sure the\n * algorithm always discards the least recently used item.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class LRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public LRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    public LRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        Entry<K, V> evicted = head;\n        head = evicted.getNextEntry();\n        head.setPreEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveNodeToLast(entry);\n        return entry.getValue();\n    }\n\n    private void moveNodeToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> existingEntry = data.get(key);\n            existingEntry.setValue(value);\n            moveNodeToLast(existingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        final LRUCache<String, Integer> cache = new LRUCache<>(2);\n        cache.put(\"Key1\", 1);\n        cache.put(\"Key2\", 2);\n        cache.put(\"Key3\", 3);\n        cache.put(\"Key4\", 4);\n        System.out.println(\"getValue(Key1): \" + cache.get(\"Key1\"));\n        System.out.println(\"getValue(Key2): \" + cache.get(\"Key2\"));\n        System.out.println(\"getValue(Key3): \" + cache.get(\"Key3\"));\n        System.out.println(\"getValue(Key4): \" + cache.get(\"Key4\"));\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Least recently used (LRU)\n * <p>\n * Discards the least recently used items first. This algorithm requires keeping\n * track of what was used when, which is expensive if one wants to make sure the\n * algorithm always discards the least recently used item.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class LRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public LRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    public LRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        Entry<K, V> evicted = head;\n        head = evicted.getNextEntry();\n        head.setPreEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveNodeToLast(entry);\n        return entry.getValue();\n    }\n\n    private void moveNodeToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> existingEntry = data.get(key);\n            existingEntry.setValue(value);\n            moveNodeToLast(existingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        LRUCache<Integer, Integer> lruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        LRUCache<String, String> lruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}"
    },
    {
        "product_commit": "d56eaa58af12ea54c4db7a974074c19f886bc332",
        "test_commit": "d56eaa58af12ea54c4db7a974074c19f886bc332",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/MRUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/MRUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Most recently used (MRU)\n * <p>\n * In contrast to Least Recently Used (LRU), MRU discards the most recently used\n * items first.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Most_recently_used_(MRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class MRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public MRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        final Entry<K, V> evicted = this.tail;\n        tail = evicted.getPreEntry();\n        tail.setNextEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    public MRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveEntryToLast(entry);\n        return entry.getValue();\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> exitingEntry = data.get(key);\n            exitingEntry.setValue(value);\n            moveEntryToLast(exitingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    private void moveEntryToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        final MRUCache<String, Integer> cache = new MRUCache<>(2);\n        cache.put(\"Key1\", 1);\n        cache.put(\"Key2\", 2);\n        cache.put(\"Key3\", 3);\n        cache.put(\"Key4\", 4);\n        System.out.println(\"getValue(Key1): \" + cache.get(\"Key1\"));\n        System.out.println(\"getValue(Key2): \" + cache.get(\"Key2\"));\n        System.out.println(\"getValue(Key3): \" + cache.get(\"Key3\"));\n        System.out.println(\"getValue(Key4): \" + cache.get(\"Key4\"));\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Most recently used (MRU)\n * <p>\n * In contrast to Least Recently Used (LRU), MRU discards the most recently used\n * items first.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Most_recently_used_(MRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class MRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public MRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        final Entry<K, V> evicted = this.tail;\n        tail = evicted.getPreEntry();\n        tail.setNextEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    public MRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveEntryToLast(entry);\n        return entry.getValue();\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> exitingEntry = data.get(key);\n            exitingEntry.setValue(value);\n            moveEntryToLast(exitingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    private void moveEntryToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class MRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        MRUCache<Integer, Integer> lruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        MRUCache<String, String> lruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}"
    },
    {
        "product_commit": "a2dd154ad65fc1199d97d793afb4fe0082a8db67",
        "test_commit": "a2dd154ad65fc1199d97d793afb4fe0082a8db67",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BubbleSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BubbleSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass BubbleSort implements SortAlgorithm {\n\n    /**\n     * Implements generic bubble sort algorithm.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the type of elements in the array.\n     * @return the sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1, size = array.length; i < size; ++i) {\n            boolean swapped = false;\n            for (int j = 0; j < size - i; ++j) {\n                if (greater(array[j], array[j + 1])) {\n                    swap(array, j, j + 1);\n                    swapped = true;\n                }\n            }\n            if (!swapped) {\n                break;\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        BubbleSort bubbleSort = new BubbleSort();\n        bubbleSort.sort(integers);\n\n        for (int i = 0; i < integers.length - 1; ++i) {\n            assert integers[i] <= integers[i + 1];\n        }\n        print(integers);\n        /* output: [1, 4, 6, 9, 12, 23, 54, 78, 231] */\n\n        String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        bubbleSort.sort(strings);\n        for (int i = 0; i < strings.length - 1; i++) {\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\n        }\n        print(bubbleSort.sort(strings));\n        /* output: [a, b, c, d, e] */\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass BubbleSort implements SortAlgorithm {\n\n    /**\n     * Implements generic bubble sort algorithm.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the type of elements in the array.\n     * @return the sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1, size = array.length; i < size; ++i) {\n            boolean swapped = false;\n            for (int j = 0; j < size - i; ++j) {\n                if (greater(array[j], array[j + 1])) {\n                    swap(array, j, j + 1);\n                    swapped = true;\n                }\n            }\n            if (!swapped) {\n                break;\n            }\n        }\n        return array;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Aitor Fidalgo (https://github.com/aitorfi)\n * @see BubbleSort\n */\npublic class BubbleSortTest {\n    private BubbleSort bubbleSort = new BubbleSort();\n\n    @Test\n    public void bubbleSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortSingleIntegerElementArray() {\n        Integer[] inputArray = {4};\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {4};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortSingleStringElementArray() {\n        String[] inputArray = {\"s\"};\n        String[] outputArray = bubbleSort.sort(inputArray);\n        String[] expectedOutput = {\"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortIntegerArray() {\n        Integer[] inputArray = {4, 23, -6, 78, 1, 54, 23, -6, -231, 9, 12};\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {-231, -6, -6, 1, 4, 9, 12, 23, 23, 54, 78};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortStringArray() {\n        String[] inputArray = {\"cbf\", \"auk\", \"\u00f3\", \"(b\", \"a\", \")\", \"au\", \"\u00e1\", \"cba\", \"auk\", \"(a\", \"bhy\", \"cba\"};\n        String[] outputArray = bubbleSort.sort(inputArray);\n        String[] expectedOutput = {\"(a\", \"(b\", \")\", \"a\", \"au\", \"auk\", \"auk\", \"bhy\", \"cba\", \"cba\", \"cbf\", \"\u00e1\", \"\u00f3\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "a41656a31130f74634e88b9c2a9f747827d0dbb2",
        "test_commit": "a41656a31130f74634e88b9c2a9f747827d0dbb2",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PollardRho.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PollardRhoTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for pollard rho algorithm\n * The algorithm is used to factorize a number n = pq,\n * where p is a non-trivial factor. \n * Pollard's rho algorithm is an algorithm for integer factorization\n * and it takes as its inputs n, the integer to be factored; \n * and g(x), a polynomial in x computed modulo n.\n * In the original algorithm, g(x) = ((x ^ 2) \u2212 1) mod n,\n * but nowadays it is more common to use g(x) = ((x ^ 2) + 1 ) mod n. \n * The output is either a non-trivial factor of n, or failure.\n * It performs the following steps:\n *     x \u2190 2\n *     y \u2190 2\n *     d \u2190 1\n\n *     while d = 1:\n *         x \u2190 g(x)\n *         y \u2190 g(g(y))\n *         d \u2190 gcd(|x - y|, n)\n\n *     if d = n: \n *         return failure\n *     else:\n *         return d\n\n * Here x and y corresponds to xi and xj in the previous section. \n * Note that this algorithm may fail to find a nontrivial factor even when n is composite.\n * In that case, the method can be tried again, using a starting value other than 2 or a different g(x)\n * \n * Wikipedia: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\npublic class PollardRho {\n\t\n\t/**\n\t * This method returns a polynomial in x computed modulo n\n\t *\n\t * @param base Integer base of the polynomial\n\t * @param modulus Integer is value which is to be used to perform modulo operation over the polynomial \n\t * @return Integer (((base * base) - 1) % modulus)\n\t */\n\tstatic int g(int base,int modulus) {\n\t\treturn ((base * base) - 1) % modulus;\n\t}\n\t\n\t/**\n\t * This method returns a non-trivial factor of given integer number  \n\t *\n\t * @param number Integer is a integer value whose non-trivial factor is to be found\n\t * @return Integer non-trivial factor of number\n\t * @throws RuntimeException object if GCD of given number cannot be found\n\t */\n\tstatic int pollardRho(int number) {\n\t\tint x = 2, y = 2, d = 1;\n\t\twhile(d == 1) {\n\t\t\t//tortoise move\n\t\t\tx = g(x, number);\n\t\t\t\n\t\t\t//hare move\n\t\t\ty = g(g(y, number), number);\n\t\t\t\n\t\t\t//check GCD of |x-y| and number\n\t\t\td = GCD.gcd(Math.abs(x - y), number);\n\t\t}\n\t\tif(d == number) {\n\t\t\tthrow new RuntimeException(\"GCD cannot be found.\");\n\t\t}\n\t\treturn d;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass PollardRhoTest {\n\n\t@Test\n\tvoid testPollardRhoForNumber315MustReturn5() {\n\t\t//given\n\t\tint number = 315;\n\t\tint expectedResult = 5;\n\n\t\t//when\n\t\tint actualResult = PollardRho.pollardRho(number);\n\n\t\t//then\n\t\tassertEquals(expectedResult, actualResult);\n\t}\n\n\t@Test\n\tvoid testPollardRhoForNumber187MustReturn11() {\n\t\t//given\n\t\tint number = 187;\n\t\tint expectedResult = 11;\n\n\t\t//when\n\t\tint actualResult = PollardRho.pollardRho(number);\n\n\t\t//then\n\t\tassertEquals(expectedResult, actualResult);\n\t}\n\n\t@Test\n\tvoid testPollardRhoForNumber239MustThrowException() {\n\t\t//given\n\t\tint number = 239;\n\t\tString expectedMessage = \"GCD cannot be found.\";\n\n\t\t//when\n\t\tException exception = assertThrows(RuntimeException.class, () -> {\n\t\t\tPollardRho.pollardRho(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n}"
    },
    {
        "product_commit": "9c418ba827605589485be4ef28fed28f3f9e9c61",
        "test_commit": "9c418ba827605589485be4ef28fed28f3f9e9c61",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Pangram.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PangramTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\");\n        /* not exists l character */\n    }\n\n    /**\n     * Check if a string is a pangram string or not\n     *\n     * @param s string to check\n     * @return {@code true} if given string is pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] marked = new boolean[26];\n        /* by default all letters don't exists */\n        char[] values = s.toCharArray();\n        for (char value : values) {\n            if (Character.isLetter(value)) {\n                int index = Character.isUpperCase(value) ? value - 'A' : value - 'a';\n                marked[index] = true;\n                /* mark current character exists */\n            }\n        }\n\n        for (boolean b : marked) {\n            if (!b) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n\npublic class PangramTest {\n    @Test\n    public void isPangram() {\n        String fullAlphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        String notFullAlphabet = \"abcdefghiklmnopqrstuvwxyz\";\n        String fullMixedCaseAlphabet = \"a BCDE fghIjkLMnop qrSTuv WXYz\";\n        String sentence1 = \"The quick brown fox jumps over the lazy dog\";\n        String sentence2 = \"The quick brown fox jumps over the lazy gentleman\";  // missing letter d\n\n        assertTrue(Pangram.isPangram(fullAlphabet));\n        assertFalse(Pangram.isPangram(notFullAlphabet));\n        assertTrue(Pangram.isPangram(fullMixedCaseAlphabet));\n        assertTrue(Pangram.isPangram(sentence1));\n        assertFalse(Pangram.isPangram(sentence2));\n\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static com.thealgorithms.strings.Pangram.isPangram;\n\n\npublic class PangramTest {\n    @Test\n    public void testPangram() {\n        assertTrue(isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}"
    },
    {
        "product_commit": "8f18b92f6e19fe44595fb5c167a1b83d6ca4a16f",
        "test_commit": "8f18b92f6e19fe44595fb5c167a1b83d6ca4a16f",
        "product_file_path": "src/main/java/com/thealgorithms/others/countSetBits.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/countSetBitsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\n\npublic class countSetBits {\n    /** \n     * The below algorithm is called as Brian Kernighan's algorithm \n     * We can use Brian Kernighan\u2019s algorithm to improve the above naive algorithm\u2019s performance. The idea is to only consider the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the next rightmost bit.\n\n        The expression n & (n-1) can be used to turn off the rightmost set bit of a number n. This works as the expression n-1 flips all the bits after the rightmost set bit of n, including the rightmost set bit itself. Therefore, n & (n-1) results in the last bit flipped of n.\n\n        For example, consider number 52, which is 00110100 in binary, and has a total 3 bits set.\n\n        1st iteration of the loop: n = 52\n        \n        00110100    &               (n)\n        00110011                    (n-1)\n        ~~~~~~~~\n        00110000\n        \n        \n        2nd iteration of the loop: n = 48\n        \n        00110000    &               (n)\n        00101111                    (n-1)\n        ~~~~~~~~\n        00100000\n        \n        \n        3rd iteration of the loop: n = 32\n        \n        00100000    &               (n)\n        00011111                    (n-1)\n        ~~~~~~~~\n        00000000                    (n = 0)\n        \n     * @param num takes Long number whose number of set bit is to be found\n     * @return the count of set bits in the binary equivalent\n    */\n    public long countsetBits(long num){\n        long cnt=0;\n        while(num>0){\n            cnt++;\n            num&=(num-1);\n        }\n        return cnt;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class countSetBitsTest {\n    @Test\n    void testSetBits(){\n        countSetBits csb= new countSetBits();\n        assertEquals(1L,csb.countsetBits(16));\n        assertEquals(4, csb.countsetBits(15));\n        assertEquals(5, csb.countsetBits(10000));\n        assertEquals(5, csb.countsetBits(31));\n    }\n}"
    },
    {
        "product_commit": "20a1f40c5ab184648be385b4c053766477b8e6e6",
        "test_commit": "20a1f40c5ab184648be385b4c053766477b8e6e6",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Isomorphic.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/IsomorphicTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings;\nimport java.util.*;\n\npublic class Isomorphic {\n  public static boolean checkStrings(String s, String t) {\n    if(s.length() != t.length()){\n        return false;\n    }\n\n    // To mark the characters of string using MAP\n    // character of first string as KEY and another as VALUE\n    // now check occurence by keeping the track with SET data structure\n    Map<Character, Character> characterMap = new HashMap<Character, Character>();\n    Set<Character> trackUinqueCharacter = new HashSet<Character>();\n    \n    for(int i=0; i<s.length(); i++){\n        if(characterMap.containsKey(s.charAt(i))){\n            if(t.charAt(i) != characterMap.get(s.charAt(i))){\n                return false;\n            }\n        }\n        else{\n            if(trackUinqueCharacter.contains(t.charAt(i))){\n                return false;\n            }\n            \n            characterMap.put(s.charAt(i), t.charAt(i));\n        }\n        trackUinqueCharacter.add(t.charAt(i));\n    }\n    return true;\n  }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\n\npublic class IsomorphicTest {\n\n    @Test\n    public static void main(String[] args) {\n\n    String str1 = \"abbbbaac\";\n    String str2 = \"kffffkkd\";\n\n    String str3 = \"xyxyxy\";\n    String str4 = \"bnbnbn\";\n\n    String str5 = \"ghjknnmm\";\n    String str6 = \"wertpopo\";\n\n    String str7 = \"aaammmnnn\";\n    String str8 = \"ggghhhbbj\";\n\n    Isomorphic isomorphic = new Isomorphic();\n\n    assertTrue(isomorphic.checkStrings(str1, str2));\n    assertTrue(isomorphic.checkStrings(str3, str4));\n    assertFalse(isomorphic.checkStrings(str5, str6));\n    assertFalse(isomorphic.checkStrings(str7, str8));\n  }\n}"
    },
    {
        "product_commit": "69d0070c99453f0a5d4793d41aa5d750a5a4a5de",
        "test_commit": "69d0070c99453f0a5d4793d41aa5d750a5a4a5de",
        "product_file_path": "src/main/java/com/thealgorithms/maths/MobiusFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/MobiusFunctionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for mobius function\n * For any positive integer n, define \u03bc(n) as the sum of the primitive nth roots of unity. \n * It has values in {\u22121, 0, 1} depending on the factorization of n into prime factors:\n *   \u03bc(n) = +1 if n is a square-free positive integer with an even number of prime factors.\n *   \u03bc(n) = \u22121 if n is a square-free positive integer with an odd number of prime factors.\n *   \u03bc(n) = 0 if n has a squared prime factor.\n * Wikipedia: https://en.wikipedia.org/wiki/M%C3%B6bius_function\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\npublic class MobiusFunction {\n\n\t/**\n\t * This method returns \u03bc(n) of given number n\n\t *\n\t * @param number Integer value which \u03bc(n) is to be calculated \n\t * @return  1 when number is less than or equals 1 \n\t *            or number has even number of prime factors\n\t *          0 when number has repeated prime factor\n\t *         -1 when number has odd number of prime factors\n\t */\n\tstatic int mobius(int number) {\n\n\t\tif(number <= 0) {\n\t\t\t//throw exception when number is less than or is zero\n\t\t\tthrow new IllegalArgumentException(\"Number must be greater than zero.\");\n\t\t}\n\n\t\tif(number == 1) {\n\t\t\t//return 1 if number passed is less or is 1\n\t\t\treturn 1;\n\t\t}\n\n\t\tint primeFactorCount=0;\n\n\t\tfor(int i = 1; i <= number; i++) {\n\t\t\t//find prime factors of number\n\t\t\tif(number % i == 0 && PrimeCheck.isPrime(i)) {\n\t\t\t\t//check if number is divisible by square of prime factor\n\t\t\t\tif(number % (i*i) == 0) { \n\t\t\t\t\t//if number is divisible by square of prime factor\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/*increment primeFactorCount by 1 \n\t\t\t\tif number is not divisible by square of found prime factor*/\n\t\t\t\tprimeFactorCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn (primeFactorCount % 2 == 0) ? 1 : -1;\n\t}\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass MobiusFunctionTest {\n\n\t@Test\n\tvoid testMobiusForZero() {\n\t\t//given\n\t\tint number = 0;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tMobiusFunction.mobius(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testMobiusForNegativeNumber() {\n\t\t//given\n\t\tint number = -1;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tMobiusFunction.mobius(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testMobiusFunction(){\n\t\tint[] expectedResultArray = {\n\t\t\t\t1, -1, -1, 0, -1, 1, -1, 0, 0, 1, -1, 0, -1, 1, 1, 0, -1, 0, -1, 0, 1, 1, -1, 0, \n\t\t\t\t0, 1, 0, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 0, 1, -1, 0, 0, \n\t\t\t\t0, 1, 0, -1, 0, 1, 0, 1, 1, -1, 0, -1, 1, 0, 0, 1, -1, -1, 0, 1, -1, -1, 0, -1, 1, \n\t\t\t\t0, 0, 1, -1, -1, 0, 0, 1, -1, 0, 1, 1, 1, 0, -1, 0, 1, 0, 1, 1, 1, 0, -1, 0, 0, 0\n\t\t};\n\n\t\tfor(int i = 1; i <= 100; i++) {\n\n\t\t\t//given\n\t\t\tint expectedValue = expectedResultArray[i-1];\n\n\t\t\t//when\n\t\t\tint actualValue = MobiusFunction.mobius(i);\n\n\t\t\t//then\n\t\t\tassertEquals(expectedValue,actualValue);\n\t\t}\n\t}\n\n}"
    },
    {
        "product_commit": "6cfb6284872fc394791042968a46f57bc585072f",
        "test_commit": "6cfb6284872fc394791042968a46f57bc585072f",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch2dArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BinarySearch2dArrayTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\n/*\nTo apply this method, the provided array must be strictly sorted. In this method, two pointers, one at 0th row\n& the other at the last row are taken & the searching is done on the basis of the middle element of the middle column.\nIf that element is equal to target, its coordinates are returned, else if it is smaller than the target, the rows above\nthat element are ignored (because the elements above it will also be smaller than the target), else that element is\ngreater than the target, then the rows below it are ignored.\n */\npublic class BinarySearch2dArray\n{\n    static int[] BinarySearch(int[][] arr, int target){\n\n        int rowCount = arr.length, colCount = arr[0].length;\n\n        if (rowCount == 1){\n            return binarySearch(arr, target, 0, 0, colCount);\n        }\n\n        int startRow = 0, endRow = rowCount - 1, midCol = colCount/2;\n\n        while (startRow < endRow - 1){\n\n            int midRow = startRow + (endRow - startRow) / 2;    //getting the index of middle row\n\n            if (arr[midRow][midCol] == target){\n                return new int[] {midRow, midCol};\n            }\n            else if (arr[midRow][midCol] < target)\n                startRow = midRow;\n            else\n                endRow = midRow;\n        }\n            /*\n            if the above search fails to find the target element, these conditions will be used to find the target\n            element, which further uses the binary search algorithm in the places which were left unexplored.\n             */\n        if (arr[startRow][midCol] == target)\n            return new int[] {startRow, midCol};\n\n        if (arr[endRow][midCol] == target)\n            return new int[] {endRow, midCol};\n\n        if (target <= arr[startRow][midCol-1])\n            return binarySearch(arr, target, startRow, 0, midCol-1);\n\n        if (target >= arr[startRow][midCol+1] && target <= arr[startRow][colCount-1])\n            return binarySearch(arr,target, startRow, midCol+1, colCount-1);\n\n        if (target <= arr[endRow][midCol-1])\n            return binarySearch(arr, target, endRow, 0, midCol-1);\n\n        else\n            return binarySearch(arr,target, endRow, midCol+1, colCount-1);\n    }\n\n    static int[] binarySearch(int[][] arr, int target, int row, int colStart, int colEnd){\n\n        while (colStart <= colEnd){\n\n            int midIndex = colStart + (colEnd - colStart) / 2;\n\n            if (arr[row][midIndex] == target)\n                return new int[] {row, midIndex};\n\n            else if (arr[row][midIndex] < target)\n                colStart = midIndex + 1;\n            else\n                colEnd = midIndex - 1;\n        }\n\n        return new int[] {-1, -1};\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BinarySearch2dArrayTest {\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddle() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 6;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestMiddleSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 8;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {1,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpper() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 2;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestUpperSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 1;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {0,0};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(0, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLower() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 10;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestLowerSide() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 11;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {2,2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void BinarySearch2dArrayTestNotFound() {\n        int[][] arr = { {1, 2, 3, 4},\n                        {5, 6, 7, 8},\n                        {9,10,11,12}};\n        int target = 101;\n\n        int[] ans = BinarySearch2dArray.BinarySearch(arr, target);\n        int[] expected = {-1,-1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n}"
    },
    {
        "product_commit": "2ffcff12fc7520bd0cb1257c7ea4e726920f9233",
        "test_commit": "2ffcff12fc7520bd0cb1257c7ea4e726920f9233",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FastInverseSqrt.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FastInverseSqrtTests.java",
        "product_old_content": null,
        "product_new_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n\n/** Program description - To find out the inverse square root of the given number*/\n\n/** Wikipedia Link - https://en.wikipedia.org/wiki/Fast_inverse_square_root */\n\n\npackage com.thealgorithms.maths;\n\npublic class FastInverseSqrt {\n    public static boolean inverseSqrt(float number) {\n        float x = number;\n        float xhalf = 0.5f * x;\n        int i = Float.floatToIntBits(x);\n        i = 0x5f3759df - (i >> 1);\n        x = Float.intBitsToFloat(i);\n        x = x * (1.5f - xhalf * x * x);\n        return x == (float)((float)1/(float)Math.sqrt(number));\n    }\n    \n    /**\n     * Returns the inverse square root of the given number upto 6 - 8 decimal places.\n     * calculates the inverse square root of the given number and returns true if calculated answer matches with given answer else returns false\n     */\n\n    \n    public static boolean inverseSqrt(double number) {\n        double x = number;\n        double xhalf = 0.5d * x;\n        long i = Double.doubleToLongBits(x);\n        i = 0x5fe6ec85e7de30daL - (i >> 1);\n        x = Double.longBitsToDouble(i);\n        for (int it = 0; it < 4; it++) {\n            x = x * (1.5d - xhalf * x * x);\n        }\n        x *= number;\n        return x == 1/Math.sqrt(number);\n    }\n    /**\n     * Returns the inverse square root of the given number upto 14 - 16 decimal places.\n     * calculates the inverse square root of the given number and returns true if calculated answer matches with given answer else returns false\n     */\n}\n\n\n/**\n     * OUTPUT :\n     * Input - number = 4522\n     * Output: it calculates the inverse squareroot of a number and returns true with it matches the given answer else returns false.\n     * 1st approach Time Complexity : O(1)\n     * Auxiliary Space Complexity : O(1)\n     * Input - number = 4522\n     * Output: it calculates the inverse squareroot of a number and returns true with it matches the given answer else returns false.\n     * 2nd approach Time Complexity : O(1)\n     * Auxiliary Space Complexity : O(1)\n     */",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\n\npublic class FastInverseSqrtTests {\n    @Test\n\tvoid testForOneElement() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1332));\n        // calls for the 2nd inverse method\n    }\n\t@Test\n\tvoid testForsecond() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1332f));\n        // calls for the 1st inverse method\n\t}\n\n\t@Test\n\tvoid testForThird() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1));\n\t}\n    \n\t@Test\n\tvoid testForFourth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(1f));\n\t}\n\n\t@Test\n\tvoid testForFifth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(4522));\n\t}\n    \n\t@Test\n\tvoid testForSixth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(4522f));\n\t}\n\n\t@Test\n\tvoid testForSeventh() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(21));\n    }\n\n\t@Test\n\tvoid testForEighth() \n\t{\n\t\tassertFalse(FastInverseSqrt.inverseSqrt(21f));\n\t}\n}"
    },
    {
        "product_commit": "3f696034402a420d0839bce58fea3477f74e46eb",
        "test_commit": "3f696034402a420d0839bce58fea3477f74e46eb",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LeastCommonMultiple.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LeastCommonMultipleTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\nimport java.util.*;\n/**\n * Is a common mathematics concept to find the smallest value number \n * that can be divide using either number without having the remainder. \n * https://maticschool.blogspot.com/2013/11/find-least-common-multiple-lcm.html\n * @author LauKinHoong\n */\n\npublic class LeastCommonMultiple {\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner(System.in);\n        System.out.println(\"Please enter first number >> \");\n        int num1 = input.nextInt();\n        System.out.println(\"Please enter second number >> \");\n        int num2 = input.nextInt();\n        System.out.println(\"The least common multiple of two numbers is >> \" + lcm(num1,num2));\n\n\t}\n\t\n    /*\n     * get least common multiple from two number\n     */\n\tpublic static int lcm (int num1, int num2){\n        int high, num3;\n        int cmv = 0;\n        /*\n         * value selection for the numerator\n         */\n        if (num1 > num2){\n            high = num3 = num1;\n        }\n        else{\n            high = num3 = num2;\n        }\n\n        while(num1 != 0){\n            if(high % num1 == 0 && high % num2 == 0){\n                cmv = high;\n                break;\n            }\n            high += num3;\n        }\n        return cmv;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class LeastCommonMultipleTest {\n    /*\n\t * Test for first number greater than second number\n\t */\n\t@Test\n\tpublic void testForFirst() {\n\t\tint result = LeastCommonMultiple.lcm(6,8);\n\t\tint expected = 24;\n\t\tAssertions.assertEquals(result, expected);\n\t}\n\n\t/*\n\t * Test for second number greater than first number\n\t */\n\t@Test\n\tpublic void testForSecond() {\n\t\tint result = LeastCommonMultiple.lcm(8,6);\n\t\tint expected = 24;\n\t\tAssertions.assertEquals(result, expected);\n\t}\n\n}"
    },
    {
        "product_commit": "05660dae92207e3d45bc74ba5c8b3cefb4865115",
        "test_commit": "05660dae92207e3d45bc74ba5c8b3cefb4865115",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/KDTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/KDTreeTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/*\n * K-D Tree Implementation\n * Wikipedia: https://en.wikipedia.org/wiki/K-d_tree\n *\n * Author: Amir Hosseini (https://github.com/itsamirhn)\n *\n * */\n\npublic class KDTree {\n\n    private Node root;\n\n    private final int k; // Dimensions of the points\n\n    /**\n     * Constructor for empty KDTree\n     *\n     * @param k Number of dimensions\n     */\n    KDTree(int k) {\n        this.k = k;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     */\n    KDTree(Point[] points) {\n        if (points.length == 0) throw new IllegalArgumentException(\"Points array cannot be empty\");\n        this.k = points[0].getDimension();\n        for (Point point : points) if (point.getDimension() != k) throw new IllegalArgumentException(\"Points must have the same dimension\");\n        this.root = build(points, 0);\n    }\n\n    /**\n     * Builds the KDTree from the specified coordinates of the points\n     *\n     * @param pointsCoordinates Array of initial points coordinates\n     *\n     */\n    KDTree(int[][] pointsCoordinates) {\n        if (pointsCoordinates.length == 0) throw new IllegalArgumentException(\"Points array cannot be empty\");\n        this.k = pointsCoordinates[0].length;\n        Point[] points = Arrays.stream(pointsCoordinates)\n                .map(Point::new)\n                .toArray(Point[]::new);\n        for (Point point : points) if (point.getDimension() != k) throw new IllegalArgumentException(\"Points must have the same dimension\");\n        this.root = build(points, 0);\n    }\n\n    static class Point {\n        int[] coordinates;\n\n        public int getCoordinate(int i) {\n            return coordinates[i];\n        }\n\n        public int getDimension() {\n            return coordinates.length;\n        }\n\n        public Point(int[] coordinates) {\n            this.coordinates = coordinates;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Point other) {\n                if (other.getDimension() != this.getDimension()) return false;\n                return Arrays.equals(other.coordinates, this.coordinates);\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(coordinates);\n        }\n\n        /**\n         * Find the comparable distance between two points (without SQRT)\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         *\n         * @return The comparable distance between the two points\n         */\n        static public int comparableDistance(Point p1, Point p2) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n\n        /**\n         * Find the comparable distance between two points with ignoring specified axis\n         *\n         * @param p1 First point\n         * @param p2 Second point\n         * @param axis The axis to ignore\n         *\n         * @return The distance between the two points\n         */\n        static public int comparableDistanceExceptAxis(Point p1, Point p2, int axis) {\n            int distance = 0;\n            for (int i = 0; i < p1.getDimension(); i++) {\n                if (i == axis) continue;\n                int t = p1.getCoordinate(i) - p2.getCoordinate(i);\n                distance += t * t;\n            }\n            return distance;\n        }\n    }\n\n\n    static class Node {\n        private Point point;\n        private int axis; // 0 for x, 1 for y, 2 for z, etc.\n\n        private Node left = null; // Left child\n        private Node right = null; // Right child\n\n        Node(Point point, int axis) {\n            this.point = point;\n            this.axis = axis;\n        }\n\n        public Point getPoint() {\n            return point;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n\n        public int getAxis() {\n            return axis;\n        }\n\n        /**\n         * Get the nearest child according to the specified point\n         *\n         * @param point The point to find the nearest child to\n         *\n         * @return The nearest child Node\n         */\n        public Node getNearChild(Point point) {\n            if (point.getCoordinate(axis) < this.point.getCoordinate(axis)) return left;\n            else return right;\n        }\n\n        /**\n         * Get the farthest child according to the specified point\n         *\n         * @param point The point to find the farthest child to\n         *\n         * @return The farthest child Node\n         */\n        public Node getFarChild(Point point) {\n            if (point.getCoordinate(axis) < this.point.getCoordinate(axis)) return right;\n            else return left;\n        }\n\n        /**\n         * Get the node axis coordinate of point\n         *\n         * @return The axis coordinate of the point\n         */\n        public int getAxisCoordinate() {\n            return point.getCoordinate(axis);\n        }\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Builds the KDTree from the specified points\n     *\n     * @param points Array of initial points\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node build(Point[] points, int depth) {\n        if (points.length == 0) return null;\n        int axis = depth % k;\n        if (points.length == 1) return new Node(points[0], axis);\n        Arrays.sort(points, Comparator.comparingInt(o -> o.getCoordinate(axis)));\n        int median = points.length >> 1;\n        Node node = new Node(points[median], axis);\n        node.left = build(Arrays.copyOfRange(points, 0, median), depth + 1);\n        node.right = build(Arrays.copyOfRange(points, median + 1, points.length), depth + 1);\n        return node;\n    }\n\n    /**\n     * Insert a point into the KDTree\n     *\n     * @param point The point to insert\n     *\n     */\n    public void insert(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\"Point has wrong dimension\");\n        root = insert(root, point, 0);\n    }\n\n    /**\n     * Insert a point into a subtree\n     *\n     * @param root The root of the subtree\n     * @param point The point to insert\n     * @param depth The current depth of the tree\n     *\n     * @return The root of the KDTree\n     */\n    private Node insert(Node root, Point point, int depth) {\n        int axis = depth % k;\n        if (root == null) return new Node(point, axis);\n        if (point.getCoordinate(axis) < root.getAxisCoordinate()) root.left = insert(root.left, point, depth + 1);\n        else root.right = insert(root.right, point, depth + 1);\n\n        return root;\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in the KDTree\n     *\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Point point) {\n        if (point.getDimension() != k) throw new IllegalArgumentException(\"Point has wrong dimension\");\n        return search(root, point);\n    }\n\n    /**\n     * Search for Node corresponding to the specified point in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param point The point to search for\n     *\n     * @return The Node corresponding to the specified point\n     */\n    public Optional<Node> search(Node root, Point point) {\n        if (root == null) return Optional.empty();\n        if (root.point.equals(point)) return Optional.of(root);\n        return search(root.getNearChild(point), point);\n    }\n\n\n    /**\n     * Find a point with minimum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The point with minimum value in the specified axis\n     */\n    public Point findMin(int axis) {\n        return findMin(root, axis).point;\n    }\n\n    /**\n     * Find a point with minimum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the minimum value in\n     *\n     * @return The Node with minimum value in the specified axis of the point\n     */\n    public Node findMin(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.left == null) return root;\n            return findMin(root.left, axis);\n        } else {\n            Node left = findMin(root.left, axis);\n            Node right = findMin(root.right, axis);\n            Node[] candidates = {left, root, right};\n            return Arrays.stream(candidates)\n                        .filter(Objects::nonNull)\n                        .min(Comparator.comparingInt(a -> a.point.getCoordinate(axis))).orElse(null);\n        }\n    }\n\n\n    /**\n     * Find a point with maximum value in specified axis in the KDTree\n     *\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The point with maximum value in the specified axis\n     */\n    public Point findMax(int axis) {\n        return findMax(root, axis).point;\n    }\n\n    /**\n     * Find a point with maximum value in specified axis in a subtree\n     *\n     * @param root The root of the subtree to search in\n     * @param axis The axis to find the maximum value in\n     *\n     * @return The Node with maximum value in the specified axis of the point\n     */\n    public Node findMax(Node root, int axis) {\n        if (root == null) return null;\n        if (root.getAxis() == axis) {\n            if (root.right == null) return root;\n            return findMax(root.right, axis);\n        } else {\n            Node left = findMax(root.left, axis);\n            Node right = findMax(root.right, axis);\n            Node[] candidates = {left, root, right};\n            return Arrays.stream(candidates)\n                        .filter(Objects::nonNull)\n                        .max(Comparator.comparingInt(a -> a.point.getCoordinate(axis))).orElse(null);\n        }\n    }\n\n    /**\n     * Delete the node with the given point.\n     *\n     * @param point the point to delete\n     * */\n    public void delete(Point point) {\n        Node node = search(point).orElseThrow(() -> new IllegalArgumentException(\"Point not found\"));\n        root = delete(root, node);\n    }\n\n    /**\n     * Delete the specified node from a subtree.\n     *\n     * @param root The root of the subtree to delete from\n     * @param node The node to delete\n     *\n     * @return The new root of the subtree\n     */\n    private Node delete(Node root, Node node) {\n        if (root == null) return null;\n        if (root.equals(node)) {\n            if (root.right != null) {\n                Node min = findMin(root.right, root.getAxis());\n                root.point = min.point;\n                root.right = delete(root.right, min);\n            } else if (root.left != null) {\n                Node min = findMin(root.left, root.getAxis());\n                root.point = min.point;\n                root.left = delete(root.left, min);\n            } else return null;\n        }\n        if (root.getAxisCoordinate() < node.point.getCoordinate(root.getAxis())) root.left = delete(root.left, node);\n        else root.right = delete(root.right, node);\n        return root;\n    }\n\n    /**\n     * Finds the nearest point in the tree to the given point.\n     *\n     * @param point The point to find the nearest neighbor to.\n     * */\n    public Point findNearest(Point point) {\n        return findNearest(root, point, root).point;\n    }\n\n\n    /**\n     * Finds the nearest point in a subtree to the given point.\n     *\n     * @param root The root of the subtree to search in.\n     * @param point The point to find the nearest neighbor to.\n     * @param nearest The nearest neighbor found so far.\n     * */\n    private Node findNearest(Node root, Point point, Node nearest) {\n        if (root == null) return nearest;\n        if (root.point.equals(point)) return root;\n        int distance = Point.comparableDistance(root.point, point);\n        int distanceExceptAxis = Point.comparableDistanceExceptAxis(root.point, point, root.getAxis());\n        if (distance < Point.comparableDistance(nearest.point, point)) nearest = root;\n        nearest = findNearest(root.getNearChild(point), point, nearest);\n        if (distanceExceptAxis < Point.comparableDistance(nearest.point, point))\n            nearest = findNearest(root.getFarChild(point), point, nearest);\n        return nearest;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class KDTreeTest {\n\n    KDTree.Point pointOf(int x, int y) {\n        return new KDTree.Point(new int[]{x, y});\n    }\n\n    @Test\n    void findMin() {\n        int[][] coordinates = {\n                {30, 40},\n                {5, 25},\n                {70, 70},\n                {10, 12},\n                {50, 30},\n                {35, 45}\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(5, kdTree.findMin(0).getCoordinate(0));\n        assertEquals(12, kdTree.findMin(1).getCoordinate(1));\n    }\n\n    @Test\n    void delete() {\n        int[][] coordinates = {\n                {30, 40},\n                {5, 25},\n                {70, 70},\n                {10, 12},\n                {50, 30},\n                {35, 45}\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        kdTree.delete(pointOf(30, 40));\n        assertEquals(35, kdTree.getRoot().getPoint().getCoordinate(0));\n        assertEquals(45, kdTree.getRoot().getPoint().getCoordinate(1));\n    }\n\n    @Test\n    void findNearest() {\n        int[][] coordinates = {\n                {2, 3},\n                {5, 4},\n                {9, 6},\n                {4, 7},\n                {8, 1},\n                {7, 2}\n        };\n        KDTree kdTree = new KDTree(coordinates);\n\n        assertEquals(pointOf(7, 2), kdTree.findNearest(pointOf(7, 2)));\n        assertEquals(pointOf(8, 1), kdTree.findNearest(pointOf(8, 1)));\n        assertEquals(pointOf(2, 3), kdTree.findNearest(pointOf(1, 1)));\n        assertEquals(pointOf(5, 4), kdTree.findNearest(pointOf(5, 5)));\n    }\n\n}"
    },
    {
        "product_commit": "854b900257d46721a7c3864475574c4bab72ccf9",
        "test_commit": "854b900257d46721a7c3864475574c4bab72ccf9",
        "product_file_path": "src/main/java/com/thealgorithms/maths/JosephusProblem.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/JosephusProblemTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n     /** There are n friends that are playing a game. The friends are sitting in a circle and are    numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\n    */\n\n    /** The rules of the game are as follows:\n\n        1.Start at the 1st friend.\n        2.Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\n        3.The last friend you counted leaves the circle and loses the game.\n        4.If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\n        5.Else, the last friend in the circle wins the game.\n\n        @author Kunal\n    */\n\npublic class JosephusProblem {\n\n    /**\n     * Find the Winner of the Circular Game.\n     *\n     * @param number of friends, n, and an integer k\n     * @return return the winner of the game\n     */\n\n    public static int findTheWinner(int n, int k) {\n        return winner(n, k) + 1;\n    }\n    \n    public static int winner(int n, int k){\n        if (n == 1){\n            return 0;\n        }\n        return (winner(n -1, k) + k) % n;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class JosephusProblemTest {\n\n    @Test\n    void testJosephusProblem(){\n        assertEquals(3, JosephusProblem.findTheWinner(5,2));\n        assertEquals(5, JosephusProblem.findTheWinner(6,4));\n    }\n\n}"
    },
    {
        "product_commit": "3e8f30c72a2eefcb03af94c9a6581f1f7e89b6ee",
        "test_commit": "3e8f30c72a2eefcb03af94c9a6581f1f7e89b6ee",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/LazySegmentTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/LazySegmentTreeTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\npublic class LazySegmentTree {\n    /**\n     * Lazy Segment Tree\n     *\n     * @see\n     *\t<a href=\"https://www.geeksforgeeks.org/lazy-propagation-in-segment-tree/\">\n     */\n    static class Node {\n        private final int start, end; // start and end of the segment represented by this node\n        private int value; // value is the sum of all elements in the range [start, end)\n        private int lazy; // lazied value that should be added to children nodes\n        Node left, right; // left and right children\n        public Node(int start, int end, int value) {\n            this.start = start;\n            this.end = end;\n            this.value = value;\n            this.lazy = 0;\n            this.left = null;\n            this.right = null;\n        }\n\n        /** Update the value of this node with the given value diff.\n         *\n         * @param diff The value to add to every index of this node range.\n         */\n        public void applyUpdate(int diff) {\n            this.lazy += diff;\n            this.value += (this.end - this.start) * diff;\n        }\n\n        /** Shift the lazy value of this node to its children.\n         */\n        public void shift() {\n            if (lazy == 0) return;\n            if (this.left == null && this.right == null) return;\n            this.value += this.lazy;\n            if (this.left != null) this.left.applyUpdate(this.lazy);\n            if (this.right != null) this.right.applyUpdate(this.lazy);\n            this.lazy = 0;\n        }\n\n        /** Create a new node that is the sum of this node and the given node.\n         *\n         * @param left The left Node of merging\n         * @param right The right Node of merging\n         * @return The new Node.\n         */\n        static Node merge(Node left, Node right) {\n            if (left == null) return right;\n            if (right == null) return left;\n            Node result = new Node(left.start, right.end, left.value + right.value);\n            result.left = left;\n            result.right = right;\n            return result;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public Node getLeft() {\n            return left;\n        }\n\n        public Node getRight() {\n            return right;\n        }\n    }\n\n    private final Node root;\n\n    /** Create a new LazySegmentTree with the given array.\n     *\n     * @param array The array to create the LazySegmentTree from.\n     */\n    public LazySegmentTree(int[] array) {\n        this.root = buildTree(array, 0, array.length);\n    }\n\n    /** Build a new LazySegmentTree from the given array in O(n) time.\n     *\n     * @param array The array to build the LazySegmentTree from.\n     * @param start The start index of the current node.\n     * @param end The end index of the current node.\n     * @return The root of the new LazySegmentTree.\n     */\n    private Node buildTree(int[] array, int start, int end) {\n        if (end - start < 2) return new Node(start, end, array[start]);\n        int mid = (start + end) >> 1;\n        Node left = buildTree(array, start, mid);\n        Node right = buildTree(array, mid, end);\n        return Node.merge(left, right);\n    }\n\n    /** Update the value of given range with the given value diff in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @param diff The value to add to every index of the range.\n     * @param curr The current node.\n     */\n    private void updateRange(int left, int right, int diff, Node curr) {\n        if (left <= curr.start && curr.end <= right) {\n            curr.applyUpdate(diff);\n            return;\n        }\n        if (left >= curr.end || right <= curr.start) return;\n        curr.shift();\n        updateRange(left, right, diff, curr.left);\n        updateRange(left, right, diff, curr.right);\n        Node merge = Node.merge(curr.left, curr.right);\n        curr.value = merge.value;\n    }\n\n    /** Get Node of given range in O(log n) time.\n     *\n     * @param left The left index of the range to update.\n     * @param right The right index of the range to update.\n     * @return The Node representing the sum of the given range.\n     */\n    private Node getRange(int left, int right, Node curr) {\n        if (left <= curr.start && curr.end <= right) return curr;\n        if (left >= curr.end || right <= curr.start) return null;\n        curr.shift();\n        return Node.merge(getRange(left, right, curr.left), getRange(left, right, curr.right));\n    }\n\n    public int getRange(int left, int right) {\n        Node result = getRange(left, right, root);\n        return result == null ? 0 : result.getValue();\n    }\n\n    public void updateRange(int left, int right, int diff) {\n        updateRange(left, right, diff, root);\n    }\n\n    public Node getRoot() {\n        return root;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LazySegmentTreeTest {\n\n    @Test\n    void build() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRoot().getValue());\n        assertEquals(15, lazySegmentTree.getRoot().getLeft().getValue());\n        assertEquals(40, lazySegmentTree.getRoot().getRight().getValue());\n    }\n\n    @Test\n    void update() {\n        int[] arr = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(10, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(0, 2, 1);\n        assertEquals(12, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(1, 3, 1);\n        assertEquals(14, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(6, 8, 1);\n        assertEquals(16, lazySegmentTree.getRoot().getValue());\n\n        lazySegmentTree.updateRange(3, 9, 1);\n        assertEquals(22, lazySegmentTree.getRoot().getValue());\n    }\n\n    @Test\n    void get() {\n        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n        assertEquals(55, lazySegmentTree.getRange(0, 10));\n        assertEquals(3, lazySegmentTree.getRange(0, 2));\n        assertEquals(19, lazySegmentTree.getRange(8, 10));\n        assertEquals(44, lazySegmentTree.getRange(1, 9));\n    }\n\n    @Test\n    void updateAndGet() {\n        int[] arr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        LazySegmentTree lazySegmentTree = new LazySegmentTree(arr);\n\n        for (int i = 0; i < 10; i++) for (int j = i + 1; j < 10; j++) {\n            lazySegmentTree.updateRange(i, j, 1);\n            assertEquals(j - i, lazySegmentTree.getRange(i, j));\n            lazySegmentTree.updateRange(i, j, -1);\n            assertEquals(0, lazySegmentTree.getRange(i, j));\n        }\n    }\n\n}"
    },
    {
        "product_commit": "d63813e0a2b05ffa3bc5d359b9b206b03e6ba962",
        "test_commit": "d63813e0a2b05ffa3bc5d359b9b206b03e6ba962",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/MazeRecursionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n\n\tpublic static void mazeRecursion() {\n\t\t// First create a 2 dimensions array to mimic a maze map\n\t\tint[][] map = new int[8][7];\n\t\tint[][] map2 = new int[8][7];\n\n\t\t// We use 1 to indicate wall\n\t\t// Set the ceiling and floor to 1\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tmap[0][i] = 1;\n\t\t\tmap[7][i] = 1;\n\t\t}\n\n\t\t// Then we set the left and right wall to 1\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tmap[i][0] = 1;\n\t\t\tmap[i][6] = 1;\n\t\t}\n\n\t\t// Now we have created a maze with its wall initialized\n\n\t\t// Here we set the obstacle\n\t\tmap[3][1] = 1;\n\t\tmap[3][2] = 1;\n\n\t\t// Print the current map\n\t\tSystem.out.println(\"The condition of the map\uff1a \");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t// clone another map for setWay2 method\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\tmap2[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\n\t\t// By using recursive backtracking to let your ball(target) find its way in the\n\t\t// maze\n\t\t// The first parameter is the map\n\t\t// Second parameter is x coordinate of your target\n\t\t// Thrid parameter is the y coordinate of your target\n\t\tsetWay(map, 1, 1);\n\t\tsetWay2(map2, 1, 1);\n\n\t\t// Print out the new map1, with the ball footprint\n\t\tSystem.out.println(\"After the ball goes through the map1\uff0cshow the current map1 condition\");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\t// Print out the new map2, with the ball footprint\n\t\tSystem.out.println(\"After the ball goes through the map2\uff0cshow the current map2 condition\");\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tfor (int j = 0; j < 7; j++) {\n\t\t\t\tSystem.out.print(map2[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\n\n\t// Using recursive path finding to help the ball find its way in the maze\n\t// Description\uff1a\n\t// 1. map (means the maze)\n\t// 2. i, j (means the initial coordinate of the ball in the maze)\n\t// 3. if the ball can reach the end of maze, that is position of map[6][5],\n\t// means the we have found a path for the ball\n\t// 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n\t// through this position, 1 means the wall, 2 means the path is feasible, 3\n\t// means the ball has gone through the path but this path is dead end\n\t// 5. We will need strategy for the ball to pass through the maze for example:\n\t// Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n\t/**\n\t *\n\t * @Description\n\t * @author OngLipWei\n\t * @date Jun 23, 202111:36:14 AM\n\t * @param map The maze\n\t * @param i   x coordinate of your ball(target)\n\t * @param j   y coordinate of your ball(target)\n\t * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n\t */\n\tpublic static boolean setWay(int[][] map, int i, int j) {\n\t\tif (map[6][5] == 2) {// means the ball find its path, ending condition\n\t\t\treturn true;\n\t\t}\n\t\tif (map[i][j] == 0) { // if the ball haven't gone through this point\n\t\t\t// then the ball follows the move strategy : down -> right -> up -> left\n\t\t\tmap[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n\t\t\tif (setWay(map, i + 1, j)) { // go down\n\t\t\t\treturn true;\n\t\t\t} else if (setWay(map, i, j + 1)) { // go right\n\t\t\t\treturn true;\n\t\t\t} else if (setWay(map, i - 1, j)) { // go up\n\t\t\t\treturn true;\n\t\t\t} else if (setWay(map, i, j - 1)) { // go left\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// means that the current point is the dead end, the ball cannot proceed, set\n\t\t\t\t// the current point to 3 and return false, the backtraking will start, it will\n\t\t\t\t// go to the previous step and check for feasible path again\n\t\t\t\tmap[i][j] = 3;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t} else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n\t\t\t// ball cannot hit the wall, cannot go to the path that has gone though before,\n\t\t\t// and cannot head to deadend.\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\t// Here is another move strategy for the ball: up->right->down->left\n\tpublic static boolean setWay2(int[][] map, int i, int j) {\n\t\tif (map[6][5] == 2) {// means the ball find its path, ending condition\n\t\t\treturn true;\n\t\t}\n\t\tif (map[i][j] == 0) { // if the ball haven't gone through this point\n\t\t\t// then the ball follows the move strategy : up->right->down->left\n\t\t\tmap[i][j] = 2; // we assume that this path is feasible first, set the current point to 2 first\u3002\n\t\t\tif (setWay2(map, i - 1, j)) { // go up\n\t\t\t\treturn true;\n\t\t\t} else if (setWay2(map, i, j + 1)) { // go right\n\t\t\t\treturn true;\n\t\t\t} else if (setWay2(map, i + 1, j)) { // go down\n\t\t\t\treturn true;\n\t\t\t} else if (setWay2(map, i, j - 1)) { // go left\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// means that the current point is the dead end, the ball cannot proceed, set\n\t\t\t\t// the current point to 3 and return false, the backtraking will start, it will\n\t\t\t\t// go to the previous step and check for feasible path again\n\t\t\t\tmap[i][j] = 3;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t} else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n\t\t\t// ball cannot hit the wall, cannot go to the path that has gone though before,\n\t\t\t// and cannot head to deadend.\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * @author onglipwei\n * @create 2022-08-03 5:17 AM\n */\npublic class MazeRecursionTest {\n\n    @Test\n    public void testMaze() {\n\n\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        //clone another map for setWay2 method\n        for (int i = 0; i < map.length;i++) {\n            for (int j = 0; j < map[i].length;j++) {\n                map2[i][j]=map[i][j];\n            }\n        }\n\n        MazeRecursion.setWay(map, 1, 1);\n        MazeRecursion.setWay2(map2, 1, 1);\n\n\n        int expectedMap[][] = new int[][]{\n                {1,1,1,1,1,1,1},\n                {1,2,0,0,0,0,1},\n                {1,2,2,2,0,0,1},\n                {1,1,1,2,0,0,1},\n                {1,0,0,2,0,0,1},\n                {1,0,0,2,0,0,1},\n                {1,0,0,2,2,2,1},\n                {1,1,1,1,1,1,1}\n        };\n\n        int expectedMap2[][] = new int[][]{\n                {1,1,1,1,1,1,1},\n                {1,2,2,2,2,2,1},\n                {1,0,0,0,0,2,1},\n                {1,1,1,0,0,2,1},\n                {1,0,0,0,0,2,1},\n                {1,0,0,0,0,2,1},\n                {1,0,0,0,0,2,1},\n                {1,1,1,1,1,1,1}\n        };\n\n        assertArrayEquals(map, expectedMap);\n        assertArrayEquals(map2, expectedMap2);\n\n    }\n\n}"
    },
    {
        "product_commit": "d82a2006bae2bf5402a9aafbb67c9d1504406ac1",
        "test_commit": "d82a2006bae2bf5402a9aafbb67c9d1504406ac1",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BinaryInsertionSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BinaryInsertionSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\npublic class BinaryInsertionSort{\n   \n\n \n    // Binary Insertion Sort method   \n    public int[] binaryInsertSort(int[] array){\n       \n        for(int i = 1; i < array.length; i++){\n           \n        \tint temp=array[i];\n            int low = 0;            \n            int high = i - 1;  \n           \n            while(low <= high){                \n                int mid = (low + high) / 2;                \n                if(temp < array[mid]){                    \n                    high = mid - 1;                \n                }else{                    \n                    low = mid + 1;\n                }       \n            }\n           \n            for(int j = i; j >= low + 1; j--){            \n                array[j] = array[j - 1];                                                      \n            }       \n           \n            array[low] = temp;       \n        }   \n        return array;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\n\nclass BinaryInsertionSortTest {\n\tBinaryInsertionSort BIS= new BinaryInsertionSort();\n\t\n    @Test\n    // valid test case\n    public void BinaryInsertionSortTestNonDuplicate() {\n    \tint[] array = {1,0,2,5,3,4,9,8,10,6,7};\t\n    \tint [] expResult= {0,1,2,3,4,5,6,7,8,9,10};\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult,actResult);\n    }\n\n    @Test\n    public void BinaryInsertionSortTestDuplicate() {\n    \tint[] array = {1,1,1,5,9,8,7,2,6};\t\n    \tint [] expResult= {1,1,1,2,5,6,7,8,9};\n        int[] actResult = BIS.binaryInsertSort(array);\n        assertArrayEquals(expResult,actResult);\n    }\n}"
    },
    {
        "product_commit": "b36f3590764811fc3be13ce190fcf5a99c74e4fd",
        "test_commit": "b36f3590764811fc3be13ce190fcf5a99c74e4fd",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/StrandSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/StrandSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n \npublic class StrandSort{\n\t// note: the input list is destroyed\n\tpublic static <E extends Comparable<? super E>> \n\tLinkedList<E> strandSort(LinkedList<E> list){\n\t\tif(list.size() <= 1) return list;\n \n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(list.size() > 0){\n\t\t\tLinkedList<E> sorted = new LinkedList<E>();\n\t\t\tsorted.add(list.removeFirst()); //same as remove() or remove(0)\n\t\t\tfor(Iterator<E> it = list.iterator(); it.hasNext(); ){\n\t\t\t\tE elem = it.next();\n\t\t\t\tif(sorted.peekLast().compareTo(elem) <= 0){\n\t\t\t\t\tsorted.addLast(elem); //same as add(elem) or add(0, elem)\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = merge(sorted, result);\n\t\t}\n\t\treturn result;\n\t}\n \n\tprivate static <E extends Comparable<? super E>>\n\tLinkedList<E> merge(LinkedList<E> left, LinkedList<E> right){\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(!left.isEmpty() && !right.isEmpty()){\n\t\t\t//change the direction of this comparison to change the direction of the sort\n\t\t\tif(left.peek().compareTo(right.peek()) <= 0)\n\t\t\t\tresult.add(left.remove());\n\t\t\telse\n\t\t\t\tresult.add(right.remove());\n\t\t}\n\t\tresult.addAll(left);\n\t\tresult.addAll(right);\n\t\treturn result;\n\t}\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\n\n\nclass StrandSortTest {\n\t@Test\n\t// valid test case\n\tpublic void StrandSortNonDuplicateTest() {\n\t\tint[] expectedArray = { 1, 2, 3, 4, 5 };\n\t\tLinkedList<Integer> actualList = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(3, 1, 2, 4, 5)));\n\t\tint[] actualArray = new int[actualList.size()];\n\t\tfor (int i = 0; i < actualList.size(); i++) {\n\t\t\tactualArray[i] = actualList.get(i);\n\t\t}\n\t\tassertArrayEquals(expectedArray, actualArray);\n\n\t}\n\n\t@Test\n\t// valid test case\n\tpublic void StrandSortDuplicateTest() {\n\t\tint[] expectedArray = { 2, 2, 2, 5, 7 };\n\t\tLinkedList<Integer> actualList = StrandSort.strandSort(new LinkedList<Integer>(Arrays.asList(7, 2, 2, 2, 5)));\n\t\tint[] actualArray = new int[actualList.size()];\n\t\tfor (int i = 0; i < actualList.size(); i++) {\n\t\t\tactualArray[i] = actualList.get(i);\n\t\t}\n\t\tassertArrayEquals(expectedArray, actualArray);\n\n\t}\n\n}"
    },
    {
        "product_commit": "92bd9ba3c98d77a0188cee676603388e78fa01dc",
        "test_commit": "92bd9ba3c98d77a0188cee676603388e78fa01dc",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RabinKarpAlgorithm.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RabinKarpAlgorithmTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\n// Following program is a Java implementation \n// of Rabin Karp Algorithm given in the CLRS book\n  \npublic class RabinKarpAlgorithm\n{\n    // d is the number of characters in the input alphabet\n    public final static int d = 256;\n      \n    /* pat -> pattern\n        txt -> text\n        q -> A prime number\n    */\n    public int search(String pat, String txt, int q)\n    {\n    \tint index = -1; //note: -1 here represent not found, it is not an index\n        int M = pat.length();\n        int N = txt.length();\n        int i, j;\n        int p = 0; // hash value for pattern\n        int t = 0; // hash value for txt\n        int h = 1;\n      \n        // The value of h would be \"pow(d, M-1)%q\"\n        for (i = 0; i < M-1; i++)\n            h = (h*d)%q;\n      \n        // Calculate the hash value of pattern and first\n        // window of text\n        for (i = 0; i < M; i++)\n        {\n            p = (d*p + pat.charAt(i))%q;\n            t = (d*t + txt.charAt(i))%q;\n        }\n      \n        // Slide the pattern over text one by one\n        for (i = 0; i <= N - M; i++)\n        {\n      \n            // Check the hash values of current window of text\n            // and pattern. If the hash values match then only\n            // check for characters one by one\n            if ( p == t )\n            {\n                /* Check for characters one by one */\n                for (j = 0; j < M; j++)\n                {\n                    if (txt.charAt(i+j) != pat.charAt(j))\n                        break;\n                }\n      \n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]\n                if (j == M) {\n                    System.out.println(\"Pattern found at index \" + i);\n                    index= i;\n                    return index ;\n                }\n            }\n      \n            // Calculate hash value for next window of text: Remove\n            // leading digit, add trailing digit\n            if ( i < N-M )\n            {\n                t = (d*(t - txt.charAt(i)*h) + txt.charAt(i+M))%q;\n      \n                // We might get negative value of t, converting it\n                // to positive\n                if (t < 0)\n                t = (t + q);\n            }\n        }\n        return index; // return -1 if pattern does not found\n    }\n      \n}\n  \n// This code is contributed by nuclode",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass RabinKarpAlgorithmTest {\n\n\t\n\tRabinKarpAlgorithm RKA= new RabinKarpAlgorithm();\n\tint q= 101;\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestExample() {\n        String txt = \"This is an example for rabin karp algorithmn\";\n        String pat = \"algorithmn\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value,34);\n    }\n    \n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestFront() {\n        String txt = \"AAABBDDG\";\n        String pat = \"AAA\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 0);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestMiddle() {\n        String txt = \"AAABBCCBB\";\n        String pat = \"BBCC\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 3);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestLast() {\n        String txt = \"AAAABBBBCCC\";\n        String pat = \"CCC\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, 8);\n    }\n\n    @Test\n    // valid test case\n    public void RabinKarpAlgorithmTestNotFound() {\n        String txt = \"ABCBCBCAAB\";\n        String pat = \"AADB\";\n        int value = RKA.search(pat, txt, q);\n        assertEquals(value, -1);\n    }\n\n}"
    },
    {
        "product_commit": "965c20381cd26febaf7b6d4fee6b46864b3a40b8",
        "test_commit": "965c20381cd26febaf7b6d4fee6b46864b3a40b8",
        "product_file_path": "src/main/java/com/thealgorithms/searches/KMPSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/KMPSearchTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\n\nclass KMPSearch {\n    int KMPSearch(String pat, String txt)\n    {\n        int M = pat.length();\n        int N = txt.length();\n \n        // create lps[] that will hold the longest\n        // prefix suffix values for pattern\n        int lps[] = new int[M];\n        int j = 0; // index for pat[]\n \n        // Preprocess the pattern (calculate lps[]\n        // array)\n        computeLPSArray(pat, M, lps);\n \n        int i = 0; // index for txt[]\n        while ((N - i) >= (M - j)) {\n            if (pat.charAt(j) == txt.charAt(i)) {\n                j++;\n                i++;\n            }\n            if (j == M) {\n                System.out.println(\"Found pattern \"\n                                + \"at index \" + (i - j));\n                int index = (i - j);\n                j = lps[j - 1];\n                return index;\n        \n            }\n \n            // mismatch after j matches\n            else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n                // Do not match lps[0..lps[j-1]] characters,\n                // they will match anyway\n                if (j != 0)\n                    j = lps[j - 1];\n                else\n                    i = i + 1;\n            }\n        }\n        System.out.println(\"No pattern found\");\n\t\treturn -1;\n    }\n \n    void computeLPSArray(String pat, int M, int lps[])\n    {\n        // length of the previous longest prefix suffix\n        int len = 0;\n        int i = 1;\n        lps[0] = 0; // lps[0] is always 0\n \n        // the loop calculates lps[i] for i = 1 to M-1\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else // (pat[i] != pat[len])\n            {\n                // This is tricky. Consider the example.\n                // AAACAAAA and i = 7. The idea is similar\n                // to search step.\n                if (len != 0) {\n                    len = lps[len - 1];\n \n                    // Also, note that we do not increment\n                    // i here\n                }\n                else // if (len == 0)\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n \n\n}\n// This code has been contributed by Amit Khandelwal.",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass KMPSearchTest {\n    \n    @Test\n    // valid test case\n    public void KMPSearchTestLast() {\n    \tString txt = \"ABABDABACDABABCABAB\";\n        String pat = \"ABABCABAB\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 10);\n    \t\n    }\n    \n    @Test\n    // valid test case\n    public void KMPSearchTestFront() {\n    \tString txt = \"AAAAABAAABA\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 0);\n    \t\n    }\n    \n    @Test\n    // valid test case\n    public void KMPSearchTestMiddle() {\n    \tString txt = \"AAACAAAAAC\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 4);\n    \t\n    }\n    @Test\n    // valid test case\n    public void KMPSearchTestNotFound() {\n    \tString txt = \"AAABAAAA\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, 4);\n    \t\n    }\n    @Test\n    // not valid test case\n    public void KMPSearchTest4() {\n    \tString txt = \"AABAAA\";\n    \tString pat = \"AAAA\";\n        KMPSearch kmpSearch = new KMPSearch();\n        int value = kmpSearch.KMPSearch(pat, txt);\n        System.out.println(value);\n        assertEquals(value, -1);\n    \t\n    }\n}"
    },
    {
        "product_commit": "3918d9eaeeb305efe9ed3758fd26d51f40cc211c",
        "test_commit": "3918d9eaeeb305efe9ed3758fd26d51f40cc211c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DistanceFormula.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DistanceFormulaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class DistanceFormula {\n\tpublic static double distance(double x1, double y1, double x2, double y2)\n\t{\n\t\tdouble dX = Math.pow(x2-x1, 2);\n\t\tdouble dY = Math.pow(y2-x1, 2);\n\t\tdouble d = Math.sqrt(dX+dY);\n\t\treturn d;\n\t}\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class DistanceFormula {\n\tpublic static double euclideanDistance(double x1, double y1, double x2, double y2) {\n\t\tdouble dX = Math.pow(x2 - x1, 2);\n\t\tdouble dY = Math.pow(y2 - x1, 2);\n\t\tdouble d = Math.sqrt(dX + dY);\n\t\treturn d;\n\t}\n\n\tpublic static double manhattanDistance(double x1, double y1, double x2, double y2) {\n\t\tdouble d = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n\t\treturn d;\n\t}\n\n\tpublic static int hammingDistance(int[] b1, int[] b2) {\n\t\tint d = 0;\n\n\t\tif (b1.length != b2.length) {\n\t\t\treturn -1; // error, both array must be have the same length\n\t\t}\n\n\t\tfor (int i = 0; i < b1.length; i++) {\n\t\t\td += Math.abs(b1[i] - b2[i]);\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tpublic static double minkowskiDistance(double[] p1, double[] p2, int p) {\n\t\tdouble d = 0;\n\t\tdouble distance = 0.0;\n\n\t\tif (p1.length != p2.length) {\n\t\t\treturn -1; // error, both array must be have the same length\n\t\t}\n\n\t\tfor (int i = 0; i < p1.length; i++) {\n\t\t\tdistance += Math.abs(Math.pow(p1[i] - p2[i], p));\n\t\t}\n\n\t\tdistance = Math.pow(distance, (double) 1 / p);\n\t\td = distance;\n\t\treturn d;\n\t}\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DistanceFormulaTest\n{\n  @Test\n  void test1()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(1,1,2,2), 1.4142135623730951);\n  }\n  @Test\n  void test2()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(1,3,8,0), 7.0710678118654755);\n  }\n  @Test\n  void test3()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(2.4,9.1,55.1,100), 110.91911467371168);\n  }\n  @Test\n  void test4()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(1000,13,20000,84), 19022.067605809836);\n  }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DistanceFormulaTest {\n\t@Test\n\tvoid euclideanTest1() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(1, 1, 2, 2), 1.4142135623730951);\n\t}\n\n\t@Test\n\tvoid euclideanTest2() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(1, 3, 8, 0), 7.0710678118654755);\n\t}\n\n\t@Test\n\tvoid euclideanTest3() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(2.4, 9.1, 55.1, 100), 110.91911467371168);\n\t}\n\n\t@Test\n\tvoid euclideanTest4() {\n\t\tAssertions.assertEquals(DistanceFormula.euclideanDistance(1000, 13, 20000, 84), 19022.067605809836);\n\t}\n\n\t@Test\n\tpublic void manhattantest1() {\n\t\tassertEquals(DistanceFormula.manhattanDistance(1, 2, 3, 4), 4);\n\t}\n\n\t@Test\n\tpublic void manhattantest2() {\n\t\tassertEquals(DistanceFormula.manhattanDistance(6.5, 8.4, 20.1, 13.6), 18.8);\n\t}\n\n\t@Test\n\tpublic void manhattanTest3() {\n\t\tassertEquals(DistanceFormula.manhattanDistance(10.112, 50, 8, 25.67), 26.442);\n\t}\n\n\t@Test\n\tpublic void hammingTest1() {\n\t\tint[] array1 = { 1, 1, 1, 1 };\n\t\tint[] array2 = { 0, 0, 0, 0 };\n\t\tassertEquals(DistanceFormula.hammingDistance(array1, array2), 4);\n\t}\n\n\t@Test\n\tpublic void hammingTest2() {\n\t\tint[] array1 = { 1, 1, 1, 1 };\n\t\tint[] array2 = { 1, 1, 1, 1 };\n\t\tassertEquals(DistanceFormula.hammingDistance(array1, array2), 0);\n\t}\n\n\t@Test\n\tpublic void hammingTest3() {\n\t\tint[] array1 = { 1, 0, 0, 1, 1, 0, 1, 1, 0 };\n\t\tint[] array2 = { 0, 1, 0, 0, 1, 1, 1, 0, 0 };\n\t\tassertEquals(DistanceFormula.hammingDistance(array1, array2), 5);\n\t}\n\n\t@Test\n\tpublic void minkowskiTest1() {\n\t\tdouble[] array1 = { 1, 3, 8, 5 };\n\t\tdouble[] array2 = { 4, 2, 6, 9 };\n\t\tassertEquals(DistanceFormula.minkowskiDistance(array1, array2, 1), 10);\n\t}\n\n\t@Test\n\tpublic void minkowskiTest2() {\n\t\tdouble[] array1 = { 1, 3, 8, 5 };\n\t\tdouble[] array2 = { 4, 2, 6, 9 };\n\t\tassertEquals(DistanceFormula.minkowskiDistance(array1, array2, 2), 5.477225575051661);\n\t}\n\n\t@Test\n\tpublic void minkowskiTest3() {\n\t\tdouble[] array1 = { 1, 3, 8, 5 };\n\t\tdouble[] array2 = { 4, 2, 6, 9 };\n\t\tassertEquals(DistanceFormula.minkowskiDistance(array1, array2, 3), 4.641588833612778);\n\t}\n}"
    },
    {
        "product_commit": "ffd02504d924f8586409fa39f379c505d187f6d0",
        "test_commit": "ffd02504d924f8586409fa39f379c505d187f6d0",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/hashmap/hashing/GenericHashMapUsingArrayListTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\n\npublic class GenericHashMapUsingArrayList<K, V> {\n    ArrayList<LinkedList<Node>> buckets;\n    private float lf = 0.5f;\n    private int size;\n\n    public GenericHashMapUsingArrayList() {\n        buckets = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            buckets.add(new LinkedList<>());\n        }\n        size = 0;\n    }\n\n    public void put(K key, V value) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                node.val = value;\n                return;\n            }\n        }\n\n        nodes.add(new Node(key, value));\n        size++;\n\n        if ((float) size / buckets.size() > lf) {\n            reHash();\n        }\n    }\n\n    private void reHash() {\n        ArrayList<LinkedList<Node>> old = buckets;\n        buckets = new ArrayList<>();\n        size = 0;\n        for (int i = 0; i < old.size() * 2; i++) {\n            buckets.add(new LinkedList<>());\n        }\n        for (LinkedList<Node> nodes : buckets) {\n            for (Node node : nodes) {\n                put(node.key, node.val);\n            }\n        }\n    }\n\n    public V get(K key) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                return node.val;\n            }\n        }\n        return null;\n    }\n\n    public void remove(K key) {\n        int hash = Math.abs(key.hashCode() % buckets.size());\n        LinkedList<Node> nodes = buckets.get(hash);\n\n        Node target = null;\n        for (Node node : nodes) {\n            if (node.key.equals(key)) {\n                target = node;\n                break;\n            }\n        }\n        nodes.remove(target);\n        size--;\n    }\n\n    public boolean containsKey(K key) {\n        return get(key) != null;\n    }\n\n    public int size() {\n        return this.size;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"{\");\n        for (LinkedList<Node> nodes : buckets) {\n            for (Node node : nodes) {\n                builder.append(node.key);\n                builder.append(\" : \");\n                builder.append(node.val);\n                builder.append(\", \");\n            }\n        }\n        builder.append(\"}\");\n        return builder.toString();\n    }\n\n    private class Node {\n        K key;\n        V val;\n\n        public Node(K key, V val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.hashmap.hashing;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass GenericHashMapUsingArrayListTest {\n    @Test\n    void testGenericHashmapWhichUsesArrayAndBothKeyAndValueAreStrings() {\n        GenericHashMapUsingArrayList<String, String> map = new GenericHashMapUsingArrayList<>();\n        map.put(\"USA\", \"Washington DC\");\n        map.put(\"Nepal\", \"Kathmandu\");\n        map.put(\"India\", \"New Delhi\");\n        map.put(\"Australia\", \"Sydney\");\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(\"Kathmandu\", map.get(\"Nepal\"));\n        assertEquals(\"Sydney\", map.get(\"Australia\"));\n    }\n\n    @Test\n    void testGenericHashmapWhichUsesArrayAndKeyIsStringValueIsInteger() {\n        GenericHashMapUsingArrayList<String, Integer> map = new GenericHashMapUsingArrayList<>();\n        map.put(\"USA\", 87);\n        map.put(\"Nepal\", 25);\n        map.put(\"India\", 101);\n        map.put(\"Australia\", 99);\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(25, map.get(\"Nepal\"));\n        assertEquals(99, map.get(\"Australia\"));\n        map.remove(\"Nepal\");\n        assertFalse(map.containsKey(\"Nepal\"));\n    }\n\n    @Test\n    void testGenericHashmapWhichUsesArrayAndKeyIsIntegerValueIsString() {\n        GenericHashMapUsingArrayList<Integer, String> map = new GenericHashMapUsingArrayList<>();\n        map.put(101, \"Washington DC\");\n        map.put(34, \"Kathmandu\");\n        map.put(46, \"New Delhi\");\n        map.put(89, \"Sydney\");\n        assertNotNull(map);\n        assertEquals(4, map.size());\n        assertEquals(\"Sydney\", map.get(89));\n        assertEquals(\"Washington DC\", map.get(101));\n        assertTrue(map.containsKey(46));\n    }\n}"
    },
    {
        "product_commit": "b2f6827c365da978991c8c1639ed74953d3f8b96",
        "test_commit": "b2f6827c365da978991c8c1639ed74953d3f8b96",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DigitalRoot.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DigitalRootTest.java",
        "product_old_content": "/** Author : Suraj Kumar Modi\n * https://github.com/skmodi649\n */\n/** You are given a number n. You need to find the digital root of n.\n * DigitalRoot of a number is the recursive sum of its digits until we get a single digit number.\n *\n * Test Case 1:\n * Input:\n * n = 1\n * Output:  1\n * Explanation: Digital root of 1 is 1\n *\n * Test Case 2:\n * Input:\n * n = 99999\n * Output: 9\n * Explanation: Sum of digits of 99999 is 45\n * which is not a single digit number, hence\n * sum of digit of 45 is 9 which is a single\n * digit number.\n */\n/** Algorithm :\n * Step 1 : Define a method digitalRoot(int n)\n * Step 2 : Define another method single(int n)\n * Step 3 : digitalRoot(int n) method takes output of single(int n) as input\n * if(single(int n) <= 9)\n * return single(n)\n * else\n * return digitalRoot(single(n))\n * Step 4 : single(int n) calculates the sum of digits of number n recursively\n * if(n<=9)\n * return n;\n * else\n * return (n%10) + (n/10)\n * Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and print the result\n */\npackage com.thealgorithms.maths;\n\nimport java.util.*;\n\nclass DigitalRoot {\n\n    public static int digitalRoot(int n) {\n        if (single(n) <= 9) // If n is already single digit than simply call single method and return the value\n        {\n            return single(n);\n        } else {\n            return digitalRoot(single(n));\n        }\n    }\n\n    // This function is used for finding the sum of digits of number\n    public static int single(int n) {\n        if (n <= 9) // if n becomes less than 10 than return n\n        {\n            return n;\n        } else {\n            return (n % 10) + single(n / 10);                     // n % 10 for extracting digits one by one\n        }\n    }                                                             // n / 10 is the number obtainded after removing the digit one by one  \n    // Sum of digits is stored in the Stack memory and then finally returned\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the number : \");\n        int n = sc.nextInt();                                     // Taking a number as input from the user\n        System.out.println(\"Digital Root : \" + digitalRoot(n));     // Printing the value returned by digitalRoot() method\n    }\n}\n\n/**\n * Time Complexity : O((Number of Digits)^2) Auxiliary Space Complexity :\n * O(Number of Digits) Constraints : 1 <= n <= 10^7\n */",
        "product_new_content": "/** Author : Suraj Kumar Modi\n * https://github.com/skmodi649\n */\n/** You are given a number n. You need to find the digital root of n.\n * DigitalRoot of a number is the recursive sum of its digits until we get a single digit number.\n *\n * Test Case 1:\n * Input:\n * n = 1\n * Output:  1\n * Explanation: Digital root of 1 is 1\n *\n * Test Case 2:\n * Input:\n * n = 99999\n * Output: 9\n * Explanation: Sum of digits of 99999 is 45\n * which is not a single digit number, hence\n * sum of digit of 45 is 9 which is a single\n * digit number.\n */\n/** Algorithm :\n * Step 1 : Define a method digitalRoot(int n)\n * Step 2 : Define another method single(int n)\n * Step 3 : digitalRoot(int n) method takes output of single(int n) as input\n * if(single(int n) <= 9)\n * return single(n)\n * else\n * return digitalRoot(single(n))\n * Step 4 : single(int n) calculates the sum of digits of number n recursively\n * if(n<=9)\n * return n;\n * else\n * return (n%10) + (n/10)\n * Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and print the result\n */\npackage com.thealgorithms.maths;\n\nimport java.util.*;\n\nclass DigitalRoot {\n\n    public static int digitalRoot(int n) {\n        if (single(n) <= 9) // If n is already single digit than simply call single method and return the value\n        {\n            return single(n);\n        } else {\n            return digitalRoot(single(n));\n        }\n    }\n\n    // This function is used for finding the sum of digits of number\n    public static int single(int n) {\n        if (n <= 9) // if n becomes less than 10 than return n\n        {\n            return n;\n        } else {\n            return (n % 10) + single(n / 10);                     // n % 10 for extracting digits one by one\n        }\n    }                                                             // n / 10 is the number obtainded after removing the digit one by one  \n    // Sum of digits is stored in the Stack memory and then finally returned\n\n}\n\n/**\n * Time Complexity : O((Number of Digits)^2) Auxiliary Space Complexity :\n * O(Number of Digits) Constraints : 1 <= n <= 10^7\n */",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DigitalRootTest {\n\n    @Test\n    void testDigitalroot() {\n\n        assertEquals(4, DigitalRoot.digitalRoot(4));\n        assertEquals(9, DigitalRoot.digitalRoot(9));\n        assertEquals(4, DigitalRoot.digitalRoot(49));\n        assertEquals(6, DigitalRoot.digitalRoot(78));\n        assertEquals(4, DigitalRoot.digitalRoot(1228));\n        assertEquals(5, DigitalRoot.digitalRoot(71348));\n        \n    }\n}"
    },
    {
        "product_commit": "199c85d19177b96d6e57e7a3cb394a9394e8a8c9",
        "test_commit": "199c85d19177b96d6e57e7a3cb394a9394e8a8c9",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Polybius.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/PolybiusTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Polybius Cipher\n * Polybius is a substitution cipher method\n * It was invented by a greek philosopher that name is Polybius\n * Letters in alphabet takes place to two dimension table.\n * Encrypted text is created according to row and column in two dimension table\n * Decrypted text is generated by looking at the row and column respectively\n * Additionally, some letters in english alphabet deliberately throws such as U because U is very similar with V\n *\n * @author Hikmet \u00c7AKIR\n * @since 08-07-2022+03:00\n */\npublic class Polybius {\n\n    private static final char[][] key = {\n          //         0    1    2    3    4\n          /* 0 */  {'A', 'B', 'C', 'D', 'E'},\n          /* 1 */  {'F', 'G', 'H', 'I', 'J'},\n          /* 2 */  {'K', 'L', 'M', 'N', 'O'},\n          /* 3 */  {'P', 'Q', 'R', 'S', 'T'},\n          /* 4 */  {'V', 'W', 'X', 'Y', 'Z'}\n    };\n\n    private static String findLocationByCharacter(final char character) {\n        final StringBuilder location = new StringBuilder();\n        for (int i = 0; i < key.length; i++) {\n            for (int j = 0; j < key[i].length; j++) {\n                if (character == key[i][j]) {\n                    location.append(i).append(j);\n                    break;\n                }\n            }\n        }\n        return location.toString();\n    }\n\n    public static String encrypt(final String plaintext) {\n        final char[] chars = plaintext.toUpperCase().toCharArray();\n        final StringBuilder ciphertext = new StringBuilder();\n        for (char aChar : chars) {\n            String location = findLocationByCharacter(aChar);\n            ciphertext.append(location);\n        }\n        return ciphertext.toString();\n    }\n\n    public static String decrypt(final String ciphertext) {\n        final char[] chars = ciphertext.toCharArray();\n        final StringBuilder plaintext = new StringBuilder();\n        for(int i = 0; i < chars.length; i+=2) {\n            int pozitionX = Character.getNumericValue(chars[i]);\n            int pozitionY = Character.getNumericValue(chars[i + 1]);\n            plaintext.append(key[pozitionX][pozitionY]);\n        }\n        return plaintext.toString();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class PolybiusTest {\n\n    @Test\n    void testEncrypt() {\n        // Given\n        String plaintext = \"HELLOWORLD\";\n\n        // When\n        String actual = Polybius.encrypt(plaintext);\n\n        // Then\n        assertEquals(\"12042121244124322103\", actual);\n    }\n\n    @Test\n    void testDecrypt() {\n        // Given\n        String ciphertext = \"12042121244124322103\";\n\n        // When\n        String actual = Polybius.decrypt(ciphertext);\n\n        // Then\n        assertEquals(\"HELLOWORLD\", actual);\n    }\n\n    @Test\n    void testIsTextTheSameAfterEncryptionAndDecryption() {\n        // Given\n        String plaintext = \"HELLOWORLD\";\n\n        // When\n        String encryptedText = Polybius.encrypt(plaintext);\n        String actual = Polybius.decrypt(encryptedText);\n\n        // Then\n        assertEquals(plaintext, actual);\n    }\n}"
    },
    {
        "product_commit": "f7bd7682ba54d3e6fa93d5c80e9ae8b287d95f9c",
        "test_commit": "f7bd7682ba54d3e6fa93d5c80e9ae8b287d95f9c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Combinations.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/CombinationsTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * @see <a href=\"https://en.wikipedia.org/wiki/Combination\">Combination</a>\n */\npublic class Combinations {\n\n    public static void main(String[] args) {\n        assert combinations(1, 1) == 1;\n        assert combinations(10, 5) == 252;\n        assert combinations(6, 3) == 20;\n        assert combinations(20, 5) == 15504;\n\n        // Since, 200 is a big number its factorial will go beyond limits of long even when 200C5 can be saved in a long\n        // variable. So below will fail\n        // assert combinations(200, 5) == 2535650040l;\n        assert combinationsOptimized(100, 0) == 1;\n        assert combinationsOptimized(1, 1) == 1;\n        assert combinationsOptimized(10, 5) == 252;\n        assert combinationsOptimized(6, 3) == 20;\n        assert combinationsOptimized(20, 5) == 15504;\n        assert combinationsOptimized(200, 5) == 2535650040l;\n    }\n\n    /**\n     * Calculate of factorial\n     *\n     * @param n the number\n     * @return factorial of given number\n     */\n    public static long factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"number is negative\");\n        }\n        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);\n    }\n\n    /**\n     * Calculate combinations\n     *\n     * @param n first number\n     * @param k second number\n     * @return combinations of given {@code n} and {@code k}\n     */\n    public static long combinations(int n, int k) {\n        return factorial(n) / (factorial(k) * factorial(n - k));\n    }\n\n    /**\n     * The above method can exceed limit of long (overflow) when factorial(n) is\n     * larger than limits of long variable. Thus even if nCk is within range of\n     * long variable above reason can lead to incorrect result. This is an\n     * optimized version of computing combinations. Observations: nC(k + 1) = (n\n     * - k) * nCk / (k + 1) We know the value of nCk when k = 1 which is nCk = n\n     * Using this base value and above formula we can compute the next term\n     * nC(k+1)\n     *\n     * @param n\n     * @param k\n     * @return nCk\n     */\n    public static long combinationsOptimized(int n, int k) {\n        if (n < 0 || k < 0) {\n            throw new IllegalArgumentException(\"n or k can't be negative\");\n        }\n        if (n < k) {\n            throw new IllegalArgumentException(\"n can't be smaller than k\");\n        }\n        // nC0 is always 1\n        long solution = 1;\n        for (int i = 0; i < k; i++) {\n            long next = (n - i) * solution / (i + 1);\n            solution = next;\n        }\n        return solution;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * @see <a href=\"https://en.wikipedia.org/wiki/Combination\">Combination</a>\n */\npublic class Combinations {\n\n    /**\n     * Calculate of factorial\n     *\n     * @param n the number\n     * @return factorial of given number\n     */\n    public static long factorial(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"number is negative\");\n        }\n        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);\n    }\n\n    /**\n     * Calculate combinations\n     *\n     * @param n first number\n     * @param k second number\n     * @return combinations of given {@code n} and {@code k}\n     */\n    public static long combinations(int n, int k) {\n        return factorial(n) / (factorial(k) * factorial(n - k));\n    }\n\n    /**\n     * The above method can exceed limit of long (overflow) when factorial(n) is\n     * larger than limits of long variable. Thus even if nCk is within range of\n     * long variable above reason can lead to incorrect result. This is an\n     * optimized version of computing combinations. Observations: nC(k + 1) = (n\n     * - k) * nCk / (k + 1) We know the value of nCk when k = 1 which is nCk = n\n     * Using this base value and above formula we can compute the next term\n     * nC(k+1)\n     *\n     * @param n\n     * @param k\n     * @return nCk\n     */\n    public static long combinationsOptimized(int n, int k) {\n        if (n < 0 || k < 0) {\n            throw new IllegalArgumentException(\"n or k can't be negative\");\n        }\n        if (n < k) {\n            throw new IllegalArgumentException(\"n can't be smaller than k\");\n        }\n        // nC0 is always 1\n        long solution = 1;\n        for (int i = 0; i < k; i++) {\n            long next = (n - i) * solution / (i + 1);\n            solution = next;\n        }\n        return solution;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CombinationsTest {\n\n    @Test\n    void testCombination() {\n\n        assertEquals(1, Combinations.combinations(1, 1));\n        assertEquals(252, Combinations.combinations(10, 5));\n        assertEquals(20, Combinations.combinations(6, 3));\n        assertEquals(15504, Combinations.combinations(20, 5));\n\n    }\n\n    @Test\n    void testCombinationOptimised() {\n\n        assertEquals(100, Combinations.combinationsOptimized(100, 1));\n        assertEquals(1, Combinations.combinationsOptimized(1, 1));\n        assertEquals(252, Combinations.combinationsOptimized(10, 5));\n        assertEquals(20, Combinations.combinationsOptimized(6, 3));\n        assertEquals(15504, Combinations.combinationsOptimized(20, 5));\n        assertEquals(2535650040L, Combinations.combinationsOptimized(200, 5));\n\n    }\n}"
    },
    {
        "product_commit": "826b612d0d314f87e202d00de2c417394d8e2200",
        "test_commit": "826b612d0d314f87e202d00de2c417394d8e2200",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Ceil.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/CeilTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Random;\n\npublic class Ceil {\n\n    public static void main(String[] args) {\n        Random random = new Random();\n        for (int i = 1; i <= 1000; ++i) {\n            double randomNumber = random.nextDouble();\n            assert ceil(randomNumber) == Math.ceil(randomNumber);\n        }\n    }\n\n    /**\n     * Returns the smallest (closest to negative infinity)\n     *\n     * @param number the number\n     * @return the smallest (closest to negative infinity) of given\n     * {@code number}\n     */\n    public static double ceil(double number) {\n        if (number - (int) number == 0) {\n            return number;\n        } else if (number - (int) number > 0) {\n            return (int) (number + 1);\n        } else {\n            return (int) number;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Random;\n\npublic class Ceil {\n\n    /**\n     * Returns the smallest (closest to negative infinity)\n     *\n     * @param number the number\n     * @return the smallest (closest to negative infinity) of given\n     * {@code number}\n     */\n    public static double ceil(double number) {\n        if (number - (int) number == 0) {\n            return number;\n        } else if (number - (int) number > 0) {\n            return (int) (number + 1);\n        } else {\n            return (int) number;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class CeilTest {\n\n    @Test\n    void testCeil() {\n        assertEquals(8, Ceil.ceil(7.057));\n        assertEquals(8, Ceil.ceil(7.004));\n        assertEquals(-13, Ceil.ceil(-13.004));\n        assertEquals(1, Ceil.ceil(.98));\n        assertEquals(-11, Ceil.ceil(-11.357));\n    }\n}"
    },
    {
        "product_commit": "3fb9a606a3b75cbb6134f7a6edbebdd4c6ff042c",
        "test_commit": "3fb9a606a3b75cbb6134f7a6edbebdd4c6ff042c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/BinomialCoefficient.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/BinomialCoefficientTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Binomial Cofficients\n * Binomial Cofficients: A binomial cofficient C(n,k) gives number ways\n * in which k objects can be chosen from n objects.\n * Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class BinomialCoefficient {\n\t\n\t/**\n     * This method returns the number of ways in which k objects can be chosen from n objects\n     *\n     * @param total_objects Total number of objects\n     * @param no_of_objects Number of objects to be chosen from total_objects\n     * @return number of ways in which no_of_objects objects can be chosen from total_objects objects\n     */\n\t\n\tstatic int binomialCoefficient(int total_objects, int no_of_objects) {\n\t\t\n\t\t//Base Case\n\t\tif(no_of_objects > total_objects) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t//Base Case\n\t\tif(no_of_objects == 0 || no_of_objects == total_objects) {\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t//Recursive Call\n\t\treturn binomialCoefficient(total_objects - 1, no_of_objects - 1)\n\t\t\t\t+ binomialCoefficient(total_objects - 1, no_of_objects);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(binomialCoefficient(20,2));\n\t\t\n\t\t//Output: 190\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Binomial Cofficients\n * Binomial Cofficients: A binomial cofficient C(n,k) gives number ways\n * in which k objects can be chosen from n objects.\n * Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class BinomialCoefficient {\n\n    /**\n     * This method returns the number of ways in which k objects can be chosen from n objects\n     *\n     * @param totalObjects    Total number of objects\n     * @param numberOfObjects Number of objects to be chosen from total_objects\n     * @return number of ways in which no_of_objects objects can be chosen from total_objects objects\n     */\n\n    public static int binomialCoefficient(int totalObjects, int numberOfObjects) {\n\n        // Base Case\n        if (numberOfObjects > totalObjects) {\n            return 0;\n        }\n\n        // Base Case\n        if (numberOfObjects == 0 || numberOfObjects == totalObjects) {\n            return 1;\n        }\n\n        // Recursive Call\n        return binomialCoefficient(totalObjects - 1, numberOfObjects - 1)\n                + binomialCoefficient(totalObjects - 1, numberOfObjects);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BinomialCoefficientTest {\n\n    @Test\n    void testBinomialCoefficient() {\n\n        assertEquals(190, BinomialCoefficient.binomialCoefficient(20, 2));\n        assertEquals(792, BinomialCoefficient.binomialCoefficient(12, 5));\n        assertEquals(84, BinomialCoefficient.binomialCoefficient(9, 3));\n        assertEquals(1, BinomialCoefficient.binomialCoefficient(17, 17));\n\n    }\n}"
    },
    {
        "product_commit": "f273b30998b023e159772ebe33c89ef75e741951",
        "test_commit": "f273b30998b023e159772ebe33c89ef75e741951",
        "product_file_path": "src/main/java/com/thealgorithms/maths/BinaryPow.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/BinaryPowTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class BinaryPow {\n\n    /**\n     * Calculate a^p using binary exponentiation\n     * [Binary-Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)\n     *\n     * @param a the base for exponentiation\n     * @param p the exponent - must be greater than 0\n     * @return a^p\n     */\n    public static int binPow(int a, int p) {\n        int res = 1;\n        while (p > 0) {\n            if ((p & 1) == 1) {\n                res = res * a;\n            }\n            a = a * a;\n            p >>>= 1;\n        }\n        return res;\n    }\n\n    /**\n     * Function for testing binary exponentiation\n     *\n     * @param a the base\n     * @param p the exponent\n     */\n    public static void test(int a, int p) {\n        int res = binPow(a, p);\n        assert res == (int) Math.pow(a, p) : \"Incorrect Implementation\";\n        System.out.println(a + \"^\" + p + \": \" + res);\n    }\n\n    /**\n     * Main Function to call tests\n     *\n     * @param args System Line Arguments\n     */\n    public static void main(String[] args) {\n        // prints 2^15: 32768\n        test(2, 15);\n\n        // prints 3^9: 19683\n        test(3, 9);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class BinaryPow {\n\n    /**\n     * Calculate a^p using binary exponentiation\n     * [Binary-Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)\n     *\n     * @param a the base for exponentiation\n     * @param p the exponent - must be greater than 0\n     * @return a^p\n     */\n    public static int binPow(int a, int p) {\n        int res = 1;\n        while (p > 0) {\n            if ((p & 1) == 1) {\n                res = res * a;\n            }\n            a = a * a;\n            p >>>= 1;\n        }\n        return res;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BinaryPowTest {\n\n    @Test\n    void testBinPow() {\n        assertEquals(4, BinaryPow.binPow(2, 2));\n        assertEquals(256, BinaryPow.binPow(4, 4));\n        assertEquals(729, BinaryPow.binPow(9, 3));\n        assertEquals(262144, BinaryPow.binPow(8, 6));\n    }\n}"
    },
    {
        "product_commit": "85c836c795377749403367a2e09e0e02a3ab7d70",
        "test_commit": "85c836c795377749403367a2e09e0e02a3ab7d70",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/QuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/QuickSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Ramdomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n\n        // For integer input\n        Integer[] array = {3, 4, 1, 32, 0, 1, 5, 12, 2, 5, 7, 8, 9, 2, 44, 111, 5};\n\n        QuickSort quickSort = new QuickSort();\n        quickSort.sort(array);\n\n        // Output => 0 1 1 2 2 3 4 5 5 5 7 8 9 12 32 44 111\n        print(array);\n\n        String[] stringArray = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        quickSort.sort(stringArray);\n\n        // Output => a\tb\tc\td\te\n        print(stringArray);\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Ramdomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n * @see QuickSort\n */\nclass QuickSortTest {\n\t\n\tprivate QuickSort quickSort = new QuickSort();\n\n\t@Test\n\tvoid quickSortEmptyArrayShouldPass()\n\t{\n\t    Integer[] array = {};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortSingleValueArrayShouldPass()\n\t{\n\t    Integer[] array = {7};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {7};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortWithIntegerArrayShouldPass()\n\t{\n\t    Integer[] array = {49,4,36,9,144,1};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {1,4,9,36,49,144};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortForArrayWithNegativeValuesShouldPass()\n\t{\n\t    Integer[] array = {49,-36,-144,-49,1,9};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {-144,-49,-36,1,9,49};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\n\t@Test\n\tvoid quickSortForArrayWithDuplicateValuesShouldPass()\n\t{\n\t    Integer[] array = {36,1,49,1,4,9};\n\t    Integer[] sorted = quickSort.sort(array);\n\t    Integer[] expected = {1,1,4,9,36,49};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\t\n\t@Test\n\tvoid quickSortWithStringArrayShouldPass()\n\t{\n\t    String[] array = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n\t    String[] sorted = quickSort.sort(array);\n\t    String[] expected = {\"a\",\"b\",\"c\",\"d\",\"e\"};\n\t    assertArrayEquals(expected, sorted);\n\t}\n\t\n}"
    },
    {
        "product_commit": "d8c9c1ac85a5df66995d9cffb87a6507d20cb574",
        "test_commit": "d8c9c1ac85a5df66995d9cffb87a6507d20cb574",
        "product_file_path": "src/main/java/com/thealgorithms/strings/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/HammingDistanceTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings;\n\n/* In information theory, the Hamming distance between two strings of equal length \nis the number of positions at which the corresponding symbols are different. \nhttps://en.wikipedia.org/wiki/Hamming_distance\n*/\npublic class HammingDistance {\n\n    /**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */\n    public static int calculateHammingDistance(String s1, String s2) throws Exception {\n        if (s1.length() != s2.length()) {\n            throw new Exception(\"String lengths must be equal\");\n        }\n        \n        int stringLength = s1.length();\n        int counter = 0;\n        \n        for (int i = 0; i < stringLength; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class HammingDistanceTest {\n    @Test\n    void testHammingDistance() throws Exception {\n        assertEquals(HammingDistance.calculateHammingDistance(\"\", \"\"), 0);\n        assertEquals(HammingDistance.calculateHammingDistance(\"java\", \"java\"), 0);\n        assertEquals(HammingDistance.calculateHammingDistance(\"karolin\", \"kathrin\"), 3);\n        assertEquals(HammingDistance.calculateHammingDistance(\"kathrin\", \"kerstin\"), 4);\n        assertEquals(HammingDistance.calculateHammingDistance(\"00000\", \"11111\"), 5);\n    }\n\n    @Test\n    void testNotEqualStringLengths() {\n        Exception exception = assertThrows(Exception.class, () -> HammingDistance.calculateHammingDistance(\"ab\", \"abc\"));\n        assertEquals(\"String lengths must be equal\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "2a2c575c89c0e0d1bcbe0c270422f5d9824d01d2",
        "test_commit": "2a2c575c89c0e0d1bcbe0c270422f5d9824d01d2",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/LFUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/LFUCacheTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Java program for LFU Cache (https://en.wikipedia.org/wiki/Least_frequently_used)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class LFUCache<K,V> {\n\n\tprivate class Node {\n\t\tprivate K key;\n\t\tprivate V value;\n\t\tprivate int frequency;\n\t\tprivate Node previous;\n\t\tprivate Node next;\n\n\t\tpublic Node(K key, V value, int frequency) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t\tthis.frequency = frequency;\n\t\t}\n\t}\n\n\tprivate Node head;\n\tprivate Node tail;\n\tprivate Map<K,Node> map = null;\n\tprivate Integer capacity;\n\tprivate static final int DEFAULT_CAPACITY = 100;\n\t\n\tpublic LFUCache() {\n\t\tthis.capacity = DEFAULT_CAPACITY;\n\t}\n\n\tpublic LFUCache(Integer capacity) {\n\t\tthis.capacity = capacity;\n\t\tthis.map = new HashMap<>();\n\t}\n\t\n    /**\n     * This method returns value present in the cache corresponding to the key passed as parameter\n     *\n     * @param <K> key for which value is to be retrieved \n     * @returns <V> object corresponding to the key passed as parameter, returns null if <K> key is not present in the cache\n     */\n\tpublic V get(K key) {\n\t\tif(this.map.get(key) == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tNode node = map.get(key);\n\t\tremoveNode(node);\n\t\tnode.frequency += 1;\n\t\taddNodeWithUpdatedFrequency(node);\n\n\t\treturn node.value;\n\t}\n\n    /**\n     * This method stores <K> key and <V> value in the cache\n     *\n     * @param <K> key which is to be stored in the cache\n     * @param <V> value which is to be stored in the cache \n     */\n\tpublic void put(K key, V value) {\n\t\tif(map.containsKey(key)) {\n\t\t\tNode node =  map.get(key);\n\t\t\tnode.value = value;\n\t\t\tnode.frequency += 1;\n\t\t\tremoveNode(node);\n\t\t\taddNodeWithUpdatedFrequency(node);\n\t\t}\n\t\telse {\n\t\t\tif(map.size() >= capacity) {\n\t\t\t\tmap.remove(this.head.key);\n\t\t\t\tremoveNode(head);\n\t\t\t}\n\t\t\tNode node = new Node(key,value,1);\n\t\t\taddNodeWithUpdatedFrequency(node);\n\t\t\tmap.put(key, node);\n\t\t}\n\t}\n\n    /**\n     * This method stores the node in the cache with updated frequency\n     *\n     * @param Node node which is to be updated in the cache \n     */\n\tprivate void addNodeWithUpdatedFrequency(Node node) {\n\t\tif(tail != null && head != null) {\n\t\t\tNode temp = this.head;\n\t\t\twhile(temp != null) {\n\t\t\t\tif(temp.frequency > node.frequency) {\n\t\t\t\t\tif(temp==head) {\n\t\t\t\t\t\tnode.next = temp;\n\t\t\t\t\t\ttemp.previous = node;\n\t\t\t\t\t\tthis.head = node;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnode.next = temp;\n\t\t\t\t\t\tnode.previous = temp.previous;\n\t\t\t\t\t\ttemp.previous.next = node;\n\t\t\t\t\t\tnode.previous = temp.previous;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttemp = temp.next;\n\t\t\t\t\tif(temp == null) {\n\t\t\t\t\t\ttail.next = node;\n\t\t\t\t\t\tnode.previous = tail;\n\t\t\t\t\t\tnode.next = null;\n\t\t\t\t\t\ttail = node;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttail = node;\n\t\t\thead = tail;\n\t\t}\n\t}\n\n    /**\n     * This method removes node from the cache \n     * \n     * @param Node node which is to be removed in the cache \n     */\n\tprivate void removeNode(Node node) {\n\t\tif(node.previous != null) {\n\t\t\tnode.previous.next = node.next;\n\t\t}\n\t\telse {\n\t\t\tthis.head = node.next;\n\t\t}\n\n\t\tif(node.next != null) {\n\t\t\tnode.next.previous = node.previous;\n\t\t}\n\t\telse {\n\t\t\tthis.tail = node.previous;\n\t\t}\t\t\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass LFUCacheTest {\n\n\t@Test\n\tvoid testLFUCacheWithIntegerValueShouldPass() {\n\n\t\tLFUCache<Integer, Integer> lfuCache = new LFUCache<>(5);\n\t\tlfuCache.put(1, 10);\n\t\tlfuCache.put(2, 20);\n\t\tlfuCache.put(3, 30);\n\t\tlfuCache.put(4, 40);\n\t\tlfuCache.put(5, 50);\n\n\t\t//get method call will increase frequency of key 1 by 1\n\t\tassertEquals(10, lfuCache.get(1));\n\n\t\t//this operation will remove value with key as 2\n\t\tlfuCache.put(6, 60);\n\n\t\t//will return null as value with key 2 is now evicted\n\t\tassertEquals(null, lfuCache.get(2));\n\n\t\t//should return 60\n\t\tassertEquals(60, lfuCache.get(6));\n\n\t\t//this operation will remove value with key as 3\n\t\tlfuCache.put(7, 70);\n\n\t\tassertEquals(null, lfuCache.get(2));\n\t\tassertEquals(70, lfuCache.get(7));\n\t}\n\n\t@Test\n\tvoid testLFUCacheWithStringValueShouldPass() {\n\n\t\tLFUCache<Integer, String> lfuCache = new LFUCache<>(5);\n\t\tlfuCache.put(1, \"Alpha\");\n\t\tlfuCache.put(2, \"Beta\");\n\t\tlfuCache.put(3, \"Gamma\");\n\t\tlfuCache.put(4, \"Delta\");\n\t\tlfuCache.put(5, \"Eplison\");\n\n\t\t//get method call will increase frequency of key 1 by 1\n\t\tassertEquals(\"Alpha\", lfuCache.get(1));\n\n\t\t//this operation will remove value with key as 2\n\t\tlfuCache.put(6, \"Digamma\");\n\n\t\t//will return null as value with key 2 is now evicted\n\t\tassertEquals(null, lfuCache.get(2));\n\n\t\t//should return string Digamma\n\t\tassertEquals(\"Digamma\", lfuCache.get(6));\n\n\t\t//this operation will remove value with key as 3\n\t\tlfuCache.put(7, \"Zeta\");\n\n\t\tassertEquals(null, lfuCache.get(2));\n\t\tassertEquals(\"Zeta\", lfuCache.get(7));\n\t}\n\n}"
    },
    {
        "product_commit": "d14a5d1eed14ca9aee01e2f775c7a3128ef20659",
        "test_commit": "d14a5d1eed14ca9aee01e2f775c7a3128ef20659",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SkipList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SkipListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            current.next(i).setPrevious(i, current.previous(i));\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                .map(layer -> {\n                    StringBuilder acc = new StringBuilder();\n                    for (boolean b : layer) {\n                        if (b) {\n                            acc.append(\"[ ]\");\n                        } else {\n                            acc.append(\"---\");\n                        }\n                        acc.append(\" \");\n                    }\n                    return acc.toString();\n                })\n                .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1)\n                .mapToObj(i -> String.format(\"%3d\", i))\n                .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            if (current.next(i) != null) {\n                current.next(i).setPrevious(i, current.previous(i));\n            }\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                .map(layer -> {\n                    StringBuilder acc = new StringBuilder();\n                    for (boolean b : layer) {\n                        if (b) {\n                            acc.append(\"[ ]\");\n                        } else {\n                            acc.append(\"---\");\n                        }\n                        acc.append(\" \");\n                    }\n                    return acc.toString();\n                })\n                .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1)\n                .mapToObj(i -> String.format(\"%3d\", i))\n                .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void remove() {\n        SkipList<String> skipList = createSkipList();\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(\"a\");\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream.range(0, values.length)\n                .mapToObj(skipList::get)\n                .toArray(String[]::new);\n\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream.range(0, values.length)\n                .mapToObj(skipList::get)\n                .toArray(String[]::new);\n\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}"
    },
    {
        "product_commit": "e59568bc5e1b0aabc41bef8de0c0da918baa9bfd",
        "test_commit": "e59568bc5e1b0aabc41bef8de0c0da918baa9bfd",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SkipList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SkipListTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            current.next(i).setPrevious(i, current.previous(i));\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                .map(layer -> {\n                    StringBuilder acc = new StringBuilder();\n                    for (boolean b : layer) {\n                        if (b) {\n                            acc.append(\"[ ]\");\n                        } else {\n                            acc.append(\"---\");\n                        }\n                        acc.append(\" \");\n                    }\n                    return acc.toString();\n                })\n                .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1)\n                .mapToObj(i -> String.format(\"%3d\", i))\n                .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void remove() {\n        SkipList<String> skipList = createSkipList();\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(\"a\");\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream.range(0, values.length)\n                .mapToObj(skipList::get)\n                .toArray(String[]::new);\n\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}"
    },
    {
        "product_commit": "22be348c546fe517c12f96575191aa6413952db5",
        "test_commit": "22be348c546fe517c12f96575191aa6413952db5",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/graphs/HamiltonianCycle.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/graphs/HamiltonianCycleTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.graphs;\n\n/**\n * Java program for Hamiltonian Cycle (https://en.wikipedia.org/wiki/Hamiltonian_path)\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class HamiltonianCycle {\n\n    private int V, pathCount;\n    private int[] cycle;\n    private int[][] graph;\n\n    /**\n     * Find hamiltonian cycle for given graph G(V,E)\n     * @param graph Adjacency matrix of a graph G(V, E) \n     * for which hamiltonian path is to be found\n     * @return Array containing hamiltonian cycle \n     * else returns 1D array with value -1.\n     */\n    public int[] findHamiltonianCycle(int[][] graph){\n        this.V = graph.length;\n        this.cycle = new int[this.V+1];\n\n        //Initialize path array with -1 value\n        for(int i=0 ; i<this.cycle.length ; i++) {\n            this.cycle[i] = -1;\n        }\n\n        this.graph = graph;        \n\n        this.cycle[0] = 0;\n        this.pathCount = 1;            \n        if(!isPathFound(0)) {\n            for(int i=0 ; i<this.cycle.length ; i++) {\n                this.cycle[i] = -1;\n            }\n        }\n        else {\n        \tthis.cycle[this.cycle.length-1] = this.cycle[0];\n        }\n        \n        return cycle;\n    }\n\n    /** function to find paths recursively\n     * Find paths recursively from given vertex\n     * @param vertex Vertex from which path is to be found\n     * @returns true if path is found false otherwise\n     */\n    public boolean isPathFound(int vertex) {\n        if (this.graph[vertex][0] == 1 && this.pathCount == this.V) {\n            return true;\n        }\n\n        /** all vertices selected but last vertex not linked to 0 **/\n        if (this.pathCount == this.V) {\n            return false;\n        }\n\n        for (int v = 0; v < this.V; v++){\n            /** if connected **/\n            if (this.graph[vertex][v] == 1 ){\n                /** add to path **/            \n                this.cycle[this.pathCount++] = v;    \n\n                /** remove connection **/            \n                this.graph[vertex][v] = 0;\n                this.graph[v][vertex] = 0;\n\n                /** if vertex not already selected  solve recursively **/\n                if (!isPresent(v)) {\n                    return isPathFound(v);\n                }\n\n                /** restore connection **/\n                this.graph[vertex][v] = 1;\n                this.graph[v][vertex] = 1;\n\n                /** remove path **/\n                this.cycle[--this.pathCount] = -1;\n            }\n        }\n        return false;\n    }    \n\n    /** function to check if path is already selected\n     * Check if path is already selected\n     * @param vertex Starting vertex \n     */\n    public boolean isPresent(int vertex){\n\n        for (int i = 0; i < pathCount - 1; i++) {\n            if (cycle[i] == vertex) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.graphs;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass HamiltonianCycleTest {\n\n\tprivate HamiltonianCycle hamiltonianCycle = new HamiltonianCycle();\n\n\t@Test\n\tvoid testFindHamiltonianCycleShouldReturnHamiltonianCycle() {\n\t\tint[] expectedArray = {0,1,2,4,3,0};\n\t\tint[][] inputArray =  {\n\t\t\t\t{0, 1, 0, 1, 0},\n\t\t\t\t{1, 0, 1, 1, 1},\n\t\t\t\t{0, 1, 0, 0, 1},\n\t\t\t\t{1, 1, 0, 0, 1},\n\t\t\t\t{0, 1, 1, 1, 0}\n\t\t};\n\n\t\tassertArrayEquals(expectedArray, hamiltonianCycle.findHamiltonianCycle(inputArray));\n\t}\n\n\t@Test\n\tvoid testFindHamiltonianCycleShouldReturnInfinityArray() {\n\t\tint[] expectedArray = {-1,-1,-1,-1,-1,-1};\n\n\t\tint[][] inputArray =  {\n\t\t\t\t{0, 1, 0, 1, 0},\n\t\t\t\t{1, 0, 1, 1, 1},\n\t\t\t\t{0, 1, 0, 0, 1},\n\t\t\t\t{1, 1, 0, 0, 0},\n\t\t\t\t{0, 1, 1, 0, 0}\n\t\t};\n\n\t\tassertArrayEquals(expectedArray, hamiltonianCycle.findHamiltonianCycle(inputArray));\n\t}\n}"
    },
    {
        "product_commit": "6c4092a46b9c313b543955d3d2c091889262937d",
        "test_commit": "6c4092a46b9c313b543955d3d2c091889262937d",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/TopologicalSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/TopologicalSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.*;\n\n/**\n * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into\n * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is\n * performed, yielding no back-edges.\n *\n * https://en.wikipedia.org/wiki/Topological_sorting\n *\n * @author Jonathan Taylor (https://github.com/Jtmonument)\n * Based on Introduction to Algorithms 3rd Edition\n */\npublic class TopologicalSort {\n\n     /*\n     * Enum to represent the colors for the depth first search\n     * */\n    private enum Color {\n        WHITE, GRAY, BLACK\n    }\n\n     /*\n     * Class to represent vertices\n     * */\n    private static class Vertex {\n        /*\n        * Name of vertex\n        * */\n        public final String label;\n\n        /*\n        * Weight of vertex\n        * (more accurately defined as the time that a vertex has begun a visit in DFS)\n        * */\n        public int weight;\n\n        /*\n        * The time that the vertex has finished a visit in DFS\n        * */\n        public int finished;\n\n        /*\n        * \u03c0 parent of the vertex\n        * */\n        public Vertex predecessor;\n\n        /*\n        * Represents the category of visit in DFS\n        * */\n        public Color color = Color.WHITE;\n\n        /*\n        * The array of names of descendant vertices\n        * */\n        public final ArrayList<String> next = new ArrayList<>();\n\n        public Vertex(String label) {\n            this.label = label;\n        }\n     }\n\n     /*\n     * Graph class uses the adjacency list representation\n     * */\n    static class Graph {\n\n        /*\n         * Adjacency list representation\n         * */\n        private final HashMap<String, Vertex> adj = new LinkedHashMap<>();\n\n        /*\n         * Function to add an edge to the graph\n         * */\n        public void addEdge(String label, String... next) {\n            adj.put(label, new Vertex(label));\n            if (!next[0].isEmpty())\n                Collections.addAll(adj.get(label).next, next);\n        }\n    }\n\n    static class BackEdgeException extends RuntimeException {\n\n        public BackEdgeException(String backEdge) {\n            super(\"This graph contains a cycle. No linear ordering is possible. \" + backEdge);\n        }\n\n    }\n\n    /*\n     * Time variable in DFS\n     * */\n    private static int time;\n\n    /*\n     * Depth First Search\n     *\n     * DFS(G)\n     *   for each vertex u \u2208 G.V\n     *       u.color = WHITE\n     *       u.\u03c0 = NIL\n     *   time = 0\n     *   for each vertex u \u2208 G.V\n     *   if u.color == WHITE\n     *       DFS-VISIT(G, u)\n     *\n     * Performed in \u0398(V + E) time\n     * */\n    public static LinkedList<String> sort(Graph graph) {\n        LinkedList<String> list = new LinkedList<>();\n        graph.adj.forEach((name, vertex) -> {\n            if (vertex.color == Color.WHITE) {\n                list.addFirst(sort(graph, vertex, list));\n            }\n        });\n        return list;\n    }\n\n    /*\n     * Depth First Search Visit\n     *\n     * DFS-Visit(G, u)\n     *   time = time + 1\n     *   u.d = time\n     *   u.color = GRAY\n     *   for each v \u2208 G.Adj[u]\n     *       if v.color == WHITE\n     *           v.\u03c0 = u\n     *           DFS-Visit(G, u)\n     *   u.color = BLACK\n     *   time = time + 1\n     *   u.f = time\n     * */\n    private static String sort(Graph graph, Vertex u, LinkedList<String> list) {\n        time++;\n        u.weight = time;\n        u.color = Color.GRAY;\n        graph.adj.get(u.label).next.forEach(label -> {\n            if (graph.adj.get(label).color == Color.WHITE) {\n                graph.adj.get(label).predecessor = u;\n                list.addFirst(sort(graph, graph.adj.get(label), list));\n            } else if (graph.adj.get(label).color == Color.GRAY) {\n                /*\n                 * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v\n                 * in a depth first tree. If v.d \u2264 u.d < u.f \u2264 v.f\n                 *\n                 * In many cases, we will not know u.f, but v.color denotes the type of edge\n                 * */\n                throw new BackEdgeException(\"Back edge: \" + u.label + \" -> \" + label);\n            }\n        });\n        u.color = Color.BLACK;\n        time++;\n        u.finished = time;\n        return u.label;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport com.thealgorithms.sorts.TopologicalSort.Graph;\nimport com.thealgorithms.sorts.TopologicalSort.BackEdgeException;\n\nimport java.util.LinkedList;\n\nclass TopologicalSortTest {\n    @Test\n    void successTest() {\n        /*\n         * Professor Bumstead example DAG. Each directed edge means that garment u must be put on\n         * before garment v.\n         * */\n        Graph graph = new Graph();\n        graph.addEdge(\"shirt\", \"tie\", \"belt\");\n        graph.addEdge(\"tie\", \"jacket\");\n        graph.addEdge(\"belt\", \"jacket\");\n        graph.addEdge(\"watch\", \"\");\n        graph.addEdge(\"undershorts\", \"pants\", \"shoes\");\n        graph.addEdge(\"shoes\", \"\");\n        graph.addEdge(\"socks\", \"shoes\");\n        graph.addEdge(\"jacket\",\"\");\n        graph.addEdge(\"pants\", \"belt\", \"shoes\");\n        LinkedList<String> expected = new LinkedList<>();\n        expected.add(\"socks\");\n        expected.add(\"undershorts\");\n        expected.add(\"pants\");\n        expected.add(\"shoes\");\n        expected.add(\"watch\");\n        expected.add(\"shirt\");\n        expected.add(\"belt\");\n        expected.add(\"tie\");\n        expected.add(\"jacket\");\n        assertIterableEquals(expected, TopologicalSort.sort(graph));\n    }\n\n    @Test\n    public void failureTest() {\n\n        /*\n        * Graph example from Geeks For Geeks\n        * https://www.geeksforgeeks.org/tree-back-edge-and-cross-edges-in-dfs-of-graph/\n        * */\n        Graph graph = new Graph();\n        graph.addEdge(\"1\", \"2\", \"3\", \"8\");\n        graph.addEdge(\"2\", \"4\");\n        graph.addEdge(\"3\", \"5\");\n        graph.addEdge(\"4\", \"6\");\n        graph.addEdge(\"5\", \"4\", \"7\", \"8\");\n        graph.addEdge(\"6\", \"2\");\n        graph.addEdge(\"7\", \"\");\n        graph.addEdge(\"8\", \"\");\n        Exception exception = assertThrows(BackEdgeException.class, () -> TopologicalSort.sort(graph));\n        String expected = \"This graph contains a cycle. No linear ordering is possible. \" +\n                \"Back edge: 6 -> 2\";\n        assertEquals(exception.getMessage(), expected);\n    }\n}"
    },
    {
        "product_commit": "bb5b50dea2a6781c1eb8a0c003d0d1839d1319e0",
        "test_commit": "bb5b50dea2a6781c1eb8a0c003d0d1839d1319e0",
        "product_file_path": "src/main/java/com/thealgorithms/maths/StandardScore.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/StandardScoreTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class StandardScore {\n\tpublic static double zScore(double num, double mean, double stdDev)\n\t{\n\t\tdouble z = (num - mean)/stdDev;\n\t\treturn z;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StandardScoreTest{\n  @Test\n  void test1()\n  {\n    Assertions.assertEquals(StandardScore.zScore(2, 0, 5), 0.4);\n  }\n  @Test\n  void test2()\n  {\n    Assertions.assertEquals(StandardScore.zScore(1, 1, 1), 0.0);\n  }\n  @Test\n  void test3()\n  {\n    Assertions.assertEquals(StandardScore.zScore(2.5, 1.8, 0.7), 1.0);\n  }\n  @Test\n  void test4()\n  {\n    Assertions.assertEquals(StandardScore.zScore(8.9, 3, 4.2), 1.4047619047619049);\n  }\n}"
    },
    {
        "product_commit": "2e09e44a38d9184f312d69f1ae046f5addb6ef1f",
        "test_commit": "2e09e44a38d9184f312d69f1ae046f5addb6ef1f",
        "product_file_path": "src/main/java/com/thealgorithms/strings/longestNonRepeativeSubstring.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/longestNonRepeativeSubstringTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings ;\nimport java.util.HashMap ;\nclass longestNonRepeativeSubstring {\n\n    public static int lengthOfLongestSubstring(String s) {\n    \n        int max = 0 , start = 0 , i = 0 ;\n        HashMap< Character , Integer > map = new HashMap<>() ;\n    \n        while ( i < s.length() ) {\n\n            char temp = s.charAt( i ) ;\n\n            // adding key to map if not present\n            if ( ! map.containsKey( temp ) )\n                map.put( temp , 0 ) ;\n\n            // checking if the first value is the dublicate value\n            else if ( s.charAt( start ) == temp )\n                start++ ;\n\n            // checking if the previous value is dublicate value\n            else if ( s.charAt( i - 1 )  == temp ) {\n                if ( max < map.size() ) max = map.size() ;\n                map = new HashMap<>() ;\n                start = i ;\n                i-- ;\n            }\n\n            // last possible place where dublicate value can be is between start and i\n            else {\n                if ( max < map.size() ) max = map.size() ;\n                while ( s.charAt( start ) != temp ) {\n                    map.remove( s.charAt( start ) ) ;\n                    start++ ;\n                }\n                start++ ;\n            }\n\n            i++ ;\n\n        }\n        if ( max < map.size() ) max = map.size() ;\n        return max ;\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class longestNonRepeativeSubstringTest {\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorld\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals( longestNonRepeativeSubstring.lengthOfLongestSubstring( input1 ) , 5 ) ;\n        Assertions.assertEquals( longestNonRepeativeSubstring.lengthOfLongestSubstring( input2 ) , 9 ) ;\n    }\n}"
    },
    {
        "product_commit": "2e09e44a38d9184f312d69f1ae046f5addb6ef1f",
        "test_commit": "2e09e44a38d9184f312d69f1ae046f5addb6ef1f",
        "product_file_path": "src/main/java/com/thealgorithms/strings/zigZagPattern/zigZagPattern.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/zigZagPattern/zigZagPatternTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.strings.zigZagPattern;\nclass zigZagPattern {\n\n    public static String encode(String s, int numRows) {\n        if ( numRows < 2 || s.length() < numRows ) return s ;\n        int start = 0 , index = 0 , height = 1 , depth = numRows ;\n        char[] zigZagedArray = new char[ s.length() ] ;\n        while ( depth != 0 ) {\n            int pointer = start , height_space = 2 + ( ( height - 2 ) * 2 ) , depth_space = 2 + ( ( depth - 2 ) * 2 ) ;\n            boolean bool = true ;\n            while ( pointer < s.length() ) {\n                zigZagedArray[index++] = s.charAt( pointer ) ;\n                if ( height_space == 0 ) pointer += depth_space ;\n                else if ( depth_space == 0 ) pointer += height_space ;\n                else if ( bool ) {\n                    pointer += depth_space ;\n                    bool = false ;\n                } else {\n                    pointer += height_space ;\n                    bool = true ;\n                }\n            }\n            height++ ;\n            depth-- ;\n            start++ ;\n        }\n        return new String( zigZagedArray ) ;\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings.zigZagPattern;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class zigZagPatternTest {\n    @Test\n    public void palindrome() {\n        String input1 = \"HelloWorldFromJava\";\n        String input2 = \"javaIsAProgrammingLanguage\";\n        Assertions.assertEquals( zigZagPattern.encode( input1 , 4 ) , \"HooeWrrmalolFJvlda\" ) ;\n        Assertions.assertEquals( zigZagPattern.encode( input2 , 4 ) , \"jAaLgasPrmgaaevIrgmnnuaoig\" ) ;\n    }\n}"
    },
    {
        "product_commit": "f9b788f7f46c0432e95f7116987d14937953729c",
        "test_commit": "f9b788f7f46c0432e95f7116987d14937953729c",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/Blowfish.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/BlowfishTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.ciphers;\n\n/*\n * Java program for Blowfish Algorithm \n * Wikipedia: https://en.wikipedia.org/wiki/Blowfish_(cipher)\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class Blowfish {\n\t\n\t//Initializing substitution boxes\n\tString S[][]\n\t\t\t= { { \"d1310ba6\", \"98dfb5ac\", \"2ffd72db\", \"d01adfb7\", \"b8e1afed\",\n\t\t\t\t\"6a267e96\", \"ba7c9045\", \"f12c7f99\", \"24a19947\", \"b3916cf7\",\n\t\t\t\t\"0801f2e2\", \"858efc16\", \"636920d8\", \"71574e69\", \"a458fea3\",\n\t\t\t\t\"f4933d7e\", \"0d95748f\", \"728eb658\", \"718bcd58\", \"82154aee\",\n\t\t\t\t\"7b54a41d\", \"c25a59b5\", \"9c30d539\", \"2af26013\", \"c5d1b023\",\n\t\t\t\t\"286085f0\", \"ca417918\", \"b8db38ef\", \"8e79dcb0\", \"603a180e\",\n\t\t\t\t\"6c9e0e8b\", \"b01e8a3e\", \"d71577c1\", \"bd314b27\", \"78af2fda\",\n\t\t\t\t\"55605c60\", \"e65525f3\", \"aa55ab94\", \"57489862\", \"63e81440\",\n\t\t\t\t\"55ca396a\", \"2aab10b6\", \"b4cc5c34\", \"1141e8ce\", \"a15486af\",\n\t\t\t\t\"7c72e993\", \"b3ee1411\", \"636fbc2a\", \"2ba9c55d\", \"741831f6\",\n\t\t\t\t\"ce5c3e16\", \"9b87931e\", \"afd6ba33\", \"6c24cf5c\", \"7a325381\",\n\t\t\t\t\"28958677\", \"3b8f4898\", \"6b4bb9af\", \"c4bfe81b\", \"66282193\",\n\t\t\t\t\"61d809cc\", \"fb21a991\", \"487cac60\", \"5dec8032\", \"ef845d5d\",\n\t\t\t\t\"e98575b1\", \"dc262302\", \"eb651b88\", \"23893e81\", \"d396acc5\",\n\t\t\t\t\"0f6d6ff3\", \"83f44239\", \"2e0b4482\", \"a4842004\", \"69c8f04a\",\n\t\t\t\t\"9e1f9b5e\", \"21c66842\", \"f6e96c9a\", \"670c9c61\", \"abd388f0\",\n\t\t\t\t\"6a51a0d2\", \"d8542f68\", \"960fa728\", \"ab5133a3\", \"6eef0b6c\",\n\t\t\t\t\"137a3be4\", \"ba3bf050\", \"7efb2a98\", \"a1f1651d\", \"39af0176\",\n\t\t\t\t\"66ca593e\", \"82430e88\", \"8cee8619\", \"456f9fb4\", \"7d84a5c3\",\n\t\t\t\t\"3b8b5ebe\", \"e06f75d8\", \"85c12073\", \"401a449f\", \"56c16aa6\",\n\t\t\t\t\"4ed3aa62\", \"363f7706\", \"1bfedf72\", \"429b023d\", \"37d0d724\",\n\t\t\t\t\"d00a1248\", \"db0fead3\", \"49f1c09b\", \"075372c9\", \"80991b7b\",\n\t\t\t\t\"25d479d8\", \"f6e8def7\", \"e3fe501a\", \"b6794c3b\", \"976ce0bd\",\n\t\t\t\t\"04c006ba\", \"c1a94fb6\", \"409f60c4\", \"5e5c9ec2\", \"196a2463\",\n\t\t\t\t\"68fb6faf\", \"3e6c53b5\", \"1339b2eb\", \"3b52ec6f\", \"6dfc511f\",\n\t\t\t\t\"9b30952c\", \"cc814544\", \"af5ebd09\", \"bee3d004\", \"de334afd\",\n\t\t\t\t\"660f2807\", \"192e4bb3\", \"c0cba857\", \"45c8740f\", \"d20b5f39\",\n\t\t\t\t\"b9d3fbdb\", \"5579c0bd\", \"1a60320a\", \"d6a100c6\", \"402c7279\",\n\t\t\t\t\"679f25fe\", \"fb1fa3cc\", \"8ea5e9f8\", \"db3222f8\", \"3c7516df\",\n\t\t\t\t\"fd616b15\", \"2f501ec8\", \"ad0552ab\", \"323db5fa\", \"fd238760\",\n\t\t\t\t\"53317b48\", \"3e00df82\", \"9e5c57bb\", \"ca6f8ca0\", \"1a87562e\",\n\t\t\t\t\"df1769db\", \"d542a8f6\", \"287effc3\", \"ac6732c6\", \"8c4f5573\",\n\t\t\t\t\"695b27b0\", \"bbca58c8\", \"e1ffa35d\", \"b8f011a0\", \"10fa3d98\",\n\t\t\t\t\"fd2183b8\", \"4afcb56c\", \"2dd1d35b\", \"9a53e479\", \"b6f84565\",\n\t\t\t\t\"d28e49bc\", \"4bfb9790\", \"e1ddf2da\", \"a4cb7e33\", \"62fb1341\",\n\t\t\t\t\"cee4c6e8\", \"ef20cada\", \"36774c01\", \"d07e9efe\", \"2bf11fb4\",\n\t\t\t\t\"95dbda4d\", \"ae909198\", \"eaad8e71\", \"6b93d5a0\", \"d08ed1d0\",\n\t\t\t\t\"afc725e0\", \"8e3c5b2f\", \"8e7594b7\", \"8ff6e2fb\", \"f2122b64\",\n\t\t\t\t\"8888b812\", \"900df01c\", \"4fad5ea0\", \"688fc31c\", \"d1cff191\",\n\t\t\t\t\"b3a8c1ad\", \"2f2f2218\", \"be0e1777\", \"ea752dfe\", \"8b021fa1\",\n\t\t\t\t\"e5a0cc0f\", \"b56f74e8\", \"18acf3d6\", \"ce89e299\", \"b4a84fe0\",\n\t\t\t\t\"fd13e0b7\", \"7cc43b81\", \"d2ada8d9\", \"165fa266\", \"80957705\",\n\t\t\t\t\"93cc7314\", \"211a1477\", \"e6ad2065\", \"77b5fa86\", \"c75442f5\",\n\t\t\t\t\"fb9d35cf\", \"ebcdaf0c\", \"7b3e89a0\", \"d6411bd3\", \"ae1e7e49\",\n\t\t\t\t\"00250e2d\", \"2071b35e\", \"226800bb\", \"57b8e0af\", \"2464369b\",\n\t\t\t\t\"f009b91e\", \"5563911d\", \"59dfa6aa\", \"78c14389\", \"d95a537f\",\n\t\t\t\t\"207d5ba2\", \"02e5b9c5\", \"83260376\", \"6295cfa9\", \"11c81968\",\n\t\t\t\t\"4e734a41\", \"b3472dca\", \"7b14a94a\", \"1b510052\", \"9a532915\",\n\t\t\t\t\"d60f573f\", \"bc9bc6e4\", \"2b60a476\", \"81e67400\", \"08ba6fb5\",\n\t\t\t\t\"571be91f\", \"f296ec6b\", \"2a0dd915\", \"b6636521\", \"e7b9f9b6\",\n\t\t\t\t\"ff34052e\", \"c5855664\", \"53b02d5d\", \"a99f8fa1\", \"08ba4799\",\n\t\t\t\"6e85076a\" },\n\t\t\t\t\t{ \"4b7a70e9\", \"b5b32944\", \"db75092e\", \"c4192623\", \"ad6ea6b0\",\n\t\t\t\t\"49a7df7d\", \"9cee60b8\", \"8fedb266\", \"ecaa8c71\", \"699a17ff\",\n\t\t\t\t\"5664526c\", \"c2b19ee1\", \"193602a5\", \"75094c29\", \"a0591340\",\n\t\t\t\t\"e4183a3e\", \"3f54989a\", \"5b429d65\", \"6b8fe4d6\", \"99f73fd6\",\n\t\t\t\t\"a1d29c07\", \"efe830f5\", \"4d2d38e6\", \"f0255dc1\", \"4cdd2086\",\n\t\t\t\t\"8470eb26\", \"6382e9c6\", \"021ecc5e\", \"09686b3f\", \"3ebaefc9\",\n\t\t\t\t\"3c971814\", \"6b6a70a1\", \"687f3584\", \"52a0e286\", \"b79c5305\",\n\t\t\t\t\"aa500737\", \"3e07841c\", \"7fdeae5c\", \"8e7d44ec\", \"5716f2b8\",\n\t\t\t\t\"b03ada37\", \"f0500c0d\", \"f01c1f04\", \"0200b3ff\", \"ae0cf51a\",\n\t\t\t\t\"3cb574b2\", \"25837a58\", \"dc0921bd\", \"d19113f9\", \"7ca92ff6\",\n\t\t\t\t\"94324773\", \"22f54701\", \"3ae5e581\", \"37c2dadc\", \"c8b57634\",\n\t\t\t\t\"9af3dda7\", \"a9446146\", \"0fd0030e\", \"ecc8c73e\", \"a4751e41\",\n\t\t\t\t\"e238cd99\", \"3bea0e2f\", \"3280bba1\", \"183eb331\", \"4e548b38\",\n\t\t\t\t\"4f6db908\", \"6f420d03\", \"f60a04bf\", \"2cb81290\", \"24977c79\",\n\t\t\t\t\"5679b072\", \"bcaf89af\", \"de9a771f\", \"d9930810\", \"b38bae12\",\n\t\t\t\t\"dccf3f2e\", \"5512721f\", \"2e6b7124\", \"501adde6\", \"9f84cd87\",\n\t\t\t\t\"7a584718\", \"7408da17\", \"bc9f9abc\", \"e94b7d8c\", \"ec7aec3a\",\n\t\t\t\t\"db851dfa\", \"63094366\", \"c464c3d2\", \"ef1c1847\", \"3215d908\",\n\t\t\t\t\"dd433b37\", \"24c2ba16\", \"12a14d43\", \"2a65c451\", \"50940002\",\n\t\t\t\t\"133ae4dd\", \"71dff89e\", \"10314e55\", \"81ac77d6\", \"5f11199b\",\n\t\t\t\t\"043556f1\", \"d7a3c76b\", \"3c11183b\", \"5924a509\", \"f28fe6ed\",\n\t\t\t\t\"97f1fbfa\", \"9ebabf2c\", \"1e153c6e\", \"86e34570\", \"eae96fb1\",\n\t\t\t\t\"860e5e0a\", \"5a3e2ab3\", \"771fe71c\", \"4e3d06fa\", \"2965dcb9\",\n\t\t\t\t\"99e71d0f\", \"803e89d6\", \"5266c825\", \"2e4cc978\", \"9c10b36a\",\n\t\t\t\t\"c6150eba\", \"94e2ea78\", \"a5fc3c53\", \"1e0a2df4\", \"f2f74ea7\",\n\t\t\t\t\"361d2b3d\", \"1939260f\", \"19c27960\", \"5223a708\", \"f71312b6\",\n\t\t\t\t\"ebadfe6e\", \"eac31f66\", \"e3bc4595\", \"a67bc883\", \"b17f37d1\",\n\t\t\t\t\"018cff28\", \"c332ddef\", \"be6c5aa5\", \"65582185\", \"68ab9802\",\n\t\t\t\t\"eecea50f\", \"db2f953b\", \"2aef7dad\", \"5b6e2f84\", \"1521b628\",\n\t\t\t\t\"29076170\", \"ecdd4775\", \"619f1510\", \"13cca830\", \"eb61bd96\",\n\t\t\t\t\"0334fe1e\", \"aa0363cf\", \"b5735c90\", \"4c70a239\", \"d59e9e0b\",\n\t\t\t\t\"cbaade14\", \"eecc86bc\", \"60622ca7\", \"9cab5cab\", \"b2f3846e\",\n\t\t\t\t\"648b1eaf\", \"19bdf0ca\", \"a02369b9\", \"655abb50\", \"40685a32\",\n\t\t\t\t\"3c2ab4b3\", \"319ee9d5\", \"c021b8f7\", \"9b540b19\", \"875fa099\",\n\t\t\t\t\"95f7997e\", \"623d7da8\", \"f837889a\", \"97e32d77\", \"11ed935f\",\n\t\t\t\t\"16681281\", \"0e358829\", \"c7e61fd6\", \"96dedfa1\", \"7858ba99\",\n\t\t\t\t\"57f584a5\", \"1b227263\", \"9b83c3ff\", \"1ac24696\", \"cdb30aeb\",\n\t\t\t\t\"532e3054\", \"8fd948e4\", \"6dbc3128\", \"58ebf2ef\", \"34c6ffea\",\n\t\t\t\t\"fe28ed61\", \"ee7c3c73\", \"5d4a14d9\", \"e864b7e3\", \"42105d14\",\n\t\t\t\t\"203e13e0\", \"45eee2b6\", \"a3aaabea\", \"db6c4f15\", \"facb4fd0\",\n\t\t\t\t\"c742f442\", \"ef6abbb5\", \"654f3b1d\", \"41cd2105\", \"d81e799e\",\n\t\t\t\t\"86854dc7\", \"e44b476a\", \"3d816250\", \"cf62a1f2\", \"5b8d2646\",\n\t\t\t\t\"fc8883a0\", \"c1c7b6a3\", \"7f1524c3\", \"69cb7492\", \"47848a0b\",\n\t\t\t\t\"5692b285\", \"095bbf00\", \"ad19489d\", \"1462b174\", \"23820e00\",\n\t\t\t\t\"58428d2a\", \"0c55f5ea\", \"1dadf43e\", \"233f7061\", \"3372f092\",\n\t\t\t\t\"8d937e41\", \"d65fecf1\", \"6c223bdb\", \"7cde3759\", \"cbee7460\",\n\t\t\t\t\"4085f2a7\", \"ce77326e\", \"a6078084\", \"19f8509e\", \"e8efd855\",\n\t\t\t\t\"61d99735\", \"a969a7aa\", \"c50c06c2\", \"5a04abfc\", \"800bcadc\",\n\t\t\t\t\"9e447a2e\", \"c3453484\", \"fdd56705\", \"0e1e9ec9\", \"db73dbd3\",\n\t\t\t\t\"105588cd\", \"675fda79\", \"e3674340\", \"c5c43465\", \"713e38d8\",\n\t\t\t\t\"3d28f89e\", \"f16dff20\", \"153e21e7\", \"8fb03d4a\", \"e6e39f2b\",\n\t\t\t\t\t\"db83adf7\" },\n\t\t\t\t\t{ \"e93d5a68\", \"948140f7\", \"f64c261c\", \"94692934\", \"411520f7\",\n\t\t\t\t\t\t\"7602d4f7\", \"bcf46b2e\", \"d4a20068\", \"d4082471\", \"3320f46a\",\n\t\t\t\t\t\t\"43b7d4b7\", \"500061af\", \"1e39f62e\", \"97244546\", \"14214f74\",\n\t\t\t\t\t\t\"bf8b8840\", \"4d95fc1d\", \"96b591af\", \"70f4ddd3\", \"66a02f45\",\n\t\t\t\t\t\t\"bfbc09ec\", \"03bd9785\", \"7fac6dd0\", \"31cb8504\", \"96eb27b3\",\n\t\t\t\t\t\t\"55fd3941\", \"da2547e6\", \"abca0a9a\", \"28507825\", \"530429f4\",\n\t\t\t\t\t\t\"0a2c86da\", \"e9b66dfb\", \"68dc1462\", \"d7486900\", \"680ec0a4\",\n\t\t\t\t\t\t\"27a18dee\", \"4f3ffea2\", \"e887ad8c\", \"b58ce006\", \"7af4d6b6\",\n\t\t\t\t\t\t\"aace1e7c\", \"d3375fec\", \"ce78a399\", \"406b2a42\", \"20fe9e35\",\n\t\t\t\t\t\t\"d9f385b9\", \"ee39d7ab\", \"3b124e8b\", \"1dc9faf7\", \"4b6d1856\",\n\t\t\t\t\t\t\"26a36631\", \"eae397b2\", \"3a6efa74\", \"dd5b4332\", \"6841e7f7\",\n\t\t\t\t\t\t\"ca7820fb\", \"fb0af54e\", \"d8feb397\", \"454056ac\", \"ba489527\",\n\t\t\t\t\t\t\"55533a3a\", \"20838d87\", \"fe6ba9b7\", \"d096954b\", \"55a867bc\",\n\t\t\t\t\t\t\"a1159a58\", \"cca92963\", \"99e1db33\", \"a62a4a56\", \"3f3125f9\",\n\t\t\t\t\t\t\"5ef47e1c\", \"9029317c\", \"fdf8e802\", \"04272f70\", \"80bb155c\",\n\t\t\t\t\t\t\"05282ce3\", \"95c11548\", \"e4c66d22\", \"48c1133f\", \"c70f86dc\",\n\t\t\t\t\t\t\"07f9c9ee\", \"41041f0f\", \"404779a4\", \"5d886e17\", \"325f51eb\",\n\t\t\t\t\t\t\"d59bc0d1\", \"f2bcc18f\", \"41113564\", \"257b7834\", \"602a9c60\",\n\t\t\t\t\t\t\"dff8e8a3\", \"1f636c1b\", \"0e12b4c2\", \"02e1329e\", \"af664fd1\",\n\t\t\t\t\t\t\"cad18115\", \"6b2395e0\", \"333e92e1\", \"3b240b62\", \"eebeb922\",\n\t\t\t\t\t\t\"85b2a20e\", \"e6ba0d99\", \"de720c8c\", \"2da2f728\", \"d0127845\",\n\t\t\t\t\t\t\"95b794fd\", \"647d0862\", \"e7ccf5f0\", \"5449a36f\", \"877d48fa\",\n\t\t\t\t\t\t\"c39dfd27\", \"f33e8d1e\", \"0a476341\", \"992eff74\", \"3a6f6eab\",\n\t\t\t\t\t\t\"f4f8fd37\", \"a812dc60\", \"a1ebddf8\", \"991be14c\", \"db6e6b0d\",\n\t\t\t\t\t\t\"c67b5510\", \"6d672c37\", \"2765d43b\", \"dcd0e804\", \"f1290dc7\",\n\t\t\t\t\t\t\"cc00ffa3\", \"b5390f92\", \"690fed0b\", \"667b9ffb\", \"cedb7d9c\",\n\t\t\t\t\t\t\"a091cf0b\", \"d9155ea3\", \"bb132f88\", \"515bad24\", \"7b9479bf\",\n\t\t\t\t\t\t\"763bd6eb\", \"37392eb3\", \"cc115979\", \"8026e297\", \"f42e312d\",\n\t\t\t\t\t\t\"6842ada7\", \"c66a2b3b\", \"12754ccc\", \"782ef11c\", \"6a124237\",\n\t\t\t\t\t\t\"b79251e7\", \"06a1bbe6\", \"4bfb6350\", \"1a6b1018\", \"11caedfa\",\n\t\t\t\t\t\t\"3d25bdd8\", \"e2e1c3c9\", \"44421659\", \"0a121386\", \"d90cec6e\",\n\t\t\t\t\t\t\"d5abea2a\", \"64af674e\", \"da86a85f\", \"bebfe988\", \"64e4c3fe\",\n\t\t\t\t\t\t\"9dbc8057\", \"f0f7c086\", \"60787bf8\", \"6003604d\", \"d1fd8346\",\n\t\t\t\t\t\t\"f6381fb0\", \"7745ae04\", \"d736fccc\", \"83426b33\", \"f01eab71\",\n\t\t\t\t\t\t\"b0804187\", \"3c005e5f\", \"77a057be\", \"bde8ae24\", \"55464299\",\n\t\t\t\t\t\t\"bf582e61\", \"4e58f48f\", \"f2ddfda2\", \"f474ef38\", \"8789bdc2\",\n\t\t\t\t\t\t\"5366f9c3\", \"c8b38e74\", \"b475f255\", \"46fcd9b9\", \"7aeb2661\",\n\t\t\t\t\t\t\"8b1ddf84\", \"846a0e79\", \"915f95e2\", \"466e598e\", \"20b45770\",\n\t\t\t\t\t\t\"8cd55591\", \"c902de4c\", \"b90bace1\", \"bb8205d0\", \"11a86248\",\n\t\t\t\t\t\t\"7574a99e\", \"b77f19b6\", \"e0a9dc09\", \"662d09a1\", \"c4324633\",\n\t\t\t\t\t\t\"e85a1f02\", \"09f0be8c\", \"4a99a025\", \"1d6efe10\", \"1ab93d1d\",\n\t\t\t\t\t\t\"0ba5a4df\", \"a186f20f\", \"2868f169\", \"dcb7da83\", \"573906fe\",\n\t\t\t\t\t\t\"a1e2ce9b\", \"4fcd7f52\", \"50115e01\", \"a70683fa\", \"a002b5c4\",\n\t\t\t\t\t\t\"0de6d027\", \"9af88c27\", \"773f8641\", \"c3604c06\", \"61a806b5\",\n\t\t\t\t\t\t\"f0177a28\", \"c0f586e0\", \"006058aa\", \"30dc7d62\", \"11e69ed7\",\n\t\t\t\t\t\t\"2338ea63\", \"53c2dd94\", \"c2c21634\", \"bbcbee56\", \"90bcb6de\",\n\t\t\t\t\t\t\"ebfc7da1\", \"ce591d76\", \"6f05e409\", \"4b7c0188\", \"39720a3d\",\n\t\t\t\t\t\t\"7c927c24\", \"86e3725f\", \"724d9db9\", \"1ac15bb4\", \"d39eb8fc\",\n\t\t\t\t\t\t\"ed545578\", \"08fca5b5\", \"d83d7cd3\", \"4dad0fc4\", \"1e50ef5e\",\n\t\t\t\t\t\t\"b161e6f8\", \"a28514d9\", \"6c51133c\", \"6fd5c7e7\", \"56e14ec4\",\n\t\t\t\t\t\t\"362abfce\", \"ddc6c837\", \"d79a3234\", \"92638212\", \"670efa8e\",\n\t\t\t\t\t\"406000e0\" },\n\t\t\t\t\t{ \"3a39ce37\", \"d3faf5cf\", \"abc27737\", \"5ac52d1b\", \"5cb0679e\",\n\t\t\t\t\t\t\"4fa33742\", \"d3822740\", \"99bc9bbe\", \"d5118e9d\", \"bf0f7315\",\n\t\t\t\t\t\t\"d62d1c7e\", \"c700c47b\", \"b78c1b6b\", \"21a19045\", \"b26eb1be\",\n\t\t\t\t\t\t\"6a366eb4\", \"5748ab2f\", \"bc946e79\", \"c6a376d2\", \"6549c2c8\",\n\t\t\t\t\t\t\"530ff8ee\", \"468dde7d\", \"d5730a1d\", \"4cd04dc6\", \"2939bbdb\",\n\t\t\t\t\t\t\"a9ba4650\", \"ac9526e8\", \"be5ee304\", \"a1fad5f0\", \"6a2d519a\",\n\t\t\t\t\t\t\"63ef8ce2\", \"9a86ee22\", \"c089c2b8\", \"43242ef6\", \"a51e03aa\",\n\t\t\t\t\t\t\"9cf2d0a4\", \"83c061ba\", \"9be96a4d\", \"8fe51550\", \"ba645bd6\",\n\t\t\t\t\t\t\"2826a2f9\", \"a73a3ae1\", \"4ba99586\", \"ef5562e9\", \"c72fefd3\",\n\t\t\t\t\t\t\"f752f7da\", \"3f046f69\", \"77fa0a59\", \"80e4a915\", \"87b08601\",\n\t\t\t\t\t\t\"9b09e6ad\", \"3b3ee593\", \"e990fd5a\", \"9e34d797\", \"2cf0b7d9\",\n\t\t\t\t\t\t\"022b8b51\", \"96d5ac3a\", \"017da67d\", \"d1cf3ed6\", \"7c7d2d28\",\n\t\t\t\t\t\t\"1f9f25cf\", \"adf2b89b\", \"5ad6b472\", \"5a88f54c\", \"e029ac71\",\n\t\t\t\t\t\t\"e019a5e6\", \"47b0acfd\", \"ed93fa9b\", \"e8d3c48d\", \"283b57cc\",\n\t\t\t\t\t\t\"f8d56629\", \"79132e28\", \"785f0191\", \"ed756055\", \"f7960e44\",\n\t\t\t\t\t\t\"e3d35e8c\", \"15056dd4\", \"88f46dba\", \"03a16125\", \"0564f0bd\",\n\t\t\t\t\t\t\"c3eb9e15\", \"3c9057a2\", \"97271aec\", \"a93a072a\", \"1b3f6d9b\",\n\t\t\t\t\t\t\"1e6321f5\", \"f59c66fb\", \"26dcf319\", \"7533d928\", \"b155fdf5\",\n\t\t\t\t\t\t\"03563482\", \"8aba3cbb\", \"28517711\", \"c20ad9f8\", \"abcc5167\",\n\t\t\t\t\t\t\"ccad925f\", \"4de81751\", \"3830dc8e\", \"379d5862\", \"9320f991\",\n\t\t\t\t\t\t\"ea7a90c2\", \"fb3e7bce\", \"5121ce64\", \"774fbe32\", \"a8b6e37e\",\n\t\t\t\t\t\t\"c3293d46\", \"48de5369\", \"6413e680\", \"a2ae0810\", \"dd6db224\",\n\t\t\t\t\t\t\"69852dfd\", \"09072166\", \"b39a460a\", \"6445c0dd\", \"586cdecf\",\n\t\t\t\t\t\t\"1c20c8ae\", \"5bbef7dd\", \"1b588d40\", \"ccd2017f\", \"6bb4e3bb\",\n\t\t\t\t\t\t\"dda26a7e\", \"3a59ff45\", \"3e350a44\", \"bcb4cdd5\", \"72eacea8\",\n\t\t\t\t\t\t\"fa6484bb\", \"8d6612ae\", \"bf3c6f47\", \"d29be463\", \"542f5d9e\",\n\t\t\t\t\t\t\"aec2771b\", \"f64e6370\", \"740e0d8d\", \"e75b1357\", \"f8721671\",\n\t\t\t\t\t\t\"af537d5d\", \"4040cb08\", \"4eb4e2cc\", \"34d2466a\", \"0115af84\",\n\t\t\t\t\t\t\"e1b00428\", \"95983a1d\", \"06b89fb4\", \"ce6ea048\", \"6f3f3b82\",\n\t\t\t\t\t\t\"3520ab82\", \"011a1d4b\", \"277227f8\", \"611560b1\", \"e7933fdc\",\n\t\t\t\t\t\t\"bb3a792b\", \"344525bd\", \"a08839e1\", \"51ce794b\", \"2f32c9b7\",\n\t\t\t\t\t\t\"a01fbac9\", \"e01cc87e\", \"bcc7d1f6\", \"cf0111c3\", \"a1e8aac7\",\n\t\t\t\t\t\t\"1a908749\", \"d44fbd9a\", \"d0dadecb\", \"d50ada38\", \"0339c32a\",\n\t\t\t\t\t\t\"c6913667\", \"8df9317c\", \"e0b12b4f\", \"f79e59b7\", \"43f5bb3a\",\n\t\t\t\t\t\t\"f2d519ff\", \"27d9459c\", \"bf97222c\", \"15e6fc2a\", \"0f91fc71\",\n\t\t\t\t\t\t\"9b941525\", \"fae59361\", \"ceb69ceb\", \"c2a86459\", \"12baa8d1\",\n\t\t\t\t\t\t\"b6c1075e\", \"e3056a0c\", \"10d25065\", \"cb03a442\", \"e0ec6e0e\",\n\t\t\t\t\t\t\"1698db3b\", \"4c98a0be\", \"3278e964\", \"9f1f9532\", \"e0d392df\",\n\t\t\t\t\t\t\"d3a0342b\", \"8971f21e\", \"1b0a7441\", \"4ba3348c\", \"c5be7120\",\n\t\t\t\t\t\t\"c37632d8\", \"df359f8d\", \"9b992f2e\", \"e60b6f47\", \"0fe3f11d\",\n\t\t\t\t\t\t\"e54cda54\", \"1edad891\", \"ce6279cf\", \"cd3e7e6f\", \"1618b166\",\n\t\t\t\t\t\t\"fd2c1d05\", \"848fd2c5\", \"f6fb2299\", \"f523f357\", \"a6327623\",\n\t\t\t\t\t\t\"93a83531\", \"56cccd02\", \"acf08162\", \"5a75ebb5\", \"6e163697\",\n\t\t\t\t\t\t\"88d273cc\", \"de966292\", \"81b949d0\", \"4c50901b\", \"71c65614\",\n\t\t\t\t\t\t\"e6c6c7bd\", \"327a140a\", \"45e1d006\", \"c3f27b9a\", \"c9aa53fd\",\n\t\t\t\t\t\t\"62a80f00\", \"bb25bfe2\", \"35bdd2f6\", \"71126905\", \"b2040222\",\n\t\t\t\t\t\t\"b6cbcf7c\", \"cd769c2b\", \"53113ec0\", \"1640e3d3\", \"38abbd60\",\n\t\t\t\t\t\t\"2547adf0\", \"ba38209c\", \"f746ce76\", \"77afa1c5\", \"20756060\",\n\t\t\t\t\t\t\"85cbfe4e\", \"8ae88dd8\", \"7aaaf9b0\", \"4cf9aa7e\", \"1948c25c\",\n\t\t\t\t\t\t\"02fb8a8c\", \"01c36ae4\", \"d6ebe1f9\", \"90d4f869\", \"a65cdea0\",\n\t\t\t\t\t\t\"3f09252d\", \"c208e69f\", \"b74e6132\", \"ce77e25b\", \"578fdfe3\",\n\t\t\t\t\t\"3ac372e6\" } };\n\n\t//Initializing subkeys with digits of pi\n\tString P[] = { \"243f6a88\", \"85a308d3\", \"13198a2e\", \"03707344\", \"a4093822\",\n\t\t\t\"299f31d0\", \"082efa98\", \"ec4e6c89\", \"452821e6\", \"38d01377\",\n\t\t\t\"be5466cf\", \"34e90c6c\", \"c0ac29b7\", \"c97c50dd\", \"3f84d5b5\",\n\t\t\t\"b5470917\", \"9216d5d9\", \"8979fb1b\" };\n\n\t//Initializing modVal to 2^32\n\tlong modVal = 4294967296L;\n\t\n\n    /**\n     * This method returns binary representation of the hexadecimal number passed as parameter\n     *\n     * @param hex Number for which binary representation is required\n     * @return String object which is a binary representation of the hex number passed as parameter\n     */\n\tprivate String hexToBin(String hex)\n\t{\n\t\tString binary = \"\";\n\t\tLong num;\n\t\tString binary4B;\n\t\tint n = hex.length();\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tnum = Long.parseUnsignedLong(\n\t\t\t\t\thex.charAt(i) + \"\", 16);\n\t\t\tbinary4B = Long.toBinaryString(num);\n\n\t\t\tbinary4B = \"0000\" + binary4B;\n\n\t\t\tbinary4B = binary4B.substring(binary4B.length() - 4);\n\t\t\tbinary += binary4B;\n\t\t}\n\t\treturn binary;\n\t}\n\n    /**\n     * This method returns hexadecimal representation of the binary number passed as parameter\n     *\n     * @param binary Number for which hexadecimal representation is required\n     * @return String object which is a hexadecimal representation of the binary number passed as parameter\n     */\n\tprivate String binToHex(String binary)\n\t{\n\n\t\tlong num = Long.parseUnsignedLong(binary, 2);\n\t\tString hex = Long.toHexString(num);\n\t\twhile (hex.length() < (binary.length() / 4))\n\t\t\thex = \"0\" + hex;\n\n\t\treturn hex;\n\t}\n\n    /**\n     * This method returns a string obtained by XOR-ing two strings of same length passed a method parameters\n     *      \n     * @param String a and b are string objects which will be XORed and are to be of same length\n     * @return String object obtained by XOR operation on String a and String b\n     * */\n\tprivate String xor(String a, String b)\n\t{\n\t\ta = hexToBin(a);\n\t\tb = hexToBin(b);\n\t\tString ans = \"\";\n\t\tfor (int i = 0; i < a.length(); i++)\n\t\t\tans += (char)(((a.charAt(i) - '0')\n\t\t\t\t\t^ (b.charAt(i) - '0'))\n\t\t\t\t\t+ '0');\n\t\tans = binToHex(ans);\n\t\treturn ans;\n\t}\n\n    /**\n     * This method returns addition of two hexadecimal numbers passed as parameters and moded with 2^32 \n     *\n     * @param String a and b are hexadecimal numbers\n     * @return String object which is a is addition that is then moded with 2^32 of hex numbers passed as parameters\n     */\n\tprivate String addBin(String a, String b)\n\t{\n\t\tString ans = \"\";\n\t\tlong n1 = Long.parseUnsignedLong(a, 16);\n\t\tlong n2 = Long.parseUnsignedLong(b, 16);\n\t\tn1 = (n1 + n2) % modVal;\n\t\tans = Long.toHexString(n1);\n\t\tans = \"00000000\" + ans;\n\t\treturn ans.substring(ans.length() - 8);\n\t}\n\n\t/*F-function splits the 32-bit input into four 8-bit quarters \n\t and uses the quarters as input to the S-boxes. \n\t The S-boxes accept 8-bit input and produce 32-bit output. \n\t The outputs are added modulo 232 and XORed to produce the final 32-bit output \n\t*/\n\tprivate String f(String plainText)\n\t{\n\t\tString a[] = new String[4];\n\t\tString ans = \"\";\n\t\tfor (int i = 0; i < 8; i += 2) {\n\t\t\t//column number for S-box is a 8-bit value\n\t\t\tlong col\n\t\t\t= Long.parseUnsignedLong(\n\t\t\t\t\thexToBin(\n\t\t\t\t\t\t\tplainText\n\t\t\t\t\t\t\t.substring(i, i + 2)),\n\t\t\t\t\t2);\n\t\t\ta[i / 2] = S[i / 2][(int)col];\n\t\t}\n\t\tans = addBin(a[0], a[1]);\n\t\tans = xor(ans, a[2]);\n\t\tans = addBin(ans, a[3]);\n\t\treturn ans;\n\t}\n\n\t//generate subkeys\n\tprivate void keyGenerate(String key)\n\t{\n\t\tint j = 0;\n\t\tfor (int i = 0; i < P.length; i++) {\n\n\t\t\t//XOR-ing 32-bit parts of the key with initial subkeys\n\t\t\tP[i] = xor(P[i], key.substring(j, j + 8));\n\n\t\t\tj = (j + 8) % key.length();\n\t\t}\n\t}\n\n\t//round function\n\tprivate String round(int time, String plainText)\n\t{\n\t\tString left, right;\n\t\tleft = plainText.substring(0, 8);\n\t\tright = plainText.substring(8, 16);\n\t\tleft = xor(left, P[time]);\n\n\t\t//output from F function\n\t\tString fOut = f(left);\n\n\t\tright = xor(fOut, right);\n\n\t\t//swap left and right\n\t\treturn right + left;\n\t}\n\n    /**\n     * This method returns cipher text for the plaintext passed as the first parameter generated\n     * using the key passed as the second parameter\n     *\n     * @param String plainText is the text which is to be encrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String cipherText is the encrypted value\n     */\n\tString encrypt(String plainText, String key)\n\t{\n\t\t//generating key\n\t\tkeyGenerate(key);\n\t\t\n\t\tfor (int i = 0; i < 16; i++)\n\t\t\tplainText = round(i, plainText);\n\n\t\t//postprocessing\n\t\tString right = plainText.substring(0, 8);\n\t\tString left = plainText.substring(8, 16);\n\t\tright = xor(right, P[16]);\n\t\tleft = xor(left, P[17]);\n\t\treturn left + right;\n\t}\n\t\n    /**\n     * This method returns plaintext for the ciphertext passed as the first parameter decoded\n     * using the key passed as the second parameter\n     *\n     * @param String ciphertext is the text which is to be decrypted\n     * @param String key is the key which is to be used for generating cipher text\n     * @return String plainText is the decrypted text\n     */\n    String decrypt(String cipherText,String key)\n    {\n    \t//generating key\n    \tkeyGenerate(key);\n    \t\n        for (int i = 17; i > 1; i--)\n            cipherText = round(i, cipherText);\n \n        //postprocessing\n        String right = cipherText.substring(0, 8);\n        String left = cipherText.substring(8, 16);\n        right = xor(right, P[1]);\n        left = xor(left, P[0]);\n        return left + right;\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.ciphers;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass BlowfishTest {\n\n\tBlowfish blowfish = new Blowfish();\n\n\t@Test\n\tvoid testEncrypt() {\n\n\t\t//given\n\t\tString plainText = \"123456abcd132536\";\n\t\tString key = \"aabb09182736ccdd\";\n\t\tString expectedOutput = \"d748ec383d3405f7\";\n\t\t\n\t\t//when\n\t\tString cipherText = blowfish.encrypt(plainText, key);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedOutput, cipherText);\n\n\t}\n\t\n\t@Test\n\tvoid testDecrypt() {\n\t\t\n\t\t//given\n\t\tString cipherText = \"d748ec383d3405f7\";\n\t\tString key = \"aabb09182736ccdd\";\n\t\tString expectedOutput = \"123456abcd132536\";\n\t\t\n\t\t//when\n\t\tString plainText = blowfish.decrypt(cipherText, key);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedOutput, plainText);\n\n\t}\n\t\n}"
    },
    {
        "product_commit": "239b27406997029745e08cd338de7956b9724a06",
        "test_commit": "239b27406997029745e08cd338de7956b9724a06",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DistanceFormula.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DistanceFormulaTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class DistanceFormula {\n\tpublic static double distance(double x1, double y1, double x2, double y2)\n\t{\n\t\tdouble dX = Math.pow(x2-x1, 2);\n\t\tdouble dY = Math.pow(y2-x1, 2);\n\t\tdouble d = Math.sqrt(dX+dY);\n\t\treturn d;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DistanceFormulaTest\n{\n  @Test\n  void test1()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(1,1,2,2), 1.4142135623730951);\n  }\n  @Test\n  void test2()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(1,3,8,0), 7.0710678118654755);\n  }\n  @Test\n  void test3()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(2.4,9.1,55.1,100), 110.91911467371168);\n  }\n  @Test\n  void test4()\n  {\n    Assertions.assertEquals(DistanceFormula.distance(1000,13,20000,84), 19022.067605809836);\n  }\n}"
    },
    {
        "product_commit": "c52b2a649c776e78ef22ea3b062e2098bf768fa9",
        "test_commit": "c52b2a649c776e78ef22ea3b062e2098bf768fa9",
        "product_file_path": "src/main/java/com/thealgorithms/maths/StandardDeviation.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/StandardDeviationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class StandardDeviation {\n\t\n  public static double stdDev(double[] data)\n\t{\n\t\tdouble var = 0;\n\t\tdouble avg = 0;\n\t\tfor (int i = 0; i < data.length; i++)\n\t\t{\n\t\t\tavg += data[i];\n\t\t}\n\t\tavg /= data.length;\n\t\tfor (int j = 0; j < data.length; j++)\n\t\t{\n\t\t\tvar += Math.pow((data[j] - avg), 2);\n\t\t}\n\t\tvar /= data.length;\n\t\treturn Math.sqrt(var);\n\t}\n  \n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class StandardDeviationTest{\n  @Test\n  void test1()\n  {\n    double[] t1 = new double[]{1,1,1,1,1};\n    Assertions.assertEquals(StandardDeviation.stdDev(t1), 0.0);\n  }\n  @Test\n  void test2()\n  {\n    double[] t2 = new double[]{1,2,3,4,5,6,7,8,9,10};\n    Assertions.assertEquals(StandardDeviation.stdDev(t2), 2.8722813232690143);\n  }\n  @Test\n  void test3()\n  {\n    double[] t3= new double[]{1.1, 8.5, 20.3, 2.4, 6.2};\n    Assertions.assertEquals(StandardDeviation.stdDev(t3), 6.8308125431752265);\n  }\n  @Test\n  void test4()\n  {\n    double[] t4 = new double[]{3.14, 2.22222, 9.89898989, 100.00045, 56.7};\n     Assertions.assertEquals(StandardDeviation.stdDev(t4), 38.506117353865775);\n  }\n}"
    },
    {
        "product_commit": "41be089f6a918aece04e6c951359c699e755206e",
        "test_commit": "41be089f6a918aece04e6c951359c699e755206e",
        "product_file_path": "src/main/java/com/thealgorithms/maths/HeronsFormula.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/HeronsFormulaTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of a triangle using only side lengths\n */\n\npublic class HeronsFormula {\n\t\n\tpublic static double Herons(int s1, int s2, int s3)\n\t{\n\t\tdouble a = s1;\n\t\tdouble b = s2;\n\t\tdouble c = s3;\n\t\tdouble s = (a + b + c)/2.0;\n\t\tdouble area = 0;\n\t\tarea = Math.sqrt((s)*(s-a)*(s-b)*(s-c));\n\t\treturn area;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class HeronsFormulaTest {\n\t\t@Test\n\t\tvoid test1()\n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(3,4,5), 6.0);\n\t\t}\n\t\t@Test\n\t\tvoid test2() \n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(24,30,18), 216.0);\n\t\t}\n\t\t@Test\n\t\tvoid test3()\n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(1,1,1), 0.4330127018922193);\n\t\t}\n\t\t@Test\n\t\tvoid test4()\n\t\t{\n\t\t\tAssertions.assertEquals(HeronsFormula.Herons(4,5,8), 8.181534085976786);\n\t\t}\n}"
    },
    {
        "product_commit": "dfdce96c6e715c1229384568473ec2251e6eb72e",
        "test_commit": "dfdce96c6e715c1229384568473ec2251e6eb72e",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/DutchNationalFlagSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DutchNationalFlagSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * The Dutch National Flag Sort sorts a sequence of values into three permutations which are defined by a value given\n * as the indented middle.\n * First permutation: values less than middle.\n * Second permutation: values equal middle.\n * Third permutation: values greater than middle.\n * If no indented middle is given, this implementation will use a value from the given Array.\n * This value is the one positioned in the arrays' middle if the arrays' length is odd.\n * If the arrays' length is even, the value left to the middle will be used.\n * More information and Pseudocode: https://en.wikipedia.org/wiki/Dutch_national_flag_problem\n */\npublic class DutchNationalFlagSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return dutch_national_flag_sort(unsorted, unsorted[(int) Math.ceil((unsorted.length)/2.0) -1]);\n    }\n\n    public <T extends Comparable<T>> T[] sort(T[] unsorted, T intendedMiddle) {\n        return dutch_national_flag_sort(unsorted, intendedMiddle);\n    }\n\n    private <T extends Comparable<T>> T[] dutch_national_flag_sort(T[] arr, T intendedMiddle){\n        int i = 0;\n        int j = 0;\n        int k = arr.length - 1;\n\n        while( j <= k){\n            if ( 0 > arr[j].compareTo(intendedMiddle)){\n                SortUtils.swap(arr, i, j);\n                j++;\n                i++;\n            } else if (0 < arr[j].compareTo(intendedMiddle)){\n                SortUtils.swap(arr, j, k);\n                k--;\n            } else {\n                j++;\n            }\n        }\n       return arr;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DutchNationalFlagSortTest {\n    @Test\n    /*\n      1 will be used as intended middle.\n      Partitions on the result array: [ smaller than 1 , equal 1, greater than 1]\n     */\n    void DNFSTestOdd() {\n        Integer[] integers = {1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 1, 4, 3};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      3 will be used as intended middle.\n      Partitions on the result array: [ smaller than 3 , equal 3, greater than 3]\n     */\n    void DNFSTestEven() {\n        Integer[] integers = {8, 1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 1, 3, 4, 8};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestEvenStrings() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\", \"e\"};\n        String[] stringsResult = {\"a\", \"b\", \"s\", \"e\", \"e\", \"d\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"b\" will be used as intended middle.\n      Partitions on the result array: [ smaller than b , equal b, greater than b]\n     */\n    void DNFSTestOddStrings() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\"};\n        String[] stringsResult = {\"a\", \"b\", \"s\", \"e\", \"d\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings);\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      0 will be used as intended middle.\n      Partitions on the result array: [ smaller than 0 , equal 0, greater than 0]\n     */\n    void DNFSTestOddMidGiven() {\n        Integer[] integers = {1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 4, 3, 1};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 0);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      4 will be used as intended middle.\n      Partitions on the result array: [ smaller than 4 , equal 4, greater than 4]\n     */\n    void DNFSTestEvenMidGiven() {\n        Integer[] integers = {8, 1, 3, 1, 4, 0};\n        Integer[] integersResult = {0, 1, 3, 1, 4, 8};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(integers, 4);\n        assertArrayEquals(integers, integersResult);\n    }\n\n    @Test\n    /*\n      \"s\" will be used as intended middle.\n      Partitions on the result array: [ smaller than s , equal s, greater than s]\n     */\n    void DNFSTestEvenStringsMidGiven() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\", \"e\"};\n        String[] stringsResult = {\"a\", \"d\", \"b\", \"e\", \"e\", \"s\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"s\");\n        assertArrayEquals(strings, stringsResult);\n    }\n\n    @Test\n    /*\n      \"e\" will be used as intended middle.\n      Partitions on the result array: [ smaller than e , equal e, greater than e]\n     */\n    void DNFSTestOddStringsMidGiven() {\n        String[] strings = {\"a\", \"d\", \"b\", \"s\", \"e\"};\n        String[] stringsResult = {\"a\", \"d\", \"b\", \"e\", \"s\"};\n        DutchNationalFlagSort dutchNationalFlagSort = new DutchNationalFlagSort();\n        dutchNationalFlagSort.sort(strings, \"e\");\n        assertArrayEquals(strings, stringsResult);\n    }\n}"
    },
    {
        "product_commit": "99ff5163e3cd88c7a384349b92238463a8b201b8",
        "test_commit": "99ff5163e3cd88c7a384349b92238463a8b201b8",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/WiggleSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/WiggleSortTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.Arrays;\n\nimport static com.thealgorithms.maths.Ceil.ceil;\nimport static com.thealgorithms.maths.Floor.floor;\nimport static com.thealgorithms.searches.QuickSelect.select;\n\n/**\n * A wiggle sort implementation based on John L.s' answer in\n * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity\n * Also have a look at: https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity?noredirect=1&lq=1\n * Not all arrays are wiggle-sortable. This algorithm will find some obviously not wiggle-sortable arrays and throw an error,\n * but there are some exceptions that won't be caught, for example [1, 2, 2].\n */\npublic class WiggleSort implements SortAlgorithm {\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        return wiggleSort(unsorted);\n    }\n\n    private int mapIndex(int index, int n) {\n        return ((2 * index + 1) % (n | 1));\n    }\n\n    /**\n     * Modified Dutch National Flag Sort. See also: sorts/DutchNationalFlagSort\n     *\n     * @param sortThis array to sort into group \"greater\", \"equal\" and \"smaller\" than median\n     * @param median   defines the groups\n     * @param <T>      extends interface Comparable\n     */\n    private <T extends Comparable<T>> void triColorSort(T[] sortThis, T median) {\n        int n = sortThis.length;\n        int i = 0;\n        int j = 0;\n        int k = n - 1;\n        while (j <= k) {\n            if (0 < sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n));\n                i++;\n                j++;\n            } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) {\n                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n));\n                k--;\n            } else {\n                j++;\n            }\n        }\n    }\n\n    private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) {\n        // find the median using quickSelect (if the result isn't in the array, use the next greater value)\n        T median;\n\n        median = select(Arrays.<T>asList(sortThis), (int) floor(sortThis.length / 2.0));\n\n        int numMedians = 0;\n\n        for (T sortThi : sortThis) {\n            if (0 == sortThi.compareTo(median)) {\n                numMedians++;\n            }\n        }\n        // added condition preventing off-by-one errors for odd arrays.\n        // https://cs.stackexchange.com/questions/150886/how-to-find-wiggle-sortable-arrays-did-i-misunderstand-john-l-s-answer?noredirect=1&lq=1\n        if (sortThis.length % 2 == 1 && numMedians == ceil(sortThis.length / 2.0)) {\n            T smallestValue = select(Arrays.asList(sortThis), 0);\n            if (!(0 == smallestValue.compareTo(median))) {\n                throw new IllegalArgumentException(\"For odd Arrays if the median appears ceil(n/2) times, \" +\n                        \"the median has to be the smallest values in the array.\");\n            }\n        }\n        if (numMedians > ceil(sortThis.length / 2.0)) {\n            throw new IllegalArgumentException(\"No more than half the number of values may be the same.\");\n\n        }\n\n        triColorSort(sortThis, median);\n        return sortThis;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\n\npublic class WiggleSortTest {\n    @Test\n    void WiggleTestNumbersEven(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 3, 4};\n        Integer[] result = {1, 4, 2, 3};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOdd(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 3, 4, 5};\n        Integer[] result = {3, 5, 1, 4, 2};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n\n    }\n\n    @Test\n    void WiggleTestNumbersOddDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {7, 2, 2, 2, 5};\n        Integer[] result = {2, 7, 2, 5, 2};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersOddMultipleDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 1, 2, 2, 5};\n        Integer[] result = {2, 5, 1, 2, 1};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenMultipleDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 1, 2, 2, 2, 5};\n        Integer[] result = {2, 5, 1, 2, 1, 2};\n        wiggleSort.sort(values);\n        System.out.println(Arrays.toString(values));\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestNumbersEvenDuplicates(){\n        WiggleSort wiggleSort = new WiggleSort();\n        Integer[] values = {1, 2, 4, 4};\n        Integer[] result = {1, 4, 2, 4};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n\n    @Test\n    void WiggleTestStrings(){\n        WiggleSort wiggleSort = new WiggleSort();\n        String[] values = {\"a\", \"b\", \"d\", \"c\"};\n        String[] result = {\"a\", \"d\", \"b\", \"c\"};\n        wiggleSort.sort(values);\n        assertArrayEquals(values, result);\n    }\n}"
    },
    {
        "product_commit": "9f7613b467bda734cdea196013c8fdfe19af81a2",
        "test_commit": "9f7613b467bda734cdea196013c8fdfe19af81a2",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AliquotSum.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AliquotSumTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    public static void main(String[] args) {\n        assert aliquotSum(1) == 0;\n        assert aliquotSum(6) == 6;\n        assert aliquotSum(15) == 9;\n        assert aliquotSum(19) == 1;\n    }\n\n    /**\n     * Finds the aliquot sum of an integer number\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int aliquotSum(int number) {\n        int sum = 0;\n        for (int i = 1, limit = number / 2; i <= limit; ++i) {\n            if (number % i == 0) {\n                sum += i;\n            }\n        }\n        return sum;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    /**\n     * Finds the aliquot sum of an integer number.\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotValue(int number) {\n        var sumWrapper = new Object() {\n            int value = 0;\n        };\n\n        IntStream.iterate(1, i -> ++i)\n                .limit(number / 2)\n                .filter(i -> number % i == 0)\n                .forEach(i -> sumWrapper.value += i);\n\n        return sumWrapper.value;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AliquotSumTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(0, AliquotSum.getAliquotValue(1));\n        assertEquals(6, AliquotSum.getAliquotValue(6));\n        assertEquals(9, AliquotSum.getAliquotValue(15));\n        assertEquals(1, AliquotSum.getAliquotValue(19));\n    }\n}"
    },
    {
        "product_commit": "4b15b2c021c32868cdc74e144fa6dc3c92324f52",
        "test_commit": "4b15b2c021c32868cdc74e144fa6dc3c92324f52",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ADTFraction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ADTFractionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class ADTFraction {\n\n    public static void main(String[] args) {\n        // TODO code application logic here\n\n        ADTFraction f1 = new ADTFraction(3, 5);\n        f1.display();\n        ADTFraction f2 = new ADTFraction(7, 8);\n        f2.display();\n        ADTFraction f3 = f1.plus(f2);\n        f3.display();\n        ADTFraction f4 = f1.times(f2);\n        f4.display();\n        ADTFraction f5 = f1.times(4);\n        f5.display();\n\n    }\n\n    private int n; //numerator\n    private int d; //denomenator\n\n    public ADTFraction() {\n        this.n = 0;\n        this.d = 1;\n    }\n\n    public ADTFraction(int a, int b) {//parameter constructor\n\n        if (b != 0) {\n            this.n = a;\n            this.d = b;\n        } else {\n            this.n = 0;\n            this.d = 1;\n            System.out.println(\"denomerator cannot be 0,default values assinged\");\n        }\n    }\n\n    public void set(int a, int b) {//set numerator and denomenator\n\n        if (b != 0) {\n            this.n = a;\n            this.d = b;\n        } else {\n            this.n = 0;\n            this.d = 1;\n            System.out.println(\"denomerator cannot be 0,default values assinged\");\n        }\n\n    }\n\n    //add two fractions\n    public ADTFraction plus(ADTFraction x) {\n\n        int num, den;\n        num = this.d * x.n + this.n * x.d;\n        den = this.d * x.d;\n        ADTFraction f = new ADTFraction(num, den);\n        return f;\n\n    }\n\n    public ADTFraction times(int a) {//multiply fraction by a number\n\n        int num, den;\n        num = this.n * a;\n        den = this.d;\n        ADTFraction f1 = new ADTFraction(num, den);\n        return f1;\n\n    }\n\n    public ADTFraction times(ADTFraction x) {//multiply two fractions\n\n        int num, dem;\n        num = this.n * x.n;\n        dem = this.d * x.d;\n        ADTFraction f3 = new ADTFraction(num, dem);\n        return f3;\n\n    }\n\n    //reciprocal of a fraction\n    public ADTFraction reciprocal() {\n        ADTFraction f1 = new ADTFraction(this.d, this.n);\n        return f1;\n    }\n\n    //numerical value of a fraction\n    public float value() {\n        return (float) this.n / this.d;\n    }\n\n    //display the fraction in the format n/d\n    public void display() {\n        System.out.println(this.n + \"/\" + this.d);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic record ADTFraction(int numerator, int denominator) {\n\n    /**\n     * Initializes a newly created {@code ADTFraction} object so that it represents\n     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.\n     *\n     * @param numerator   The fraction numerator\n     * @param denominator The fraction denominator\n     */\n    public ADTFraction {\n        if (denominator == 0) {\n            throw new IllegalArgumentException(\"Denominator cannot be 0\");\n        }\n    }\n\n    /**\n     * Add two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to add\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction plus(ADTFraction fraction) {\n        var numerator = this.denominator * fraction.numerator + this.numerator * fraction.denominator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n\n    }\n\n    /**\n     * Multiply fraction by a number.\n     *\n     * @param number the number to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(int number) {\n        return times(new ADTFraction(number, 1));\n    }\n\n    /**\n     * Multiply two fractions.\n     *\n     * @param fraction the {@code ADTFraction} to multiply\n     * @return A new {@code ADTFraction} containing the result of the operation\n     */\n    public ADTFraction times(ADTFraction fraction) {\n        var numerator = this.numerator * fraction.numerator;\n        var denominator = this.denominator * fraction.denominator;\n        return new ADTFraction(numerator, denominator);\n    }\n\n    /**\n     * Generates the reciprocal of the fraction.\n     *\n     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched\n     */\n    public ADTFraction reciprocal() {\n        return new ADTFraction(this.denominator, this.numerator);\n    }\n\n    /**\n     * Calculates the result of the fraction.\n     *\n     * @return The numerical result of the division between {@code numerator} and {@code denominator}\n     */\n    public float value() {\n        return (float) this.numerator / this.denominator;\n    }\n\n    /**\n     * Returns a string representation of this {@code ADTFraction} in the format\n     * {@code numerator}/{@code denominator}.\n     *\n     * @return A string representation of this {@code ADTFraction}\n     */\n    @Override\n    public String toString() {\n        return String.format(\"%d/%d\", this.numerator, this.denominator);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class ADTFractionTest {\n\n    private final ADTFraction fraction1 = new ADTFraction(3, 5);\n    private final ADTFraction fraction2 = new ADTFraction(7, 8);\n\n    @Test\n    void testConstructorWithDenominatorEqualToZero() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> new ADTFraction(1, 0));\n        assertEquals(\"Denominator cannot be 0\", exception.getMessage());\n    }\n\n    @Test\n    public void testPlus() {\n        assertEquals(new ADTFraction(59, 40), fraction1.plus(fraction2));\n    }\n\n    @Test\n    public void testTimes() {\n        assertEquals(new ADTFraction(12, 5), fraction1.times(4));\n        assertEquals(new ADTFraction(21, 40), fraction1.times(fraction2));\n    }\n\n    @Test\n    public void testReciprocal() {\n        assertEquals(new ADTFraction(5, 3), fraction1.reciprocal());\n    }\n\n    @Test\n    public void testValue() {\n        assertEquals(0.6F, fraction1.value());\n    }\n\n    @Test\n    public void testEqualsAndHashCode() {\n        ADTFraction fraction3 = new ADTFraction(3, 5);\n        assertTrue(fraction1.equals(fraction3) && fraction3.equals(fraction1));\n        assertEquals(fraction1.hashCode(), fraction3.hashCode());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"3/5\", fraction1.toString());\n    }\n}"
    },
    {
        "product_commit": "5eed0849ef4734e3faec8fa21d798c2927ec3b4e",
        "test_commit": "5eed0849ef4734e3faec8fa21d798c2927ec3b4e",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteValue.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteValueTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Random;\n\npublic class AbsoluteValue {\n\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* test 1000 random numbers */\n        for (int i = 1; i <= 1000; ++i) {\n            int randomNumber = random.nextInt();\n            assert absVal(randomNumber) == Math.abs(randomNumber);\n        }\n    }\n\n    /**\n     * If value is less than zero, make value positive.\n     *\n     * @param value a number\n     * @return the absolute value of a number\n     */\n    public static int absVal(int value) {\n        return value < 0 ? -value : value;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class AbsoluteValue {\n\n    /**\n     * Returns the absolute value of a number.\n     *\n     * @param number The number to be transformed\n     * @return The absolute value of the {@code number}\n     */\n    public static int getAbsValue(int number) {\n        return number < 0 ? -number : number;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AbsoluteValueTest {\n\n    @Test\n    void testGetAbsValue() {\n        Stream.generate(() -> ThreadLocalRandom.current().nextInt())\n                .limit(1000)\n                .forEach(number -> assertEquals(Math.abs(number), AbsoluteValue.getAbsValue(number)));\n    }\n}"
    },
    {
        "product_commit": "64b624efb204b641d300307d595049f7120ed7a0",
        "test_commit": "64b624efb204b641d300307d595049f7120ed7a0",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteMaxTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\n/**\n * description:\n *\n * <p>\n * absMax([0, 5, 1, 11]) = 11, absMax([3 , -10, -2]) = -10\n */\npublic class AbsoluteMax {\n\n    public static void main(String[] args) {\n        int[] testnums = {-2, 0, 16};\n        assert absMax(testnums) == 16;\n\n        int[] numbers = {3, -10, -2};\n        System.out.println(\"absMax(\" + Arrays.toString(numbers) + \") = \" + absMax(numbers));\n    }\n\n    /**\n     * get the value, return the absolute max value\n     *\n     * @param numbers contains elements\n     * @return the absolute max value\n     */\n    public static int absMax(int[] numbers) {\n        int absMaxValue = numbers[0];\n        for (int i = 1, length = numbers.length; i < length; ++i) {\n            if (Math.abs(numbers[i]) > Math.abs(absMaxValue)) {\n                absMaxValue = numbers[i];\n            }\n        }\n        return absMaxValue;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMax {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute max value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute max value\n     */\n    public static int getMaxValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMaxWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays.stream(numbers)\n                .skip(1)\n                .forEach(number -> {\n                    if (Math.abs(number) > Math.abs(absMaxWrapper.value)) {\n                        absMaxWrapper.value = number;\n                    }\n                });\n\n        return absMaxWrapper.value;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class AbsoluteMaxTest {\n\n    @Test\n    void testGetMaxValue() {\n        assertEquals(16, AbsoluteMax.getMaxValue(-2, 0, 16));\n        assertEquals(-10, AbsoluteMax.getMaxValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMaxValueWithNoArguments() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> AbsoluteMax.getMaxValue());\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "02375e0683b7f7ba28feae686fa7d4aece5a2095",
        "test_commit": "02375e0683b7f7ba28feae686fa7d4aece5a2095",
        "product_file_path": "src/main/java/com/thealgorithms/maths/AbsoluteMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AbsoluteMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\n/**\n * description:\n *\n * <p>\n * absMin([0, 5, 1, 11]) = 0, absMin([3 , -10, -2]) = -2\n */\npublic class AbsoluteMin {\n\n    public static void main(String[] args) {\n        int[] testnums = {4, 0, 16};\n        assert absMin(testnums) == 0;\n\n        int[] numbers = {3, -10, -2};\n        System.out.println(\"absMin(\" + Arrays.toString(numbers) + \") = \" + absMin(numbers));\n    }\n\n    /**\n     * get the value, returns the absolute min value min\n     *\n     * @param numbers contains elements\n     * @return the absolute min value\n     */\n    public static int absMin(int[] numbers) {\n        int absMinValue = numbers[0];\n        for (int i = 1, length = numbers.length; i < length; ++i) {\n            if (Math.abs(numbers[i]) < Math.abs(absMinValue)) {\n                absMinValue = numbers[i];\n            }\n        }\n        return absMinValue;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\n\npublic class AbsoluteMin {\n\n    /**\n     * Compares the numbers given as arguments to get the absolute min value.\n     *\n     * @param numbers The numbers to compare\n     * @return The absolute min value\n     */\n    public static int getMinValue(int... numbers) {\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty\");\n        }\n\n        var absMinWrapper = new Object() {\n            int value = numbers[0];\n        };\n\n        Arrays.stream(numbers)\n                .skip(1)\n                .forEach(number -> {\n                    if (Math.abs(number) < Math.abs(absMinWrapper.value)) {\n                        absMinWrapper.value = number;\n                    }\n                });\n\n        return absMinWrapper.value;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class AbsoluteMinTest {\n\n    @Test\n    void testGetMinValue() {\n        assertEquals(0, AbsoluteMin.getMinValue(4, 0, 16));\n        assertEquals(-2, AbsoluteMin.getMinValue(3, -10, -2));\n    }\n\n    @Test\n    void testGetMinValueWithNoArguments() {\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> AbsoluteMin.getMinValue());\n        assertEquals(\"Numbers array cannot be empty\", exception.getMessage());\n    }\n}"
    },
    {
        "product_commit": "719e1d8132f1aeea3e7ab2eb7ec86270a30d68df",
        "test_commit": "719e1d8132f1aeea3e7ab2eb7ec86270a30d68df",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Armstrong.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ArmstrongTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * An Armstrong number is equal to the sum of the cubes of its digits. For\n * example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370. An\n * Armstrong number is often called Narcissistic number.\n */\npublic class Armstrong {\n\n    public static void main(String[] args) {\n        assert (isArmStrong(0));\n        assert (isArmStrong(1));\n        assert (isArmStrong(153));\n        assert (isArmStrong(1634));\n        assert (isArmStrong(371));\n        assert (!isArmStrong(200));\n    }\n\n    /**\n     * Checks whether a given number is an armstrong number or not.\n     *\n     * @param number number to check\n     * @return {@code true} if given number is armstrong number, {@code false}\n     * otherwise\n     */\n    private static boolean isArmStrong(int number) {\n        int sum = 0;\n        int temp = number;\n        int numberOfDigits = 0;\n        while (temp != 0) {\n            numberOfDigits++;\n            temp /= 10;\n        }\n        temp = number;\n        /* copy number again */\n        while (number > 0) {\n            int remainder = number % 10;\n            int power = 1;\n            for (int i = 1; i <= numberOfDigits; power *= remainder, ++i)\n        ;\n            sum = sum + power;\n            number /= 10;\n        }\n        return sum == temp;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * An Armstrong number is equal to the sum of the cubes of its digits. For\n * example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370. An\n * Armstrong number is often called Narcissistic number.\n *\n * @author Vivek\n */\npublic class Armstrong {\n\n    /**\n     * Checks whether a given number is an armstrong number or not.\n     *\n     * @param number number to check\n     * @return {@code true} if given number is armstrong number, {@code false}\n     * otherwise\n     */\n    public boolean isArmstrong(int number) {\n        long sum = 0;\n        long number2 = number;\n        while (number2 > 0) {\n            long mod = number2 % 10;\n            sum += Math.pow(mod, 3);\n            number2 /= 10;\n        }\n        return sum == number;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Vivek\n * @since 15/03/22\n */\nclass ArmstrongTest {\n\n    @Test\n    void testIsArmstrong() {\n        Armstrong armstrong = new Armstrong();\n        assertThat(armstrong.isArmstrong(0)).isTrue();\n        assertThat(armstrong.isArmstrong(1)).isTrue();\n        assertThat(armstrong.isArmstrong(153)).isTrue();\n        assertThat(armstrong.isArmstrong(371)).isTrue();\n        assertThat(armstrong.isArmstrong(1634)).isFalse();\n        assertThat(armstrong.isArmstrong(200)).isFalse();\n    }\n}"
    },
    {
        "product_commit": "8d099ee7d1776cc6c146c06995a7ce11eee989f1",
        "test_commit": "8d099ee7d1776cc6c146c06995a7ce11eee989f1",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Anagrams.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/AnagramsTest.java",
        "product_old_content": "/** Author : Siddhant Swarup Mallick\n * Github : https://github.com/siddhant2002\n */\n\n/** PROBLEM DESCRIPTION :\n * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.[1] For example, the word anagram itself can be rearranged into nag a ram, also the word binary into brainy and the word adobe into abode. Reference from https://en.wikipedia.org/wiki/Anagram\n */\n\npackage com.thealgorithms.strings;\nimport java.util.*;\npublic class Anagrams \n{\n    // 4 approaches are provided for anagram checking. approach 2 and approach 3 are similar but differ in running time.\n    public static void main(String args[]) {\n        String first = \"deal\";\n        String second = \"lead\";\n        // All the below methods takes input but doesn't return any output to the main method.\n        Anagrams nm=new Anagrams();\n        System.out.println(nm.approach2(first, second));  /* To activate methods for different approaches*/\n        System.out.println(nm.approach1(first, second));  /* To activate methods for different approaches*/\n        System.out.println(nm.approach3(first, second));  /* To activate methods for different approaches*/\n        System.out.println(nm.approach4(first, second));  /* To activate methods for different approaches*/\n\n        /**\n         * OUTPUT :\n         * first string =\"deal\" second string =\"lead\"\n         * Output: Anagram\n         * Input and output is constant for all four approaches\n         * 1st approach Time Complexity : O(n logn)\n         * Auxiliary Space Complexity : O(1)\n         * 2nd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 3rd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 4th approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(n)\n         */\n    }\n\n    boolean approach1(String s, String t) \n    {\n        if (s.length() != t.length())\n        {\n            return false;\n        }\n        else \n        {\n            char c[] = s.toCharArray();\n            char d[] = t.toCharArray();\n            Arrays.sort(c);\n            Arrays.sort(d);    /* In this approach the strings are stored in the character arrays and both the arrays are sorted. After that both the arrays are compared for checking anangram */\n            if (Arrays.equals(c, d)) \n            {\n                return true;\n            } else \n            {\n                return false;\n            }\n        }\n    }\n\n    boolean approach2(String a, String b)\n    {\n        if(a.length()!=b.length())\n        {\n            return false;\n        }\n        else\n        {\n            int m[]=new int[26];\n            int n[]=new int[26];\n            for(char c: a.toCharArray())\n            {\n                m[c-'a']++;\n            }\n            // In this approach the frequency of both the strings are stored and after that the frequencies are iterated from 0 to 26(from 'a' to 'z' ). If the frequencies match then anagram message is displayed in the form of boolean format\n            // Running time and space complexity of this algo is less as compared to others\n            for(char c:b.toCharArray())\n            {\n                n[c-'a']++;\n            }\n            for(int i=0;i<26;i++)\n            {\n                if(m[i]!=n[i])\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    boolean approach3(String s, String t)\n    {\n        if(s.length()!=t.length())\n        {\n            return false;\n        }\n        // this is similar to approach number 2 but here the string is not converted to character array\n        else\n        {\n            int a[]=new int[26];\n            int b[]=new int[26];\n            int k=s.length();\n            for(int i=0;i<k;i++)\n            {\n                a[s.charAt(i)-'a']++;\n                b[t.charAt(i)-'a']++;\n            }\n            for(int i=0;i<26;i++)\n            {\n                if(a[i]!=b[i])\n                    return false;\n            }\n            return true;\n        }\n    }\n\n    boolean approach4(String s, String t)\n    {\n        if(s.length()!=t.length())\n        {\n             return false;\n        }\n        // This approach is done using hashmap where frequencies are stored and checked iteratively and if all the frequencies of first string match with the second string then anagram message is displayed in boolean format\n        else\n        {\n            HashMap<Character,Integer> nm=new HashMap<>(); \n            HashMap<Character,Integer> kk=new HashMap<>();\n            for(char c: s.toCharArray())\n            {\n                nm.put(c, nm.getOrDefault(c,0)+1);\n            }\n            for(char c: t.toCharArray())\n            {\n            \n                kk.put(c, kk.getOrDefault(c,0)+1);\n            }\n            // It checks for equal frequencies\n            for(char c:nm.keySet())\n            {\n                if(!nm.get(c).equals(kk.get(c)))\n                {\n                    return false;\n                }\n            } \n            return true;\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\n/**\n * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase,\n * typically using all the original letters exactly once.[1]\n * For example, the word anagram itself can be rearranged into nag a ram,\n * also the word binary into brainy and the word adobe into abode.\n * Reference from https://en.wikipedia.org/wiki/Anagram\n */\npublic class Anagrams {\n    // 4 approaches are provided for anagram checking. approach 2 and approach 3 are similar but differ in running time.\n    public static void main(String[] args) {\n        String first = \"deal\";\n        String second = \"lead\";\n        // All the below methods takes input but doesn't return any output to the main method.\n        Anagrams nm = new Anagrams();\n        System.out.println(nm.approach2(first, second));  /* To activate methods for different approaches*/\n        System.out.println(nm.approach1(first, second));  /* To activate methods for different approaches*/\n        System.out.println(nm.approach3(first, second));  /* To activate methods for different approaches*/\n        System.out.println(nm.approach4(first, second));  /* To activate methods for different approaches*/\n\n        /**\n         * OUTPUT :\n         * first string =\"deal\" second string =\"lead\"\n         * Output: Anagram\n         * Input and output is constant for all four approaches\n         * 1st approach Time Complexity : O(n logn)\n         * Auxiliary Space Complexity : O(1)\n         * 2nd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 3rd approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(1)\n         * 4th approach Time Complexity : O(n)\n         * Auxiliary Space Complexity : O(n)\n         */\n    }\n\n    boolean approach1(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        } else {\n            char c[] = s.toCharArray();\n            char d[] = t.toCharArray();\n            Arrays.sort(c);\n            Arrays.sort(d);    /* In this approach the strings are stored in the character arrays and both the arrays are sorted. After that both the arrays are compared for checking anangram */\n            if (Arrays.equals(c, d)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    boolean approach2(String a, String b) {\n        if (a.length() != b.length()) {\n            return false;\n        } else {\n            int m[] = new int[26];\n            int n[] = new int[26];\n            for (char c : a.toCharArray()) {\n                m[c - 'a']++;\n            }\n            // In this approach the frequency of both the strings are stored and after that the frequencies are iterated from 0 to 26(from 'a' to 'z' ). If the frequencies match then anagram message is displayed in the form of boolean format\n            // Running time and space complexity of this algo is less as compared to others\n            for (char c : b.toCharArray()) {\n                n[c - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (m[i] != n[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    boolean approach3(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        // this is similar to approach number 2 but here the string is not converted to character array\n        else {\n            int a[] = new int[26];\n            int b[] = new int[26];\n            int k = s.length();\n            for (int i = 0; i < k; i++) {\n                a[s.charAt(i) - 'a']++;\n                b[t.charAt(i) - 'a']++;\n            }\n            for (int i = 0; i < 26; i++) {\n                if (a[i] != b[i])\n                    return false;\n            }\n            return true;\n        }\n    }\n\n    boolean approach4(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        // This approach is done using hashmap where frequencies are stored and checked iteratively and if all the frequencies of first string match with the second string then anagram message is displayed in boolean format\n        else {\n            HashMap<Character, Integer> nm = new HashMap<>();\n            HashMap<Character, Integer> kk = new HashMap<>();\n            for (char c : s.toCharArray()) {\n                nm.put(c, nm.getOrDefault(c, 0) + 1);\n            }\n            for (char c : t.toCharArray()) {\n\n                kk.put(c, kk.getOrDefault(c, 0) + 1);\n            }\n            // It checks for equal frequencies\n            for (char c : nm.keySet()) {\n                if (!nm.get(c).equals(kk.get(c))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AnagramsTest {\n    @Test\n    public void isAlphabetical() {\n        String input1 = \"late\";\n        Anagrams anagrams = new Anagrams();\n        assertTrue(anagrams.approach1(input1, \"tale\"));\n        assertTrue(anagrams.approach1(input1, \"teal\"));\n        assertTrue(anagrams.approach2(input1, \"tale\"));\n        assertTrue(anagrams.approach2(input1, \"teal\"));\n        assertTrue(anagrams.approach3(input1, \"tale\"));\n        assertTrue(anagrams.approach3(input1, \"teal\"));\n        assertTrue(anagrams.approach4(input1, \"tale\"));\n        assertTrue(anagrams.approach4(input1, \"teal\"));\n    }\n}"
    },
    {
        "product_commit": "260a302563c5e2735d3f13ff9777d5b807b8f7c5",
        "test_commit": "260a302563c5e2735d3f13ff9777d5b807b8f7c5",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/FloodFill.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/FloodFillTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (https://github.com/itsAkshayDubey)\n */\npublic class FloodFill {\n\n    /**\n     * Get the color at the given co-odrinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\t\n\tpublic static int getPixel(int[][] image, int x, int y) {\n\t\n\t\treturn image[x][y];\n\t\n\t}\n\t\n    /**\n     * Put the color at the given co-odrinates of a 2D image\n     *\n     * @param image The image to be filed\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n\tpublic static void putPixel(int[][] image, int x, int y, int newColor) {\n\t\t\n\t\timage[x][y] = newColor;\n\t\n\t}\n\t\n\t\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filed\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     * @return\n     */\n\tpublic static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {\n\n\t\tif(x < 0 || x >= image.length) return;\n\t\tif(y < 0 || y >= image[x].length) return;\n\t\tif(getPixel(image, x, y) != oldColor) return;\n\n\t\tputPixel(image, x, y, newColor);\n\n\t\t/* Recursively check for horizontally & vertically adjacent coordinates */\n\t\tfloodFill(image, x + 1, y, newColor, oldColor);\n\t\tfloodFill(image, x - 1, y, newColor, oldColor);\n\t\tfloodFill(image, x, y + 1, newColor, oldColor);\n\t\tfloodFill(image, x, y - 1, newColor, oldColor);\n\n\t\t/* Recursively check for diagonally adjacent coordinates  */\n\t\tfloodFill(image, x + 1, y - 1, newColor, oldColor);\n\t\tfloodFill(image, x - 1, y + 1, newColor, oldColor);\n\t\tfloodFill(image, x + 1, y + 1, newColor, oldColor);\n\t\tfloodFill(image, x - 1, y - 1, newColor, oldColor);\n\n\t}\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nclass FloodFillTest {\n\n    @Test\n    void testForEmptyImage()\n    {\n        int image[][] = {};\n        int expected[][] = {};\n\n        FloodFill.floodFill(image, 4, 5, 3, 2);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForSingleElementImage()\n    {\n        int image[][] = {{1}};\n        int expected[][] = {{3}};\n\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForImageOne()\n    {\n        int image[][] = {\n                { 0,0,0,0,0,0,0 },\n                { 0,3,3,3,3,0,0 },\n                { 0,3,1,1,5,0,0 },\n                { 0,3,1,1,5,5,3 },\n                { 0,3,5,5,1,1,3 },\n                { 0,0,0,5,1,1,3 },\n                { 0,0,0,3,3,3,3 }\n        };\n\n        int expected[][] = {\n                { 0,0,0,0,0,0,0 },\n                { 0,3,3,3,3,0,0 },\n                { 0,3,2,2,5,0,0 },\n                { 0,3,2,2,5,5,3 },\n                { 0,3,5,5,2,2,3 },\n                { 0,0,0,5,2,2,3 },\n                { 0,0,0,3,3,3,3 }\n        };\n\n        FloodFill.floodFill(image,2,2,2,1);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForImageTwo()\n    {\n        int image[][] = {\n                { 0,0,1,1,0,0,0 },\n                { 1,1,3,3,3,0,0 },\n                { 1,3,1,1,5,0,0 },\n                { 0,3,1,1,5,5,3 },\n                { 0,3,5,5,1,1,3 },\n                { 0,0,0,5,1,1,3 },\n                { 0,0,0,1,3,1,3 }\n        };\n\n        int expected[][] = {\n                { 0,0,2,2,0,0,0 },\n                { 2,2,3,3,3,0,0 },\n                { 2,3,2,2,5,0,0 },\n                { 0,3,2,2,5,5,3 },\n                { 0,3,5,5,2,2,3 },\n                { 0,0,0,5,2,2,3 },\n                { 0,0,0,2,3,2,3 }\n        };\n\n        FloodFill.floodFill(image, 2, 2, 2, 1);\n        assertArrayEquals(expected, image);\n    }\n\n\n    @Test\n    void testForImageThree()\n    {\n        int image[][] = {\n                { 1,1,2,3,1,1,1 },\n                { 1,0,0,1,0,0,1 },\n                { 1,1,1,0,3,1,2 }\n        };\n\n        int expected[][] = {\n                { 4,4,2,3,4,4,4 },\n                { 4,0,0,4,0,0,4 },\n                { 4,4,4,0,3,4,2 },\n        };\n\n        FloodFill.floodFill(image, 0, 1, 4, 1);\n        assertArrayEquals(expected, image);\n    }\n\n}"
    },
    {
        "product_commit": "49a4a83adaa0dbe5bb6d594b51542aae4b0ba5b9",
        "test_commit": "49a4a83adaa0dbe5bb6d594b51542aae4b0ba5b9",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FFT.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FFTTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            double d = z.abs() * z.abs();\n            d = (double)Math.round(d * 1000000000d) / 1000000000d;\n            temp.real = (this.real * z.real + this.img * z.img) / (d);\n            temp.img = (this.img * z.real - this.real * z.img) / (d);\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *\n     * @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     */\n    public static void fft(ArrayList<Complex> x, boolean inverse) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n\n        /* Find the log2(N) */\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n\n        /* Swap the values of the signal with bit-reversal method */\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n\n        /* Divide by N if we want the inverse FFT */\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            double d = z.abs() * z.abs();\n            d = (double)Math.round(d * 1000000000d) / 1000000000d;\n            temp.real = (this.real * z.real + this.img * z.img) / (d);\n            temp.img = (this.img * z.real - this.real * z.img) / (d);\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */\n    public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n        int log2N = findLog2(N);\n        x = fftBitReversal(N,log2N,x);\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n        x = inverseFFT(N,inverse,x);\n        return x;\n    }\n\n    /* Find the log2(N) */\n    public static int findLog2(int N){\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n        return log2N;\n    }\n\n    /* Swap the values of the signal with bit-reversal method */\n    public static ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x){\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n        return x;\n    }\n\n    /* Divide by N if we want the inverse FFT */\n    public static ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x ){\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n        return x;\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass FFTTest {\n\n    // Testing the simple function getReal\n    @Test\n    void getRealtest()\n    {\n        FFT.Complex complex = new FFT.Complex(1.0,1.0);\n        assertEquals(1.0,complex.getReal());\n    }\n\n    // Testing the simple function getImaginary\n    @Test\n    void getImaginaryTest()\n    {\n        FFT.Complex complex = new FFT.Complex();\n        assertEquals(0.0,complex.getImaginary());\n    }\n\n    // Testing the function add, assertEqual test\n    @Test\n    void addTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(1.0,1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0,2.0);\n        double add = complex1.add(complex2).getReal();\n        assertEquals(3.0,add);\n    }\n\n    // Testing the function add, assertNotEqual test\n    @Test\n    void addFalseTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(1.0,1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0,2.0);\n        double add = complex1.add(complex2).getReal();\n        assertNotEquals(2.0,add);\n    }\n\n    // Testing the function substract, assertEqual test\n    @Test\n    void subtractTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,1.0);\n        double sub = complex1.subtract(complex2).getReal();\n        assertEquals(1.0,sub);\n    }\n\n    // Testing the function multiply complex, assertEqual test\n    @Test\n    void multiplyWithComplexTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,1.0);\n        double multiReal = complex1.multiply(complex2).getReal();\n        double multiImg = complex1.multiply(complex2).getImaginary();\n        assertEquals(0.0,multiReal);\n        assertEquals(4.0,multiImg);\n    }\n\n    // Testing the function multiply scalar, assertEqual test\n    @Test\n    void multiplyWithScalarTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n\n        double multiReal = complex1.multiply(2).getReal();\n        double multiImg = complex1.multiply(3).getImaginary();\n        assertEquals(4.0,multiReal);\n        assertEquals(6.0,multiImg);\n    }\n\n    // Testing the function conjugate, assertEqual test\n    @Test\n    void conjugateTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        double conReal = complex1.conjugate().getReal();\n        double conImg = complex1.conjugate().getImaginary();\n        assertEquals(2.0,conReal);\n        assertEquals(-2.0,conImg);\n    }\n\n    // Testing the function abs, assertEqual test\n    @Test\n    void abs()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,3.0);\n        double abs = complex1.abs();\n        assertEquals(Math.sqrt(13),abs);\n    }\n\n    // Testing the function divide complex, assertEqual test.\n    @Test\n    void divideWithComplexTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,2.0);\n        double divReal = complex1.divide(complex2).getReal();\n        double divImg = complex1.divide(complex2).getImaginary();\n        assertEquals(1.2,divReal);\n        assertEquals(-0.4,divImg);\n    }\n\n    // Testing the function divide scalar, assertEqual test.\n    @Test\n    void divideWithScalarTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        double divReal = complex1.divide(2).getReal();\n        double divImg = complex1.divide(2).getImaginary();\n        assertEquals(1,divReal);\n        assertEquals(1,divImg);\n    }\n\n    // Testing the function fft, assertEqual test.\n    // https://scistatcalc.blogspot.com/2013/12/fft-calculator.html used this link to\n    // ensure the result\n    @Test\n    void fft()\n    {\n        ArrayList<FFT.Complex> arr = new ArrayList<FFT.Complex>();\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,3.0);\n        FFT.Complex complex3 = new FFT.Complex(3.0,1.0);\n        FFT.Complex complex4 = new FFT.Complex(2.0,2.0);\n\n        arr.add(complex1);\n        arr.add(complex2);\n        arr.add(complex3);\n        arr.add(complex4);\n        arr = FFT.fft(arr,false);\n        double realV1= arr.get(0).getReal();\n        double realV2= arr.get(2).getReal();\n        double imgV1 = arr.get(0).getImaginary();\n        double imgV2 = arr.get(2).getImaginary();\n        assertEquals(8.0,realV1);\n        assertEquals(2.0,realV2);\n        assertEquals(8.0, imgV1);\n        assertEquals(-2.0,imgV2);\n    }\n}"
    },
    {
        "product_commit": "8bf74929e3f74e938d4f74c85203a5acc039fff1",
        "test_commit": "8bf74929e3f74e938d4f74c85203a5acc039fff1",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Gaussian.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GaussianTest.java",
        "product_old_content": "/**\n * \\file\n * \\brief [Gaussian elimination\n * method](https://en.wikipedia.org/wiki/Gaussian_elimination)\n * @author [Sachwin Kohli](https://github.com/Sachwin-Kohli)\n */\npackage com.thealgorithms.maths;\n\nimport java.util.*;\n\n/**\n * Main function\n */\npublic class Gaussian {\n\n    public static void main(String[] args) {\n        int mat_size, i, j, step;\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println(\"Matrix Size : \");\n        mat_size = sc.nextInt();\n\n        double[][] mat = new double[mat_size + 1][mat_size + 1];\n        double[][] x = new double[mat_size][mat_size + 1];\n\n        System.out.println(\"Enter value of the matrix\");\n        System.out.println(' ');\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                mat[i][j] = sc.nextInt();\n            }\n        }\n\n        // perform Gaussian elimination\n        for (step = 0; step < mat_size - 1; step++) {\n            for (i = step; i < mat_size - 1; i++) {\n                double a = (mat[i + 1][step] / mat[step][step]);\n\n                for (j = step; j <= mat_size; j++) {\n                    mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);\n                }\n            }\n        }\n\n        System.out.println(\"Matrix using Gaussian Elimination method: \");\n        System.out.println(\" \");\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                x[i][j] = mat[i][j];\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println(\"Value of the Gaussian Elimination method: \");\n        System.out.println(\" \");\n\n        for (i = mat_size - 1; i >= 0; i--) {\n            double sum = 0;\n            for (j = mat_size - 1; j > i; j--) {\n                x[i][j] = x[j][j] * x[i][j];\n                sum = x[i][j] + sum;\n            }\n            if (x[i][i] == 0) {\n                x[i][i] = 0;\n            } else {\n                x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);\n            }\n            System.out.print(\"x\" + i + \"=\" + x[i][i]);\n            System.out.println(\" \");\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\n\npublic class Gaussian {\n\n    public static ArrayList<Double> gaussian(int mat_size, ArrayList<Double> matrix) {\n        ArrayList<Double> answerArray = new ArrayList<Double>();\n        int i, j = 0;\n\n        double[][] mat = new double[mat_size + 1][mat_size + 1];\n        double[][] x = new double[mat_size][mat_size + 1];\n\n        // Values from arraylist to matrix\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                mat[i][j] = matrix.get(i);\n            }\n        }\n\n        mat = gaussianElimination(mat_size, i, mat);\n        answerArray = valueOfGaussian(mat_size, x, mat);\n        return answerArray;\n    }\n\n    // Perform Gaussian elimination\n    public static double[][] gaussianElimination(int mat_size, int i, double[][] mat) {\n        int step = 0;\n        for (step = 0; step < mat_size - 1; step++) {\n            for (i = step; i < mat_size - 1; i++) {\n                double a = (mat[i + 1][step] / mat[step][step]);\n\n                for (int j = step; j <= mat_size; j++) {\n                    mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);\n                }\n            }\n        }\n        return mat;\n    }\n\n    // calcilate the x_1, x_2,... values of the gaussian and save it in an arraylist.\n    public static ArrayList<Double> valueOfGaussian(int mat_size, double[][] x, double[][] mat) {\n        ArrayList<Double> answerArray = new ArrayList<Double>();\n        int i, j;\n\n        for (i = 0; i < mat_size; i++) {\n            for (j = 0; j <= mat_size; j++) {\n                x[i][j] = mat[i][j];\n            }\n        }\n\n        for (i = mat_size - 1; i >= 0; i--) {\n            double sum = 0;\n            for (j = mat_size - 1; j > i; j--) {\n                x[i][j] = x[j][j] * x[i][j];\n                sum = x[i][j] + sum;\n            }\n            if (x[i][i] == 0) {\n                x[i][i] = 0;\n            } else {\n                x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);\n            }\n            answerArray.add(x[i][j]);\n        }\n        return answerArray;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\n\nimport static com.thealgorithms.maths.Gaussian.gaussian;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class GaussianTest {\n\n    // easy pass test for the whole class. Matrix of 2*3.\n    @Test\n    void passTest1()\n    {\n        ArrayList<Double> list = new ArrayList<Double>();\n        ArrayList<Double> gaussian = new ArrayList<Double>();\n        ArrayList<Double> answer = new ArrayList<Double>();\n        answer.add(0.0);\n        answer.add(1.0);\n\n        int matrixSize = 2;\n        list.add(1.0);\n        list.add(1.0);\n        list.add(1.0);\n        list.add(2.0);\n        list.add(1.0);\n        list.add(1.0);\n        gaussian=gaussian(matrixSize,list);\n\n        assertEquals(answer,gaussian);\n    }\n}"
    },
    {
        "product_commit": "adadb2f6d65a245361f5a599a4ab542fae8c328f",
        "test_commit": "adadb2f6d65a245361f5a599a4ab542fae8c328f",
        "product_file_path": "src/main/java/com/thealgorithms/others/BestFit.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/BestFitCPUTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @author Dekas Dimitrios\n */\npublic class BestFit {\n\n    private static final int NO_ALLOCATION\n            = -255; // if a process has been allocated in position -255,\n    // it means that it has not been actually allocated.\n\n    /**\n     * Method to find the maximum valued element of an array filled with\n     * positive integers.\n     *\n     * @param array: an array filled with positive integers.\n     * @return the maximum valued element of the array.\n     */\n    private static int findMaxElement(int[] array) {\n        int max = -1;\n        for (int value : array) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n\n    /**\n     * Method to find the index of the memory block that is going to fit the\n     * given process based on the best fit algorithm.\n     *\n     * @param blocks: the array with the available memory blocks.\n     * @param process: the size of the process.\n     * @return the index of the block that fits, or -255 if no such block\n     * exists.\n     */\n    private static int findBestFit(int[] blockSizes, int processSize) {\n        // Initialize minDiff with an unreachable value by a difference between a blockSize and the\n        // processSize.\n        int minDiff = findMaxElement(blockSizes);\n        int index\n                = NO_ALLOCATION; // If there is no block that can fit the process, return NO_ALLOCATION as the\n        // result.\n        for (int i = 0;\n                i < blockSizes.length;\n                i++) { // Find the most fitting memory block for the given process.\n            if (blockSizes[i] - processSize < minDiff && blockSizes[i] - processSize >= 0) {\n                minDiff = blockSizes[i] - processSize;\n                index = i;\n            }\n        }\n        return index;\n    }\n\n    /**\n     * Method to allocate memory to blocks according to the best fit algorithm.\n     * It should return an ArrayList of Integers, where the index is the process\n     * ID (zero-indexed) and the value is the block number (also zero-indexed).\n     *\n     * @param sizeOfBlocks: an int array that contains the sizes of the memory\n     * blocks available.\n     * @param sizeOfProcesses: an int array that contains the sizes of the\n     * processes we need memory blocks for.\n     * @return the ArrayList filled with Integers repressenting the memory\n     * allocation that took place.\n     */\n    static ArrayList<Integer> bestFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\n        // The array list responsible for saving the memory allocations done by the best-fit algorithm\n        ArrayList<Integer> memAlloc = new ArrayList<>();\n        // Do this for every process\n        for (int processSize : sizeOfProcesses) {\n            int chosenBlockIdx\n                    = findBestFit(\n                            sizeOfBlocks, processSize); // Find the index of the memory block going to be used\n            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\n            if (chosenBlockIdx\n                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\n                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\n            }\n        }\n        return memAlloc;\n    }\n\n    /**\n     * Method to print the memory allocated.\n     *\n     * @param memAllocation: an ArrayList of Integer representing the memory\n     * allocation done by the bestFit method.\n     */\n    public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\n        System.out.println(\"Process No.\\tBlock No.\");\n        System.out.println(\"===========\\t=========\");\n        for (int i = 0; i < memAllocation.size(); i++) {\n            System.out.print(\" \" + i + \"\\t\\t\");\n            if (memAllocation.get(i) != NO_ALLOCATION) {\n                System.out.print(memAllocation.get(i));\n            } else {\n                System.out.print(\"Not Allocated\");\n            }\n            System.out.println();\n        }\n    }\n}",
        "product_new_content": null,
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * author Alexandros Lemonaris\n */\nclass BestFitCPUTest {\n    int [] sizeOfBlocks;\n    int [] sizeOfProcesses;\n    ArrayList<Integer> memAllocation = new ArrayList<>();\n    ArrayList<Integer> testMemAllocation ;\n    CPUalgorithms bestFit = new BestFitCPU();\n\n    @Test\n    void testFitForUseOfOneBlock() {\n        //test1 - 2 processes shall fit to one block instead of using a different block each\n        sizeOfBlocks = new int[]{5, 12, 17, 10};\n        sizeOfProcesses = new int[]{10, 5, 15, 2};\n        memAllocation = bestFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(3, 0, 2, 2)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForEqualProcecesses() {\n        //test2\n        sizeOfBlocks = new int[]{5, 12, 17, 10};\n        sizeOfProcesses = new int[]{10, 10, 10, 10};\n        memAllocation = bestFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(3, 1, 2, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForNoEmptyBlockCell() {\n        //test3 for more processes than blocks - no empty space left to none of the blocks\n        sizeOfBlocks = new int[]{5, 12, 17};\n        sizeOfProcesses = new int[]{5, 12, 10, 7};\n        memAllocation = bestFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(0, 1, 2, 2)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForSameInputDifferentQuery() {\n        //test4 for more processes than blocks - one element does not fit due to input series\n        sizeOfBlocks = new int[]{5, 12, 17};\n        sizeOfProcesses = new int[]{5, 7, 10, 12};\n        memAllocation = bestFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(0, 1, 2, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForMoreBlocksNoFit() {\n        //test5 for more blocks than processes\n        sizeOfBlocks = new int[] {5, 4, -1, 3, 6};\n        sizeOfProcesses = new int [] {10, 11};\n        memAllocation = bestFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList( -255, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n}"
    },
    {
        "product_commit": "adadb2f6d65a245361f5a599a4ab542fae8c328f",
        "test_commit": "adadb2f6d65a245361f5a599a4ab542fae8c328f",
        "product_file_path": "src/main/java/com/thealgorithms/others/FirstFit.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/FirstFitCPUTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @author Dekas Dimitrios\n */\npublic class FirstFit {\n\n    private static final int NO_ALLOCATION\n            = -255; // if a process has been allocated in position -255,\n    // it means that it has not been actually allocated.\n\n    /**\n     * Method to find the index of the memory block that is going to fit the\n     * given process based on the first fit algorithm.\n     *\n     * @param blocks: the array with the available memory blocks.\n     * @param process: the size of the process.\n     * @return the index of the block that fits, or -255 if no such block\n     * exists.\n     */\n    private static int findFirstFit(int[] blockSizes, int processSize) {\n        for (int i = 0; i < blockSizes.length; i++) {\n            if (blockSizes[i] >= processSize) {\n                return i;\n            }\n        }\n        // If there is not a block that can fit the process, return -255 as the result\n        return NO_ALLOCATION;\n    }\n\n    /**\n     * Method to allocate memory to blocks according to the first fit algorithm.\n     * It should return an ArrayList of Integers, where the index is the process\n     * ID (zero-indexed) and the value is the block number (also zero-indexed).\n     *\n     * @param sizeOfBlocks: an int array that contains the sizes of the memory\n     * blocks available.\n     * @param sizeOfProcesses: an int array that contains the sizes of the\n     * processes we need memory blocks for.\n     * @return the ArrayList filled with Integers repressenting the memory\n     * allocation that took place.\n     */\n    static ArrayList<Integer> firstFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\n        // The array list responsible for saving the memory allocations done by the first-fit algorithm\n        ArrayList<Integer> memAlloc = new ArrayList<>();\n        // Do this for every process\n        for (int processSize : sizeOfProcesses) {\n            int chosenBlockIdx\n                    = findFirstFit(\n                            sizeOfBlocks, processSize); // Find the index of the memory block going to be used\n            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\n            if (chosenBlockIdx\n                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\n                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\n            }\n        }\n        return memAlloc;\n    }\n\n    /**\n     * Method to print the memory allocated.\n     *\n     * @param memAllocation: an ArrayList of Integer representing the memory\n     * allocation done by the firstFit method.\n     */\n    public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\n        System.out.println(\"Process No.\\tBlock No.\");\n        System.out.println(\"===========\\t=========\");\n        for (int i = 0; i < memAllocation.size(); i++) {\n            System.out.print(\" \" + i + \"\\t\\t\");\n            if (memAllocation.get(i) != NO_ALLOCATION) {\n                System.out.print(memAllocation.get(i));\n            } else {\n                System.out.print(\"Not Allocated\");\n            }\n            System.out.println();\n        }\n    }\n}",
        "product_new_content": null,
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * author Alexandros Lemonaris\n */\nclass FirstFitCPUTest {\n    int [] sizeOfBlocks;\n    int [] sizeOfProcesses;\n    ArrayList<Integer> memAllocation = new ArrayList<>();\n    ArrayList<Integer> testMemAllocation ;\n    CPUalgorithms firstFit = new FirstFitCPU();\n\n    @Test\n    void testFitForUseOfOneBlock() {\n        //test1 - no use of one block for two processes\n        sizeOfBlocks = new int[]{5, 12, 17, 10};\n        sizeOfProcesses = new int[]{10, 5, 15, 2};\n        memAllocation = firstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(1, 0, 2, 1)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForEqualProcecesses() {\n        //test2\n        sizeOfBlocks = new int[]{5, 12, 17, 10};\n        sizeOfProcesses = new int[]{10, 10, 10, 10};\n        memAllocation = firstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(1, 2, 3, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForNoEmptyBlockCell() {\n        //test3 for more processes than blocks - no empty space left to none of the blocks\n        sizeOfBlocks = new int[]{5, 12, 17};\n        sizeOfProcesses = new int[]{5, 12, 10, 7};\n        memAllocation = firstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(0, 1, 2, 2)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForSameInputDifferentQuery() {\n        //test4 for more processes than blocks - one element does not fit due to input series\n        sizeOfBlocks = new int[]{5, 12, 17};\n        sizeOfProcesses = new int[]{5, 7, 10, 12};\n        memAllocation = firstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(0, 1, 2, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForMoreBlocksNoFit() {\n        //test5 for more blocks than processes\n        sizeOfBlocks = new int[] {5, 4, -1, 3, 6};\n        sizeOfProcesses = new int [] {10, 11};\n        memAllocation = firstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList( -255, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n}"
    },
    {
        "product_commit": "adadb2f6d65a245361f5a599a4ab542fae8c328f",
        "test_commit": "adadb2f6d65a245361f5a599a4ab542fae8c328f",
        "product_file_path": "src/main/java/com/thealgorithms/others/WorstFit.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/WorstFitCPUTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @author Dekas Dimitrios\n */\npublic class WorstFit {\n\n    private static final int NO_ALLOCATION\n            = -255; // if a process has been allocated in position -255,\n    // it means that it has not been actually allocated.\n\n    /**\n     * Method to find the index of the memory block that is going to fit the\n     * given process based on the worst fit algorithm.\n     *\n     * @param blocks: the array with the available memory blocks.\n     * @param process: the size of the process.\n     * @return the index of the block that fits, or -255 if no such block\n     * exists.\n     */\n    private static int findWorstFit(int[] blockSizes, int processSize) {\n        int max = -1;\n        int index = -1;\n        for (int i = 0;\n                i < blockSizes.length;\n                i++) { // Find the index of the biggest memory block available.\n            if (blockSizes[i] > max) {\n                max = blockSizes[i];\n                index = i;\n            }\n        }\n        // If the biggest memory block cannot fit the process, return -255 as the result\n        if (processSize > blockSizes[index]) {\n            return NO_ALLOCATION;\n        }\n        return index;\n    }\n\n    /**\n     * Method to allocate memory to blocks according to the worst fit algorithm.\n     * It should return an ArrayList of Integers, where the index is the process\n     * ID (zero-indexed) and the value is the block number (also zero-indexed).\n     *\n     * @param sizeOfBlocks: an int array that contains the sizes of the memory\n     * blocks available.\n     * @param sizeOfProcesses: an int array that contains the sizes of the\n     * processes we need memory blocks for.\n     * @return the ArrayList filled with Integers repressenting the memory\n     * allocation that took place.\n     */\n    static ArrayList<Integer> worstFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\n        // The array list responsible for saving the memory allocations done by the worst-fit algorithm\n        ArrayList<Integer> memAlloc = new ArrayList<>();\n        // Do this for every process\n        for (int processSize : sizeOfProcesses) {\n            int chosenBlockIdx\n                    = findWorstFit(\n                            sizeOfBlocks, processSize); // Find the index of the memory block going to be used\n            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\n            if (chosenBlockIdx\n                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\n                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\n            }\n        }\n        return memAlloc;\n    }\n\n    /**\n     * Method to print the memory allocated.\n     *\n     * @param memAllocation: an ArrayList of Integer representing the memory\n     * allocation done by the worstFit method.\n     */\n    public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\n        System.out.println(\"Process No.\\tBlock No.\");\n        System.out.println(\"===========\\t=========\");\n        for (int i = 0; i < memAllocation.size(); i++) {\n            System.out.print(\" \" + i + \"\\t\\t\");\n            if (memAllocation.get(i) != NO_ALLOCATION) {\n                System.out.print(memAllocation.get(i));\n            } else {\n                System.out.print(\"Not Allocated\");\n            }\n            System.out.println();\n        }\n    }\n}",
        "product_new_content": null,
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * author Alexandros Lemonaris\n */\nclass WorstFitCPUTest {\n    int [] sizeOfBlocks;\n    int [] sizeOfProcesses;\n    ArrayList<Integer> memAllocation = new ArrayList<>();\n    ArrayList<Integer> testMemAllocation ;\n    CPUalgorithms worstFit = new WorstFitCPU();\n\n    @Test\n    void testFitForUseOfOneBlock() {\n        //test1\n        sizeOfBlocks = new int[]{5, 12, 17, 10};\n        sizeOfProcesses = new int[]{10, 5, 15, 2};\n        memAllocation = worstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(2, 1, -255, 3)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForEqualProcecesses() {\n        //test2\n        sizeOfBlocks = new int[]{5, 12, 17, 10};\n        sizeOfProcesses = new int[]{10, 10, 10, 10};\n        memAllocation = worstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(2, 1, 3, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForNoEmptyBlockCell() {\n        //test3 - could suits best, bad use of memory allocation due to worstFit algorithm\n        sizeOfBlocks = new int[]{5, 12, 17};\n        sizeOfProcesses = new int[]{5, 12, 10, 7};\n        memAllocation = worstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(2, 1, 2, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForSameInputDifferentQuery() {\n        //test4 same example different series - same results\n        sizeOfBlocks = new int[]{5, 12, 17};\n        sizeOfProcesses = new int[]{5, 7, 10, 12};\n        memAllocation = worstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList(2, 1, 2, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitForMoreBlocksNoFit() {\n        //test5 for more blocks than processes\n        sizeOfBlocks = new int[] {5, 4, -1, 3, 6};\n        sizeOfProcesses = new int [] {10, 11};\n        memAllocation = worstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList( -255, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n    @Test\n    void testFitBadCase() {\n        //test6 for only two process fit\n        sizeOfBlocks = new int[] {7, 17, 7, 5, 6};\n        sizeOfProcesses = new int [] {8, 10, 10, 8, 8, 8};\n        memAllocation = worstFit.fitProcess(sizeOfBlocks, sizeOfProcesses);\n        testMemAllocation = new ArrayList<>(\n                Arrays.asList( 1, -255, -255, 1, -255, -255)\n        );\n        assertEquals(testMemAllocation, memAllocation);\n    }\n}"
    },
    {
        "product_commit": "12c67bc50182b0e68a10577cece3d5a65f4adbc1",
        "test_commit": "12c67bc50182b0e68a10577cece3d5a65f4adbc1",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/Combination.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/CombinationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.*;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Combination {\n    private static int length;\n    /**\n     * Find all combinations of given array using backtracking\n     * @param arr the array.\n     * @param n length of combination\n     * @param <T> the type of elements in the array.\n     * @return a list of all combinations of length n. If n == 0, return null.\n     */\n    public static <T> List<TreeSet<T>> combination(T[] arr, int n) {\n        if (n == 0) {\n            return null;\n        }\n        length = n;\n        T[] array = arr.clone();\n        Arrays.sort(array);\n        List<TreeSet<T>> result = new LinkedList<>();\n        backtracking(array, 0, new TreeSet<T>(), result);\n        return result;\n    }\n    /**\n     * Backtrack all possible combinations of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param currSet set that tracks current combination\n     * @param result the list contains all combination.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(T[] arr, int index, TreeSet<T> currSet, List<TreeSet<T>> result) {\n        if (index + length - currSet.size() > arr.length) return;\n        if (length - 1 == currSet.size()) {\n            for (int i = index; i < arr.length; i++) {\n                currSet.add(arr[i]);\n                result.add((TreeSet<T>) currSet.clone());\n                currSet.remove(arr[i]);\n            }\n        }\n        for (int i = index; i < arr.length; i++) {\n            currSet.add(arr[i]);\n            backtracking(arr, i + 1, currSet, result);\n            currSet.remove(arr[i]);\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class CombinationTest {\n    @Test\n    void testNoElement()\n    {\n        List<TreeSet<Integer>> result  = Combination.combination(new Integer[]{1, 2}, 0);\n        assertTrue(result == null);\n    }\n    @Test\n    void testLengthOne()\n    {\n        List<TreeSet<Integer>> result  = Combination.combination(new Integer[]{1, 2}, 1);\n        assertTrue(result.get(0).iterator().next() == 1);\n        assertTrue(result.get(1).iterator().next() == 2);\n    }\n    @Test\n    void testLengthTwo()\n    {\n        List<TreeSet<Integer>> result  = Combination.combination(new Integer[]{1, 2}, 2);\n        Integer[] arr = result.get(0).toArray(new Integer[2]);\n        assertTrue(arr[0] == 1);\n        assertTrue(arr[1] == 2);\n    }\n}"
    },
    {
        "product_commit": "12c67bc50182b0e68a10577cece3d5a65f4adbc1",
        "test_commit": "12c67bc50182b0e68a10577cece3d5a65f4adbc1",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/Permutation.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/PermutationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Finds all permutations of given array\n * @author Alan Piao (https://github.com/cpiao3)\n */\npublic class Permutation {\n    /**\n     * Find all permutations of given array using backtracking\n     * @param arr the array.\n     * @param <T> the type of elements in the array.\n     * @return a list of all permutations.\n     */\n    public static <T> List<T[]> permutation(T[] arr) {\n        T[] array = arr.clone();\n        List<T[]> result = new LinkedList<>();\n        backtracking(array, 0, result);\n        return result;\n    }\n    /**\n     * Backtrack all possible orders of a given array\n     * @param arr the array.\n     * @param index the starting index.\n     * @param result the list contains all permutations.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void backtracking(T[] arr, int index, List<T[]> result) {\n        if (index == arr.length) {\n            result.add(arr.clone());\n        }\n        for (int i = index; i < arr.length; i++) {\n            swap(index, i, arr);\n            backtracking(arr, index + 1, result);\n            swap(index, i, arr);\n        }\n    }\n    /**\n     * Swap two element for a given array\n     * @param a first index\n     * @param b second index\n     * @param arr the array.\n     * @param <T> the type of elements in the array.\n     */\n    private static <T> void swap(int a, int b, T[] arr) {\n        T temp = arr[a];\n        arr[a] = arr[b];\n        arr[b] = temp;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PermutationTest {\n    @Test\n    void testNoElement()\n    {\n        List<Integer []> result = Permutation.permutation(new Integer[]{});\n        assertEquals(result.get(0).length, 0);\n    }\n    @Test\n    void testSingleElement()\n    {\n        List<Integer []> result = Permutation.permutation(new Integer[]{1});\n        assertEquals(result.get(0)[0], 1);\n    }\n    @Test\n    void testMultipleElements()\n    {\n        List<Integer []> result = Permutation.permutation(new Integer[]{1, 2});\n        assertTrue(Arrays.equals(result.get(0), new Integer[]{1,2}));\n        assertTrue(Arrays.equals(result.get(1), new Integer[]{2,1}));\n    }\n\n\n}"
    },
    {
        "product_commit": "ab9f74c2ee0dee9174616f2154f1161d600f68cd",
        "test_commit": "ab9f74c2ee0dee9174616f2154f1161d600f68cd",
        "product_file_path": "src/main/java/com/thealgorithms/maths/KaprekarNumbers.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/KaprekarNumbersTest.java",
        "product_old_content": "package com.thealgorithms.maths;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n\t/* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n\t// Provides a list of kaprekarNumber in a range\n\tpublic static ArrayList<Long> kaprekarNumberInRange(long start, long end) throws Exception {\n\t\tlong n = end-start;\n\t\tif (n <0) throw new Exception(\"Invalid range\");\n\t\tArrayList<Long> list = new ArrayList<>();\n\n\t\tfor (long i = start; i <= end; i++) {\n\t\t\tif (isKaprekarNumber(i)) list.add(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t// Checks whether a given number is Kaprekar Number or not\n\tpublic static boolean isKaprekarNumber(long number) {\n\t\tlong numberSquared = number * number;\n\t\tif(Long.toString(number).length() == Long.toString(numberSquared).length()){\n\t\t\treturn (number == numberSquared);\n\t\t}\n\t\telse{\n\t\t\tlong leftDigits1 = 0, leftDigits2;\n\t\t\tif(Long.toString(numberSquared).contains(\"0\")){\n\t\t\t\tleftDigits1 = Long.parseLong(Long.toString(numberSquared).substring(0, Long.toString(numberSquared).indexOf(\"0\")));\n\t\t\t}\n\t\t\tleftDigits2 = Long.parseLong(Long.toString(numberSquared).substring(0, (Long.toString(numberSquared).length() - Long.toString(number).length())));\n\t\t\tlong rightDigits = Long.parseLong(Long.toString(numberSquared).substring(Long.toString(numberSquared).length() - Long.toString(number).length()));\n\t\t\treturn (number == (leftDigits1 + rightDigits)) || (number == (leftDigits2 + rightDigits));\n\t\t}\t\t\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.maths;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n\t/* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n\t// Provides a list of kaprekarNumber in a range\n\tpublic static ArrayList<Long> kaprekarNumberInRange(long start, long end) throws Exception {\n\t\tlong n = end-start;\n\t\tif (n <0) throw new Exception(\"Invalid range\");\n\t\tArrayList<Long> list = new ArrayList<>();\n\n\t\tfor (long i = start; i <= end; i++) {\n\t\t\tif (isKaprekarNumber(i)) list.add(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t// Checks whether a given number is Kaprekar Number or not\n\tpublic static boolean isKaprekarNumber(long num) {\n\t\tString number = Long.toString(num);\n\t\tBigInteger originalNumber = new BigInteger(number);\n\t\tBigInteger numberSquared = originalNumber.multiply(originalNumber);\n\t\tif(number.length() == numberSquared.toString().length()){\n\t\t\treturn number.equals(numberSquared.toString());\n\t\t}\n\t\telse{\n\t\t\tBigInteger leftDigits1 = new BigInteger(\"0\");\n\t\t\tBigInteger leftDigits2;\n\t\t\tif(numberSquared.toString().contains(\"0\")){\n\t\t\t\tleftDigits1 = new BigInteger(\n\t\t\t\t\t\tnumberSquared.toString().\n\t\t\t\t\t\t\t\tsubstring(0, numberSquared.toString().indexOf(\"0\")\n\t\t\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tleftDigits2 = new BigInteger(\n\t\t\t\t\tnumberSquared.toString()\n\t\t\t\t\t\t\t.substring(0, (numberSquared.toString().length() - number.length()))\n\t\t\t);\n\t\t\tBigInteger rightDigits = new BigInteger(numberSquared.toString().substring(numberSquared.toString().length() - number.length()));\n\t\t\tString x = leftDigits1.add(rightDigits).toString();\n\t\t\tString y = leftDigits2.add(rightDigits).toString();\n\t\t\treturn (number.equals(x)) || (number.equals(y));\n\t\t}\t\t\n\t}\n\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KaprekarNumbersTest {\n\n\t@Test\n\tvoid testFor1() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(1));\n\t}\n\n\t@Test\n\tvoid testFor45() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(45));\n\t}\n\n\t@Test\n\tvoid testFor297() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(297));\n\t}\n\n\t@Test\n\tvoid testFor2223() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n\t}\n\n\t@Test\n\tvoid testFor857143() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n\t}\n\n\n\t@Test\n\tvoid testFor3() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(3));\n\t}\n\n\t@Test\n\tvoid testFor26() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(26));\n\t}\n\n\t@Test\n\tvoid testFor98() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(98));\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KaprekarNumbersTest {\n\n\t@Test\n\tvoid testFor1() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(1));\n\t}\n\n\t@Test\n\tvoid testFor45() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(45));\n\t}\n\n\t@Test\n\tvoid testFor297() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(297));\n\t}\n\n\t@Test\n\tvoid testFor2223() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n\t}\n\n\t@Test\n\tvoid testFor857143() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n\t}\n\n\n\t@Test\n\tvoid testFor3() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(3));\n\t}\n\n\t@Test\n\tvoid testFor26() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(26));\n\t}\n\n\t@Test\n\tvoid testFor98() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(98));\n\t}\n\n\t@Test\n\tvoid testForRangeOfNumber() { try {\n\t\tArrayList<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(1,100000);\n\t\tlong[] allTheNumbers = {1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4950, 5050, 7272, 7777, 9999, 17344, 22222, 77778, 82656, 95121, 99999};\n\t\tfor (long i:allTheNumbers) {\n\t\t\tassert rangedNumbers.contains(i);\n\t\t}\n\t} catch (Exception e) {\n\t\tassert false;\n\t}\n\t}\n\n}"
    },
    {
        "product_commit": "32cdf02afb448be9a47689c829005cf1e3719dc7",
        "test_commit": "32cdf02afb448be9a47689c829005cf1e3719dc7",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PronicNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PronicNumberTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for Pronic Number\n * Pronic Number: A number n is a pronic number if\n * it is equal to product of two consecutive numbers m and m+1.\n * Wikipedia: https://en.wikipedia.org/wiki/Pronic_number\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class PronicNumber {\n\n\t/**\n     * This method checks if the given number is pronic number or non-pronic number\n     *\n     * @param input_number Integer value which is to be checked if is a pronic number or not \n     * @return true if input number is a pronic number, false otherwise\n     */\n\tstatic boolean isPronic(int input_number) {\n\t\t\n\t\t//Iterating from 0 to input_number\n\t\tfor(int i = 0; i <= input_number; i++) {\n\t\t\t\n\t\t\t//Checking if product of i and (i+1) is equals input_number\n\t\t\tif(i * (i+1) == input_number && i != input_number) {\n\t\t\t\t\n\t\t\t\t//return true if product of i and (i+1) is equals input_number\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t//return false if product of i and (i+1) for all values from 0 to input_number is not equals input_number\n\t\treturn false;\n\t}\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class PronicNumberTest {\n\n    @Test\n    void testForPronicNumber() {\n\n        //given\n        int number = 30;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n        \n        //then\n        assertTrue(result);\n    }\n\n    @Test\n    void testForNonPronicNumber() {\n        \n        //given\n        int number = 21;\n\n        //when\n        boolean result = PronicNumber.isPronic(number);\n        \n        //then\n        assertFalse(result);\n    }\n}"
    },
    {
        "product_commit": "98656cb0cdacd175559272bcbb8bc3b86ddac52a",
        "test_commit": "98656cb0cdacd175559272bcbb8bc3b86ddac52a",
        "product_file_path": "src/main/java/com/thealgorithms/maths/KaprekarNumbers.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/KaprekarNumbersTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\npublic class KaprekarNumbers {\n\n\t/* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n\t// Checks whether a given number is Kaprekar Number or not\n\n\tpublic static boolean isKaprekarNumber(long number) {\t\t\t\n\t\tlong numberSquared = number * number;\n\t\tif(Long.toString(number).length() == Long.toString(numberSquared).length()){\n\t\t\treturn (number == numberSquared);\n\t\t}\n\t\telse{\n\t\t\tlong leftDigits1 = 0, leftDigits2 = 0;\n\t\t\tif(Long.toString(numberSquared).contains(\"0\")){\n\t\t\t\tleftDigits1 = Long.parseLong(Long.toString(numberSquared).substring(0, Long.toString(numberSquared).indexOf(\"0\")));\n\t\t\t}\n\t\t\tleftDigits2 = Long.parseLong(Long.toString(numberSquared).substring(0, (Long.toString(numberSquared).length() - Long.toString(number).length())));\n\t\t\tlong rightDigits = Long.parseLong(Long.toString(numberSquared).substring(Long.toString(numberSquared).length() - Long.toString(number).length()));\n\t\t\treturn (number == (leftDigits1 + rightDigits)) || (number == (leftDigits2 + rightDigits));\n\t\t}\t\t\n\t}\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KaprekarNumbersTest {\n\n\t@Test\n\tvoid testFor1() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(1));\n\t}\n\n\t@Test\n\tvoid testFor45() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(45));\n\t}\n\n\t@Test\n\tvoid testFor297() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(297));\n\t}\n\n\t@Test\n\tvoid testFor2223() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n\t}\n\n\t@Test\n\tvoid testFor857143() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n\t}\n\n\n\t@Test\n\tvoid testFor3() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(3));\n\t}\n\n\t@Test\n\tvoid testFor26() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(26));\n\t}\n\n\t@Test\n\tvoid testFor98() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(98));\n\t}\n\n}"
    },
    {
        "product_commit": "b1242e045b1d1cffbe71f05b8aeb97469f154f13",
        "test_commit": "b1242e045b1d1cffbe71f05b8aeb97469f154f13",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PascalTriangle.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PascalTriangleTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Scanner;\npublic class PascalTriangle {\n    /**\n     *In mathematics, Pascal's triangle is a triangular array of the binomial coefficients that arises\n     * in probability theory, combinatorics, and algebra. In much of the Western world, it is named after\n     * the French mathematician Blaise Pascal, although other mathematicians studied it centuries before\n     * him in India, Persia, China, Germany, and Italy.\n     *\n     * The rows of Pascal's triangle are conventionally enumerated starting with row n=0 at the top (the 0th row).\n     * The entries in each row are numbered from the left beginning with k=0 and are usually staggered relative\n     * to the numbers in the adjacent rows. The triangle may be constructed in the following manner:\n     * In row 0 (the topmost row), there is a unique nonzero entry 1. Each entry of each subsequent row is\n     * constructed by adding the number above and to the left with the number above and to the right, treating\n     * blank entries as 0. For example, the initial number in the first (or any other) row is 1 (the sum of 0 and 1),\n     * whereas the numbers 1 and 3 in the third row are added to produce the number 4 in the fourth row. *\n     *\n     *<p>\n     *     link:-https://en.wikipedia.org/wiki/Pascal%27s_triangle\n     *\n     * <p>\n     *     Example:-\n     *                  1\n     *                1   1\n     *              1   2   1\n     *            1   3   3   1\n     *          1   4   6   4   1\n     *        1   5  10   10  5   1\n     *      1   6  15  20   15  6   1\n     *    1   7  21  35   35  21  7   1\n     *  1   8  28  56  70   56   28  8   1\n     *\n     */\n\n        public static int[][] pascal(int n)\n    {\n        /**\n         * @param arr  An auxiliary array to store generated pascal triangle values\n         * @return\n         */\n        int[][] arr = new int[n][n];\n        /**\n         * @param line Iterate through every line and print integer(s) in it\n         * @param i Represents the column number of the element we are currently on\n         */\n        for (int line = 0; line < n; line++)\n        {\n            /**\n             *  @Every line has number of integers equal to line number\n             */\n            for (int i = 0; i <= line; i++)\n            {\n                // First and last values in every row are 1\n                if (line == i || i == 0)\n                    arr[line][i] = 1;\n                    // The rest elements are sum of values just above and left of above\n                else\n                    arr[line][i] = arr[line-1][i-1] + arr[line-1][i];\n            }\n        }\n        \n        return arr;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass PascalTriangleTest {\n\n\t@Test\n\tvoid testForOne() \n\t{\n\t\tint[][] result = PascalTriangle.pascal(1);\n        int[][] expected = {{1}};\n\t\tassertArrayEquals(result,expected);\n\t}\n\n\t@Test\n\tvoid testForTwo() \n\t{\n\t\tint[][] result = PascalTriangle.pascal(2);\n    \tint[][] expected = {{1,0},{1,1}};\n\t\tassertArrayEquals(result,expected);\n\t}\n\n\t@Test\n\tvoid testForFive() \n\t{\n\t\tint[][] result = PascalTriangle.pascal(5);\n    \tint[][] expected = {{1,0,0,0,0},{1,1,0,0,0},{1,2,1,0,0},{1,3,3,1,0},{1,4,6,4,1}};\n\t\tassertArrayEquals(result,expected);\n\t}\n\n\t@Test\n\tvoid testForEight() {\n\t\tint[][] result = PascalTriangle.pascal(8);\n    \tint[][] expected = {{1,0,0,0,0,0,0,0},{1,1,0,0,0,0,0,0},{1,2,1,0,0,0,0,0},{1,3,3,1,0,0,0,0},{1,4,6,4,1,0,0,0},{1,5,10,10,5,1,0,0},{1,6,15,20,15,6,1,0},{1,7,21,35,35,21,7,1}};\n\t\tassertArrayEquals(expected, result);\n\t}\n\n\n}"
    },
    {
        "product_commit": "734f7a4a042f68d4bc4fd8dd83ae6227f432a297",
        "test_commit": "734f7a4a042f68d4bc4fd8dd83ae6227f432a297",
        "product_file_path": "src/main/java/com/thealgorithms/others/ArrayLeftRotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/ArrayLeftRotationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\n\n/*\n * A left rotation operation on an array\n * shifts each of the array's elements\n * given integer n unit to the left.\n * \n * @author sangin-lee \n */\n\npublic class ArrayLeftRotation {\n\n\t/*\n\t * Returns the result of left rotation of given array arr and integer n\n\t * \n\t * @param arr : int[] given array\n\t * \n\t * @param n : int given integer\n\t * \n\t * @return : int[] result of left rotation\n\t */\n\tpublic static int[] rotateLeft(int[] arr, int n) {\n\t\tint size = arr.length;\n\t\tint[] dst = new int[size];\n\t\tn = n % size;\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tdst[i] = arr[n];\n\t\t\tn = (n + 1) % size;\n\t\t}\n\t\treturn dst;\n\t}\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ArrayLeftRotationTest {\n\n\t@Test\n\tvoid testForOneElement() {\n\t\tint[] arr = {3};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 3);\n\t\tassertArrayEquals(arr, result);\n\t}\n\t\n\t@Test\n\tvoid testForZeroStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 0);\n\t\tassertArrayEquals(arr, result);\n\t}\n\t\n\t@Test\n\tvoid testForEqualSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 5);\n\t\tassertArrayEquals(arr, result);\n\t}\n\t\n\t@Test\n\tvoid testForLowerSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 2;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\t\n\t@Test\n\tvoid testForHigherSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 7;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\n}"
    },
    {
        "product_commit": "66d8d51de67fd3e7c7249930f4a912ad9560d823",
        "test_commit": "66d8d51de67fd3e7c7249930f4a912ad9560d823",
        "product_file_path": "src/main/java/com/thealgorithms/searches/QuickSelect.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/QuickSelectTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.searches;\n\nimport java.util.*;\n\n/**\n * An implementation of the Quickselect algorithm as described\n * <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">here</a>.\n */\npublic final class QuickSelect {\n\n    /**\n     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would\n     * be at index n if the list was sorted.\n     * <p>\n     * Calling this function might change the order of elements in {@code list}.\n     *\n     * @param list the list of elements\n     * @param n    the index\n     * @param <T>  the type of list elements\n     * @return the n-th largest element in the list\n     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to\n     *                                   the number of elements in the list\n     * @throws IllegalArgumentException  if the list is empty\n     * @throws NullPointerException      if {@code list} is null\n     */\n    public static <T extends Comparable<T>> T select(List<T> list, int n) {\n        Objects.requireNonNull(list, \"The list of elements must not be null.\");\n\n        if (list.size() == 0) {\n            String msg = \"The list of elements must not be empty.\";\n            throw new IllegalArgumentException(msg);\n        }\n\n        if (n < 0) {\n            String msg = \"The index must not be negative.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        if (n >= list.size()) {\n            String msg = \"The index must be less than the number of elements.\";\n            throw new IndexOutOfBoundsException(msg);\n        }\n\n        int index = selectIndex(list, n);\n        return list.get(index);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {\n        return selectIndex(list, 0, list.size() - 1, n);\n    }\n\n    private static <T extends Comparable<T>> int selectIndex(\n            List<T> list,\n            int left,\n            int right,\n            int n\n    ) {\n        while (true) {\n            if (left == right)\n                return left;\n            int pivotIndex = pivot(list, left, right);\n            pivotIndex = partition(list, left, right, pivotIndex, n);\n            if (n == pivotIndex) {\n                return n;\n            } else if (n < pivotIndex) {\n                right = pivotIndex - 1;\n            } else {\n                left = pivotIndex + 1;\n            }\n        }\n    }\n\n    private static <T extends Comparable<T>> int partition(\n            List<T> list,\n            int left,\n            int right,\n            int pivotIndex,\n            int n\n    ) {\n        T pivotValue = list.get(pivotIndex);\n        Collections.swap(list, pivotIndex, right);\n        int storeIndex = left;\n\n        for (int i = left; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) < 0) {\n                Collections.swap(list, storeIndex, i);\n                storeIndex++;\n            }\n        }\n\n        int storeIndexEq = storeIndex;\n\n        for (int i = storeIndex; i < right; i++) {\n            if (list.get(i).compareTo(pivotValue) == 0) {\n                Collections.swap(list, storeIndexEq, i);\n                storeIndexEq++;\n            }\n        }\n\n        Collections.swap(list, right, storeIndexEq);\n\n        return (n < storeIndex)\n                ? storeIndex\n                : Math.min(n, storeIndexEq);\n    }\n\n    private static <T extends Comparable<T>> int pivot(\n            List<T> list,\n            int left,\n            int right\n    ) {\n        if (right - left < 5) {\n            return partition5(list, left, right);\n        }\n\n        for (int i = left; i < right; i += 5) {\n            int subRight = i + 4;\n            if (subRight > right) {\n                subRight = right;\n            }\n            int median5 = partition5(list, i, subRight);\n            int rightIndex = left + (i - left) / 5;\n            Collections.swap(list, median5, rightIndex);\n        }\n\n        int mid = (right - left) / 10 + left + 1;\n        int rightIndex = left + (right - left) / 5;\n        return selectIndex(list, left, rightIndex, mid);\n    }\n\n    private static <T extends Comparable<T>> int partition5(\n            List<T> list,\n            int left,\n            int right\n    ) {\n        List<T> ts = list.subList(left, right);\n        ts.sort(Comparator.naturalOrder());\n        return (left + right) >>> 1;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass QuickSelectTest {\n    @Test\n    void quickSelectMinimumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int minimum = QuickSelect.select(elements, 0);\n        assertEquals(42, minimum);\n    }\n\n    @Test\n    void quickSelectMinimumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n\n        assertEquals(42, minimum1);\n        assertEquals(42, minimum2);\n    }\n\n    @Test\n    void quickSelectMinimumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int minimum1 = QuickSelect.select(elements1, 0);\n        int minimum2 = QuickSelect.select(elements2, 0);\n        int minimum3 = QuickSelect.select(elements3, 0);\n\n        assertEquals(1, minimum1);\n        assertEquals(1, minimum2);\n        assertEquals(1, minimum3);\n    }\n\n    @Test\n    void quickSelectMinimumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, 0);\n        int expected = elements.stream().min(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMaximumOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int maximum = QuickSelect.select(elements, 0);\n        assertEquals(42, maximum);\n    }\n\n    @Test\n    void quickSelectMaximumOfTwoElements() {\n        List<Integer> elements1 = Arrays.asList(42, 90);\n        List<Integer> elements2 = Arrays.asList(90, 42);\n\n        int maximum1 = QuickSelect.select(elements1, 1);\n        int maximum2 = QuickSelect.select(elements2, 1);\n\n        assertEquals(90, maximum1);\n        assertEquals(90, maximum2);\n    }\n\n    @Test\n    void quickSelectMaximumOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int maximum1 = QuickSelect.select(elements1, 2);\n        int maximum2 = QuickSelect.select(elements2, 2);\n        int maximum3 = QuickSelect.select(elements3, 2);\n\n        assertEquals(3, maximum1);\n        assertEquals(3, maximum2);\n        assertEquals(3, maximum3);\n    }\n\n    @Test\n    void quickSelectMaximumOfManyElements() {\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, NUM_RND_ELEMENTS - 1);\n        int expected = elements.stream().max(Comparator.naturalOrder()).get();\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void quickSelectMedianOfOneElement() {\n        List<Integer> elements = Collections.singletonList(42);\n        int median = QuickSelect.select(elements, 0);\n        assertEquals(42, median);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeElements() {\n        List<Integer> elements1 = Arrays.asList(1, 2, 3);\n        List<Integer> elements2 = Arrays.asList(2, 1, 3);\n        List<Integer> elements3 = Arrays.asList(2, 3, 1);\n\n        int median1 = QuickSelect.select(elements1, 1);\n        int median2 = QuickSelect.select(elements2, 1);\n        int median3 = QuickSelect.select(elements3, 1);\n\n        assertEquals(2, median1);\n        assertEquals(2, median2);\n        assertEquals(2, median3);\n    }\n\n    @Test\n    void quickSelectMedianOfManyElements() {\n        int medianIndex = NUM_RND_ELEMENTS / 2;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, medianIndex);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(medianIndex), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 2);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(2), actual);\n    }\n\n    @Test\n    void quickSelect30thPercentileOfManyElements() {\n        int percentile30th = NUM_RND_ELEMENTS / 10 * 3;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile30th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile30th), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOf10Elements() {\n        List<Integer> elements = generateRandomIntegers(10);\n        int actual = QuickSelect.select(elements, 6);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(6), actual);\n    }\n\n    @Test\n    void quickSelect70thPercentileOfManyElements() {\n        int percentile70th = NUM_RND_ELEMENTS / 10 * 7;\n        List<Integer> elements = generateRandomIntegers(NUM_RND_ELEMENTS);\n        int actual = QuickSelect.select(elements, percentile70th);\n\n        List<Integer> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(percentile70th), actual);\n    }\n\n    @Test\n    void quickSelectMedianOfThreeCharacters() {\n        List<Character> elements = Arrays.asList('X', 'Z', 'Y');\n        char actual = QuickSelect.select(elements, 1);\n        assertEquals(actual, 'Y');\n    }\n\n    @Test\n    void quickSelectMedianOfManyCharacters() {\n        List<Character> elements = generateRandomCharacters(NUM_RND_ELEMENTS);\n        char actual = QuickSelect.select(elements, NUM_RND_ELEMENTS / 30);\n\n        List<Character> elementsSorted = getSortedCopyOfList(elements);\n        assertEquals(elementsSorted.get(NUM_RND_ELEMENTS / 30), actual);\n    }\n\n    @Test\n    void quickSelectNullList() {\n        NullPointerException exception = assertThrows(\n                NullPointerException.class,\n                () -> QuickSelect.select(null, 0)\n        );\n        String expectedMsg = \"The list of elements must not be null.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectEmptyList() {\n        List<String> objects = Collections.emptyList();\n        IllegalArgumentException exception = assertThrows(\n                IllegalArgumentException.class,\n                () -> QuickSelect.select(objects, 0)\n        );\n        String expectedMsg = \"The list of elements must not be empty.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfLeftBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n                IndexOutOfBoundsException.class,\n                () -> QuickSelect.select(Collections.singletonList(1), -1)\n        );\n        String expectedMsg = \"The index must not be negative.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    @Test\n    void quickSelectIndexOutOfRightBound() {\n        IndexOutOfBoundsException exception = assertThrows(\n                IndexOutOfBoundsException.class,\n                () -> QuickSelect.select(Collections.singletonList(1), 1)\n        );\n        String expectedMsg = \"The index must be less than the number of elements.\";\n        assertEquals(expectedMsg, exception.getMessage());\n    }\n\n    private static final int NUM_RND_ELEMENTS = 99;\n    private static final Random RANDOM = new Random(42);\n    private static final int ASCII_A = 0x41;\n    private static final int ASCII_Z = 0x5A;\n\n    private static List<Integer> generateRandomIntegers(int n) {\n        return RANDOM.ints(n).boxed().collect(Collectors.toList());\n    }\n\n    private static List<Character> generateRandomCharacters(int n) {\n        return RANDOM.ints(n, ASCII_A, ASCII_Z)\n                .mapToObj(i -> (char) i)\n                .collect(Collectors.toList());\n    }\n\n    private static <T extends Comparable<T>> List<T> getSortedCopyOfList(List<T> list) {\n        return list.stream().sorted().collect(Collectors.toList());\n    }\n}"
    }
]