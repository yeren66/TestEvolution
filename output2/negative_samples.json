[
    {
        "product_commit": "1ea95ffa928e42bda532380233a9667764dafdf5",
        "test_commit": "ac7152d757096d5a30e68b3864108e2843d0c2ed",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PerfectSquare.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PerfectSquareTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Perfect_square\n */\npublic class PerfectSquare {\n\n    public static void main(String[] args) {\n        assert !isPerfectSquare(-1);\n        assert !isPerfectSquare(3);\n        assert !isPerfectSquare(5);\n        assert isPerfectSquare(9);\n        assert isPerfectSquare(100);\n    }\n\n    /**\n     * Check if a number is perfect square number\n     *\n     * @param number the number to be checked\n     * @return <tt>true</tt> if {@code number} is perfect square, otherwise\n     * <tt>false</tt>\n     */\n    public static boolean isPerfectSquare(int number) {\n        int sqrt = (int) Math.sqrt(number);\n        return sqrt * sqrt == number;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * https://en.wikipedia.org/wiki/Perfect_square\n */\npublic final class PerfectSquare {\n    private PerfectSquare() {\n    }\n\n    /**\n     * Check if a number is perfect square number\n     *\n     * @param number the number to be checked\n     * @return <tt>true</tt> if {@code number} is perfect square, otherwise\n     * <tt>false</tt>\n     */\n    public static boolean isPerfectSquare(final int number) {\n        final int sqrt = (int) Math.sqrt(number);\n        return sqrt * sqrt == number;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\npublic class PerfectSquareTest {\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2 * 2, 3 * 3, 4 * 4, 5 * 5, 6 * 6, 7 * 7, 8 * 8, 9 * 9, 10 * 10, 11 * 11, 123 * 123})\n    void positiveTest(final int number) {\n        Assertions.assertTrue(PerfectSquare.isPerfectSquare(number));\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {-1, -2, -3, -4, -5, -100, 2, 3, 5, 6, 7, 8, 10, 11, 12, 13, 15, 17, 99, 101, 257, 999, 1001})\n    void negativeTest(final int number) {\n        Assertions.assertFalse(PerfectSquare.isPerfectSquare(number));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\npublic class PerfectSquareTest {\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2 * 2, 3 * 3, 4 * 4, 5 * 5, 6 * 6, 7 * 7, 8 * 8, 9 * 9, 10 * 10, 11 * 11, 123 * 123})\n    void positiveTest(final int number) {\n        Assertions.assertTrue(PerfectSquare.isPerfectSquare(number));\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {-1, -2, -3, -4, -5, -100, 2, 3, 5, 6, 7, 8, 10, 11, 12, 13, 15, 17, 99, 101, 257, 999, 1001})\n    void negativeTest(final int number) {\n        Assertions.assertFalse(PerfectSquare.isPerfectSquare(number));\n    }\n}"
    },
    {
        "product_commit": "a7d140a43e03821728f919f2402b006ae985cfa5",
        "test_commit": "092ac5795bc2004c04032fc2b79ee892e2ffcb05",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/SetKthBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/SetKthBitTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/***\n * Sets the kth bit of a given integer to 1\n * e.g. setting 3rd bit in binary of 17 (binary 10001) gives 25 (binary 11001)\n * @author inishantjain\n */\n\npublic class SetKthBit {\n    /**\n     * Sets the kth bit of a given integer.\n     *\n     * @param num The original integer.\n     * @param k   The position of the bit to set (0-based index).\n     * @return The integer with the kth bit set.\n     */\n    public static int setKthBit(int num, int k) {\n        int mask = 1 << k;\n        num = num | mask;\n        return num;\n    }\n}",
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass SetKthBitTest {\n\n    @Test\n    void testSetKthBit() {\n        // Test case: Setting the 0th bit in 5 (binary 101)\n        assertEquals(5, SetKthBit.setKthBit(5, 0));\n\n        // Test case: Setting the 2nd bit in 10 (binary 1010)\n        assertEquals(14, SetKthBit.setKthBit(10, 2));\n\n        // Test case: Setting the 3rd bit in 15 (binary 1111)\n        assertEquals(15, SetKthBit.setKthBit(15, 3));\n\n        // Test case: Setting the 1st bit in 0 (binary 0)\n        assertEquals(2, SetKthBit.setKthBit(0, 1));\n    }\n}",
        "test_new_content": null
    },
    {
        "product_commit": "249ee1dc994735a6cf02a6048ab8bedd2e91ce4a",
        "test_commit": "4aa8e6a0eb65e8edb9b716851ee4dd8881c434af",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/TwoPSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/TwoPSetTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * TwoPhaseSet (2P-Set) is a state-based CRDT (Conflict-free Replicated Data Type) designed for managing sets\n * with support for both addition and removal operations in a distributed and concurrent environment.\n * It combines two G-Sets (grow-only sets) - one set for additions and another set (tombstone set) for removals.\n * Once an element is removed and placed in the tombstone set, it cannot be re-added, adhering to \"remove-wins\" semantics.\n * This implementation supports querying the presence of elements, adding elements, removing elements,\n * comparing with other 2P-Sets, and merging two 2P-Sets while preserving the remove-wins semantics.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class TwoPSet {\n    private Set<String> setA;\n    private Set<String> setR;\n\n    /**\n     * Constructs an empty Two-Phase Set.\n     */\n    public TwoPSet() {\n        this.setA = new HashSet<>();\n        this.setR = new HashSet<>();\n    }\n\n    /**\n     * Checks if an element is in the set and has not been removed.\n     *\n     * @param element The element to be checked.\n     * @return True if the element is in the set and has not been removed, otherwise false.\n     */\n    public boolean lookup(String element) {\n        return setA.contains(element) && !setR.contains(element);\n    }\n\n    /**\n     * Adds an element to the set.\n     *\n     * @param element The element to be added.\n     */\n    public void add(String element) {\n        setA.add(element);\n    }\n\n    /**\n     * Removes an element from the set. The element will be placed in the tombstone set.\n     *\n     * @param element The element to be removed.\n     */\n    public void remove(String element) {\n        if (lookup(element)) {\n            setR.add(element);\n        }\n    }\n\n    /**\n     * Compares the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to compare with.\n     * @return True if both SetA and SetR are subset, otherwise false.\n     */\n    public boolean compare(TwoPSet otherSet) {\n        return otherSet.setA.containsAll(setA) && otherSet.setR.containsAll(setR);\n    }\n\n    /**\n     * Merges the current 2P-Set with another 2P-Set.\n     *\n     * @param otherSet The other 2P-Set to merge with.\n     * @return A new 2P-Set containing the merged elements.\n     */\n    public TwoPSet merge(TwoPSet otherSet) {\n        TwoPSet mergedSet = new TwoPSet();\n        mergedSet.setA.addAll(this.setA);\n        mergedSet.setA.addAll(otherSet.setA);\n        mergedSet.setR.addAll(this.setR);\n        mergedSet.setR.addAll(otherSet.setR);\n        return mergedSet;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass TwoPSetTest {\n\n    private TwoPSet set;\n\n    @BeforeEach\n    void setUp() {\n        set = new TwoPSet();\n    }\n\n    @Test\n    void testLookup() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n        assertFalse(set.lookup(\"B\"));\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testAdd() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testRemove() {\n        set.add(\"A\");\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testCompare() {\n        TwoPSet set1 = new TwoPSet();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet set2 = new TwoPSet();\n        set2.add(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.add(\"B\");\n        assertTrue(set1.compare(set2));\n        set1.remove(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.remove(\"A\");\n        assertTrue(set1.compare(set2));\n    }\n\n    @Test\n    void testMerge() {\n        TwoPSet set1 = new TwoPSet();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet set2 = new TwoPSet();\n        set2.add(\"B\");\n        set2.add(\"C\");\n        TwoPSet mergedSet = set1.merge(set2);\n        assertTrue(mergedSet.lookup(\"A\"));\n        assertTrue(mergedSet.lookup(\"B\"));\n        assertTrue(mergedSet.lookup(\"C\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass TwoPSetTest {\n\n    private TwoPSet<String> set;\n\n    @BeforeEach\n    void setUp() {\n        set = new TwoPSet<>();\n    }\n\n    @Test\n    void testLookup() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n        assertFalse(set.lookup(\"B\"));\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testAdd() {\n        set.add(\"A\");\n        assertTrue(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testRemove() {\n        set.add(\"A\");\n        set.remove(\"A\");\n        assertFalse(set.lookup(\"A\"));\n    }\n\n    @Test\n    void testCompare() {\n        TwoPSet<String> set1 = new TwoPSet<>();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet<String> set2 = new TwoPSet<>();\n        set2.add(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.add(\"B\");\n        assertTrue(set1.compare(set2));\n        set1.remove(\"A\");\n        assertFalse(set1.compare(set2));\n        set2.remove(\"A\");\n        assertTrue(set1.compare(set2));\n    }\n\n    @Test\n    void testMerge() {\n        TwoPSet<String> set1 = new TwoPSet<>();\n        set1.add(\"A\");\n        set1.add(\"B\");\n        TwoPSet<String> set2 = new TwoPSet<>();\n        set2.add(\"B\");\n        set2.add(\"C\");\n        TwoPSet<String> mergedSet = set1.merge(set2);\n        assertTrue(mergedSet.lookup(\"A\"));\n        assertTrue(mergedSet.lookup(\"B\"));\n        assertTrue(mergedSet.lookup(\"C\"));\n    }\n}"
    },
    {
        "product_commit": "e59a3b1ebba0b484fad64adb06aedc06eb366825",
        "test_commit": "92131de3774d6dc7be7662bd0a8a9c02704255d5",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/crdt/GSet.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/crdt/GSetTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * GSet (Grow-only Set) is a state-based CRDT (Conflict-free Replicated Data Type)\n * that allows only the addition of elements and ensures that once an element is added,\n * it cannot be removed. The merge operation of two G-Sets is their union.\n * This implementation supports adding elements, looking up elements, comparing with other G-Sets,\n * and merging with another G-Set to create a new G-Set containing all unique elements from both sets.\n * (https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type)\n *\n * @author itakurah (Niklas Hoefflin) (https://github.com/itakurah)\n */\n\npublic class GSet<T> {\n    private final Set<T> elements;\n\n    /**\n     * Constructs an empty G-Set.\n     */\n    public GSet() {\n        this.elements = new HashSet<>();\n    }\n\n    /**\n     * Adds an element to the G-Set.\n     *\n     * @param e the element to be added\n     */\n    public void addElement(T e) {\n        elements.add(e);\n    }\n\n    /**\n     * Checks if the given element is present in the G-Set.\n     *\n     * @param e the element to be checked\n     * @return true if the element is present, false otherwise\n     */\n    public boolean lookup(T e) {\n        return elements.contains(e);\n    }\n\n    /**\n     * Compares the G-Set with another G-Set to check if it is a subset.\n     *\n     * @param other the other G-Set to compare with\n     * @return true if the current G-Set is a subset of the other, false otherwise\n     */\n    public boolean compare(GSet<T> other) {\n        return elements.containsAll(other.elements);\n    }\n\n    /**\n     * Merges the current G-Set with another G-Set, creating a new G-Set\n     * containing all unique elements from both sets.\n     *\n     * @param other the G-Set to merge with\n     */\n    public void merge(GSet<T> other) {\n        elements.addAll(other.elements);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass GSetTest {\n\n    @Test\n    void testAddElement() {\n        GSet<String> gSet = new GSet<>();\n        gSet.addElement(\"apple\");\n        gSet.addElement(\"orange\");\n\n        assertTrue(gSet.lookup(\"apple\"));\n        assertTrue(gSet.lookup(\"orange\"));\n        assertFalse(gSet.lookup(\"banana\"));\n    }\n\n    @Test\n    void testLookup() {\n        GSet<Integer> gSet = new GSet<>();\n        gSet.addElement(1);\n        gSet.addElement(2);\n\n        assertTrue(gSet.lookup(1));\n        assertTrue(gSet.lookup(2));\n        assertFalse(gSet.lookup(3));\n    }\n\n    @Test\n    void testCompare() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        assertFalse(gSet1.compare(gSet2));\n\n        GSet<String> gSet3 = new GSet<>();\n        gSet3.addElement(\"apple\");\n        gSet3.addElement(\"orange\");\n\n        assertTrue(gSet1.compare(gSet3));\n    }\n\n    @Test\n    void testMerge() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        GSet<String> mergedSet = new GSet<>();\n        mergedSet.merge(gSet1);\n        mergedSet.merge(gSet2);\n\n        assertTrue(mergedSet.lookup(\"apple\"));\n        assertTrue(mergedSet.lookup(\"orange\"));\n        assertTrue(mergedSet.lookup(\"banana\"));\n        assertFalse(mergedSet.lookup(\"grape\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.crdt;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass GSetTest {\n\n    @Test\n    void testAddElement() {\n        GSet<String> gSet = new GSet<>();\n        gSet.addElement(\"apple\");\n        gSet.addElement(\"orange\");\n\n        assertTrue(gSet.lookup(\"apple\"));\n        assertTrue(gSet.lookup(\"orange\"));\n        assertFalse(gSet.lookup(\"banana\"));\n    }\n\n    @Test\n    void testLookup() {\n        GSet<Integer> gSet = new GSet<>();\n        gSet.addElement(1);\n        gSet.addElement(2);\n\n        assertTrue(gSet.lookup(1));\n        assertTrue(gSet.lookup(2));\n        assertFalse(gSet.lookup(3));\n    }\n\n    @Test\n    void testCompare() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n        gSet2.addElement(\"orange\");\n        assertFalse(gSet1.compare(gSet2));\n        gSet2.addElement(\"apple\");\n        assertTrue(gSet1.compare(gSet2));\n        gSet2.addElement(\"banana\");\n        assertTrue(gSet1.compare(gSet2));\n    }\n\n    @Test\n    void testMerge() {\n        GSet<String> gSet1 = new GSet<>();\n        GSet<String> gSet2 = new GSet<>();\n\n        gSet1.addElement(\"apple\");\n        gSet1.addElement(\"orange\");\n\n        gSet2.addElement(\"orange\");\n        gSet2.addElement(\"banana\");\n\n        GSet<String> mergedSet = new GSet<>();\n        mergedSet.merge(gSet1);\n        mergedSet.merge(gSet2);\n\n        assertTrue(mergedSet.lookup(\"apple\"));\n        assertTrue(mergedSet.lookup(\"orange\"));\n        assertTrue(mergedSet.lookup(\"banana\"));\n        assertFalse(mergedSet.lookup(\"grape\"));\n    }\n}"
    },
    {
        "product_commit": "945e7b56bb186c3be908e02720e932b5ce834e01",
        "test_commit": "574138c7a35351a0837bb4bd56e2eb295064b690",
        "product_file_path": "src/main/java/com/thealgorithms/others/BoyerMoore.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/BoyerMooreTest.java",
        "product_old_content": "/* this Code is the illustration of Boyer moore's voting algorithm to\nfind the majority element is an array that appears more than n/2 times in an array\nwhere \"n\" is the length of the array.\nFor more information on the algorithm refer\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n */\npackage com.thealgorithms.others;\n\nimport java.util.*;\n\npublic class BoyerMoore {\n\n    public static int findmajor(int[] a) {\n        int count = 0;\n        int cand = -1;\n        for (int i = 0; i < a.length; i++) {\n            if (count == 0) {\n                cand = a[i];\n                count = 1;\n            } else {\n                if (a[i] == cand) {\n                    count++;\n                } else {\n                    count--;\n                }\n            }\n        }\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] == cand) {\n                count++;\n            }\n        }\n        if (count > (a.length / 2)) {\n            return cand;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = input.nextInt();\n        }\n        System.out.println(\"the majority element is \" + findmajor(a));\n        input.close();\n    }\n}",
        "product_new_content": "/* this Code is the illustration of Boyer moore's voting algorithm to\nfind the majority element is an array that appears more than n/2 times in an array\nwhere \"n\" is the length of the array.\nFor more information on the algorithm refer\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n */\npackage com.thealgorithms.others;\n\npublic final class BoyerMoore {\n    private BoyerMoore() {\n    }\n\n    public static int findmajor(final int[] a) {\n        int count = 0;\n        int cand = -1;\n        for (final var k : a) {\n            if (count == 0) {\n                cand = k;\n                count = 1;\n            } else {\n                if (k == cand) {\n                    count++;\n                } else {\n                    count--;\n                }\n            }\n        }\n        count = 0;\n        for (final var j : a) {\n            if (j == cand) {\n                count++;\n            }\n        }\n        if (count > (a.length / 2)) {\n            return cand;\n        }\n        return -1;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class BoyerMooreTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, BoyerMoore.findmajor(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 2}), Arguments.of(10, new int[] {10, 10, 20}), Arguments.of(10, new int[] {10, 20, 10}), Arguments.of(10, new int[] {20, 10, 10}), Arguments.of(-1, new int[] {10, 10, 20, 20, 30, 30}), Arguments.of(4, new int[] {1, 4, 2, 4, 4, 5, 4}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class BoyerMooreTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStreamWithExistingMajority\")\n    void checkWhenMajorityExists(int expected, int[] input) {\n        Assertions.assertEquals(expected, BoyerMoore.findMajor(input).get());\n    }\n\n    private static Stream<Arguments> inputStreamWithExistingMajority() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 2}), Arguments.of(10, new int[] {10, 10, 20}), Arguments.of(10, new int[] {10, 20, 10}), Arguments.of(10, new int[] {20, 10, 10}), Arguments.of(4, new int[] {1, 4, 2, 4, 4, 5, 4}), Arguments.of(-1, new int[] {-1}));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"inputStreamWithoutMajority\")\n    void checkWhenMajorityExists(int[] input) {\n        Assertions.assertFalse(BoyerMoore.findMajor(input).isPresent());\n    }\n\n    private static Stream<Arguments> inputStreamWithoutMajority() {\n        return Stream.of(Arguments.of(new int[] {10, 10, 20, 20, 30, 30}), Arguments.of(new int[] {10, 20, 30, 40, 50}), Arguments.of(new int[] {1, 2}), Arguments.of(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "da687c11cb35d9c13c8d2681796b512e08f59f27",
        "test_commit": "aaa2b26ed19477c4e8b8198782c1ee6c560bf8b3",
        "product_file_path": "src/main/java/com/thealgorithms/searches/RecursiveBinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RecursiveBinarySearchTest.java",
        "product_old_content": null,
        "product_new_content": "// Code by Pronay Debnath\n// Created:- 1/10/2023\n// File Name should be RecursiveBinarySearch.java\n// Explanation:- https://www.tutorialspoint.com/java-program-for-binary-search-recursive\n\nimport java.util.*;\n\n// Create a SearchAlgorithm class with a generic type\nabstract class SearchAlgorithm<T extends Comparable<T>> {\n    // Abstract find method to be implemented by subclasses\n    public abstract int find(T[] arr, T target);\n}\n\npublic class RecursiveBinarySearch<T extends Comparable<T>> extends SearchAlgorithm<T> {\n\n    // Override the find method as required\n    @Override\n    public int find(T[] arr, T target) {\n        // Call the recursive binary search function\n        return binsear(arr, 0, arr.length - 1, target);\n    }\n\n    // Recursive binary search function\n    public int binsear(T[] arr, int left, int right, T target) {\n        if (right >= left) {\n            int mid = left + (right - left) / 2;\n\n            // Compare the element at the middle with the target\n            int comparison = arr[mid].compareTo(target);\n\n            // If the element is equal to the target, return its index\n            if (comparison == 0) {\n                return mid;\n            }\n\n            // If the element is greater than the target, search in the left subarray\n            if (comparison > 0) {\n                return binsear(arr, left, mid - 1, target);\n            }\n\n            // Otherwise, search in the right subarray\n            return binsear(arr, mid + 1, right, target);\n        }\n\n        // Element is not present in the array\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        // User inputs\n        System.out.print(\"Enter the number of elements in the array: \");\n        int n = sc.nextInt();\n\n        Integer[] a = new Integer[n]; // You can change the array type as needed\n\n        System.out.println(\"Enter the elements in sorted order:\");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        System.out.print(\"Enter the target element to search for: \");\n        int t = sc.nextInt();\n\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n        int res = searcher.find(a, t);\n\n        if (res == -1)\n            System.out.println(\"Element not found in the array.\");\n        else\n            System.out.println(\"Element found at index \" + res);\n    }\n}",
        "test_old_content": "// Created by Pronay Debnath\n// Date:- 1/10/2023\n// Test file updated with JUnit tests\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test; // Import the JUnit 5 Test annotation\n\npublic class RecursiveBinarySearchTest {\n\n    @Test\n    public void testBinarySearch() {\n        // Create an instance of GenericBinarySearch\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n\n        // Test case 1: Element found in the array\n        Integer[] arr1 = {1, 2, 3, 4, 5};\n        int target1 = 3;\n        int result1 = searcher.binsear(arr1, 0, arr1.length - 1, target1);\n        assertEquals(2, result1);\n\n        // Test case 2: Element not found in the array\n        Integer[] arr2 = {1, 2, 3, 4, 5};\n        int target2 = 6;\n        int result2 = searcher.binsear(arr2, 0, arr2.length - 1, target2);\n        assertEquals(-1, result2);\n\n        // Test case 3: Element found at the beginning of the array\n        Integer[] arr3 = {10, 20, 30, 40, 50};\n        int target3 = 10;\n        int result3 = searcher.binsear(arr3, 0, arr3.length - 1, target3);\n        assertEquals(0, result3);\n\n        // Test case 4: Element found at the end of the array\n        Integer[] arr4 = {10, 20, 30, 40, 50};\n        int target4 = 50;\n        int result4 = searcher.binsear(arr4, 0, arr4.length - 1, target4);\n        assertEquals(4, result4);\n    }\n}",
        "test_new_content": "// Created by Pronay Debnath\n// Date:- 1/10/2023\n// Test file updated with JUnit tests\npackage com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test; // Import the JUnit 5 Test annotation\n\npublic class RecursiveBinarySearchTest {\n\n    @Test\n    public void testBinarySearch() {\n        // Create an instance of GenericBinarySearch\n        RecursiveBinarySearch<Integer> searcher = new RecursiveBinarySearch<>();\n\n        // Test case 1: Element found in the array\n        Integer[] arr1 = {1, 2, 3, 4, 5};\n        int target1 = 3;\n        int result1 = searcher.binsear(arr1, 0, arr1.length - 1, target1);\n        assertEquals(2, result1);\n\n        // Test case 2: Element not found in the array\n        Integer[] arr2 = {1, 2, 3, 4, 5};\n        int target2 = 6;\n        int result2 = searcher.binsear(arr2, 0, arr2.length - 1, target2);\n        assertEquals(-1, result2);\n\n        // Test case 3: Element found at the beginning of the array\n        Integer[] arr3 = {10, 20, 30, 40, 50};\n        int target3 = 10;\n        int result3 = searcher.binsear(arr3, 0, arr3.length - 1, target3);\n        assertEquals(0, result3);\n\n        // Test case 4: Element found at the end of the array\n        Integer[] arr4 = {10, 20, 30, 40, 50};\n        int target4 = 50;\n        int result4 = searcher.binsear(arr4, 0, arr4.length - 1, target4);\n        assertEquals(4, result4);\n    }\n}"
    },
    {
        "product_commit": "bf777fff8f075cccff32223cd2f5c085adb5b09e",
        "test_commit": "064ca8f59124eb3c792d2202ff12260e87e91552",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMinRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMinRecursion {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* rand size */\n        int size = rand.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with rand numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = rand.nextInt() % 100;\n        }\n\n        assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();\n        assert min(array, array.length) == Arrays.stream(array).min().getAsInt();\n    }\n\n    /**\n     * Get min of array using divide and conquer algorithm\n     *\n     * @param array contains elements\n     * @param low the index of the first element\n     * @param high the index of the last element\n     * @return min of {@code array}\n     */\n    public static int min(int[] array, int low, int high) {\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMin = min(array, low, mid); // get min in [low, mid]\n        int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]\n\n        return Math.min(leftMin, rightMin);\n    }\n\n    /**\n     * Get min of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @param len length of given array\n     * @return min value of {@code array}\n     */\n    public static int min(int[] array, int len) {\n        return len == 1 ? array[0] : Math.min(min(array, len - 1), array[len - 1]);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMinRecursion {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* rand size */\n        int size = rand.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with rand numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = rand.nextInt() % 100;\n        }\n\n        assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();\n        assert min(array) == Arrays.stream(array).min().getAsInt();\n    }\n\n    /**\n     * Get min of array using divide and conquer algorithm\n     *\n     * @param array contains elements\n     * @param low the index of the first element\n     * @param high the index of the last element\n     * @return min of {@code array}\n     */\n    public static int min(int[] array, int low, int high) {\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMin = min(array, low, mid); // get min in [low, mid]\n        int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]\n\n        return leftMin > rightMin ? rightMin : leftMin;\n    }\n\n    /**\n     * Get min of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @param len length of given array\n     * @return min value of {@code array}\n     */\n    public static int min(int[] array) {\n        return array.length == 1 ? array[0] : min(array, 0, array.length);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMinRecursion.min(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(-1, new int[] {-1, 0}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(-4, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMinRecursion.min(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "cada67b1eb58558b08049b84ee93a15de7867e4b",
        "test_commit": "8dc5505323708dc0963ba7871afac85cf9db60f7",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMaxRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMaxRecursion {\n\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* rand size */\n        int size = rand.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with rand numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = rand.nextInt() % 100;\n        }\n\n        assert max(array, array.length) == Arrays.stream(array).max().getAsInt();\n        assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();\n    }\n\n    /**\n     * Get max of array using divide and conquer algorithm\n     *\n     * @param array contains elements\n     * @param low the index of the first element\n     * @param high the index of the last element\n     * @return max of {@code array}\n     */\n    public static int max(int[] array, int low, int high) {\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMax = max(array, low, mid); // get max in [low, mid]\n        int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]\n\n        return Math.max(leftMax, rightMax);\n    }\n\n    /**\n     * Get max of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @param len length of given array\n     * @return max value of {@code array}\n     */\n    public static int max(int[] array, int len) {\n        return len == 1 ? array[0] : Math.max(max(array, len - 1), array[len - 1]);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMaxRecursion {\n\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        /* rand size */\n        int size = rand.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with rand numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = rand.nextInt() % 100;\n        }\n\n        assert max(array) == Arrays.stream(array).max().getAsInt();\n        assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();\n    }\n\n    /**\n     * Get max of array using divide and conquer algorithm\n     *\n     * @param array contains elements\n     * @param low the index of the first element\n     * @param high the index of the last element\n     * @return max of {@code array}\n     */\n    public static int max(int[] array, int low, int high) {\n        if (low == high) {\n            return array[low]; // or array[high]\n        }\n\n        int mid = (low + high) >>> 1;\n\n        int leftMax = max(array, low, mid); // get max in [low, mid]\n        int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]\n\n        return leftMax < rightMax ? rightMax : leftMax;\n    }\n\n    /**\n     * Get max of array using recursion algorithm\n     *\n     * @param array contains elements\n     * @return max value of {@code array}\n     */\n    public static int max(int[] array) {\n        return array.length == 1 ? array[0] : max(array, 0, array.length);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMaxRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMaxRecursion.max(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {-1, 0}), Arguments.of(-1, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(9, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMaxRecursion.max(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "d6024f9cd49e3dc33576cb949ba379e62ad42528",
        "test_commit": "01157f299c20011cf6227039909b9ecc3a99341c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class FindMin {\n    private FindMin() {\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(final int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMinTest {\n\n    @Test\n    public void testFindMinValue() {\n        assertEquals(1, FindMin.findMin(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    }\n\n    @Test\n    public void test1() {\n        assertEquals(1, FindMin.findMin(new int[] {1, 3, 5, 7, 9}));\n    }\n\n    @Test\n    public void test2() {\n        assertEquals(0, FindMin.findMin(new int[] {0, 192, 384, 576}));\n    }\n\n    @Test\n    public void test3() {\n        assertEquals(0, FindMin.findMin(new int[] {10, 10, 0, 10}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinTest {\n\n    @ParameterizedTest\n    @MethodSource(\"provideStringsForIsBlank\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMin.findMin(input));\n    }\n\n    private static Stream<Arguments> provideStringsForIsBlank() {\n        return Stream.of(Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {0, 192, 384, 576}), Arguments.of(-1, new int[] {-1, 2, 5, 10}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "d6024f9cd49e3dc33576cb949ba379e62ad42528",
        "test_commit": "02bac7e3d4f152a2369dca61cc1b2a1664bbcf24",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class FindMin {\n    private FindMin() {\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(final int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinTest {\n\n    @ParameterizedTest\n    @MethodSource(\"provideStringsForIsBlank\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMin.findMin(input));\n    }\n\n    private static Stream<Arguments> provideStringsForIsBlank() {\n        return Stream.of(Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {0, 192, 384, 576}), Arguments.of(-1, new int[] {-1, 2, 5, 10}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMin.findMin(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {0, 192, 384, 576}), Arguments.of(-1, new int[] {-1, 2, 5, 10}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}),\n            Arguments.of(-4, new int[] {4, -3, 8, 9, -4, -4, 10}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "d6024f9cd49e3dc33576cb949ba379e62ad42528",
        "test_commit": "064ca8f59124eb3c792d2202ff12260e87e91552",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class FindMin {\n    private FindMin() {\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(final int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMinRecursion.min(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(-1, new int[] {-1, 0}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(-4, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMinRecursion.min(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "fa77b50ef9edb90949db77de76116c1a3ede10a1",
        "test_commit": "8583ca3b40ffb21d3005b7c354737e1ac9a3b39c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class FindMax {\n    private FindMax() {\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(final int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMaxTest {\n\n    @Test\n    public void testFindMax0() {\n        assertEquals(10, FindMax.findMax(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    }\n\n    @Test\n    public void testFindMax1() {\n        assertEquals(7, FindMax.findMax(new int[] {6, 3, 5, 1, 7, 4, 1}));\n    }\n\n    @Test\n    public void testFindMax2() {\n        assertEquals(10, FindMax.findMax(new int[] {10, 0}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMax.findMax(new int[] {}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMaxTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMax.findMax(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(10, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {-1, 0}), Arguments.of(-1, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(9, new int[] {3, -2, 3, 9, -4, -4, 8}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMax.findMax(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "fa77b50ef9edb90949db77de76116c1a3ede10a1",
        "test_commit": "8dc5505323708dc0963ba7871afac85cf9db60f7",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\npublic final class FindMax {\n    private FindMax() {\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(final int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMaxRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMaxRecursion.max(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {-1, 0}), Arguments.of(-1, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(9, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMaxRecursion.max(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "ad4be217d43fdaa38c994d7397ba5e732de26096",
        "test_commit": "8583ca3b40ffb21d3005b7c354737e1ac9a3b39c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = Integer.MIN_VALUE;\n        for (final var value : array) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMaxTest {\n\n    @Test\n    public void testFindMax0() {\n        assertEquals(10, FindMax.findMax(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    }\n\n    @Test\n    public void testFindMax1() {\n        assertEquals(7, FindMax.findMax(new int[] {6, 3, 5, 1, 7, 4, 1}));\n    }\n\n    @Test\n    public void testFindMax2() {\n        assertEquals(10, FindMax.findMax(new int[] {10, 0}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMax.findMax(new int[] {}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMaxTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMax.findMax(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(10, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {-1, 0}), Arguments.of(-1, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(9, new int[] {3, -2, 3, 9, -4, -4, 8}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMax.findMax(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "ad4be217d43fdaa38c994d7397ba5e732de26096",
        "test_commit": "8dc5505323708dc0963ba7871afac85cf9db60f7",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = Integer.MIN_VALUE;\n        for (final var value : array) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMaxRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMaxRecursion.max(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {-1, 0}), Arguments.of(-1, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(9, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMaxRecursion.max(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "c1476d796c54e4f9ee47f91895a7d830461f9a68",
        "test_commit": "01157f299c20011cf6227039909b9ecc3a99341c",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = Integer.MAX_VALUE;\n        for (final var value : array) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMinTest {\n\n    @Test\n    public void testFindMinValue() {\n        assertEquals(1, FindMin.findMin(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    }\n\n    @Test\n    public void test1() {\n        assertEquals(1, FindMin.findMin(new int[] {1, 3, 5, 7, 9}));\n    }\n\n    @Test\n    public void test2() {\n        assertEquals(0, FindMin.findMin(new int[] {0, 192, 384, 576}));\n    }\n\n    @Test\n    public void test3() {\n        assertEquals(0, FindMin.findMin(new int[] {10, 10, 0, 10}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinTest {\n\n    @ParameterizedTest\n    @MethodSource(\"provideStringsForIsBlank\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMin.findMin(input));\n    }\n\n    private static Stream<Arguments> provideStringsForIsBlank() {\n        return Stream.of(Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {0, 192, 384, 576}), Arguments.of(-1, new int[] {-1, 2, 5, 10}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "c1476d796c54e4f9ee47f91895a7d830461f9a68",
        "test_commit": "02bac7e3d4f152a2369dca61cc1b2a1664bbcf24",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = Integer.MAX_VALUE;\n        for (final var value : array) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinTest {\n\n    @ParameterizedTest\n    @MethodSource(\"provideStringsForIsBlank\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMin.findMin(input));\n    }\n\n    private static Stream<Arguments> provideStringsForIsBlank() {\n        return Stream.of(Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {0, 192, 384, 576}), Arguments.of(-1, new int[] {-1, 2, 5, 10}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMin.findMin(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(1, new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(0, new int[] {0, 192, 384, 576}), Arguments.of(-1, new int[] {-1, 2, 5, 10}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}),\n            Arguments.of(-4, new int[] {4, -3, 8, 9, -4, -4, 10}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "c1476d796c54e4f9ee47f91895a7d830461f9a68",
        "test_commit": "064ca8f59124eb3c792d2202ff12260e87e91552",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinRecursionTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = Integer.MAX_VALUE;\n        for (final var value : array) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.stream.Stream;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class FindMinRecursionTest {\n\n    @ParameterizedTest\n    @MethodSource(\"inputStream\")\n    void numberTests(int expected, int[] input) {\n        Assertions.assertEquals(expected, FindMinRecursion.min(input));\n    }\n\n    private static Stream<Arguments> inputStream() {\n        return Stream.of(Arguments.of(5, new int[] {5, 5, 5, 5, 5}), Arguments.of(-1, new int[] {-1, 0}), Arguments.of(-10, new int[] {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1}), Arguments.of(-4, new int[] {3, -2, 3, 9, -4, -4, 8}), Arguments.of(3, new int[] {3}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMinRecursion.min(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "fbe348b105a06258a81538023698117e2bb116cb",
        "test_commit": "d3a32135dc9230125599c38d56849228f99a3b11",
        "product_file_path": "src/main/java/com/thealgorithms/misc/MedianOfRunningArray.java",
        "test_file_path": "src/test/java/com/thealgorithms/misc/MedianOfRunningArrayTest.java",
        "product_old_content": "package com.thealgorithms.misc;\n\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/**\n * @author shrutisheoran\n */\npublic class MedianOfRunningArray {\n\n    private PriorityQueue<Integer> p1;\n    private PriorityQueue<Integer> p2;\n\n    // Constructor\n    public MedianOfRunningArray() {\n        this.p1 = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\n        this.p2 = new PriorityQueue<>(); // Min Heap\n    }\n\n    /*\n      Inserting lower half of array to max Heap\n      and upper half to min heap\n     */\n    public void insert(Integer e) {\n        p2.add(e);\n        if (p2.size() - p1.size() > 1) {\n            p1.add(p2.remove());\n        }\n    }\n\n    /*\n      Returns median at any given point\n     */\n    public Integer median() {\n        if (p1.size() == p2.size()) {\n            return (p1.peek() + p2.peek()) / 2;\n        }\n        return p1.size() > p2.size() ? p1.peek() : p2.peek();\n    }\n\n    public static void main(String[] args) {\n        /*\n        Testing the median function\n         */\n\n        MedianOfRunningArray p = new MedianOfRunningArray();\n        int[] arr = {10, 7, 4, 9, 2, 3, 11, 17, 14};\n        for (int i = 0; i < 9; i++) {\n            p.insert(arr[i]);\n            System.out.print(p.median() + \" \");\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.misc;\n\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/**\n * @author shrutisheoran\n */\npublic class MedianOfRunningArray {\n\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n\n    // Constructor\n    public MedianOfRunningArray() {\n        this.maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\n        this.minHeap = new PriorityQueue<>(); // Min Heap\n    }\n\n    /*\n      Inserting lower half of array to max Heap\n      and upper half to min heap\n     */\n    public void insert(Integer e) {\n        if (!minHeap.isEmpty() && e < minHeap.peek()) {\n            maxHeap.offer(e);\n            if (maxHeap.size() > minHeap.size() + 1) {\n                minHeap.offer(maxHeap.poll());\n            }\n        } else {\n            minHeap.offer(e);\n            if (minHeap.size() > maxHeap.size() + 1) {\n                maxHeap.offer(minHeap.poll());\n            }\n        }\n    }\n\n    /*\n      Returns median at any given point\n     */\n    public double median() {\n        if (maxHeap.isEmpty() && minHeap.isEmpty()) {\n            throw new IllegalArgumentException(\"Enter at least 1 element, Median of empty list is not defined!\");\n        }\n\n        if (maxHeap.size() == minHeap.size()) {\n            return (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() * 1.0 : minHeap.peek() * 1.0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Two sum Problem.\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class MedianOfRunningArrayTest {\n    private static final String EXCEPTION_MESSAGE = \"Enter at least 1 element, Median of empty list is not defined!\";\n\n    @Test\n    public void testWhenInvalidInoutProvidedShouldThrowException() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> stream.median());\n        assertEquals(exception.getMessage(), EXCEPTION_MESSAGE);\n    }\n\n    @Test\n    public void testWithNegativeValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-2);\n        assertEquals(-1.5, stream.median());\n        stream.insert(-3);\n        assertEquals(-2, stream.median());\n    }\n\n    @Test\n    public void testWithSingleValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithRandomValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        assertEquals(10.0, stream.median());\n\n        stream.insert(5);\n        assertEquals(7.5, stream.median());\n\n        stream.insert(20);\n        assertEquals(10.0, stream.median());\n\n        stream.insert(15);\n        assertEquals(12.5, stream.median());\n\n        stream.insert(25);\n        assertEquals(15.0, stream.median());\n\n        stream.insert(30);\n        assertEquals(17.5, stream.median());\n\n        stream.insert(35);\n        assertEquals(20.0, stream.median());\n\n        stream.insert(1);\n        assertEquals(17.5, stream.median());\n    }\n\n    @Test\n    public void testWithNegativeAndPositiveValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(2);\n        assertEquals(0.5, stream.median());\n        stream.insert(-3);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValuesB() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(0);\n        stream.insert(50);\n        assertEquals(10, stream.median());\n    }\n\n    @Test\n    public void testWithLargeValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(1000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(12000);\n        assertEquals(506000, stream.median());\n        stream.insert(15000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(2300000);\n        assertEquals(1650000.00, stream.median());\n    }\n\n    @Test\n    public void testWithLargeCountOfValues() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        for (int i = 1; i <= 1000; i++) stream.insert(i);\n        assertEquals(500.5, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInDescendingOrder() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(30);\n        stream.insert(20);\n        stream.insert(10);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInOrder() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(30);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderA() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(30);\n        stream.insert(10);\n        stream.insert(20);\n        assertEquals(20.0, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderB() {\n        MedianOfRunningArray stream = new MedianOfRunningArray();\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(30);\n        assertEquals(20.0, stream.median());\n    }\n}",
        "test_new_content": "package com.thealgorithms.misc;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Median Of Running Array Problem.\n * @author Ansh Shah (https://github.com/govardhanshah456)\n */\n\npublic class MedianOfRunningArrayTest {\n    private static final String EXCEPTION_MESSAGE = \"Enter at least 1 element, Median of empty list is not defined!\";\n\n    @Test\n    public void testWhenInvalidInoutProvidedShouldThrowException() {\n        var stream = new MedianOfRunningArrayInteger();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> stream.median());\n        assertEquals(exception.getMessage(), EXCEPTION_MESSAGE);\n    }\n\n    @Test\n    public void testWithNegativeValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-2);\n        assertEquals(-1, stream.median());\n        stream.insert(-3);\n        assertEquals(-2, stream.median());\n    }\n\n    @Test\n    public void testWithSingleValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithRandomValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(10);\n        assertEquals(10, stream.median());\n\n        stream.insert(5);\n        assertEquals(7, stream.median());\n\n        stream.insert(20);\n        assertEquals(10, stream.median());\n\n        stream.insert(15);\n        assertEquals(12, stream.median());\n\n        stream.insert(25);\n        assertEquals(15, stream.median());\n\n        stream.insert(30);\n        assertEquals(17, stream.median());\n\n        stream.insert(35);\n        assertEquals(20, stream.median());\n\n        stream.insert(1);\n        assertEquals(17, stream.median());\n    }\n\n    @Test\n    public void testWithNegativeAndPositiveValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(2);\n        assertEquals(0, stream.median());\n        stream.insert(-3);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n        stream.insert(-1);\n        assertEquals(-1, stream.median());\n    }\n\n    @Test\n    public void testWithDuplicateValuesB() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(0);\n        stream.insert(50);\n        assertEquals(10, stream.median());\n    }\n\n    @Test\n    public void testWithLargeValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(1000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(12000);\n        assertEquals(506000, stream.median());\n        stream.insert(15000000);\n        assertEquals(1000000, stream.median());\n        stream.insert(2300000);\n        assertEquals(1650000, stream.median());\n    }\n\n    @Test\n    public void testWithLargeCountOfValues() {\n        var stream = new MedianOfRunningArrayInteger();\n        for (int i = 1; i <= 1000; i++) stream.insert(i);\n        assertEquals(500, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInDescendingOrder() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(30);\n        stream.insert(20);\n        stream.insert(10);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesInOrder() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(10);\n        stream.insert(20);\n        stream.insert(30);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderA() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(30);\n        stream.insert(10);\n        stream.insert(20);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithThreeValuesNotInOrderB() {\n        var stream = new MedianOfRunningArrayInteger();\n        stream.insert(20);\n        stream.insert(10);\n        stream.insert(30);\n        assertEquals(20, stream.median());\n    }\n\n    @Test\n    public void testWithFloatValues() {\n        var stream = new MedianOfRunningArrayFloat();\n        stream.insert(20.0f);\n        assertEquals(20.0f, stream.median());\n        stream.insert(10.5f);\n        assertEquals(15.25f, stream.median());\n        stream.insert(30.0f);\n        assertEquals(20.0f, stream.median());\n    }\n\n    @Test\n    public void testWithByteValues() {\n        var stream = new MedianOfRunningArrayByte();\n        stream.insert((byte) 120);\n        assertEquals((byte) 120, stream.median());\n        stream.insert((byte) -120);\n        assertEquals((byte) 0, stream.median());\n        stream.insert((byte) 127);\n        assertEquals((byte) 120, stream.median());\n    }\n\n    @Test\n    public void testWithLongValues() {\n        var stream = new MedianOfRunningArrayLong();\n        stream.insert(120000000L);\n        assertEquals(120000000L, stream.median());\n        stream.insert(92233720368547757L);\n        assertEquals(46116860244273878L, stream.median());\n    }\n\n    @Test\n    public void testWithDoubleValues() {\n        var stream = new MedianOfRunningArrayDouble();\n        stream.insert(12345.67891);\n        assertEquals(12345.67891, stream.median());\n        stream.insert(23456789.98);\n        assertEquals(Double.valueOf(11734567.83), stream.median(), .01);\n    }\n}"
    },
    {
        "product_commit": "ea15f2bd98c24150b590fac800e386d2f98b203d",
        "test_commit": "09950d6097ea7b2590fb80336d144ee402e61226",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/RotateSinglyLinkedListsTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list[Iterative] from a given node till the end\n     *\n     */\n    public Node reverseListIter(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n    /**\n     * Reverse a singly linked list[Recursive] from a given node till the end\n     *\n     */\n    public Node reverseListRec(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Node prev = null;\n        Node h2 = reverseListRec(head.next);\n\n        head.next.next = head;\n        head.next = prev;\n\n        return h2;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList implements Iterable<Integer> {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list[Iterative] from a given node till the end\n     *\n     */\n    public Node reverseListIter(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n    /**\n     * Reverse a singly linked list[Recursive] from a given node till the end\n     *\n     */\n    public Node reverseListRec(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Node prev = null;\n        Node h2 = reverseListRec(head.next);\n\n        head.next.next = head;\n        head.next = prev;\n\n        return h2;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        for (final var element : this) {\n            ++count;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(final int key) {\n        for (final var element : this) {\n            if (element == key) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        for (final var element : this) {\n            joiner.add(element + \"\");\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return new SinglyLinkedListIterator();\n    }\n\n    private class SinglyLinkedListIterator implements Iterator<Integer> {\n        private Node current;\n\n        SinglyLinkedListIterator() {\n            current = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return current != null;\n        }\n\n        @Override\n        public Integer next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            final var value = current.value;\n            current = current.next;\n            return value;\n        }\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\n/**\n * Test cases for RotateSinglyLinkedLists\n * Author: Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RotateSinglyLinkedListsTest {\n\n    @Test\n    public void testRotateRightEmptyList() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate an empty list\n        assertNull(rotator.rotateRight(null, 2));\n    }\n\n    @Test\n    public void testRotateRightSingleNodeList() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate a list with one element\n        Node singleNode = new Node(5);\n        Node rotatedSingleNode = rotator.rotateRight(singleNode, 3);\n        assertEquals(5, rotatedSingleNode.value);\n        assertNull(rotatedSingleNode.next);\n    }\n\n    @Test\n    public void testRotateRightMultipleElementsList() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate a list with multiple elements (Rotate by 2)\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        Node rotated1 = rotator.rotateRight(head, 2);\n        assertEquals(4, rotated1.value);\n        assertEquals(5, rotated1.next.value);\n        assertEquals(1, rotated1.next.next.value);\n        assertEquals(2, rotated1.next.next.next.value);\n        assertEquals(3, rotated1.next.next.next.next.value);\n        assertNull(rotated1.next.next.next.next.next);\n    }\n\n    @Test\n    public void testRotateRightFullRotation() {\n        RotateSinglyLinkedLists rotator = new RotateSinglyLinkedLists();\n\n        // Test case: Rotate a list with multiple elements (Full rotation)\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.next = new Node(3);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(5);\n\n        Node rotated3 = rotator.rotateRight(head, 7);\n        assertEquals(4, rotated3.value);\n        assertEquals(5, rotated3.next.value);\n        assertEquals(1, rotated3.next.next.value);\n        assertEquals(2, rotated3.next.next.next.value);\n        assertEquals(3, rotated3.next.next.next.next.value);\n        assertNull(rotated3.next.next.next.next.next);\n    }\n}"
    },
    {
        "product_commit": "80a443503895b7514e5e9466914e06a1a9fee1fd",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PowerUsingRecursion.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PowerUsingRecursionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * calculate Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class PowerUsingRecursion {\n\n    public static double power(double base, int exponent) {\n        // Base case: anything raised to the power of 0 is 1\n        if (exponent == 0) {\n            return 1;\n        }\n\n        // Recursive case: base ^ exponent = base * base ^ (exponent - 1)\n        // Recurse with a smaller exponent and multiply with base\n        return base * power(base, exponent - 1);\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass PowerUsingRecursionTest {\n\n    @Test\n    void testPowerUsingRecursion() {\n        assertEquals(32.0, PowerUsingRecursion.power(2.0, 5));\n        assertEquals(97.65625, PowerUsingRecursion.power(2.5, 5));\n        assertEquals(81, PowerUsingRecursion.power(3, 4));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Power using Recursion\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass PowerUsingRecursionTest {\n\n    @Test\n    void testPowerUsingRecursion() {\n        assertEquals(32.0, PowerUsingRecursion.power(2.0, 5));\n        assertEquals(97.65625, PowerUsingRecursion.power(2.5, 5));\n        assertEquals(81, PowerUsingRecursion.power(3, 4));\n    }\n}"
    },
    {
        "product_commit": "b4f786369bc013221371dcd708e4cb2eb82c3956",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinder.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/NonRepeatingNumberFinderTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find Non Repeating Number\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class NonRepeatingNumberFinder {\n\n    public static int findNonRepeatingNumber(int[] arr) {\n        int result = 0;\n        for (int num : arr) {\n            result ^= num;\n        }\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Non Repeating Number Finder\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass NonRepeatingNumberFinderTest {\n\n    @Test\n    void testNonRepeatingNumberFinder() {\n        int arr[] = {1, 2, 1, 2, 6};\n        assertEquals(6, NonRepeatingNumberFinder.findNonRepeatingNumber(arr));\n        int arr1[] = {1, 2, 1, 2};\n        assertEquals(0, NonRepeatingNumberFinder.findNonRepeatingNumber(arr1));\n        int arr2[] = {12};\n        assertEquals(12, NonRepeatingNumberFinder.findNonRepeatingNumber(arr2));\n    }\n}",
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Non Repeating Number Finder\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass NonRepeatingNumberFinderTest {\n\n    @Test\n    void testNonRepeatingNumberFinder() {\n        int arr[] = {1, 2, 1, 2, 6};\n        assertEquals(6, NonRepeatingNumberFinder.findNonRepeatingNumber(arr));\n        int arr1[] = {1, 2, 1, 2};\n        assertEquals(0, NonRepeatingNumberFinder.findNonRepeatingNumber(arr1));\n        int arr2[] = {12};\n        assertEquals(12, NonRepeatingNumberFinder.findNonRepeatingNumber(arr2));\n    }\n}"
    },
    {
        "product_commit": "52f365a915d9d7bd3967fc11e61c7592ad28dea9",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBit.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/IndexOfRightMostSetBitTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Find The Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\npublic class IndexOfRightMostSetBit {\n    public static int indexOfRightMostSetBit(int n) {\n        if (n == 0) {\n            return -1; // No set bits\n        }\n\n        // Handle negative numbers by finding the two's complement\n        if (n < 0) {\n            n = -n;\n            n = n & (~n + 1); // Get the rightmost set bit in positive form\n        }\n\n        int index = 0;\n        while ((n & 1) == 0) {\n            n = n >> 1;\n            index++;\n        }\n\n        return index;\n    }\n}",
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass IndexOfRightMostSetBitTest {\n\n    @Test\n    void testIndexOfRightMostSetBit() {\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));\n        assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));\n    }\n}",
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test case for Index Of Right Most SetBit\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\n\nclass IndexOfRightMostSetBitTest {\n\n    @Test\n    void testIndexOfRightMostSetBit() {\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(40));\n        assertEquals(-1, IndexOfRightMostSetBit.indexOfRightMostSetBit(0));\n        assertEquals(3, IndexOfRightMostSetBit.indexOfRightMostSetBit(-40));\n    }\n}"
    },
    {
        "product_commit": "4bcddd323ca11db87f25af053053390467ddc53e",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/scheduling/PreemptivePriorityScheduling.java",
        "test_file_path": "src/test/java/com/thealgorithms/scheduling/PreemptivePrioritySchedulingTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.scheduling;\n\nimport java.util.*;\n\n/**\n * Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nclass Process {\n    String name;\n    int arrivalTime;\n    int burstTime;\n    int priority;\n\n    public Process(String name, int arrivalTime, int burstTime, int priority) {\n        this.name = name;\n        this.arrivalTime = arrivalTime;\n        this.burstTime = burstTime;\n        this.priority = priority;\n    }\n}\n\npublic class PreemptivePriorityScheduling {\n    public static List<String> preemptivePriorityScheduling(List<Process> processes) {\n        List<String> ganttChart = new ArrayList<>();\n        PriorityQueue<Process> readyQueue = new PriorityQueue<>(Comparator.comparingInt(p -> - p.priority));\n\n        int currentTime = 0;\n\n        while (!processes.isEmpty() || !readyQueue.isEmpty()) {\n            while (!processes.isEmpty() && processes.get(0).arrivalTime <= currentTime) {\n                readyQueue.add(processes.remove(0));\n            }\n\n            if (!readyQueue.isEmpty()) {\n                Process currentProcess = readyQueue.poll();\n\n                ganttChart.add(currentProcess.name);\n                currentProcess.burstTime--;\n\n                if (currentProcess.burstTime > 0) {\n                    readyQueue.add(currentProcess);\n                }\n            } else {\n                ganttChart.add(\"Idle\");\n            }\n\n            currentTime++;\n        }\n\n        return ganttChart;\n    }\n}",
        "test_old_content": "package com.thealgorithms.scheduling;\n\n/**\n * Test Cases of Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\nclass PreemptivePrioritySchedulingTest {\n\n    @Test\n    void testPreemptivePriorityScheduling() {\n        // Arrange\n        List<Process> processes = new ArrayList<>();\n        processes.add(new Process(\"P1\", 0, 5, 10));\n        processes.add(new Process(\"P2\", 1, 4, 20));\n        processes.add(new Process(\"P3\", 2, 2, 30));\n        processes.add(new Process(\"P4\", 4, 1, 40));\n\n        List<String> expectedGanttChart = Arrays.asList(\"P1\", \"P2\", \"P3\", \"P3\", \"P4\", \"P2\", \"P2\", \"P2\", \"P1\", \"P1\", \"P1\", \"P1\");\n\n        // Act\n        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);\n\n        // Assert\n        assertEquals(expectedGanttChart, actualGanttChart);\n    }\n}",
        "test_new_content": "package com.thealgorithms.scheduling;\n\n/**\n * Test Cases of Preemptive Priority Scheduling Algorithm\n * @author [Bama Charan Chhandogi](https://www.github.com/BamaCharanChhandogi)\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\n\nclass PreemptivePrioritySchedulingTest {\n\n    @Test\n    void testPreemptivePriorityScheduling() {\n        // Arrange\n        List<Process> processes = new ArrayList<>();\n        processes.add(new Process(\"P1\", 0, 5, 10));\n        processes.add(new Process(\"P2\", 1, 4, 20));\n        processes.add(new Process(\"P3\", 2, 2, 30));\n        processes.add(new Process(\"P4\", 4, 1, 40));\n\n        List<String> expectedGanttChart = Arrays.asList(\"P1\", \"P2\", \"P3\", \"P3\", \"P4\", \"P2\", \"P2\", \"P2\", \"P1\", \"P1\", \"P1\", \"P1\");\n\n        // Act\n        List<String> actualGanttChart = PreemptivePriorityScheduling.preemptivePriorityScheduling(processes);\n\n        // Assert\n        assertEquals(expectedGanttChart, actualGanttChart);\n    }\n}"
    },
    {
        "product_commit": "2c16c8605455117e1bc6557430830961a3df97e2",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/bitmanipulation/NumbersDifferentSigns.java",
        "test_file_path": "src/test/java/com/thealgorithms/bitmanipulation/NumbersDifferentSignsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\npublic class NumbersDifferentSigns {\n\n    public static boolean differentSigns(int num1, int num2) {\n        return (num1 ^ num2) < 0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * test Cases of Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass NumbersDifferentSignsTest {\n\n    @Test\n    void testDifferentSignsPositiveNegative() {\n        assertTrue(NumbersDifferentSigns.differentSigns(2, -1));\n    }\n\n    @Test\n    void testDifferentSignsNegativePositive() {\n        assertTrue(NumbersDifferentSigns.differentSigns(-3, 7));\n    }\n\n    @Test\n    void testSameSignsPositive() {\n        assertFalse(NumbersDifferentSigns.differentSigns(10, 20));\n    }\n\n    @Test\n    void testSameSignsNegative() {\n        assertFalse(NumbersDifferentSigns.differentSigns(-5, -8));\n    }\n}",
        "test_new_content": "package com.thealgorithms.bitmanipulation;\n\n/**\n * test Cases of Numbers Different Signs\n * @author Bama Charan Chhandogi\n */\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass NumbersDifferentSignsTest {\n\n    @Test\n    void testDifferentSignsPositiveNegative() {\n        assertTrue(NumbersDifferentSigns.differentSigns(2, -1));\n    }\n\n    @Test\n    void testDifferentSignsNegativePositive() {\n        assertTrue(NumbersDifferentSigns.differentSigns(-3, 7));\n    }\n\n    @Test\n    void testSameSignsPositive() {\n        assertFalse(NumbersDifferentSigns.differentSigns(10, 20));\n    }\n\n    @Test\n    void testSameSignsNegative() {\n        assertFalse(NumbersDifferentSigns.differentSigns(-5, -8));\n    }\n}"
    },
    {
        "product_commit": "18848574be543d01245b0e871c264f06592cc2b9",
        "test_commit": "f010a47608607a2622a49a4414e7fbf4b4a7ee03",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BreadthFirstSearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.searches.DepthFirstSearch.Node;\nimport java.util.ArrayDeque;\nimport java.util.Optional;\nimport java.util.Queue;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n */\npublic class BreadthFirstSearch {\n    public static Optional<Node> search(final Node node, final String name) {\n        if (node.getName().equals(name)) {\n            return Optional.of(node);\n        }\n\n        Queue<Node> queue = new ArrayDeque<>(node.getSubNodes());\n\n        while (!queue.isEmpty()) {\n            final Node current = queue.poll();\n\n            if (current.getName().equals(name)) {\n                return Optional.of(current);\n            }\n\n            queue.addAll(current.getSubNodes());\n        }\n\n        return Optional.empty();\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.datastructures.Node;\nimport java.util.*;\n\n/**\n * @author: caos321\n * @date: 31 October 2021 (Sunday)\n * @wiki: https://en.wikipedia.org/wiki/Breadth-first_search\n */\npublic class BreadthFirstSearch<T> {\n\n    private final List<T> visited = new ArrayList<>();\n\n    public Optional<Node<T>> search(final Node<T> node, final T value) {\n        if (node == null) {\n            return Optional.empty();\n        }\n        if (node.getValue().equals(value)) {\n            // add root node to visited\n            visited.add(value);\n            return Optional.of(node);\n        }\n        visited.add(node.getValue());\n\n        Queue<Node<T>> queue = new ArrayDeque<>(node.getChildren());\n\n        while (!queue.isEmpty()) {\n            final Node<T> current = queue.poll();\n            visited.add(current.getValue());\n\n            if (current.getValue().equals(value)) {\n                return Optional.of(current);\n            }\n\n            queue.addAll(current.getChildren());\n        }\n\n        return Optional.empty();\n    }\n\n    public List<T> getVisited() {\n        return visited;\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.datastructures.Node;\nimport java.util.List;\nimport java.util.Optional;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class BreadthFirstSearchTest {\n    private Node<String> root;\n    private BreadthFirstSearch<String> bfs;\n\n    // Tree structure:\n    //\n    //        A\n    //      / | \\\n    //     B  C  D\n    //    / \\\n    //   E   F\n\n    @BeforeEach\n    public void setUp() {\n        // nodes declaration\n        root = new Node<>(\"A\");\n\n        var nodeB = new Node<>(\"B\");\n        var nodeC = new Node<>(\"C\");\n        var nodeD = new Node<>(\"D\");\n\n        var nodeE = new Node<>(\"E\");\n        var nodeF = new Node<>(\"F\");\n\n        // tree initialization\n        root.addChild(nodeB);\n        root.addChild(nodeC);\n        root.addChild(nodeD);\n\n        nodeB.addChild(nodeE);\n        nodeB.addChild(nodeF);\n\n        // create an instance to monitor the visited nodes\n        bfs = new BreadthFirstSearch<>();\n    }\n\n    @Test\n    public void testSearchRoot() {\n        String expectedValue = \"A\";\n        List<String> expectedPath = List.of(\"A\");\n\n        // check value\n        Optional<Node<String>> value = bfs.search(root, expectedValue);\n        assertEquals(expectedValue, value.orElse(new Node<>(\"\")).getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    public void testSearchF() {\n        String expectedValue = \"F\";\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n\n        // check value\n        Optional<Node<String>> value = Optional.of(bfs.search(root, expectedValue).orElse(new Node<>(null)));\n        assertEquals(expectedValue, value.get().getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    void testSearchNull() {\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n        Optional<Node<String>> node = bfs.search(root, null);\n\n        // check value\n        assertTrue(node.isEmpty());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    void testNullRoot() {\n        var value = bfs.search(null, \"B\");\n        assertTrue(value.isEmpty());\n    }\n\n    @Test\n    void testSearchValueThatNotExists() {\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n        var value = bfs.search(root, \"Z\");\n\n        // check that the value is empty because it's not exists in the tree\n        assertTrue(value.isEmpty());\n\n        // check path is the whole list\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.thealgorithms.datastructures.Node;\nimport java.util.List;\nimport java.util.Optional;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class BreadthFirstSearchTest {\n    private Node<String> root;\n    private BreadthFirstSearch<String> bfs;\n\n    // Tree structure:\n    //\n    //        A\n    //      / | \\\n    //     B  C  D\n    //    / \\\n    //   E   F\n\n    @BeforeEach\n    public void setUp() {\n        // nodes declaration\n        root = new Node<>(\"A\");\n\n        var nodeB = new Node<>(\"B\");\n        var nodeC = new Node<>(\"C\");\n        var nodeD = new Node<>(\"D\");\n\n        var nodeE = new Node<>(\"E\");\n        var nodeF = new Node<>(\"F\");\n\n        // tree initialization\n        root.addChild(nodeB);\n        root.addChild(nodeC);\n        root.addChild(nodeD);\n\n        nodeB.addChild(nodeE);\n        nodeB.addChild(nodeF);\n\n        // create an instance to monitor the visited nodes\n        bfs = new BreadthFirstSearch<>();\n    }\n\n    @Test\n    public void testSearchRoot() {\n        String expectedValue = \"A\";\n        List<String> expectedPath = List.of(\"A\");\n\n        // check value\n        Optional<Node<String>> value = bfs.search(root, expectedValue);\n        assertEquals(expectedValue, value.orElse(new Node<>(\"\")).getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    public void testSearchF() {\n        String expectedValue = \"F\";\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n\n        // check value\n        Optional<Node<String>> value = Optional.of(bfs.search(root, expectedValue).orElse(new Node<>(null)));\n        assertEquals(expectedValue, value.get().getValue());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    void testSearchNull() {\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n        Optional<Node<String>> node = bfs.search(root, null);\n\n        // check value\n        assertTrue(node.isEmpty());\n\n        // check path\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n\n    @Test\n    void testNullRoot() {\n        var value = bfs.search(null, \"B\");\n        assertTrue(value.isEmpty());\n    }\n\n    @Test\n    void testSearchValueThatNotExists() {\n        List<String> expectedPath = List.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\");\n        var value = bfs.search(root, \"Z\");\n\n        // check that the value is empty because it's not exists in the tree\n        assertTrue(value.isEmpty());\n\n        // check path is the whole list\n        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());\n    }\n}"
    },
    {
        "product_commit": "4fe419ebd894ba178e2f00cebef2157594f5042e",
        "test_commit": "ea15f2bd98c24150b590fac800e386d2f98b203d",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    public Node reverseList(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list[Iterative] from a given node till the end\n     *\n     */\n    public Node reverseListIter(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n    /**\n     * Reverse a singly linked list[Recursive] from a given node till the end\n     *\n     */\n    public Node reverseListRec(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Node prev = null;\n        Node h2 = reverseListRec(head.next);\n\n        head.next.next = head;\n        head.next = prev;\n\n        return h2;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseListIter(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseListIter(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseListIter(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n    // This is Recursive Reverse List Test\n    // Test to check whether the method reverseListRec() works fine\n    void RecursiveReverseList() {\n        // Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\n        SinglyLinkedList list = createSampleList(5);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list is: 5 -> 4 -> 3 -> 2 -> 1\n        assertEquals(5, head.value);\n        assertEquals(4, head.next.value);\n        assertEquals(3, head.next.next.value);\n        assertEquals(2, head.next.next.next.value);\n        assertEquals(1, head.next.next.next.next.value);\n    }\n\n    @Test\n    void RecursiveReverseListNullPointer() {\n        // Create an empty linked list\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the empty linked list\n        Node head = list.reverseListRec(first);\n\n        // Check if the head remains the same (null)\n        assertNull(head);\n    }\n\n    @Test\n    void RecursiveReverseListTest() {\n        // Create a linked list with values from 1 to 20\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list has the correct values\n        int i = 20;\n        Node temp = head;\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseListIter(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseListIter(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseListIter(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n    // This is Recursive Reverse List Test\n    // Test to check whether the method reverseListRec() works fine\n    void RecursiveReverseList() {\n        // Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\n        SinglyLinkedList list = createSampleList(5);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list is: 5 -> 4 -> 3 -> 2 -> 1\n        assertEquals(5, head.value);\n        assertEquals(4, head.next.value);\n        assertEquals(3, head.next.next.value);\n        assertEquals(2, head.next.next.next.value);\n        assertEquals(1, head.next.next.next.next.value);\n    }\n\n    @Test\n    void RecursiveReverseListNullPointer() {\n        // Create an empty linked list\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the empty linked list\n        Node head = list.reverseListRec(first);\n\n        // Check if the head remains the same (null)\n        assertNull(head);\n    }\n\n    @Test\n    void RecursiveReverseListTest() {\n        // Create a linked list with values from 1 to 20\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list has the correct values\n        int i = 20;\n        Node temp = head;\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n\n    @Test\n    void readWithEnhancedForLoopTest() {\n        final var expeced = new ArrayList<Integer>(Arrays.asList(10, 20, 30));\n\n        SinglyLinkedList list = new SinglyLinkedList();\n        for (final var x : expeced) {\n            list.insert(x);\n        }\n\n        var readElements = new ArrayList<Integer>();\n        for (final var x : list) {\n            readElements.add(x);\n        }\n\n        assertEquals(readElements, expeced);\n    }\n\n    @Test\n    void toStringTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n        assertEquals(\"1->2->3\", list.toString());\n    }\n\n    @Test\n    void toStringForEmptyListTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assertEquals(\"\", list.toString());\n    }\n\n    @Test\n    void countTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        list.insert(10);\n        list.insert(20);\n        assertEquals(2, list.count());\n    }\n\n    @Test\n    void countForEmptyListTest() {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assertEquals(0, list.count());\n    }\n}"
    },
    {
        "product_commit": "44dcebb6996b39b5a1a67a8633f95b6e4c1bd0f0",
        "test_commit": "e5c7a08874a6c7ff043ec5e3f44b3aac553f4e53",
        "product_file_path": "src/main/java/com/thealgorithms/others/StackPostfixNotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/StackPostfixNotationTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.*;\n\npublic class StackPostfixNotation {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String post = scanner.nextLine(); // Takes input with spaces in between eg. \"1 21 +\"\n        System.out.println(postfixEvaluate(post));\n        scanner.close();\n    }\n\n    // Evaluates the given postfix expression string and returns the result.\n    public static int postfixEvaluate(String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt()); // If int then push to stack\n            } else { // else pop top two values and perform the operation\n                int num2 = s.pop();\n                int num1 = s.pop();\n                String op = tokens.next();\n\n                switch (op) {\n                    case \"+\" -> s.push(num1 + num2);\n                    case \"-\" -> s.push(num1 - num2);\n                    case \"*\" -> s.push(num1 * num2);\n                    default -> s.push(num1 / num2);\n                }\n                //  \"+\", \"-\", \"*\", \"/\"\n            }\n        }\n        tokens.close();\n        return s.pop();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic final class StackPostfixNotation {\n    private StackPostfixNotation() {\n    }\n\n    // Evaluates the given postfix expression string and returns the result.\n    public static int postfixEvaluate(final String exp) {\n        Stack<Integer> s = new Stack<Integer>();\n        Scanner tokens = new Scanner(exp);\n\n        while (tokens.hasNext()) {\n            if (tokens.hasNextInt()) {\n                s.push(tokens.nextInt()); // If int then push to stack\n            } else { // else pop top two values and perform the operation\n                int num2 = s.pop();\n                int num1 = s.pop();\n                String op = tokens.next();\n\n                switch (op) {\n                    case \"+\" -> s.push(num1 + num2);\n                    case \"-\" -> s.push(num1 - num2);\n                    case \"*\" -> s.push(num1 * num2);\n                    case \"/\" -> s.push(num1 / num2);\n                    default -> throw new IllegalArgumentException(\"exp contains an unknown operation.\");\n                }\n                //  \"+\", \"-\", \"*\", \"/\"\n            }\n        }\n        tokens.close();\n        if (s.size() != 1) {\n            throw new IllegalArgumentException(\"exp is not a proper postfix expression.\");\n        }\n        return s.pop();\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static java.util.Map.entry;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class StackPostfixNotationTest {\n    @Test\n    public void testEvaluate() {\n        final Map<String, Integer> testCases = Map.ofEntries(entry(\"1 1 +\", 2), entry(\"2 3 *\", 6), entry(\"6 2 /\", 3), entry(\"-5 -2 -\", -3), entry(\"5 2 + 3 *\", 21), entry(\"-5\", -5));\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), StackPostfixNotation.postfixEvaluate(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInproperInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 3\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithUnknownOperation() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 !\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static java.util.Map.entry;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class StackPostfixNotationTest {\n    @Test\n    public void testEvaluate() {\n        final Map<String, Integer> testCases = Map.ofEntries(entry(\"1 1 +\", 2), entry(\"2 3 *\", 6), entry(\"6 2 /\", 3), entry(\"-5 -2 -\", -3), entry(\"5 2 + 3 *\", 21), entry(\"-5\", -5));\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(tc.getValue(), StackPostfixNotation.postfixEvaluate(tc.getKey()));\n        }\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInproperInput() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 3\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithUnknownOperation() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"3 3 !\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithTooFewArgsA() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"+\"));\n    }\n\n    @Test\n    public void testIfEvaluateThrowsExceptionForInputWithTooFewArgsB() {\n        assertThrows(IllegalArgumentException.class, () -> StackPostfixNotation.postfixEvaluate(\"2 +\"));\n    }\n}"
    },
    {
        "product_commit": "2488a2ad51bd4d15309449b6d88bbf8eb33fd29b",
        "test_commit": "4fe419ebd894ba178e2f00cebef2157594f5042e",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    public Node reverseList(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    public Node reverseList(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseList(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseList(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseList(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i + 1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        // List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode / 2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode / 2, list.middle().value);\n\n        // return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        // return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1, 5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); // Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    // Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList() {\n\n        // Creating a new LinkedList of size:4\n        // The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node The reversed linkedlist will be 4->3->2->1->null\n        Node head = list.reverseListIter(list.getHead());\n\n        // Recording the Nodes after reversing the LinkedList\n        Node firstNode = head; // 4\n        Node secondNode = firstNode.next; // 3\n        Node thirdNode = secondNode.next; // 2\n        Node fourthNode = thirdNode.next; // 1\n\n        // Checking whether the LinkedList is reversed or not by comparing the original list and\n        // reversed list nodes\n        assertEquals(1, fourthNode.value);\n        assertEquals(2, thirdNode.value);\n        assertEquals(3, secondNode.value);\n        assertEquals(4, firstNode.value);\n    }\n\n    // Test to check whether implemented reverseList() method handles NullPointer Exception for\n    // TestCase where head==null\n    @Test\n    void reverseListNullPointer() {\n        // Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the linkedlist\n        Node head = list.reverseListIter(first);\n\n        // checking whether the method works fine if the input is null\n        assertEquals(head, first);\n    }\n\n    // Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest() {\n        // Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the LinkedList using reverseList() method and storing the head of the reversed\n        // linkedlist in a head node\n        Node head = list.reverseListIter(list.getHead());\n\n        // Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp = head;\n\n        int i = 20; // This is for the comparison of values of nodes of the reversed linkedlist\n        // Checking whether the reverseList() method performed its task\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n    // This is Recursive Reverse List Test\n    // Test to check whether the method reverseListRec() works fine\n    void RecursiveReverseList() {\n        // Create a linked list: 1 -> 2 -> 3 -> 4 -> 5\n        SinglyLinkedList list = createSampleList(5);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list is: 5 -> 4 -> 3 -> 2 -> 1\n        assertEquals(5, head.value);\n        assertEquals(4, head.next.value);\n        assertEquals(3, head.next.next.value);\n        assertEquals(2, head.next.next.next.value);\n        assertEquals(1, head.next.next.next.next.value);\n    }\n\n    @Test\n    void RecursiveReverseListNullPointer() {\n        // Create an empty linked list\n        SinglyLinkedList list = new SinglyLinkedList();\n        Node first = list.getHead();\n\n        // Reversing the empty linked list\n        Node head = list.reverseListRec(first);\n\n        // Check if the head remains the same (null)\n        assertNull(head);\n    }\n\n    @Test\n    void RecursiveReverseListTest() {\n        // Create a linked list with values from 1 to 20\n        SinglyLinkedList list = createSampleList(20);\n\n        // Reversing the linked list using reverseList() method\n        Node head = list.reverseListRec(list.getHead());\n\n        // Check if the reversed list has the correct values\n        int i = 20;\n        Node temp = head;\n        while (temp != null && i > 0) {\n            assertEquals(i, temp.value);\n            temp = temp.next;\n            i--;\n        }\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "05ca93eace893a75e886a19739778a67bd3a18bc",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Area.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AreaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(\n        final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(()\n                      -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(()\n                      -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangle(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangle(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}"
    },
    {
        "product_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "test_commit": "7a3273ae1db2a652b80a4b655e642f06331937cb",
        "product_file_path": "src/main/java/com/thealgorithms/others/SieveOfEratosthenes.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/SieveOfEratosthenesTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers\n * up to any given limit.\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Wiki</a>\n */\npublic class SieveOfEratosthenes {\n\n    /**\n     * Finds all prime numbers till n.\n     *\n     * @param n The number till which we have to check for primes. Should be more than 1.\n     * @return Array of all prime numbers between 0 to n.\n     */\n    public static int[] findPrimesTill(int n) {\n        Type[] numbers = new Type[n + 1];\n        Arrays.fill(numbers, Type.PRIME);\n        numbers[0] = numbers[1] = Type.NOT_PRIME;\n\n        double cap = Math.sqrt(n);\n        for (int i = 2; i <= cap; i++) {\n            if (numbers[i] == Type.PRIME) {\n                for (int j = 2; i * j <= n; j++) {\n                    numbers[i * j] = Type.NOT_PRIME;\n                }\n            }\n        }\n\n        int primesCount\n            = (int) Arrays.stream(numbers).filter(element -> element == Type.PRIME).count();\n        int[] primes = new int[primesCount];\n\n        int primeIndex = 0;\n        for (int i = 0; i < n + 1; i++) {\n            if (numbers[i] == Type.PRIME) {\n                primes[primeIndex++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    private enum Type {\n        PRIME,\n        NOT_PRIME,\n    }\n\n    public static void main(String[] args) {\n        int n = 100;\n        System.out.println(\"Searching for all primes from zero to \" + n);\n        int[] primes = findPrimesTill(n);\n        System.out.println(\"Found: \" + Arrays.toString(primes));\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers\n * up to any given limit.\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Wiki</a>\n */\npublic class SieveOfEratosthenes {\n\n    /**\n     * Finds all prime numbers till n.\n     *\n     * @param n The number till which we have to check for primes. Should be more than 1.\n     * @return Array of all prime numbers between 0 to n.\n     */\n    public static int[] findPrimesTill(int n) {\n        Type[] numbers = new Type[n + 1];\n        Arrays.fill(numbers, Type.PRIME);\n        numbers[0] = numbers[1] = Type.NOT_PRIME;\n\n        double cap = Math.sqrt(n);\n        for (int i = 2; i <= cap; i++) {\n            if (numbers[i] == Type.PRIME) {\n                for (int j = 2; i * j <= n; j++) {\n                    numbers[i * j] = Type.NOT_PRIME;\n                }\n            }\n        }\n\n        int primesCount = (int) Arrays.stream(numbers).filter(element -> element == Type.PRIME).count();\n        int[] primes = new int[primesCount];\n\n        int primeIndex = 0;\n        for (int i = 0; i < n + 1; i++) {\n            if (numbers[i] == Type.PRIME) {\n                primes[primeIndex++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    private enum Type {\n        PRIME,\n        NOT_PRIME,\n    }\n\n    public static void main(String[] args) {\n        int n = 100;\n        System.out.println(\"Searching for all primes from zero to \" + n);\n        int[] primes = findPrimesTill(n);\n        System.out.println(\"Found: \" + Arrays.toString(primes));\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass SieveOfEratosthenesTest {\n    @Test\n    public void testfFindPrimesTill1() {\n        assertArrayEquals(new int[] {}, SieveOfEratosthenes.findPrimesTill(1));\n    }\n\n    @Test\n    public void testfFindPrimesTill2() {\n        assertArrayEquals(new int[] {2}, SieveOfEratosthenes.findPrimesTill(2));\n    }\n\n    @Test\n    public void testfFindPrimesTill4() {\n        var primesTill4 = new int[] {2, 3};\n        assertArrayEquals(primesTill4, SieveOfEratosthenes.findPrimesTill(3));\n        assertArrayEquals(primesTill4, SieveOfEratosthenes.findPrimesTill(4));\n    }\n\n    @Test\n    public void testfFindPrimesTill40() {\n        var primesTill40 = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(37));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(38));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(39));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(40));\n    }\n\n    @Test\n    public void testfFindPrimesTill240() {\n        var primesTill240 = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239};\n        assertArrayEquals(primesTill240, SieveOfEratosthenes.findPrimesTill(239));\n        assertArrayEquals(primesTill240, SieveOfEratosthenes.findPrimesTill(240));\n    }\n\n    @Test\n    public void testFindPrimesTillThrowsExceptionForNonPositiveInput() {\n        assertThrows(IllegalArgumentException.class, () -> SieveOfEratosthenes.findPrimesTill(0));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "bc699b86e5719cd897fb182121f6c23b03bc6caf",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalancedTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * This entire class is used to build a Binary Tree data structure. There is the\n * Node Class and the Tree Class, both explained below.\n */\n/**\n * A binary tree is a data structure in which an element has two\n * successors(children). The left child is usually smaller than the parent, and\n * the right child is usually bigger.\n *\n * @author Unknown\n */\npublic class BinaryTree {\n\n    /**\n     * This class implements the nodes that will go on the Binary Tree. They\n     * consist of the data in them, the node to the left, the node to the right,\n     * and the parent from which they came from.\n     *\n     * @author Unknown\n     */\n    static class Node {\n\n        /**\n         * Data for the node\n         */\n        public int data;\n        /**\n         * The Node to the left of this one\n         */\n        public Node left;\n        /**\n         * The Node to the right of this one\n         */\n        public Node right;\n        /**\n         * The parent of this node\n         */\n        public Node parent;\n\n        /**\n         * Constructor of Node\n         *\n         * @param value Value to put in the node\n         */\n        public Node(int value) {\n            data = value;\n            left = null;\n            right = null;\n            parent = null;\n        }\n    }\n\n    /**\n     * The root of the Binary Tree\n     */\n    private Node root;\n\n    /**\n     * Constructor\n     */\n    public BinaryTree() {\n        root = null;\n    }\n\n    /**\n     * Parameterized Constructor\n     */\n    public BinaryTree(Node root) {\n        this.root = root;\n    }\n\n    /**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */\n    public Node find(int key) {\n        Node current = root;\n        while (current != null) {\n            if (key < current.data) {\n                if (current.left == null) {\n                    return current; // The key isn't exist, returns the parent\n                }\n                current = current.left;\n            } else if (key > current.data) {\n                if (current.right == null) {\n                    return current;\n                }\n                current = current.right;\n            } else { // If you find the value return it\n                return current;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts certain value into the Binary Tree\n     *\n     * @param value Value to be inserted\n     */\n    public void put(int value) {\n        Node newNode = new Node(value);\n        if (root == null) {\n            root = newNode;\n        } else {\n            // This will return the soon to be parent of the value you're inserting\n            Node parent = find(value);\n\n            // This if/else assigns the new node to be either the left or right child of the parent\n            if (value < parent.data) {\n                parent.left = newNode;\n                parent.left.parent = parent;\n            } else {\n                parent.right = newNode;\n                parent.right.parent = parent;\n            }\n        }\n    }\n\n    /**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */\n    public boolean remove(int value) {\n        // temp is the node to be deleted\n        Node temp = find(value);\n\n        // If the value doesn't exist\n        if (temp.data != value) {\n            return false;\n        }\n\n        // No children\n        if (temp.right == null && temp.left == null) {\n            if (temp == root) {\n                root = null;\n            } // This if/else assigns the new node to be either the left or right child of the parent\n            else if (temp.parent.data < temp.data) {\n                temp.parent.right = null;\n            } else {\n                temp.parent.left = null;\n            }\n            return true;\n        } // Two children\n        else if (temp.left != null && temp.right != null) {\n            Node successor = findSuccessor(temp);\n\n            // The left tree of temp is made the left tree of the successor\n            successor.left = temp.left;\n            successor.left.parent = successor;\n\n            // If the successor has a right child, the child's grandparent is it's new parent\n            if (successor.parent != temp) {\n                if (successor.right != null) {\n                    successor.right.parent = successor.parent;\n                    successor.parent.left = successor.right;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                } else {\n                    successor.parent.left = null;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                }\n            }\n\n            if (temp == root) {\n                successor.parent = null;\n                root = successor;\n            } // If you're not deleting the root\n            else {\n                successor.parent = temp.parent;\n\n                // This if/else assigns the new node to be either the left or right child of the parent\n                if (temp.parent.data < temp.data) {\n                    temp.parent.right = successor;\n                } else {\n                    temp.parent.left = successor;\n                }\n            }\n            return true;\n        } // One child\n        else {\n            // If it has a right child\n            if (temp.right != null) {\n                if (temp == root) {\n                    root = temp.right;\n                    return true;\n                }\n\n                temp.right.parent = temp.parent;\n\n                // Assigns temp to left or right child\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.right;\n                } else {\n                    temp.parent.right = temp.right;\n                }\n            } // If it has a left child\n            else {\n                if (temp == root) {\n                    root = temp.left;\n                    return true;\n                }\n\n                temp.left.parent = temp.parent;\n\n                // Assigns temp to left or right side\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.left;\n                } else {\n                    temp.parent.right = temp.left;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * This method finds the Successor to the Node given. Move right once and go\n     * left down the tree as far as you can\n     *\n     * @param n Node that you want to find the Successor of\n     * @return The Successor of the node\n     */\n    public Node findSuccessor(Node n) {\n        if (n.right == null) {\n            return n;\n        }\n        Node current = n.right;\n        Node parent = n.right;\n        while (current != null) {\n            parent = current;\n            current = current.left;\n        }\n        return parent;\n    }\n\n    /**\n     * Returns the root of the Binary Tree\n     *\n     * @return the root of the Binary Tree\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\n     * first search\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void inOrder(Node localRoot) {\n        if (localRoot != null) {\n            inOrder(localRoot.left);\n            System.out.print(localRoot.data + \" \");\n            inOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints root - leftChild - rightChild\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void preOrder(Node localRoot) {\n        if (localRoot != null) {\n            System.out.print(localRoot.data + \" \");\n            preOrder(localRoot.left);\n            preOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints rightChild - leftChild - root\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void postOrder(Node localRoot) {\n        if (localRoot != null) {\n            postOrder(localRoot.left);\n            postOrder(localRoot.right);\n            System.out.print(localRoot.data + \" \");\n        }\n    }\n\n    /**\n     * Prints the tree in a breadth first search order This is similar to\n     * pre-order traversal, but instead of being implemented with a stack (or\n     * recursion), it is implemented with a queue\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void bfs(Node localRoot) {\n        // Create a queue for the order of the nodes\n        Queue<Node> queue = new LinkedList<Node>();\n\n        // If the give root is null, then we don't add to the queue\n        // and won't do anything\n        if (localRoot != null) {\n            queue.add(localRoot);\n        }\n\n        // Continue until the queue is empty\n        while (!queue.isEmpty()) {\n            // Get the next node on the queue to visit\n            localRoot = queue.remove();\n\n            // Print the data from the node we are visiting\n            System.out.print(localRoot.data + \" \");\n\n            // Add the children to the queue if not null\n            if (localRoot.right != null) {\n                queue.add(localRoot.right);\n            }\n            if (localRoot.left != null) {\n                queue.add(localRoot.left);\n            }\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * This entire class is used to build a Binary Tree data structure. There is the\n * Node Class and the Tree Class, both explained below.\n */\n/**\n * A binary tree is a data structure in which an element has two\n * successors(children). The left child is usually smaller than the parent, and\n * the right child is usually bigger.\n *\n * @author Unknown\n */\npublic class BinaryTree {\n\n    /**\n     * This class implements the nodes that will go on the Binary Tree. They\n     * consist of the data in them, the node to the left, the node to the right,\n     * and the parent from which they came from.\n     *\n     * @author Unknown\n     */\n    static class Node {\n\n        /**\n         * Data for the node\n         */\n        public int data;\n        /**\n         * The Node to the left of this one\n         */\n        public Node left;\n        /**\n         * The Node to the right of this one\n         */\n        public Node right;\n        /**\n         * The parent of this node\n         */\n        public Node parent;\n\n        /**\n         * Constructor of Node\n         *\n         * @param value Value to put in the node\n         */\n        public Node(int value) {\n            data = value;\n            left = null;\n            right = null;\n            parent = null;\n        }\n    }\n\n    /**\n     * The root of the Binary Tree\n     */\n    private Node root;\n\n    /**\n     * Constructor\n     */\n    public BinaryTree() {\n        root = null;\n    }\n\n    /**\n     * Parameterized Constructor\n     */\n    public BinaryTree(Node root) {\n        this.root = root;\n    }\n\n    /**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */\n    public Node find(int key) {\n        Node current = root;\n        while (current != null) {\n            if (key < current.data) {\n                if (current.left == null) {\n                    return current; // The key isn't exist, returns the parent\n                }\n                current = current.left;\n            } else if (key > current.data) {\n                if (current.right == null) {\n                    return current;\n                }\n                current = current.right;\n            } else { // If you find the value return it\n                return current;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts certain value into the Binary Tree\n     *\n     * @param value Value to be inserted\n     */\n    public void put(int value) {\n        Node newNode = new Node(value);\n        if (root == null) {\n            root = newNode;\n        } else {\n            // This will return the soon to be parent of the value you're inserting\n            Node parent = find(value);\n\n            // This if/else assigns the new node to be either the left or right child of the parent\n            if (value < parent.data) {\n                parent.left = newNode;\n                parent.left.parent = parent;\n            } else {\n                parent.right = newNode;\n                parent.right.parent = parent;\n            }\n        }\n    }\n\n    /**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */\n    public boolean remove(int value) {\n        // temp is the node to be deleted\n        Node temp = find(value);\n\n        // If the value doesn't exist\n        if (temp.data != value) {\n            return false;\n        }\n\n        // No children\n        if (temp.right == null && temp.left == null) {\n            if (temp == root) {\n                root = null;\n            } // This if/else assigns the new node to be either the left or right child of the\n              // parent\n            else if (temp.parent.data < temp.data) {\n                temp.parent.right = null;\n            } else {\n                temp.parent.left = null;\n            }\n            return true;\n        } // Two children\n        else if (temp.left != null && temp.right != null) {\n            Node successor = findSuccessor(temp);\n\n            // The left tree of temp is made the left tree of the successor\n            successor.left = temp.left;\n            successor.left.parent = successor;\n\n            // If the successor has a right child, the child's grandparent is it's new parent\n            if (successor.parent != temp) {\n                if (successor.right != null) {\n                    successor.right.parent = successor.parent;\n                    successor.parent.left = successor.right;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                } else {\n                    successor.parent.left = null;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                }\n            }\n\n            if (temp == root) {\n                successor.parent = null;\n                root = successor;\n            } // If you're not deleting the root\n            else {\n                successor.parent = temp.parent;\n\n                // This if/else assigns the new node to be either the left or right child of the\n                // parent\n                if (temp.parent.data < temp.data) {\n                    temp.parent.right = successor;\n                } else {\n                    temp.parent.left = successor;\n                }\n            }\n            return true;\n        } // One child\n        else {\n            // If it has a right child\n            if (temp.right != null) {\n                if (temp == root) {\n                    root = temp.right;\n                    return true;\n                }\n\n                temp.right.parent = temp.parent;\n\n                // Assigns temp to left or right child\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.right;\n                } else {\n                    temp.parent.right = temp.right;\n                }\n            } // If it has a left child\n            else {\n                if (temp == root) {\n                    root = temp.left;\n                    return true;\n                }\n\n                temp.left.parent = temp.parent;\n\n                // Assigns temp to left or right side\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.left;\n                } else {\n                    temp.parent.right = temp.left;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * This method finds the Successor to the Node given. Move right once and go\n     * left down the tree as far as you can\n     *\n     * @param n Node that you want to find the Successor of\n     * @return The Successor of the node\n     */\n    public Node findSuccessor(Node n) {\n        if (n.right == null) {\n            return n;\n        }\n        Node current = n.right;\n        Node parent = n.right;\n        while (current != null) {\n            parent = current;\n            current = current.left;\n        }\n        return parent;\n    }\n\n    /**\n     * Returns the root of the Binary Tree\n     *\n     * @return the root of the Binary Tree\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\n     * first search\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void inOrder(Node localRoot) {\n        if (localRoot != null) {\n            inOrder(localRoot.left);\n            System.out.print(localRoot.data + \" \");\n            inOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints root - leftChild - rightChild\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void preOrder(Node localRoot) {\n        if (localRoot != null) {\n            System.out.print(localRoot.data + \" \");\n            preOrder(localRoot.left);\n            preOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints rightChild - leftChild - root\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void postOrder(Node localRoot) {\n        if (localRoot != null) {\n            postOrder(localRoot.left);\n            postOrder(localRoot.right);\n            System.out.print(localRoot.data + \" \");\n        }\n    }\n\n    /**\n     * Prints the tree in a breadth first search order This is similar to\n     * pre-order traversal, but instead of being implemented with a stack (or\n     * recursion), it is implemented with a queue\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void bfs(Node localRoot) {\n        // Create a queue for the order of the nodes\n        Queue<Node> queue = new LinkedList<Node>();\n\n        // If the give root is null, then we don't add to the queue\n        // and won't do anything\n        if (localRoot != null) {\n            queue.add(localRoot);\n        }\n\n        // Continue until the queue is empty\n        while (!queue.isEmpty()) {\n            // Get the next node on the queue to visit\n            localRoot = queue.remove();\n\n            // Print the data from the node we are visiting\n            System.out.print(localRoot.data + \" \");\n\n            // Add the children to the queue if not null\n            if (localRoot.right != null) {\n                queue.add(localRoot.right);\n            }\n            if (localRoot.left != null) {\n                queue.add(localRoot.left);\n            }\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test check both implemented ways, iterative and recursive algorithms.\n *\n * @author Albina Gimaletdinova on 26/06/2023\n */\npublic class CheckIfBinaryTreeBalancedTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(null));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {Integer.MIN_VALUE});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n     9    <-- Math.abs(height(left) - height(right)) == 0\n    / \\\n   7   13\n  /\\   / \\\n 3  8 10 20\n*/\n    @Test\n    public void testBinaryTreeIsBalancedEqualSubtreeHeights() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n     9    <-- Math.abs(height(left) - height(right)) == 1\n    / \\\n   7   13\n  /\\\n 3  8\n*/\n    @Test\n    public void testBinaryTreeIsBalancedWithDifferentHeights() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n         9  <-- only left tree exists, Math.abs(height(left) - height(right)) > 1\n        /\n       7\n      /\\\n     3  8\n    */\n    @Test\n    public void testBinaryTreeNotBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, null, 3, 8});\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n         9    <-- Math.abs(height(left) - height(right)) > 1\n        / \\\n       7   13\n      /\\\n     3  8\n    /\n   11\n*/\n    @Test\n    public void testBinaryTreeNotBalancedBecauseLeftTreeNotBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, null, null, 11});\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "bc699b86e5719cd897fb182121f6c23b03bc6caf",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalanced.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalancedTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * This class will check if a BinaryTree is balanced. A balanced binary tree is\n * defined as a binary tree where the differenced in height between the left and\n * right subtree of each node differs by at most one.\n *\n * This can be done in both an iterative and recursive fashion. Below,\n * `isBalancedRecursive()` is implemented in a recursive fashion, and\n * `isBalancedIterative()` is implemented in an iterative fashion.\n *\n * @author [Ian Cowan](https://github.com/iccowan)\n */\npublic class CheckIfBinaryTreeBalanced {\n\n    /**\n     * This class implements the BinaryTree for these algorithms\n     */\n    class BinaryTree {\n\n        /**\n         * The root node of the binary tree\n         */\n        BTNode root = null;\n    }\n\n    /**\n     * This class implements the nodes for the binary tree\n     */\n    class BTNode {\n\n        /**\n         * The value of the node\n         */\n        int value;\n\n        /**\n         * The left child of the node\n         */\n        BTNode left = null;\n\n        /**\n         * The right child of the node\n         */\n        BTNode right = null;\n\n        /**\n         * Constructor\n         */\n        BTNode(int value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * Recursive is BT balanced implementation\n     *\n     * @param binaryTree The binary tree to check if balanced\n     */\n    public boolean isBalancedRecursive(BinaryTree binaryTree) {\n        // Create an array of length 1 to keep track of our balance\n        // Default to true. We use an array so we have an efficient mutable object\n        boolean[] isBalanced = new boolean[1];\n        isBalanced[0] = true;\n\n        // Check for balance and return whether or not we are balanced\n        isBalancedRecursive(binaryTree.root, 0, isBalanced);\n        return isBalanced[0];\n    }\n\n    /**\n     * Private helper method to keep track of the depth and balance during\n     * recursion. We effectively perform a modified post-order traversal where\n     * we are looking at the heights of both children of each node in the tree\n     *\n     * @param node The current node to explore\n     * @param depth The current depth of the node\n     * @param isBalanced The array of length 1 keeping track of our balance\n     */\n    private int isBalancedRecursive(\n        BTNode node,\n        int depth,\n        boolean[] isBalanced\n    ) {\n        // If the node is null, we should not explore it and the height is 0\n        // If the tree is already not balanced, might as well stop because we\n        // can't make it balanced now!\n        if (node == null || !isBalanced[0]) {\n            return 0;\n        }\n\n        // Visit the left and right children, incrementing their depths by 1\n        int leftHeight = isBalancedRecursive(node.left, depth + 1, isBalanced);\n        int rightHeight = isBalancedRecursive(\n            node.right,\n            depth + 1,\n            isBalanced\n        );\n\n        // If the height of either of the left or right subtrees differ by more\n        // than 1, we cannot be balanced\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            isBalanced[0] = false;\n        }\n\n        // The height of our tree is the maximum of the heights of the left\n        // and right subtrees plus one\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    /**\n     * Iterative is BT balanced implementation\n     */\n    public boolean isBalancedIterative(BinaryTree binaryTree) {\n        // Default that we are balanced and our algo will prove it wrong\n        boolean isBalanced = true;\n\n        // Create a stack for our post order traversal\n        Stack<BTNode> nodeStack = new Stack<BTNode>();\n\n        // For post order traversal, we'll have to keep track of where we\n        // visited last\n        BTNode lastVisited = null;\n\n        // Create a HashMap to keep track of the subtree heights for each node\n        HashMap<BTNode, Integer> subtreeHeights = new HashMap<BTNode, Integer>();\n\n        // We begin at the root of the tree\n        BTNode node = binaryTree.root;\n\n        // We loop while:\n        // - the node stack is empty and the node we explore is null\n        // AND\n        // - the tree is still balanced\n        while (!(nodeStack.isEmpty() && node == null) && isBalanced) {\n            // If the node is not null, we push it to the stack and continue\n            // to the left\n            if (node != null) {\n                nodeStack.push(node);\n                node = node.left;\n                // Once we hit a node that is null, we are as deep as we can go\n                // to the left\n            } else {\n                // Find the last node we put on the stack\n                node = nodeStack.peek();\n\n                // If the right child of the node has either been visited or\n                // is null, we visit this node\n                if (node.right == null || node.right == lastVisited) {\n                    // We assume the left and right heights are 0\n                    int leftHeight = 0;\n                    int rightHeight = 0;\n\n                    // If the right and left children are not null, we must\n                    // have already explored them and have a height\n                    // for them so let's get that\n                    if (node.left != null) {\n                        leftHeight = subtreeHeights.get(node.left);\n                    }\n\n                    if (node.right != null) {\n                        rightHeight = subtreeHeights.get(node.right);\n                    }\n\n                    // If the difference in the height of the right subtree\n                    // and left subtree differs by more than 1, we cannot be\n                    // balanced\n                    if (Math.abs(rightHeight - leftHeight) > 1) {\n                        isBalanced = false;\n                    }\n\n                    // The height of the subtree containing this node is the\n                    // max of the left and right subtree heighs plus 1\n                    subtreeHeights.put(\n                        node,\n                        Math.max(rightHeight, leftHeight) + 1\n                    );\n\n                    // We've now visited this node, so we pop it from the stack\n                    nodeStack.pop();\n                    lastVisited = node;\n\n                    // Current visiting node is now null\n                    node = null;\n                    // If the right child node of this node has not been visited\n                    // and is not null, we need to get that child node on the stack\n                } else {\n                    node = node.right;\n                }\n            }\n        }\n\n        // Return whether or not the tree is balanced\n        return isBalanced;\n    }\n\n    /**\n     * Generates the following unbalanced binary tree for testing 0 / \\ / \\ 0 0\n     * / / \\ / / \\ 0 0 0 / \\ / \\ 0 0 / / 0\n     */\n    private BinaryTree buildUnbalancedTree() {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new BTNode(0);\n\n        BTNode root = tree.root;\n        root.left = new BTNode(0);\n        root.right = new BTNode(0);\n\n        BTNode left = root.left;\n        BTNode right = root.right;\n\n        left.left = new BTNode(0);\n        right.left = new BTNode(0);\n        right.right = new BTNode(0);\n        right.left.right = new BTNode(0);\n\n        left = left.left;\n        left.left = new BTNode(0);\n        left.left.left = new BTNode(0);\n        left.left.left.left = new BTNode(0);\n\n        return tree;\n    }\n\n    /**\n     * Generates the following balanced binary tree for testing 0 / \\ / \\ 0 0 /\n     * \\ / \\ / 0 / \\ 0 0 0 / / / / 0 0\n     */\n    private BinaryTree buildBalancedTree() {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new BTNode(0);\n\n        BTNode root = tree.root;\n        root.left = new BTNode(0);\n        root.right = new BTNode(0);\n\n        BTNode left = root.left;\n        BTNode right = root.right;\n\n        left.left = new BTNode(0);\n        left.right = new BTNode(0);\n        right.left = new BTNode(0);\n        right.right = new BTNode(0);\n\n        right.right.left = new BTNode(0);\n\n        left.left.left = new BTNode(0);\n\n        return tree;\n    }\n\n    /**\n     * Main\n     */\n    public static void main(String[] args) {\n        // We create a new object to check the binary trees for balance\n        CheckIfBinaryTreeBalanced balanceCheck = new CheckIfBinaryTreeBalanced();\n\n        // Build a balanced and unbalanced binary tree\n        BinaryTree balancedTree = balanceCheck.buildBalancedTree();\n        BinaryTree unbalancedTree = balanceCheck.buildUnbalancedTree();\n\n        // Run basic tests on the algorithms to check for balance\n        boolean isBalancedRB = balanceCheck.isBalancedRecursive(balancedTree); // true\n        boolean isBalancedRU = balanceCheck.isBalancedRecursive(unbalancedTree); // false\n        boolean isBalancedIB = balanceCheck.isBalancedIterative(balancedTree); // true\n        boolean isBalancedIU = balanceCheck.isBalancedIterative(unbalancedTree); // false\n\n        // Print the results\n        System.out.println(\"isBalancedRB: \" + isBalancedRB);\n        System.out.println(\"isBalancedRU: \" + isBalancedRU);\n        System.out.println(\"isBalancedIB: \" + isBalancedIB);\n        System.out.println(\"isBalancedIU: \" + isBalancedIU);\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * This class will check if a BinaryTree is balanced. A balanced binary tree is\n * defined as a binary tree where the differenced in height between the left and\n * right subtree of each node differs by at most one.\n *\n * This can be done in both an iterative and recursive fashion. Below,\n * `isBalancedRecursive()` is implemented in a recursive fashion, and\n * `isBalancedIterative()` is implemented in an iterative fashion.\n *\n * @author [Ian Cowan](https://github.com/iccowan)\n */\npublic class CheckIfBinaryTreeBalanced {\n\n    /**\n     * This class implements the BinaryTree for these algorithms\n     */\n    class BinaryTree {\n\n        /**\n         * The root node of the binary tree\n         */\n        BTNode root = null;\n    }\n\n    /**\n     * This class implements the nodes for the binary tree\n     */\n    class BTNode {\n\n        /**\n         * The value of the node\n         */\n        int value;\n\n        /**\n         * The left child of the node\n         */\n        BTNode left = null;\n\n        /**\n         * The right child of the node\n         */\n        BTNode right = null;\n\n        /**\n         * Constructor\n         */\n        BTNode(int value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * Recursive is BT balanced implementation\n     *\n     * @param binaryTree The binary tree to check if balanced\n     */\n    public boolean isBalancedRecursive(BinaryTree binaryTree) {\n        // Create an array of length 1 to keep track of our balance\n        // Default to true. We use an array so we have an efficient mutable object\n        boolean[] isBalanced = new boolean[1];\n        isBalanced[0] = true;\n\n        // Check for balance and return whether or not we are balanced\n        isBalancedRecursive(binaryTree.root, 0, isBalanced);\n        return isBalanced[0];\n    }\n\n    /**\n     * Private helper method to keep track of the depth and balance during\n     * recursion. We effectively perform a modified post-order traversal where\n     * we are looking at the heights of both children of each node in the tree\n     *\n     * @param node The current node to explore\n     * @param depth The current depth of the node\n     * @param isBalanced The array of length 1 keeping track of our balance\n     */\n    private int isBalancedRecursive(BTNode node, int depth, boolean[] isBalanced) {\n        // If the node is null, we should not explore it and the height is 0\n        // If the tree is already not balanced, might as well stop because we\n        // can't make it balanced now!\n        if (node == null || !isBalanced[0]) {\n            return 0;\n        }\n\n        // Visit the left and right children, incrementing their depths by 1\n        int leftHeight = isBalancedRecursive(node.left, depth + 1, isBalanced);\n        int rightHeight = isBalancedRecursive(node.right, depth + 1, isBalanced);\n\n        // If the height of either of the left or right subtrees differ by more\n        // than 1, we cannot be balanced\n        if (Math.abs(leftHeight - rightHeight) > 1) {\n            isBalanced[0] = false;\n        }\n\n        // The height of our tree is the maximum of the heights of the left\n        // and right subtrees plus one\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n\n    /**\n     * Iterative is BT balanced implementation\n     */\n    public boolean isBalancedIterative(BinaryTree binaryTree) {\n        // Default that we are balanced and our algo will prove it wrong\n        boolean isBalanced = true;\n\n        // Create a stack for our post order traversal\n        Stack<BTNode> nodeStack = new Stack<BTNode>();\n\n        // For post order traversal, we'll have to keep track of where we\n        // visited last\n        BTNode lastVisited = null;\n\n        // Create a HashMap to keep track of the subtree heights for each node\n        HashMap<BTNode, Integer> subtreeHeights = new HashMap<BTNode, Integer>();\n\n        // We begin at the root of the tree\n        BTNode node = binaryTree.root;\n\n        // We loop while:\n        // - the node stack is empty and the node we explore is null\n        // AND\n        // - the tree is still balanced\n        while (!(nodeStack.isEmpty() && node == null) && isBalanced) {\n            // If the node is not null, we push it to the stack and continue\n            // to the left\n            if (node != null) {\n                nodeStack.push(node);\n                node = node.left;\n                // Once we hit a node that is null, we are as deep as we can go\n                // to the left\n            } else {\n                // Find the last node we put on the stack\n                node = nodeStack.peek();\n\n                // If the right child of the node has either been visited or\n                // is null, we visit this node\n                if (node.right == null || node.right == lastVisited) {\n                    // We assume the left and right heights are 0\n                    int leftHeight = 0;\n                    int rightHeight = 0;\n\n                    // If the right and left children are not null, we must\n                    // have already explored them and have a height\n                    // for them so let's get that\n                    if (node.left != null) {\n                        leftHeight = subtreeHeights.get(node.left);\n                    }\n\n                    if (node.right != null) {\n                        rightHeight = subtreeHeights.get(node.right);\n                    }\n\n                    // If the difference in the height of the right subtree\n                    // and left subtree differs by more than 1, we cannot be\n                    // balanced\n                    if (Math.abs(rightHeight - leftHeight) > 1) {\n                        isBalanced = false;\n                    }\n\n                    // The height of the subtree containing this node is the\n                    // max of the left and right subtree heighs plus 1\n                    subtreeHeights.put(node, Math.max(rightHeight, leftHeight) + 1);\n\n                    // We've now visited this node, so we pop it from the stack\n                    nodeStack.pop();\n                    lastVisited = node;\n\n                    // Current visiting node is now null\n                    node = null;\n                    // If the right child node of this node has not been visited\n                    // and is not null, we need to get that child node on the stack\n                } else {\n                    node = node.right;\n                }\n            }\n        }\n\n        // Return whether or not the tree is balanced\n        return isBalanced;\n    }\n\n    /**\n     * Generates the following unbalanced binary tree for testing 0 / \\ / \\ 0 0\n     * / / \\ / / \\ 0 0 0 / \\ / \\ 0 0 / / 0\n     */\n    private BinaryTree buildUnbalancedTree() {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new BTNode(0);\n\n        BTNode root = tree.root;\n        root.left = new BTNode(0);\n        root.right = new BTNode(0);\n\n        BTNode left = root.left;\n        BTNode right = root.right;\n\n        left.left = new BTNode(0);\n        right.left = new BTNode(0);\n        right.right = new BTNode(0);\n        right.left.right = new BTNode(0);\n\n        left = left.left;\n        left.left = new BTNode(0);\n        left.left.left = new BTNode(0);\n        left.left.left.left = new BTNode(0);\n\n        return tree;\n    }\n\n    /**\n     * Generates the following balanced binary tree for testing 0 / \\ / \\ 0 0 /\n     * \\ / \\ / 0 / \\ 0 0 0 / / / / 0 0\n     */\n    private BinaryTree buildBalancedTree() {\n        BinaryTree tree = new BinaryTree();\n        tree.root = new BTNode(0);\n\n        BTNode root = tree.root;\n        root.left = new BTNode(0);\n        root.right = new BTNode(0);\n\n        BTNode left = root.left;\n        BTNode right = root.right;\n\n        left.left = new BTNode(0);\n        left.right = new BTNode(0);\n        right.left = new BTNode(0);\n        right.right = new BTNode(0);\n\n        right.right.left = new BTNode(0);\n\n        left.left.left = new BTNode(0);\n\n        return tree;\n    }\n\n    /**\n     * Main\n     */\n    public static void main(String[] args) {\n        // We create a new object to check the binary trees for balance\n        CheckIfBinaryTreeBalanced balanceCheck = new CheckIfBinaryTreeBalanced();\n\n        // Build a balanced and unbalanced binary tree\n        BinaryTree balancedTree = balanceCheck.buildBalancedTree();\n        BinaryTree unbalancedTree = balanceCheck.buildUnbalancedTree();\n\n        // Run basic tests on the algorithms to check for balance\n        boolean isBalancedRB = balanceCheck.isBalancedRecursive(balancedTree); // true\n        boolean isBalancedRU = balanceCheck.isBalancedRecursive(unbalancedTree); // false\n        boolean isBalancedIB = balanceCheck.isBalancedIterative(balancedTree); // true\n        boolean isBalancedIU = balanceCheck.isBalancedIterative(unbalancedTree); // false\n\n        // Print the results\n        System.out.println(\"isBalancedRB: \" + isBalancedRB);\n        System.out.println(\"isBalancedRU: \" + isBalancedRU);\n        System.out.println(\"isBalancedIB: \" + isBalancedIB);\n        System.out.println(\"isBalancedIU: \" + isBalancedIU);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Test check both implemented ways, iterative and recursive algorithms.\n *\n * @author Albina Gimaletdinova on 26/06/2023\n */\npublic class CheckIfBinaryTreeBalancedTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(null));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {Integer.MIN_VALUE});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n     9    <-- Math.abs(height(left) - height(right)) == 0\n    / \\\n   7   13\n  /\\   / \\\n 3  8 10 20\n*/\n    @Test\n    public void testBinaryTreeIsBalancedEqualSubtreeHeights() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n     9    <-- Math.abs(height(left) - height(right)) == 1\n    / \\\n   7   13\n  /\\\n 3  8\n*/\n    @Test\n    public void testBinaryTreeIsBalancedWithDifferentHeights() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8});\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertTrue(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n         9  <-- only left tree exists, Math.abs(height(left) - height(right)) > 1\n        /\n       7\n      /\\\n     3  8\n    */\n    @Test\n    public void testBinaryTreeNotBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, null, 3, 8});\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n\n    /*\n         9    <-- Math.abs(height(left) - height(right)) > 1\n        / \\\n       7   13\n      /\\\n     3  8\n    /\n   11\n*/\n    @Test\n    public void testBinaryTreeNotBalancedBecauseLeftTreeNotBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] {9, 7, 13, 3, 8, null, null, 11});\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedRecursive(root));\n        assertFalse(CheckIfBinaryTreeBalanced.isBalancedIterative(root));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "05ca93eace893a75e886a19739778a67bd3a18bc",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Area.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AreaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    /**\n     * String of IllegalArgumentException for radius\n     */\n    private static final String POSITIVE_RADIUS = \"Must be a positive radius\";\n\n    /**\n     * String of IllegalArgumentException for height\n     */\n    private static final String POSITIVE_HEIGHT = \"Must be a positive height\";\n\n    /**\n     * String of IllegalArgumentException for base\n     */\n    private static final String POSITIVE_BASE = \"Must be a positive base\";\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    public static double surfaceAreaCube(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    public static double surfaceAreaSphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle.\n     *\n     * @param length length of a rectangle\n     * @param width  width of a rectangle\n     * @return area of given rectangle\n     */\n    public static double surfaceAreaRectangle(final double length, final double width) {\n        if (length <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive length\");\n        }\n        if (width <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive width\");\n        }\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder.\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    public static double surfaceAreaCylinder(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square.\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    public static double surfaceAreaSquare(final double sideLength) {\n        if (sideLength <= 0) {\n            throw new IllegalArgumentException(\"Must be a positive sideLength\");\n        }\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle.\n     *\n     * @param base   base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    public static double surfaceAreaTriangleRectangle(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram.\n     *\n     * @param base   base of a parallelogram\n     * @param height height of a parallelogram\n     * @return area of given parallelogram\n     */\n    public static double surfaceAreaParallelogram(final double base, final double height) {\n        if (base <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium.\n     *\n     * @param base1  upper base of trapezium\n     * @param base2  bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    public static double surfaceAreaTrapezium(\n        final double base1, final double base2, final double height) {\n        if (base1 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 1);\n        }\n        if (base2 <= 0) {\n            throw new IllegalArgumentException(POSITIVE_BASE + 2);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle.\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    public static double surfaceAreaCircle(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    public static double surfaceAreaHemisphere(final double radius) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    public static double surfaceAreaCone(final double radius, final double height) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(POSITIVE_RADIUS);\n        }\n        if (height <= 0) {\n            throw new IllegalArgumentException(POSITIVE_HEIGHT);\n        }\n        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(()\n                      -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(()\n                      -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangle(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangle(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n            ()\n                -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n            () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)), () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1)));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "7a3273ae1db2a652b80a4b655e642f06331937cb",
        "product_file_path": "src/main/java/com/thealgorithms/others/SieveOfEratosthenes.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/SieveOfEratosthenesTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers\n * up to any given limit.\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Wiki</a>\n */\npublic class SieveOfEratosthenes {\n\n    /**\n     * Finds all prime numbers till n.\n     *\n     * @param n The number till which we have to check for primes. Should be more than 1.\n     * @return Array of all prime numbers between 0 to n.\n     */\n    public static int[] findPrimesTill(int n) {\n        Type[] numbers = new Type[n + 1];\n        Arrays.fill(numbers, Type.PRIME);\n        numbers[0] = numbers[1] = Type.NOT_PRIME;\n\n        double cap = Math.sqrt(n);\n        for (int i = 2; i <= cap; i++) {\n            if (numbers[i] == Type.PRIME) {\n                for (int j = 2; i * j <= n; j++) {\n                    numbers[i * j] = Type.NOT_PRIME;\n                }\n            }\n        }\n\n        int primesCount = (int) Arrays\n            .stream(numbers)\n            .filter(element -> element == Type.PRIME)\n            .count();\n        int[] primes = new int[primesCount];\n\n        int primeIndex = 0;\n        for (int i = 0; i < n + 1; i++) {\n            if (numbers[i] == Type.PRIME) {\n                primes[primeIndex++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    private enum Type {\n        PRIME,\n        NOT_PRIME,\n    }\n\n    public static void main(String[] args) {\n        int n = 100;\n        System.out.println(\"Searching for all primes from zero to \" + n);\n        int[] primes = findPrimesTill(n);\n        System.out.println(\"Found: \" + Arrays.toString(primes));\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Arrays;\n\n/**\n * Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers\n * up to any given limit.\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Wiki</a>\n */\npublic class SieveOfEratosthenes {\n\n    /**\n     * Finds all prime numbers till n.\n     *\n     * @param n The number till which we have to check for primes. Should be more than 1.\n     * @return Array of all prime numbers between 0 to n.\n     */\n    public static int[] findPrimesTill(int n) {\n        Type[] numbers = new Type[n + 1];\n        Arrays.fill(numbers, Type.PRIME);\n        numbers[0] = numbers[1] = Type.NOT_PRIME;\n\n        double cap = Math.sqrt(n);\n        for (int i = 2; i <= cap; i++) {\n            if (numbers[i] == Type.PRIME) {\n                for (int j = 2; i * j <= n; j++) {\n                    numbers[i * j] = Type.NOT_PRIME;\n                }\n            }\n        }\n\n        int primesCount\n            = (int) Arrays.stream(numbers).filter(element -> element == Type.PRIME).count();\n        int[] primes = new int[primesCount];\n\n        int primeIndex = 0;\n        for (int i = 0; i < n + 1; i++) {\n            if (numbers[i] == Type.PRIME) {\n                primes[primeIndex++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    private enum Type {\n        PRIME,\n        NOT_PRIME,\n    }\n\n    public static void main(String[] args) {\n        int n = 100;\n        System.out.println(\"Searching for all primes from zero to \" + n);\n        int[] primes = findPrimesTill(n);\n        System.out.println(\"Found: \" + Arrays.toString(primes));\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass SieveOfEratosthenesTest {\n    @Test\n    public void testfFindPrimesTill1() {\n        assertArrayEquals(new int[] {}, SieveOfEratosthenes.findPrimesTill(1));\n    }\n\n    @Test\n    public void testfFindPrimesTill2() {\n        assertArrayEquals(new int[] {2}, SieveOfEratosthenes.findPrimesTill(2));\n    }\n\n    @Test\n    public void testfFindPrimesTill4() {\n        var primesTill4 = new int[] {2, 3};\n        assertArrayEquals(primesTill4, SieveOfEratosthenes.findPrimesTill(3));\n        assertArrayEquals(primesTill4, SieveOfEratosthenes.findPrimesTill(4));\n    }\n\n    @Test\n    public void testfFindPrimesTill40() {\n        var primesTill40 = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(37));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(38));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(39));\n        assertArrayEquals(primesTill40, SieveOfEratosthenes.findPrimesTill(40));\n    }\n\n    @Test\n    public void testfFindPrimesTill240() {\n        var primesTill240 = new int[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239};\n        assertArrayEquals(primesTill240, SieveOfEratosthenes.findPrimesTill(239));\n        assertArrayEquals(primesTill240, SieveOfEratosthenes.findPrimesTill(240));\n    }\n\n    @Test\n    public void testFindPrimesTillThrowsExceptionForNonPositiveInput() {\n        assertThrows(IllegalArgumentException.class, () -> SieveOfEratosthenes.findPrimesTill(0));\n    }\n}"
    },
    {
        "product_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "test_commit": "63739f493368b76d1b426a30deb2de06e9a9cd7e",
        "product_file_path": "src/main/java/com/thealgorithms/others/cn/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/cn/HammingDistanceTest.java",
        "product_old_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n    public int getHammingDistanceBetweenBits(\n        String senderBits,\n        String receiverBits\n    ) {\n        if (senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\n                \"Sender and Receiver bits should be same\"\n            );\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < senderData.length; i++) {\n            totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if (totalErrorBitCount == 0) {\n            System.out.println(\"No Error bit in data segments\");\n        } else {\n            System.out.println(\"Total Error bit count \" + totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n    public int getHammingDistanceBetweenBits(String senderBits, String receiverBits) {\n        if (senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\"Sender and Receiver bits should be same\");\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for (int i = 0; i < senderData.length; i++) {\n            totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if (totalErrorBitCount == 0) {\n            System.out.println(\"No Error bit in data segments\");\n        } else {\n            System.out.println(\"Total Error bit count \" + totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n    void initialize() {\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits() {\n        String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n}",
        "test_new_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n    @Test\n    public void checkForDifferentBits() {\n        int answer = HammingDistance.compute(\"000\", \"011\");\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        int answer = HammingDistance.compute(\"10101\", \"11110\");\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String someBits = \"111\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        int answer = HammingDistance.compute(\"10010101101010000100110100\", \"00110100001011001100110101\");\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"100010\", \"00011\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void mismatchDataBits2() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"1\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must have the same length\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String someBits = \"10010101101010000100110100\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForEmptyInput() {\n        String someBits = \"\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForInputOfLength1() {\n        String someBits = \"0\";\n        int answer = HammingDistance.compute(someBits, someBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void computeThrowsExceptionWhenInputsAreNotBitStrs() {\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () -> { int answer = HammingDistance.compute(\"1A\", \"11\"); });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"must be a binary string\");\n    }\n}"
    },
    {
        "product_commit": "ad03086f547854a4c00b1e3a85dde5d315f119b6",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/CountWords.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/CountWordsTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\n\n/**\n * You enter a string into this program, and it will return how many words were\n * in that particular string\n *\n * @author Marcus\n */\npublic class CountWords {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Enter your text: \");\n        String str = input.nextLine();\n\n        System.out.println(\"Your text has \" + wordCount(str) + \" word(s)\");\n        System.out.println(\n            \"Your text has \" + secondaryWordCount(str) + \" word(s)\"\n        );\n        input.close();\n    }\n\n    private static int wordCount(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        return s.trim().split(\"[\\\\s]+\").length;\n    }\n\n    /**\n     * counts the number of words in a sentence but ignores all potential\n     * non-alphanumeric characters that do not represent a word. runs in O(n)\n     * where n is the length of s\n     *\n     * @param s String: sentence with word(s)\n     * @return int: number of words\n     */\n    private static int secondaryWordCount(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c) || Character.isDigit(c)) {\n                sb.append(c);\n            }\n        }\n        s = sb.toString();\n        return s.trim().split(\"[\\\\s]+\").length;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\n\n/**\n * @author Marcus\n */\nfinal public class CountWords {\n    private CountWords() {\n    }\n\n    /**\n     * @brief counts the number of words in the input string\n     * @param s the input string\n     * @return the number of words in the input string\n     */\n    public static int wordCount(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        return s.trim().split(\"[\\\\s]+\").length;\n    }\n\n    private static String removeSpecialCharacters(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isLetterOrDigit(c) || Character.isWhitespace(c)) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * counts the number of words in a sentence but ignores all potential\n     * non-alphanumeric characters that do not represent a word. runs in O(n)\n     * where n is the length of s\n     *\n     * @param s String: sentence with word(s)\n     * @return int: number of words\n     */\n    public static int secondaryWordCount(String s) {\n        if (s == null) {\n            return 0;\n        }\n        return wordCount(removeSpecialCharacters(s));\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\n\nclass CountWordsTest {\n    @Test\n    public void testWordCount() {\n        HashMap<String, Integer> testCases = new HashMap<>();\n        testCases.put(\"\", 0);\n        testCases.put(null, 0);\n        testCases.put(\"aaaa bbb cccc\", 3);\n        testCases.put(\"note  extra     spaces   here\", 4);\n        testCases.put(\" a  b c d  e    \", 5);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(CountWords.wordCount(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testSecondaryWordCount() {\n        HashMap<String, Integer> testCases = new HashMap<>();\n        testCases.put(\"\", 0);\n        testCases.put(null, 0);\n        testCases.put(\"aaaa bbb cccc\", 3);\n        testCases.put(\"this-is-one-word!\", 1);\n        testCases.put(\"What, about, this? Hmmm----strange\", 4);\n        testCases.put(\"word1 word-2 word-3- w?o,r.d.@!@#$&*()<>4\", 4);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(CountWords.secondaryWordCount(tc.getKey()), tc.getValue());\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\nclass CountWordsTest {\n    @Test\n    public void testWordCount() {\n        HashMap<String, Integer> testCases = new HashMap<>();\n        testCases.put(\"\", 0);\n        testCases.put(null, 0);\n        testCases.put(\"aaaa bbb cccc\", 3);\n        testCases.put(\"note  extra     spaces   here\", 4);\n        testCases.put(\" a  b c d  e    \", 5);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(CountWords.wordCount(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testSecondaryWordCount() {\n        HashMap<String, Integer> testCases = new HashMap<>();\n        testCases.put(\"\", 0);\n        testCases.put(null, 0);\n        testCases.put(\"aaaa bbb cccc\", 3);\n        testCases.put(\"this-is-one-word!\", 1);\n        testCases.put(\"What, about, this? Hmmm----strange\", 4);\n        testCases.put(\"word1 word-2 word-3- w?o,r.d.@!@#$&*()<>4\", 4);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(CountWords.secondaryWordCount(tc.getKey()), tc.getValue());\n        }\n    }\n}"
    },
    {
        "product_commit": "22002c9939fdeff1d7ef659a688ad7f396dd564a",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/NthUglyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/NthUglyNumberTest.java",
        "product_old_content": "// Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, \u2026 shows the first 11 ugly numbers.\n// By convention, 1 is included.\n// A program to find the nth Ugly number\n// Algorithm :\n// Initialize three-pointers two, three, and five pointing to zero.\n// Take 3 variables nm2, nm3, and nm5 to keep track of next multiple of 2,3 and 5.\n// Make an array of size n to store the ugly numbers with 1 at 0th index.\n// Initialize a variable next which stores the value of the last element in the array.\n// Run a loop n-1 times and perform steps 6,7 and 8.\n// Update the values of nm2, nm3, nm5 as ugly[two]*2, ugly[three]*3, ugly[5]*5 respectively.\n// Select the minimum value from nm2, nm3, and nm5 and increment the pointer related to it.\n// Store the minimum value in variable next and array.\n// Return next.\npackage com.thealgorithms.maths;\n\nimport java.util.*;\n\nclass NthUglyNumber {\n\n    /* Function to get the nth ugly number*/\n    public long getNthUglyNo(int n) {\n        long[] ugly = new long[n];\n        int two = 0, three = 0, five = 0;\n        long nm2 = 2, nm3 = 3, nm5 = 5;\n        long next = 1;\n\n        ugly[0] = 1;\n\n        for (int i = 1; i < n; i++) {\n            next = Math.min(nm2, Math.min(nm3, nm5));\n\n            ugly[i] = next;\n            if (next == nm2) {\n                two = two + 1;\n                nm2 = ugly[two] * 2;\n            }\n            if (next == nm3) {\n                three = three + 1;\n                nm3 = ugly[three] * 3;\n            }\n            if (next == nm5) {\n                five = five + 1;\n                nm5 = ugly[five] * 5;\n            }\n        }\n        return next;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the value of n : \");\n        int n = sc.nextInt();\n        NthUglyNumber ob = new NthUglyNumber();\n        long ugly = ob.getNthUglyNo(n);\n        System.out.println(\"nth Ugly number is : \" + ugly);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.lang.IllegalArgumentException;\n\n\n/**\n * @brief class computing the n-th ugly number (when they are sorted)\n * @details the ugly numbers with base [2, 3, 5] are all numbers of the form 2^a*3^b^5^c,\n *   where the exponents a, b, c are non-negative integers.\n *   Some properties of ugly numbers:\n *     - base [2, 3, 5] ugly numbers are the 5-smooth numbers, cf. https://oeis.org/A051037\n *     - base [2, 3, 5, 7] ugly numbers are 7-smooth numbers, cf. https://oeis.org/A002473\n *     - base [2] ugly numbers are the non-negative powers of 2,\n *     - the base [2, 3, 5] ugly numbers are the same as base [5, 6, 2, 3, 5] ugly numbers\n */\npublic class NthUglyNumber {\n    ArrayList<Long> uglyNumbers = new ArrayList<>(Arrays.asList(1L));\n    final int[] baseNumbers;\n    HashMap<Integer, Integer> positions = new HashMap<>();\n\n    /**\n     * @brief initialized the object allowing to compute ugly numbers with given base\n     * @param baseNumbers the given base of ugly numbers\n     * @exception IllegalArgumentException baseNumber is empty\n     */\n    NthUglyNumber(int[] baseNumbers) {\n        if (baseNumbers.length == 0) {\n            throw new IllegalArgumentException(\"baseNumbers must be non-empty.\");\n        }\n\n        this.baseNumbers = baseNumbers;\n        for (final var baseNumber : baseNumbers) {\n            this.positions.put(baseNumber, 0);\n        }\n    }\n\n    /**\n     * @param n the zero-based-index of the queried ugly number\n     * @exception IllegalArgumentException n is negative\n     * @return the n-th ugly number (starting from index 0)\n     */\n    public Long get(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative.\");\n        }\n\n        while (uglyNumbers.size() <= n) {\n            addUglyNumber();\n        }\n\n        return uglyNumbers.get(n);\n    }\n\n    private void addUglyNumber() {\n        uglyNumbers.add(computeMinimalCandidate());\n        updatePositions();\n    }\n\n    private void updatePositions() {\n        final var lastUglyNumber = uglyNumbers.get(uglyNumbers.size() - 1);\n        for (final var baseNumber : baseNumbers) {\n            if (computeCandidate(baseNumber) == lastUglyNumber) {\n                positions.put(baseNumber, positions.get(baseNumber) + 1);\n            }\n        }\n    }\n\n    private long computeCandidate(int candidateBase) {\n        return candidateBase * uglyNumbers.get(positions.get(candidateBase));\n    }\n\n    private long computeMinimalCandidate() {\n        long res = Long.MAX_VALUE;\n        for (final var baseNumber : baseNumbers) {\n            res = Math.min(res, computeCandidate(baseNumber));\n        }\n        return res;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\n\nimport org.junit.jupiter.api.Test;\n\npublic class NthUglyNumberTest {\n    @Test\n    public void testGetWithNewObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(9, 12L);\n        testCases.put(19, 36L);\n        testCases.put(52, 270L);\n        testCases.put(1078, 84934656L);\n        testCases.put(1963, 6973568802L);\n\n        for (final var tc : testCases.entrySet()) {\n            var uglyNumbers = new NthUglyNumber(new int[] {2, 3, 5});\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n\n            var otherUglyNumbers = new NthUglyNumber(new int[] {5, 25, 6, 2, 3, 5});\n            assertEquals(otherUglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testGetWithSameObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(6, 7L);\n        testCases.put(1499, 1984500L);\n        testCases.put(1572, 2449440L);\n        testCases.put(1658, 3072000L);\n        testCases.put(6625, 4300800000L);\n\n        var uglyNumbers = new NthUglyNumber(new int[] {7, 2, 5, 3});\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n        \n        assertEquals(uglyNumbers.get(999), 385875);\n    }\n\n    @Test\n    public void testGetWithBase1() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1});\n        assertEquals(uglyNumbers.get(10), 1);\n    }\n\n    @Test\n    public void testGetWithBase2() {\n        var uglyNumbers = new NthUglyNumber(new int[] {2});\n        assertEquals(uglyNumbers.get(5), 32);\n    }\n\n\n    @Test\n    public void testGetThrowsAnErrorForNegativeInput() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1, 2});\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> uglyNumbers.get(-1)\n        );\n    }\n\n    @Test\n    public void testConstructorThrowsAnErrorForEmptyInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> new NthUglyNumber(new int[] {})\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\npublic class NthUglyNumberTest {\n    @Test\n    public void testGetWithNewObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(9, 12L);\n        testCases.put(19, 36L);\n        testCases.put(52, 270L);\n        testCases.put(1078, 84934656L);\n        testCases.put(1963, 6973568802L);\n\n        for (final var tc : testCases.entrySet()) {\n            var uglyNumbers = new NthUglyNumber(new int[] {2, 3, 5});\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n\n            var otherUglyNumbers = new NthUglyNumber(new int[] {5, 25, 6, 2, 3, 5});\n            assertEquals(otherUglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testGetWithSameObject() {\n        HashMap<Integer, Long> testCases = new HashMap<>();\n        testCases.put(0, 1L);\n        testCases.put(1, 2L);\n        testCases.put(2, 3L);\n        testCases.put(3, 4L);\n        testCases.put(4, 5L);\n        testCases.put(5, 6L);\n        testCases.put(6, 7L);\n        testCases.put(1499, 1984500L);\n        testCases.put(1572, 2449440L);\n        testCases.put(1658, 3072000L);\n        testCases.put(6625, 4300800000L);\n\n        var uglyNumbers = new NthUglyNumber(new int[] {7, 2, 5, 3});\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(uglyNumbers.get(tc.getKey()), tc.getValue());\n        }\n\n        assertEquals(uglyNumbers.get(999), 385875);\n    }\n\n    @Test\n    public void testGetWithBase1() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1});\n        assertEquals(uglyNumbers.get(10), 1);\n    }\n\n    @Test\n    public void testGetWithBase2() {\n        var uglyNumbers = new NthUglyNumber(new int[] {2});\n        assertEquals(uglyNumbers.get(5), 32);\n    }\n\n    @Test\n    public void testGetThrowsAnErrorForNegativeInput() {\n        var uglyNumbers = new NthUglyNumber(new int[] {1, 2});\n        assertThrows(IllegalArgumentException.class, () -> uglyNumbers.get(-1));\n    }\n\n    @Test\n    public void testConstructorThrowsAnErrorForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> new NthUglyNumber(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "4bbc4bd69f2a68963ba733df744c6ea356aba109",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/ReverseNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/ReverseNumberTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.lang.IllegalStateException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class ReverseNumber {\n\n    public static void main(String[] args) {\n        int number;\n        int reverse = 0;\n\n        try (Scanner sc = new Scanner(System.in)) {\n            System.out.println(\"Enter a number:\");\n            number = sc.nextInt();\n        } catch (NoSuchElementException | IllegalStateException e) {\n            System.out.println(\"ERROR: Invalid input\");\n            return;\n        }\n\n        while (number != 0) {\n            int remainder = number % 10;\n\n            reverse = reverse * 10 + remainder;\n            number = number / 10;\n        }\n\n        System.out.println(\"The reverse of the given number is: \" + reverse);\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.lang.IllegalArgumentException;\n\n/**\n * @brief utility class reversing numbers\n */\nfinal public class ReverseNumber {\n    private ReverseNumber() {\n    }\n\n    /**\n     * @brief reverses the input number\n     * @param number the input number\n     * @exception IllegalArgumentException number is negative\n     * @return the number created by reversing the order of digits of the input number\n     */\n    public static int reverseNumber(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"number must be nonnegative.\");\n        }\n\n        int result = 0;\n        while (number > 0) {\n            result *= 10;\n            result += number % 10;\n            number /= 10;\n        }\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ReverseNumberTest {\n\n    @Test\n    public void testReverseNumber() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 0);\n        testCases.put(1, 1);\n        testCases.put(10, 1);\n        testCases.put(123, 321);\n        testCases.put(7890, 987);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(ReverseNumber.reverseNumber(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testReverseNumberThrowsExceptionForNegativeInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> ReverseNumber.reverseNumber(-1)\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\npublic class ReverseNumberTest {\n\n    @Test\n    public void testReverseNumber() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 0);\n        testCases.put(1, 1);\n        testCases.put(10, 1);\n        testCases.put(123, 321);\n        testCases.put(7890, 987);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(ReverseNumber.reverseNumber(tc.getKey()), tc.getValue());\n        }\n    }\n\n    @Test\n    public void testReverseNumberThrowsExceptionForNegativeInput() {\n        assertThrows(IllegalArgumentException.class, () -> ReverseNumber.reverseNumber(-1));\n    }\n}"
    },
    {
        "product_commit": "5d7a59654fc4394162b69ee220c6c079c71a039b",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/others/LowestBasePalindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/LowestBasePalindromeTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\n/**\n * Class for finding the lowest base in which a given integer is a palindrome.\n * Includes auxiliary methods for converting between bases and reversing\n * strings.\n *\n * <p>\n * NOTE: There is potential for error, see note at line 63.\n *\n * @author RollandMichael\n * @version 2017.09.28\n */\npublic class LowestBasePalindrome {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = 0;\n        while (true) {\n            try {\n                System.out.print(\"Enter number: \");\n                n = in.nextInt();\n                break;\n            } catch (InputMismatchException e) {\n                System.out.println(\"Invalid input!\");\n                in.next();\n            }\n        }\n        System.out.println(\n            n + \" is a palindrome in base \" + lowestBasePalindrome(n)\n        );\n        System.out.println(\n            base2base(Integer.toString(n), 10, lowestBasePalindrome(n))\n        );\n        in.close();\n    }\n\n    /**\n     * Given a number in base 10, returns the lowest base in which the number is\n     * represented by a palindrome (read the same left-to-right and\n     * right-to-left).\n     *\n     * @param num A number in base 10.\n     * @return The lowest base in which num is a palindrome.\n     */\n    public static int lowestBasePalindrome(int num) {\n        int base, num2 = num;\n        int digit;\n        char digitC;\n        boolean foundBase = false;\n        String newNum = \"\";\n        String digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n        while (!foundBase) {\n            // Try from bases 2 to num-1\n            for (base = 2; base < num2; base++) {\n                newNum = \"\";\n                while (num > 0) {\n                    // Obtain the first digit of n in the current base,\n                    // which is equivalent to the integer remainder of (n/base).\n                    // The next digit is obtained by dividing n by the base and\n                    // continuing the process of getting the remainder. This is done\n                    // until n is <=0 and the number in the new base is obtained.\n                    digit = (num % base);\n                    num /= base;\n                    // If the digit isn't in the set of [0-9][A-Z] (beyond base 36), its character\n                    // form is just its value in ASCII.\n\n                    // NOTE: This may cause problems, as the capital letters are ASCII values\n                    // 65-90. It may cause false positives when one digit is, for instance 10 and assigned\n                    // 'A' from the character array and the other is 65 and also assigned 'A'.\n                    // Regardless, the character is added to the representation of n\n                    // in the current base.\n                    if (digit >= digits.length()) {\n                        digitC = (char) (digit);\n                        newNum += digitC;\n                        continue;\n                    }\n                    newNum += digits.charAt(digit);\n                }\n                // Num is assigned back its original value for the next iteration.\n                num = num2;\n                // Auxiliary method reverses the number.\n                String reverse = reverse(newNum);\n                // If the number is read the same as its reverse, then it is a palindrome.\n                // The current base is returned.\n                if (reverse.equals(newNum)) {\n                    foundBase = true;\n                    return base;\n                }\n            }\n        }\n        // If all else fails, n is always a palindrome in base n-1. (\"11\")\n        return num - 1;\n    }\n\n    private static String reverse(String str) {\n        String reverse = \"\";\n        for (int i = str.length() - 1; i >= 0; i--) {\n            reverse += str.charAt(i);\n        }\n        return reverse;\n    }\n\n    private static String base2base(String n, int b1, int b2) {\n        // Declare variables: decimal value of n,\n        // character of base b1, character of base b2,\n        // and the string that will be returned.\n        int decimalValue = 0, charB2;\n        char charB1;\n        String output = \"\";\n        // Go through every character of n\n        for (int i = 0; i < n.length(); i++) {\n            // store the character in charB1\n            charB1 = n.charAt(i);\n            // if it is a non-number, convert it to a decimal value >9 and store it in charB2\n            if (charB1 >= 'A' && charB1 <= 'Z') {\n                charB2 = 10 + (charB1 - 'A');\n            } // Else, store the integer value in charB2\n            else {\n                charB2 = charB1 - '0';\n            }\n            // Convert the digit to decimal and add it to the\n            // decimalValue of n\n            decimalValue = decimalValue * b1 + charB2;\n        }\n\n        // Converting the decimal value to base b2:\n        // A number is converted from decimal to another base\n        // by continuously dividing by the base and recording\n        // the remainder until the quotient is zero. The number in the\n        // new base is the remainders, with the last remainder\n        // being the left-most digit.\n        // While the quotient is NOT zero:\n        while (decimalValue != 0) {\n            // If the remainder is a digit < 10, simply add it to\n            // the left side of the new number.\n            if (decimalValue % b2 < 10) {\n                output = decimalValue % b2 + output;\n            } // If the remainder is >= 10, add a character with the\n            // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)\n            else {\n                output = (char) ((decimalValue % b2) + 55) + output;\n            }\n            // Divide by the new base again\n            decimalValue /= b2;\n        }\n        return output;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @brief Class for finding the lowest base in which a given integer is a palindrome.\n     cf. https://oeis.org/A016026\n */\nfinal public class LowestBasePalindrome {\n    private LowestBasePalindrome() {\n    }\n\n    private static void checkBase(int base) {\n        if (base <= 1) {\n            throw new IllegalArgumentException(\"base must be greater than 1.\");\n        }\n    }\n\n    private static void checkNumber(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"number must be nonnegative.\");\n        }\n    }\n\n    /**\n     * @brief computes the representation of the input number in given base\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return the list containing the digits of the input number in the given base, the most significant digit is at the end of the array\n     */\n    public static ArrayList<Integer> computeDigitsInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n        var result = new ArrayList<Integer>();\n        while (number > 0) {\n            result.add(number % base);\n            number /= base;\n        }\n        return result;\n    }\n\n    /**\n     * @brief checks if the input array is a palindrome\n     * @brief list the input array\n     * @return true, if the input array is a palindrome, false otherwise\n     */\n    public static boolean isPalindromic(ArrayList<Integer> list) {\n        for (int pos = 0; pos < list.size()/2; ++pos) {\n            if(list.get(pos) != list.get(list.size()-1-pos)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @brief checks if representation of the input number in given base is a palindrome\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return true, if the input number represented in the given base is a palindrome, false otherwise\n     */\n    public static boolean isPalindromicInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n\n        if (number <= 1) {\n            return true;\n        }\n\n        if (number % base == 0) {\n            // the last digit of number written in base is 0\n            return false;\n        }\n\n        return isPalindromic(computeDigitsInBase(number, base));\n    }\n\n    /**\n     * @brief finds the smallest base for which the representation of the input number is a palindrome\n     * @param number the input number\n     * @exception IllegalArgumentException number is negative\n     * @return the smallest base for which the representation of the input number is a palindrome\n     */\n    public static int lowestBasePalindrome(int number) {\n        int base = 2;\n        while(!isPalindromicInBase(number, base)) {\n            ++base;\n        }\n        return base;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.HashMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LowestBasePalindromeTest {\n    @Test\n    public void testIsPalindromicPositive() {\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>()));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 2, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2))));\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicInBasePositive() {\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(1, 190));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(0, 11));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(10101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(23, 22));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(1010, 10));\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(123, 10));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForNegativeNumbers() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> LowestBasePalindrome.isPalindromicInBase(-1, 5)\n        );\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForWrongBases() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> LowestBasePalindrome.isPalindromicInBase(10, 1)\n        );\n    }\n\n    @Test\n    public void testLowestBasePalindrome() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 2);\n        testCases.put(1, 2);\n        testCases.put(2, 3);\n        testCases.put(3, 2);\n        testCases.put(10, 3);\n        testCases.put(11, 10);\n        testCases.put(15, 2);\n        testCases.put(39, 12);\n        testCases.put(44, 10);\n        testCases.put(58, 28);\n        testCases.put(69, 22);\n        testCases.put(79, 78);\n        testCases.put(87, 28);\n        testCases.put(90, 14);\n        testCases.put(5591, 37);\n        testCases.put(5895, 130);\n        testCases.put(9950, 198);\n        testCases.put(9974, 4986);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(LowestBasePalindrome.lowestBasePalindrome(tc.getKey()), tc.getValue());\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\npublic class LowestBasePalindromeTest {\n    @Test\n    public void testIsPalindromicPositive() {\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>()));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 1))));\n        assertTrue(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1))));\n        assertTrue(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 2, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicNegative() {\n        assertFalse(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2))));\n        assertFalse(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicInBasePositive() {\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(1, 190));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(0, 11));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(10101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(23, 22));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(1010, 10));\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(123, 10));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForNegativeNumbers() {\n        assertThrows(\n            IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(-1, 5));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForWrongBases() {\n        assertThrows(\n            IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(10, 1));\n    }\n\n    @Test\n    public void testLowestBasePalindrome() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 2);\n        testCases.put(1, 2);\n        testCases.put(2, 3);\n        testCases.put(3, 2);\n        testCases.put(10, 3);\n        testCases.put(11, 10);\n        testCases.put(15, 2);\n        testCases.put(39, 12);\n        testCases.put(44, 10);\n        testCases.put(58, 28);\n        testCases.put(69, 22);\n        testCases.put(79, 78);\n        testCases.put(87, 28);\n        testCases.put(90, 14);\n        testCases.put(5591, 37);\n        testCases.put(5895, 130);\n        testCases.put(9950, 198);\n        testCases.put(9974, 4986);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(LowestBasePalindrome.lowestBasePalindrome(tc.getKey()), tc.getValue());\n        }\n    }\n}"
    },
    {
        "product_commit": "5d7a59654fc4394162b69ee220c6c079c71a039b",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/others/LowestBasePalindrome.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/LowestBasePalindromeTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\n/**\n * Class for finding the lowest base in which a given integer is a palindrome.\n * Includes auxiliary methods for converting between bases and reversing\n * strings.\n *\n * <p>\n * NOTE: There is potential for error, see note at line 63.\n *\n * @author RollandMichael\n * @version 2017.09.28\n */\npublic class LowestBasePalindrome {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = 0;\n        while (true) {\n            try {\n                System.out.print(\"Enter number: \");\n                n = in.nextInt();\n                break;\n            } catch (InputMismatchException e) {\n                System.out.println(\"Invalid input!\");\n                in.next();\n            }\n        }\n        System.out.println(\n            n + \" is a palindrome in base \" + lowestBasePalindrome(n)\n        );\n        System.out.println(\n            base2base(Integer.toString(n), 10, lowestBasePalindrome(n))\n        );\n        in.close();\n    }\n\n    /**\n     * Given a number in base 10, returns the lowest base in which the number is\n     * represented by a palindrome (read the same left-to-right and\n     * right-to-left).\n     *\n     * @param num A number in base 10.\n     * @return The lowest base in which num is a palindrome.\n     */\n    public static int lowestBasePalindrome(int num) {\n        int base, num2 = num;\n        int digit;\n        char digitC;\n        boolean foundBase = false;\n        String newNum = \"\";\n        String digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n        while (!foundBase) {\n            // Try from bases 2 to num-1\n            for (base = 2; base < num2; base++) {\n                newNum = \"\";\n                while (num > 0) {\n                    // Obtain the first digit of n in the current base,\n                    // which is equivalent to the integer remainder of (n/base).\n                    // The next digit is obtained by dividing n by the base and\n                    // continuing the process of getting the remainder. This is done\n                    // until n is <=0 and the number in the new base is obtained.\n                    digit = (num % base);\n                    num /= base;\n                    // If the digit isn't in the set of [0-9][A-Z] (beyond base 36), its character\n                    // form is just its value in ASCII.\n\n                    // NOTE: This may cause problems, as the capital letters are ASCII values\n                    // 65-90. It may cause false positives when one digit is, for instance 10 and assigned\n                    // 'A' from the character array and the other is 65 and also assigned 'A'.\n                    // Regardless, the character is added to the representation of n\n                    // in the current base.\n                    if (digit >= digits.length()) {\n                        digitC = (char) (digit);\n                        newNum += digitC;\n                        continue;\n                    }\n                    newNum += digits.charAt(digit);\n                }\n                // Num is assigned back its original value for the next iteration.\n                num = num2;\n                // Auxiliary method reverses the number.\n                String reverse = reverse(newNum);\n                // If the number is read the same as its reverse, then it is a palindrome.\n                // The current base is returned.\n                if (reverse.equals(newNum)) {\n                    foundBase = true;\n                    return base;\n                }\n            }\n        }\n        // If all else fails, n is always a palindrome in base n-1. (\"11\")\n        return num - 1;\n    }\n\n    private static String reverse(String str) {\n        String reverse = \"\";\n        for (int i = str.length() - 1; i >= 0; i--) {\n            reverse += str.charAt(i);\n        }\n        return reverse;\n    }\n\n    private static String base2base(String n, int b1, int b2) {\n        // Declare variables: decimal value of n,\n        // character of base b1, character of base b2,\n        // and the string that will be returned.\n        int decimalValue = 0, charB2;\n        char charB1;\n        String output = \"\";\n        // Go through every character of n\n        for (int i = 0; i < n.length(); i++) {\n            // store the character in charB1\n            charB1 = n.charAt(i);\n            // if it is a non-number, convert it to a decimal value >9 and store it in charB2\n            if (charB1 >= 'A' && charB1 <= 'Z') {\n                charB2 = 10 + (charB1 - 'A');\n            } // Else, store the integer value in charB2\n            else {\n                charB2 = charB1 - '0';\n            }\n            // Convert the digit to decimal and add it to the\n            // decimalValue of n\n            decimalValue = decimalValue * b1 + charB2;\n        }\n\n        // Converting the decimal value to base b2:\n        // A number is converted from decimal to another base\n        // by continuously dividing by the base and recording\n        // the remainder until the quotient is zero. The number in the\n        // new base is the remainders, with the last remainder\n        // being the left-most digit.\n        // While the quotient is NOT zero:\n        while (decimalValue != 0) {\n            // If the remainder is a digit < 10, simply add it to\n            // the left side of the new number.\n            if (decimalValue % b2 < 10) {\n                output = decimalValue % b2 + output;\n            } // If the remainder is >= 10, add a character with the\n            // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)\n            else {\n                output = (char) ((decimalValue % b2) + 55) + output;\n            }\n            // Divide by the new base again\n            decimalValue /= b2;\n        }\n        return output;\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.ArrayList;\n\n/**\n * @brief Class for finding the lowest base in which a given integer is a palindrome.\n     cf. https://oeis.org/A016026\n */\nfinal public class LowestBasePalindrome {\n    private LowestBasePalindrome() {\n    }\n\n    private static void checkBase(int base) {\n        if (base <= 1) {\n            throw new IllegalArgumentException(\"base must be greater than 1.\");\n        }\n    }\n\n    private static void checkNumber(int number) {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"number must be nonnegative.\");\n        }\n    }\n\n    /**\n     * @brief computes the representation of the input number in given base\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return the list containing the digits of the input number in the given base, the most significant digit is at the end of the array\n     */\n    public static ArrayList<Integer> computeDigitsInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n        var result = new ArrayList<Integer>();\n        while (number > 0) {\n            result.add(number % base);\n            number /= base;\n        }\n        return result;\n    }\n\n    /**\n     * @brief checks if the input array is a palindrome\n     * @brief list the input array\n     * @return true, if the input array is a palindrome, false otherwise\n     */\n    public static boolean isPalindromic(ArrayList<Integer> list) {\n        for (int pos = 0; pos < list.size()/2; ++pos) {\n            if(list.get(pos) != list.get(list.size()-1-pos)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @brief checks if representation of the input number in given base is a palindrome\n     * @param number the input number\n     * @param base the given base\n     * @exception IllegalArgumentException number is negative or base is less than 2\n     * @return true, if the input number represented in the given base is a palindrome, false otherwise\n     */\n    public static boolean isPalindromicInBase(int number, int base) {\n        checkNumber(number);\n        checkBase(base);\n\n        if (number <= 1) {\n            return true;\n        }\n\n        if (number % base == 0) {\n            // the last digit of number written in base is 0\n            return false;\n        }\n\n        return isPalindromic(computeDigitsInBase(number, base));\n    }\n\n    /**\n     * @brief finds the smallest base for which the representation of the input number is a palindrome\n     * @param number the input number\n     * @exception IllegalArgumentException number is negative\n     * @return the smallest base for which the representation of the input number is a palindrome\n     */\n    public static int lowestBasePalindrome(int number) {\n        int base = 2;\n        while(!isPalindromicInBase(number, base)) {\n            ++base;\n        }\n        return base;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\npublic class LowestBasePalindromeTest {\n    @Test\n    public void testIsPalindromicPositive() {\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>()));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 1))));\n        assertTrue(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1))));\n        assertTrue(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 2, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicNegative() {\n        assertFalse(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2))));\n        assertFalse(\n            LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicInBasePositive() {\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(1, 190));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(0, 11));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(10101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(23, 22));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(1010, 10));\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(123, 10));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForNegativeNumbers() {\n        assertThrows(\n            IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(-1, 5));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForWrongBases() {\n        assertThrows(\n            IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(10, 1));\n    }\n\n    @Test\n    public void testLowestBasePalindrome() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 2);\n        testCases.put(1, 2);\n        testCases.put(2, 3);\n        testCases.put(3, 2);\n        testCases.put(10, 3);\n        testCases.put(11, 10);\n        testCases.put(15, 2);\n        testCases.put(39, 12);\n        testCases.put(44, 10);\n        testCases.put(58, 28);\n        testCases.put(69, 22);\n        testCases.put(79, 78);\n        testCases.put(87, 28);\n        testCases.put(90, 14);\n        testCases.put(5591, 37);\n        testCases.put(5895, 130);\n        testCases.put(9950, 198);\n        testCases.put(9974, 4986);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(LowestBasePalindrome.lowestBasePalindrome(tc.getKey()), tc.getValue());\n        }\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport org.junit.jupiter.api.Test;\n\npublic class LowestBasePalindromeTest {\n    @Test\n    public void testIsPalindromicPositive() {\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>()));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1))));\n        assertTrue(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 2, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2))));\n        assertFalse(LowestBasePalindrome.isPalindromic(new ArrayList<Integer>(Arrays.asList(1, 2, 1, 1))));\n    }\n\n    @Test\n    public void testIsPalindromicInBasePositive() {\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(1, 190));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(0, 11));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(10101, 10));\n        assertTrue(LowestBasePalindrome.isPalindromicInBase(23, 22));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseNegative() {\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(1010, 10));\n        assertFalse(LowestBasePalindrome.isPalindromicInBase(123, 10));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForNegativeNumbers() {\n        assertThrows(IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(-1, 5));\n    }\n\n    @Test\n    public void testIsPalindromicInBaseThrowsExceptionForWrongBases() {\n        assertThrows(IllegalArgumentException.class, () -> LowestBasePalindrome.isPalindromicInBase(10, 1));\n    }\n\n    @Test\n    public void testLowestBasePalindrome() {\n        HashMap<Integer, Integer> testCases = new HashMap<>();\n        testCases.put(0, 2);\n        testCases.put(1, 2);\n        testCases.put(2, 3);\n        testCases.put(3, 2);\n        testCases.put(10, 3);\n        testCases.put(11, 10);\n        testCases.put(15, 2);\n        testCases.put(39, 12);\n        testCases.put(44, 10);\n        testCases.put(58, 28);\n        testCases.put(69, 22);\n        testCases.put(79, 78);\n        testCases.put(87, 28);\n        testCases.put(90, 14);\n        testCases.put(5591, 37);\n        testCases.put(5895, 130);\n        testCases.put(9950, 198);\n        testCases.put(9974, 4986);\n\n        for (final var tc : testCases.entrySet()) {\n            assertEquals(LowestBasePalindrome.lowestBasePalindrome(tc.getKey()), tc.getValue());\n        }\n    }\n}"
    },
    {
        "product_commit": "96c1a96647c947f8f0c531ade3bc18967359e0ea",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMax.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMaxTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * find max of array\n     *\n     * @param array the array contains element\n     * @return max value of given array\n     */\n    public static int findMax(int[] array) {\n        int max = array[0];\n        for (int i = 1; i < array.length; ++i) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).max().getAsInt() == findMax(array);\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int max = Integer.MIN_VALUE;\n        for (final var value : array) {\n            if (value > max) {\n                max = value;\n            }\n        }\n        return max;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMaxTest {\n\n    @Test\n    public void testFindMax0() {\n        assertEquals(\n            10,\n            FindMax.findMax(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })\n        );\n    }\n\n    @Test\n    public void testFindMax1() {\n        assertEquals(\n            7,\n            FindMax.findMax(new int[] { 6, 3, 5, 1, 7, 4, 1 })\n        );\n    }\n\n    @Test\n    public void testFindMax2() {\n        assertEquals(\n            10,\n            FindMax.findMax(new int[] { 10, 0 })\n        );\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> FindMax.findMax(new int[]{})\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMaxTest {\n\n    @Test\n    public void testFindMax0() {\n        assertEquals(10, FindMax.findMax(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    }\n\n    @Test\n    public void testFindMax1() {\n        assertEquals(7, FindMax.findMax(new int[] {6, 3, 5, 1, 7, 4, 1}));\n    }\n\n    @Test\n    public void testFindMax2() {\n        assertEquals(10, FindMax.findMax(new int[] {10, 0}));\n    }\n\n    @Test\n    public void testFindMaxThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMax.findMax(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "4f1514980495c4daaae2eb060228a87e14cbae11",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FindMin.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FindMinTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * Find the minimum number of an array of numbers.\n     *\n     * @param array the array contains element\n     * @return min value\n     */\n    public static int findMin(int[] array) {\n        int min = array[0];\n        for (int i = 1; i < array.length; ++i) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Random random = new Random();\n\n        /* random size */\n        int size = random.nextInt(100) + 1;\n        int[] array = new int[size];\n\n        /* init array with random numbers */\n        for (int i = 0; i < size; i++) {\n            array[i] = random.nextInt() % 100;\n        }\n\n        assert Arrays.stream(array).min().getAsInt() == findMin(array);\n    }\n\n    /**\n     * @brief finds the minimum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the mimum value stored in the input array\n     */\n    public static int findMin(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException(\"array must be non-empty.\");\n        }\n        int min = Integer.MAX_VALUE;\n        for (final var value : array) {\n            if (value < min) {\n                min = value;\n            }\n        }\n        return min;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMinTest {\n\n    @Test\n    public void testFindMinValue() {\n        assertEquals(\n            1,\n            FindMin.findMin(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 })\n        );\n    }\n\n    @Test\n    public void test1() {\n        assertEquals(1, FindMin.findMin(new int[] { 1, 3, 5, 7, 9 }));\n    }\n\n    @Test\n    public void test2() {\n        assertEquals(0, FindMin.findMin(new int[] { 0, 192, 384, 576 }));\n    }\n\n    @Test\n    public void test3() {\n        assertEquals(0, FindMin.findMin(new int[] { 10, 10, 0, 10 }));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> FindMin.findMin(new int[]{})\n        );\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\npublic class FindMinTest {\n\n    @Test\n    public void testFindMinValue() {\n        assertEquals(1, FindMin.findMin(new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}));\n    }\n\n    @Test\n    public void test1() {\n        assertEquals(1, FindMin.findMin(new int[] {1, 3, 5, 7, 9}));\n    }\n\n    @Test\n    public void test2() {\n        assertEquals(0, FindMin.findMin(new int[] {0, 192, 384, 576}));\n    }\n\n    @Test\n    public void test3() {\n        assertEquals(0, FindMin.findMin(new int[] {10, 10, 0, 10}));\n    }\n\n    @Test\n    public void testFindMinThrowsExceptionForEmptyInput() {\n        assertThrows(IllegalArgumentException.class, () -> FindMin.findMin(new int[] {}));\n    }\n}"
    },
    {
        "product_commit": "e14b30b88c0de95186fe1937f795b7d8fd3fa8aa",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/maths/GCD.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GCDTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * get greatest common divisor in array\n     *\n     * @param number contains number\n     * @return gcd\n     */\n    public static int gcd(int[] number) {\n        int result = number[0];\n        for (int i = 1; i < number.length; i++) { // call gcd function (input two value)\n            result = gcd(result, number[i]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * @brief computes gcd of an array of numbers\n     *\n     * @param numbers the input array\n     * @return gcd of all of the numbers in the input array\n     */\n    public static int gcd(int[] numbers) {\n        int result = 0;\n        for (final var number : numbers) {\n            result = gcd(result, number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-1, 0)\n        );\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(10, -2)\n        );\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(\n            ArithmeticException.class,\n            () -> GCD.gcd(-5, -3)\n        );\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n    \n    @Test\n    void testArrayGcd1() {\n        Assertions.assertEquals(GCD.gcd(new int[]{9, 6}), 3);\n    }\n\n    @Test\n    void testArrayGcd2() {\n        Assertions.assertEquals(GCD.gcd(new int[]{2*3*5*7, 2*5*5*5, 2*5*11, 5*5*5*13}), 5);\n    }\n    \n    @Test\n    void testArrayGcdForEmptyInput() {\n        Assertions.assertEquals(GCD.gcd(new int[]{}), 0);\n    }    \n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-1, 0));\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(10, -2));\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-5, -3));\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n\n    @Test\n    void testArrayGcd1() {\n        Assertions.assertEquals(GCD.gcd(new int[] {9, 6}), 3);\n    }\n\n    @Test\n    void testArrayGcd2() {\n        Assertions.assertEquals(\n            GCD.gcd(new int[] {2 * 3 * 5 * 7, 2 * 5 * 5 * 5, 2 * 5 * 11, 5 * 5 * 5 * 13}), 5);\n    }\n\n    @Test\n    void testArrayGcdForEmptyInput() {\n        Assertions.assertEquals(GCD.gcd(new int[] {}), 0);\n    }\n}"
    },
    {
        "product_commit": "e14b30b88c0de95186fe1937f795b7d8fd3fa8aa",
        "test_commit": "415a04ea7f1eb3ca129bbaafc85323b24faccacf",
        "product_file_path": "src/main/java/com/thealgorithms/maths/GCD.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/GCDTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * get greatest common divisor in array\n     *\n     * @param number contains number\n     * @return gcd\n     */\n    public static int gcd(int[] number) {\n        int result = number[0];\n        for (int i = 1; i < number.length; i++) { // call gcd function (input two value)\n            result = gcd(result, number[i]);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common\n * denominator Overide function name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n    /**\n     * get greatest common divisor\n     *\n     * @param num1 the first number\n     * @param num2 the second number\n     * @return gcd\n     */\n    public static int gcd(int num1, int num2) {\n        if (num1 < 0 || num2 < 0) {\n            throw new ArithmeticException();\n        }\n\n        if (num1 == 0 || num2 == 0) {\n            return Math.abs(num1 - num2);\n        }\n\n        while (num1 % num2 != 0) {\n            int remainder = num1 % num2;\n            num1 = num2;\n            num2 = remainder;\n        }\n        return num2;\n    }\n\n    /**\n     * @brief computes gcd of an array of numbers\n     *\n     * @param numbers the input array\n     * @return gcd of all of the numbers in the input array\n     */\n    public static int gcd(int[] numbers) {\n        int result = 0;\n        for (final var number : numbers) {\n            result = gcd(result, number);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] myIntArray = { 4, 16, 32 };\n\n        // call gcd function (input array)\n        System.out.println(gcd(myIntArray)); // => 4\n        System.out.printf(\n            \"gcd(40,24)=%d gcd(24,40)=%d%n\",\n            gcd(40, 24),\n            gcd(24, 40)\n        ); // => 8\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-1, 0));\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(10, -2));\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-5, -3));\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n\n    @Test\n    void testArrayGcd1() {\n        Assertions.assertEquals(GCD.gcd(new int[] {9, 6}), 3);\n    }\n\n    @Test\n    void testArrayGcd2() {\n        Assertions.assertEquals(\n            GCD.gcd(new int[] {2 * 3 * 5 * 7, 2 * 5 * 5 * 5, 2 * 5 * 11, 5 * 5 * 5 * 13}), 5);\n    }\n\n    @Test\n    void testArrayGcdForEmptyInput() {\n        Assertions.assertEquals(GCD.gcd(new int[] {}), 0);\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class GCDTest {\n\n    @Test\n    void test1() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-1, 0));\n    }\n\n    @Test\n    void test2() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(10, -2));\n    }\n\n    @Test\n    void test3() {\n        Assertions.assertThrows(ArithmeticException.class, () -> GCD.gcd(-5, -3));\n    }\n\n    @Test\n    void test4() {\n        Assertions.assertEquals(GCD.gcd(0, 2), 2);\n    }\n\n    @Test\n    void test5() {\n        Assertions.assertEquals(GCD.gcd(10, 0), 10);\n    }\n\n    @Test\n    void test6() {\n        Assertions.assertEquals(GCD.gcd(1, 0), 1);\n    }\n\n    @Test\n    void test7() {\n        Assertions.assertEquals(GCD.gcd(9, 6), 3);\n    }\n\n    @Test\n    void testArrayGcd1() {\n        Assertions.assertEquals(GCD.gcd(new int[] {9, 6}), 3);\n    }\n\n    @Test\n    void testArrayGcd2() {\n        Assertions.assertEquals(GCD.gcd(new int[] {2 * 3 * 5 * 7, 2 * 5 * 5 * 5, 2 * 5 * 11, 5 * 5 * 5 * 13}), 5);\n    }\n\n    @Test\n    void testArrayGcdForEmptyInput() {\n        Assertions.assertEquals(GCD.gcd(new int[] {}), 0);\n    }\n}"
    },
    {
        "product_commit": "36232a8373264319cdb893bf9da1615fea05999d",
        "test_commit": "00282efd8becbd0612cc710f49bf21a562deb034",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/QuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DualPivotQuickSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(\n        T[] array,\n        int left,\n        int right\n    ) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Ramdomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(\n        T[] array,\n        int left,\n        int right\n    ) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Randomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = { 7 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 7 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = { 49, 4, 36, 9, 144, 1 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 4, 9, 36, 49, 144 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = { 49, -36, -124, -49, 12, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { -124, -49, -36, 9, 12, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = { 36, 1, 49, 1, 4, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 1, 4, 9, 36, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = { \"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\" };\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = { \"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\" };\n        assertArrayEquals(expected, sorted);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = {7};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = {49, -36, -124, -49, 12, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {-124, -49, -36, 9, 12, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = {\"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\"};\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = {\"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\"};\n        assertArrayEquals(expected, sorted);\n    }\n}"
    },
    {
        "product_commit": "ad72c28d91989460f61917b28545f4f33c2771d4",
        "test_commit": "1ce907625b65abe27fef450df9c645b5d71c383d",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SinglyLinkedListTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    Node reverseList(Node node) {\n        Node prevNode = head;\n        while (prevNode.next != node) {\n            prevNode = prevNode.next;\n        }\n        Node prev = null, curr = node, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        prevNode.next = prev;\n        return head;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (\n                    newHead.next != null && newHead.value == newHead.next.value\n                ) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list.toString());\n        /* Test search function */\n        assert list.search(10) &&\n        list.search(5) &&\n        list.search(1) &&\n        !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 &&\n        list.getNth(2) == 5 &&\n        list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list.toString());\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(\n            0,\n            new Node(2, new Node(3, new Node(3, new Node(4))))\n        );\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {}\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList extends Node {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list from a given node till the end\n     *\n     */\n    Node reverseList(Node node) {\n        Node prevNode = head;\n        while (prevNode.next != node) {\n            prevNode = prevNode.next;\n        }\n        Node prev = null, curr = node, next;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        prevNode.next = prev;\n        return head;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            Node prev = cur;\n            cur = cur.next;\n            prev = null; // clear to let GC do its work\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(int key) {\n        Node cur = head;\n        while (cur != null) {\n            if (cur.value == key) {\n                return true;\n            }\n            cur = cur.next;\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        Node cur = head;\n        while (cur != null) {\n            joiner.add(cur.value + \"\");\n            cur = cur.next;\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (\n                    newHead.next != null && newHead.value == newHead.next.value\n                ) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            Node destroy = head;\n            head = head.next;\n            destroy = null;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        Node destroy = cur.next;\n        cur.next = cur.next.next;\n        destroy = null; // clear to let GC do its work\n\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) &&\n        list.search(5) &&\n        list.search(1) &&\n        !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 &&\n        list.getNth(2) == 5 &&\n        list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(\n            0,\n            new Node(2, new Node(3, new Node(3, new Node(4))))\n        );\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {}\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i+1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        //List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode/2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode/2, list.middle().value);\n\n        //return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        //return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1,5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); //Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SinglyLinkedListTest {\n\n    /**\n     * Initialize a list with natural order values with pre-defined length\n     * @param length\n     * @return linked list with pre-defined number of nodes\n     */\n    private SinglyLinkedList createSampleList(int length) {\n        List<Node> nodeList = new ArrayList<>();\n        for (int i = 1; i <= length; i++) {\n            Node node = new Node(i);\n            nodeList.add(node);\n        }\n\n        for (int i = 0; i < length - 1; i++) {\n            nodeList.get(i).next = nodeList.get(i+1);\n        }\n\n        return new SinglyLinkedList(nodeList.get(0), length);\n    }\n\n    @Test\n    void detectLoop() {\n        //List has cycle\n        Node firstNode = new Node(1);\n        Node secondNode = new Node(2);\n        Node thirdNode = new Node(3);\n        Node fourthNode = new Node(4);\n\n        firstNode.next = secondNode;\n        secondNode.next = thirdNode;\n        thirdNode.next = fourthNode;\n        fourthNode.next = firstNode;\n\n        SinglyLinkedList listHasLoop = new SinglyLinkedList(firstNode, 4);\n        assertTrue(listHasLoop.detectLoop());\n\n        SinglyLinkedList listHasNoLoop = createSampleList(5);\n        assertFalse(listHasNoLoop.detectLoop());\n    }\n\n    @Test\n    void middle() {\n        int oddNumberOfNode = 7;\n        SinglyLinkedList list = createSampleList(oddNumberOfNode);\n        assertEquals(oddNumberOfNode/2 + 1, list.middle().value);\n        int evenNumberOfNode = 8;\n        list = createSampleList(evenNumberOfNode);\n        assertEquals(evenNumberOfNode/2, list.middle().value);\n\n        //return null if empty\n        list = new SinglyLinkedList();\n        assertNull(list.middle());\n\n        //return head if there is only one node\n        list = createSampleList(1);\n        assertEquals(list.getHead(), list.middle());\n    }\n\n    @Test\n    void swap() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(1, list.getHead().value);\n        assertEquals(5, list.getNth(4));\n        list.swapNodes(1,5);\n        assertEquals(5, list.getHead().value);\n        assertEquals(1, list.getNth(4));\n    }\n\n    @Test\n    void clear() {\n        SinglyLinkedList list = createSampleList(5);\n        assertEquals(5, list.size());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    void search() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(5));\n        assertFalse(list.search(20));\n    }\n\n    @Test\n    void deleteNth() {\n        SinglyLinkedList list = createSampleList(10);\n        assertTrue(list.search(7));\n        list.deleteNth(6); //Index 6 has value 7\n        assertFalse(list.search(7));\n    }\n    //Test to check whether the method reverseList() works fine\n    @Test\n    void reverseList(){\n\n        //Creating a new LinkedList of size:4\n        //The linkedlist will be 1->2->3->4->null\n        SinglyLinkedList list = createSampleList(4);\n          \n        //Reversing the LinkedList using reverseList() method and storing the head of the reversed linkedlist in a head node\n        //The reversed linkedlist will be 4->3->2->1->null\n        Node head=list.reverseList(list.getHead());\n\n        //Recording the Nodes after reversing the LinkedList\n        Node firstNode = head;              //4\n        Node secondNode = firstNode.next;   //3\n        Node thirdNode = secondNode.next;   //2\n        Node fourthNode = thirdNode.next;   //1\n        \n        //Checking whether the LinkedList is reversed or not by comparing the original list and reversed list nodes\n        assertEquals(1,fourthNode.value);\n        assertEquals(2,thirdNode.value);\n        assertEquals(3,secondNode.value);\n        assertEquals(4,firstNode.value);\n    }\n    \n    //Test to check whether implemented reverseList() method handles NullPointer Exception for TestCase where head==null\n    @Test\n    void reverseListNullPointer(){\n        //Creating a linkedlist with first node assigned to null\n        SinglyLinkedList list=new SinglyLinkedList();\n        Node first=list.getHead();\n        \n        //Reversing the linkedlist\n        Node head=list.reverseList(first);\n\n        //checking whether the method works fine if the input is null\n        assertEquals(head,first);\n    }\n\n    //Testing reverseList() method for a linkedlist of size: 20\n    @Test\n    void reverseListTest(){\n        //Creating a new linkedlist\n        SinglyLinkedList list = createSampleList(20);\n\n        //Reversing the LinkedList using reverseList() method and storing the head of the reversed linkedlist in a head node\n        Node head=list.reverseList(list.getHead());\n        \n        //Storing the head in a temp variable, so that we cannot loose the track of head\n        Node temp=head;\n\n        int i=20; //This is for the comparison of values of nodes of the reversed linkedlist\n        //Checking whether the reverseList() method performed its task\n        while(temp!=null && i>0){\n             assertEquals(i,temp.value);\n             temp=temp.next;\n             i--;\n        }\n    }\n\n}"
    },
    {
        "product_commit": "ad72c28d91989460f61917b28545f4f33c2771d4",
        "test_commit": "4c18e60671adebb2b8236024ad50f14367455e2a",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/CheckBinaryTreeIsValidBSTTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * This entire class is used to build a Binary Tree data structure. There is the\n * Node Class and the Tree Class, both explained below.\n */\n/**\n * A binary tree is a data structure in which an element has two\n * successors(children). The left child is usually smaller than the parent, and\n * the right child is usually bigger.\n *\n * @author Unknown\n */\npublic class BinaryTree {\n\n    /**\n     * This class implements the nodes that will go on the Binary Tree. They\n     * consist of the data in them, the node to the left, the node to the right,\n     * and the parent from which they came from.\n     *\n     * @author Unknown\n     */\n    static class Node {\n\n        /**\n         * Data for the node\n         */\n        public int data;\n        /**\n         * The Node to the left of this one\n         */\n        public Node left;\n        /**\n         * The Node to the right of this one\n         */\n        public Node right;\n        /**\n         * The parent of this node\n         */\n        public Node parent;\n\n        /**\n         * Constructor of Node\n         *\n         * @param value Value to put in the node\n         */\n        public Node(int value) {\n            data = value;\n            left = null;\n            right = null;\n            parent = null;\n        }\n    }\n\n    /**\n     * The root of the Binary Tree\n     */\n    private Node root;\n\n    /**\n     * Constructor\n     */\n    public BinaryTree() {\n        root = null;\n    }\n\n    /**\n     * Parameterized Constructor\n     */\n    public BinaryTree(Node root) {\n        this.root = root;\n    }\n\n    /**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */\n    public Node find(int key) {\n        Node current = root;\n        while (current != null) {\n            if (key < current.data) {\n                if (current.left == null) {\n                    return current; // The key isn't exist, returns the parent\n                }\n                current = current.left;\n            } else if (key > current.data) {\n                if (current.right == null) {\n                    return current;\n                }\n                current = current.right;\n            } else { // If you find the value return it\n                return current;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts certain value into the Binary Tree\n     *\n     * @param value Value to be inserted\n     */\n    public void put(int value) {\n        Node newNode = new Node(value);\n        if (root == null) {\n            root = newNode;\n        } else {\n            // This will return the soon to be parent of the value you're inserting\n            Node parent = find(value);\n\n            // This if/else assigns the new node to be either the left or right child of the parent\n            if (value < parent.data) {\n                parent.left = newNode;\n                parent.left.parent = parent;\n                return;\n            } else {\n                parent.right = newNode;\n                parent.right.parent = parent;\n                return;\n            }\n        }\n    }\n\n    /**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */\n    public boolean remove(int value) {\n        // temp is the node to be deleted\n        Node temp = find(value);\n\n        // If the value doesn't exist\n        if (temp.data != value) {\n            return false;\n        }\n\n        // No children\n        if (temp.right == null && temp.left == null) {\n            if (temp == root) {\n                root = null;\n            } // This if/else assigns the new node to be either the left or right child of the parent\n            else if (temp.parent.data < temp.data) {\n                temp.parent.right = null;\n            } else {\n                temp.parent.left = null;\n            }\n            return true;\n        } // Two children\n        else if (temp.left != null && temp.right != null) {\n            Node successor = findSuccessor(temp);\n\n            // The left tree of temp is made the left tree of the successor\n            successor.left = temp.left;\n            successor.left.parent = successor;\n\n            // If the successor has a right child, the child's grandparent is it's new parent\n            if (successor.parent != temp) {\n                if (successor.right != null) {\n                    successor.right.parent = successor.parent;\n                    successor.parent.left = successor.right;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                } else {\n                    successor.parent.left = null;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                }\n            }\n\n            if (temp == root) {\n                successor.parent = null;\n                root = successor;\n                return true;\n            } // If you're not deleting the root\n            else {\n                successor.parent = temp.parent;\n\n                // This if/else assigns the new node to be either the left or right child of the parent\n                if (temp.parent.data < temp.data) {\n                    temp.parent.right = successor;\n                } else {\n                    temp.parent.left = successor;\n                }\n                return true;\n            }\n        } // One child\n        else {\n            // If it has a right child\n            if (temp.right != null) {\n                if (temp == root) {\n                    root = temp.right;\n                    return true;\n                }\n\n                temp.right.parent = temp.parent;\n\n                // Assigns temp to left or right child\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.right;\n                } else {\n                    temp.parent.right = temp.right;\n                }\n                return true;\n            } // If it has a left child\n            else {\n                if (temp == root) {\n                    root = temp.left;\n                    return true;\n                }\n\n                temp.left.parent = temp.parent;\n\n                // Assigns temp to left or right side\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.left;\n                } else {\n                    temp.parent.right = temp.left;\n                }\n                return true;\n            }\n        }\n    }\n\n    /**\n     * This method finds the Successor to the Node given. Move right once and go\n     * left down the tree as far as you can\n     *\n     * @param n Node that you want to find the Successor of\n     * @return The Successor of the node\n     */\n    public Node findSuccessor(Node n) {\n        if (n.right == null) {\n            return n;\n        }\n        Node current = n.right;\n        Node parent = n.right;\n        while (current != null) {\n            parent = current;\n            current = current.left;\n        }\n        return parent;\n    }\n\n    /**\n     * Returns the root of the Binary Tree\n     *\n     * @return the root of the Binary Tree\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\n     * first search\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void inOrder(Node localRoot) {\n        if (localRoot != null) {\n            inOrder(localRoot.left);\n            System.out.print(localRoot.data + \" \");\n            inOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints root - leftChild - rightChild\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void preOrder(Node localRoot) {\n        if (localRoot != null) {\n            System.out.print(localRoot.data + \" \");\n            preOrder(localRoot.left);\n            preOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints rightChild - leftChild - root\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void postOrder(Node localRoot) {\n        if (localRoot != null) {\n            postOrder(localRoot.left);\n            postOrder(localRoot.right);\n            System.out.print(localRoot.data + \" \");\n        }\n    }\n\n    /**\n     * Prints the tree in a breadth first search order This is similar to\n     * pre-order traversal, but instead of being implemented with a stack (or\n     * recursion), it is implemented with a queue\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void bfs(Node localRoot) {\n        // Create a queue for the order of the nodes\n        Queue<Node> queue = new LinkedList<Node>();\n\n        // If the give root is null, then we don't add to the queue\n        // and won't do anything\n        if (localRoot != null) {\n            queue.add(localRoot);\n        }\n\n        // Continue until the queue is empty\n        while (!queue.isEmpty()) {\n            // Get the next node on the queue to visit\n            localRoot = queue.remove();\n\n            // Print the data from the node we are visiting\n            System.out.print(localRoot.data + \" \");\n\n            // Add the children to the queue if not null\n            if (localRoot.right != null) {\n                queue.add(localRoot.right);\n            }\n            if (localRoot.left != null) {\n                queue.add(localRoot.left);\n            }\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * This entire class is used to build a Binary Tree data structure. There is the\n * Node Class and the Tree Class, both explained below.\n */\n/**\n * A binary tree is a data structure in which an element has two\n * successors(children). The left child is usually smaller than the parent, and\n * the right child is usually bigger.\n *\n * @author Unknown\n */\npublic class BinaryTree {\n\n    /**\n     * This class implements the nodes that will go on the Binary Tree. They\n     * consist of the data in them, the node to the left, the node to the right,\n     * and the parent from which they came from.\n     *\n     * @author Unknown\n     */\n    static class Node {\n\n        /**\n         * Data for the node\n         */\n        public int data;\n        /**\n         * The Node to the left of this one\n         */\n        public Node left;\n        /**\n         * The Node to the right of this one\n         */\n        public Node right;\n        /**\n         * The parent of this node\n         */\n        public Node parent;\n\n        /**\n         * Constructor of Node\n         *\n         * @param value Value to put in the node\n         */\n        public Node(int value) {\n            data = value;\n            left = null;\n            right = null;\n            parent = null;\n        }\n    }\n\n    /**\n     * The root of the Binary Tree\n     */\n    private Node root;\n\n    /**\n     * Constructor\n     */\n    public BinaryTree() {\n        root = null;\n    }\n\n    /**\n     * Parameterized Constructor\n     */\n    public BinaryTree(Node root) {\n        this.root = root;\n    }\n\n    /**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */\n    public Node find(int key) {\n        Node current = root;\n        while (current != null) {\n            if (key < current.data) {\n                if (current.left == null) {\n                    return current; // The key isn't exist, returns the parent\n                }\n                current = current.left;\n            } else if (key > current.data) {\n                if (current.right == null) {\n                    return current;\n                }\n                current = current.right;\n            } else { // If you find the value return it\n                return current;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts certain value into the Binary Tree\n     *\n     * @param value Value to be inserted\n     */\n    public void put(int value) {\n        Node newNode = new Node(value);\n        if (root == null) {\n            root = newNode;\n        } else {\n            // This will return the soon to be parent of the value you're inserting\n            Node parent = find(value);\n\n            // This if/else assigns the new node to be either the left or right child of the parent\n            if (value < parent.data) {\n                parent.left = newNode;\n                parent.left.parent = parent;\n            } else {\n                parent.right = newNode;\n                parent.right.parent = parent;\n            }\n        }\n    }\n\n    /**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */\n    public boolean remove(int value) {\n        // temp is the node to be deleted\n        Node temp = find(value);\n\n        // If the value doesn't exist\n        if (temp.data != value) {\n            return false;\n        }\n\n        // No children\n        if (temp.right == null && temp.left == null) {\n            if (temp == root) {\n                root = null;\n            } // This if/else assigns the new node to be either the left or right child of the parent\n            else if (temp.parent.data < temp.data) {\n                temp.parent.right = null;\n            } else {\n                temp.parent.left = null;\n            }\n            return true;\n        } // Two children\n        else if (temp.left != null && temp.right != null) {\n            Node successor = findSuccessor(temp);\n\n            // The left tree of temp is made the left tree of the successor\n            successor.left = temp.left;\n            successor.left.parent = successor;\n\n            // If the successor has a right child, the child's grandparent is it's new parent\n            if (successor.parent != temp) {\n                if (successor.right != null) {\n                    successor.right.parent = successor.parent;\n                    successor.parent.left = successor.right;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                } else {\n                    successor.parent.left = null;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                }\n            }\n\n            if (temp == root) {\n                successor.parent = null;\n                root = successor;\n            } // If you're not deleting the root\n            else {\n                successor.parent = temp.parent;\n\n                // This if/else assigns the new node to be either the left or right child of the parent\n                if (temp.parent.data < temp.data) {\n                    temp.parent.right = successor;\n                } else {\n                    temp.parent.left = successor;\n                }\n            }\n            return true;\n        } // One child\n        else {\n            // If it has a right child\n            if (temp.right != null) {\n                if (temp == root) {\n                    root = temp.right;\n                    return true;\n                }\n\n                temp.right.parent = temp.parent;\n\n                // Assigns temp to left or right child\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.right;\n                } else {\n                    temp.parent.right = temp.right;\n                }\n            } // If it has a left child\n            else {\n                if (temp == root) {\n                    root = temp.left;\n                    return true;\n                }\n\n                temp.left.parent = temp.parent;\n\n                // Assigns temp to left or right side\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.left;\n                } else {\n                    temp.parent.right = temp.left;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * This method finds the Successor to the Node given. Move right once and go\n     * left down the tree as far as you can\n     *\n     * @param n Node that you want to find the Successor of\n     * @return The Successor of the node\n     */\n    public Node findSuccessor(Node n) {\n        if (n.right == null) {\n            return n;\n        }\n        Node current = n.right;\n        Node parent = n.right;\n        while (current != null) {\n            parent = current;\n            current = current.left;\n        }\n        return parent;\n    }\n\n    /**\n     * Returns the root of the Binary Tree\n     *\n     * @return the root of the Binary Tree\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\n     * first search\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void inOrder(Node localRoot) {\n        if (localRoot != null) {\n            inOrder(localRoot.left);\n            System.out.print(localRoot.data + \" \");\n            inOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints root - leftChild - rightChild\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void preOrder(Node localRoot) {\n        if (localRoot != null) {\n            System.out.print(localRoot.data + \" \");\n            preOrder(localRoot.left);\n            preOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints rightChild - leftChild - root\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void postOrder(Node localRoot) {\n        if (localRoot != null) {\n            postOrder(localRoot.left);\n            postOrder(localRoot.right);\n            System.out.print(localRoot.data + \" \");\n        }\n    }\n\n    /**\n     * Prints the tree in a breadth first search order This is similar to\n     * pre-order traversal, but instead of being implemented with a stack (or\n     * recursion), it is implemented with a queue\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void bfs(Node localRoot) {\n        // Create a queue for the order of the nodes\n        Queue<Node> queue = new LinkedList<Node>();\n\n        // If the give root is null, then we don't add to the queue\n        // and won't do anything\n        if (localRoot != null) {\n            queue.add(localRoot);\n        }\n\n        // Continue until the queue is empty\n        while (!queue.isEmpty()) {\n            // Get the next node on the queue to visit\n            localRoot = queue.remove();\n\n            // Print the data from the node we are visiting\n            System.out.print(localRoot.data + \" \");\n\n            // Add the children to the queue if not null\n            if (localRoot.right != null) {\n                queue.add(localRoot.right);\n            }\n            if (localRoot.left != null) {\n                queue.add(localRoot.left);\n            }\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class CheckBinaryTreeIsValidBSTTest {\n    @Test\n    public void testRootNull() {\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(null));\n    }\n\n    @Test\n    public void testOneNode() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{Integer.MIN_VALUE});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 20\n    */\n    @Test\n    public void testBinaryTreeIsBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 20});\n        assertTrue(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 13 <--- duplicated node\n    */\n    @Test\n    public void testBinaryTreeWithDuplicatedNodesIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 13});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n\n    /*\n         9\n        / \\\n       7   13\n      /\\   / \\\n     3  8 10 12 <---- violates BST rule, needs to be more than 13 (parent node)\n    */\n    @Test\n    public void testBinaryTreeIsNotBST() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{9, 7, 13, 3, 8, 10, 12});\n        assertFalse(CheckBinaryTreeIsValidBST.isBST(root));\n    }\n}"
    },
    {
        "product_commit": "ad72c28d91989460f61917b28545f4f33c2771d4",
        "test_commit": "1dc388653a3895fe51f464c5b0f140bb88216dc8",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/sortOrderAgnosticBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport static java.lang.String.format;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n        T array[],\n        T key,\n        int left,\n        int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.println(\n            format(\n                \"Should be found: %d. Found %d at index %d. An array length %d\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n            )\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.println(\n            format(\n                \"Found by system method at an index: %d. Is equal: %b\",\n                toCheck,\n                toCheck == atIndex\n            )\n        );\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n        T array[],\n        T key,\n        int left,\n        int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.printf(\n                \"Should be found: %d. Found %d at index %d. An array length %d%n\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.printf(\"Found by system method at an index: %d. Is equal: %b%n\", toCheck, toCheck == atIndex);\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int arr[] = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int arr[] = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class sortOrderAgnosticBinarySearchTest{\n\n    @Test\n    public void testAscending(){\n        int[] arr = {1,2,3,4,5};// for ascending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 1;\n        assertEquals(excepted,ans);\n    }\n\n    @Test\n    public void testDescending(){\n        int[] arr = {5,4,3,2,1};// for descending order.\n        int target = 2;\n        int ans=sortOrderAgnosticBinarySearch.find(arr, target);\n        int excepted = 3;\n        assertEquals(excepted,ans );\n    }\n\n}"
    },
    {
        "product_commit": "d565edc69abbd5ac44e80cabed36f7d4f2a158d5",
        "test_commit": "45923d68726e111fd1663ca7975c09b764cdbd34",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/trees/PreOrderTraversal.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/trees/PreOrderTraversalTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Given tree is traversed in a 'pre-order' way: ROOT -> LEFT -> RIGHT.\n * Below are given the recursive and iterative implementations.\n *\n * Complexities:\n * Recursive: O(n) - time, O(n) - space, where 'n' is the number of nodes in a tree.\n *\n * Iterative: O(n) - time, O(h) - space, where 'n' is the number of nodes in a tree\n * and 'h' is the height of a binary tree.\n * In the worst case 'h' can be O(n) if tree is completely unbalanced, for instance:\n * 5\n *  \\\n *   6\n *    \\\n *     7\n *      \\\n *       8\n *\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class PreOrderTraversal {\n    public static List<Integer> recursivePreOrder(BinaryTree.Node root) {\n        List<Integer> result = new ArrayList<>();\n        recursivePreOrder(root, result);\n        return result;\n    }\n\n    public static List<Integer> iterativePreOrder(BinaryTree.Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Deque<BinaryTree.Node> stack = new LinkedList<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            BinaryTree.Node node = stack.pop();\n            result.add(node.data);\n            if (node.right != null) stack.push(node.right);\n            if (node.left != null) stack.push(node.left);\n        }\n\n        return result;\n    }\n\n    private static void recursivePreOrder(BinaryTree.Node root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        result.add(root.data);\n        recursivePreOrder(root.left, result);\n        recursivePreOrder(root.right, result);\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class PreOrderTraversalTest {\n    @Test\n    public void testNullRoot() {\n        assertEquals(Collections.emptyList(), PreOrderTraversal.recursivePreOrder(null));\n        assertEquals(Collections.emptyList(), PreOrderTraversal.iterativePreOrder(null));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testRecursivePreOrder() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        assertEquals(List.of(1, 2, 4, 5, 3, 6, 7), PreOrderTraversal.recursivePreOrder(root));\n        assertEquals(List.of(1, 2, 4, 5, 3, 6, 7), PreOrderTraversal.iterativePreOrder(root));\n    }\n\n    /*\n         5\n          \\\n           6\n            \\\n             7\n              \\\n               8\n    */\n    @Test\n    public void testRecursivePreOrderNonBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{5, null, 6, null, 7, null, 8});\n        assertEquals(List.of(5, 6, 7, 8), PreOrderTraversal.recursivePreOrder(root));\n        assertEquals(List.of(5, 6, 7, 8), PreOrderTraversal.iterativePreOrder(root));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Albina Gimaletdinova on 17/02/2023\n */\npublic class PreOrderTraversalTest {\n    @Test\n    public void testNullRoot() {\n        assertEquals(Collections.emptyList(), PreOrderTraversal.recursivePreOrder(null));\n        assertEquals(Collections.emptyList(), PreOrderTraversal.iterativePreOrder(null));\n    }\n\n    /*\n         1\n        / \\\n       2   3\n      /\\   /\\\n     4  5 6  7\n    */\n    @Test\n    public void testRecursivePreOrder() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{1, 2, 3, 4, 5, 6, 7});\n        List<Integer> expected = List.of(1, 2, 4, 5, 3, 6, 7);\n\n        assertEquals(expected, PreOrderTraversal.recursivePreOrder(root));\n        assertEquals(expected, PreOrderTraversal.iterativePreOrder(root));\n    }\n\n    /*\n         5\n          \\\n           6\n            \\\n             7\n              \\\n               8\n    */\n    @Test\n    public void testRecursivePreOrderNonBalanced() {\n        final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[]{5, null, 6, null, 7, null, 8});\n        List<Integer> expected = List.of(5, 6, 7, 8);\n\n        assertEquals(expected, PreOrderTraversal.recursivePreOrder(root));\n        assertEquals(expected, PreOrderTraversal.iterativePreOrder(root));\n    }\n}"
    },
    {
        "product_commit": "58cf08f2fd1d144840f032a9c10df732a1eeb7ae",
        "test_commit": "72468cc707d72ff353efaeecd35b8615076f192a",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/InsertionSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/InsertionSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.less;\nimport static com.thealgorithms.sorts.SortUtils.print;\n\nclass InsertionSort implements SortAlgorithm {\n\n    /**\n     * Generic insertion sort algorithm in increasing order.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1; i < array.length; i++) {\n            T insertValue = array[i];\n            int j;\n            for (j = i - 1; j >= 0 && less(insertValue, array[j]); j--) {\n                array[j + 1] = array[j];\n            }\n            if (j != i - 1) {\n                array[j + 1] = insertValue;\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        Integer[] integers = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };\n        InsertionSort sort = new InsertionSort();\n        sort.sort(integers);\n        print(integers);\n        /* [1, 4, 6, 9, 12, 23, 54, 78, 231] */\n\n        String[] strings = { \"c\", \"a\", \"e\", \"b\", \"d\" };\n        sort.sort(strings);\n        print(strings);\n        /* [a, b, c, d, e] */\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport java.util.function.Function;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\nclass InsertionSort implements SortAlgorithm {\n\n    /**\n     * Generic insertion sort algorithm in increasing order.\n     *\n     * @param array the array to be sorted.\n     * @param <T>   the class of array.\n     * @return sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1; i < array.length; i++)\n            for (int j = i; j > 0 && less(array[j], array[j - 1]); j--)\n                swap(array, j, j - 1);\n        return array;\n    }\n\n    /**\n     * Sentinel sort is a function which on the first step finds the minimal element in the provided\n     * array and puts it to the zero position, such a trick gives us an ability to avoid redundant\n     * comparisons like `j > 0` and swaps (we can move elements on position right, until we find\n     * the right position for the chosen element) on further step.\n     *\n     * @param array the array to be sorted\n     * @param <T>   Generic type which extends Comparable interface.\n     * @return sorted array\n     */\n    public <T extends Comparable<T>> T[] sentinelSort(T[] array) {\n        int minElemIndex = 0;\n        int n = array.length;\n        if (n < 1)\n            return array;\n\n        // put the smallest element to the 0 position as a sentinel, which will allow us to avoid\n        // redundant comparisons like `j > 0` further\n        for (int i = 1; i < n; i++)\n            if (less(array[i], array[minElemIndex]))\n                minElemIndex = i;\n        swap(array, 0, minElemIndex);\n\n        for (int i = 2; i < n; i++) {\n            int j = i;\n            T currentValue = array[i];\n            while (less(currentValue, array[j - 1])) {\n                array[j] = array[j - 1];\n                j--;\n            }\n\n            array[j] = currentValue;\n        }\n\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        int size = 100_000;\n        Double[] randomArray = SortUtilsRandomGenerator.generateArray(size);\n        Double[] copyRandomArray = new Double[size];\n        System.arraycopy(randomArray, 0, copyRandomArray, 0, size);\n\n        InsertionSort insertionSort = new InsertionSort();\n        double insertionTime = measureApproxExecTime(insertionSort::sort, randomArray);\n        System.out.printf(\"Original insertion time: %5.2f  sec.\\n\", insertionTime);\n\n        double insertionSentinelTime = measureApproxExecTime(insertionSort::sentinelSort, copyRandomArray);\n        System.out.printf(\"Sentinel insertion time: %5.2f  sec.\\n\", insertionSentinelTime);\n\n        // ~ 1.5 time sentinel sort is faster, then classical Insertion sort implementation.\n        System.out.printf(\"Sentinel insertion is %f3.2 time faster than Original insertion sort\\n\",\n                insertionTime / insertionSentinelTime);\n    }\n\n    private static double measureApproxExecTime(Function<Double[], Double[]> sortAlgorithm, Double[] randomArray) {\n        long start = System.currentTimeMillis();\n        sortAlgorithm.apply(randomArray);\n        long end = System.currentTimeMillis();\n        return (end - start) / 1000.0;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.function.Function;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass InsertionSortTest {\n    private InsertionSort insertionSort;\n\n    @BeforeEach\n    void setUp() {\n        insertionSort = new InsertionSort();\n    }\n\n    @Test\n    void insertionSortSortEmptyArrayShouldPass() {\n        testEmptyArray(insertionSort::sort);\n        testEmptyArray(insertionSort::sentinelSort);\n    }\n\n    private void testEmptyArray(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalSortSingleValueArrayShouldPass() {\n        testSingleValue(insertionSort::sort);\n        testSingleValue(insertionSort::sentinelSort);\n    }\n\n    private void testSingleValue(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {7};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithIntegerArrayShouldPass() {\n        testIntegerArray(insertionSort::sort);\n        testIntegerArray(insertionSort::sentinelSort);\n    }\n\n    private void testIntegerArray(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalForArrayWithNegativeValuesShouldPass() {\n        testWithNegativeValues(insertionSort::sort);\n        testWithNegativeValues(insertionSort::sentinelSort);\n    }\n\n    private void testWithNegativeValues(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {49, -36, -144, -49, 1, 9};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {-144, -49, -36, 1, 9, 49};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalForArrayWithDuplicateValuesShouldPass() {\n        testWithDuplicates(insertionSort::sort);\n        testWithDuplicates(insertionSort::sentinelSort);\n    }\n\n    private void testWithDuplicates(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithStringArrayShouldPass() {\n        testWithStringArray(insertionSort::sort);\n        testWithStringArray(insertionSort::sentinelSort);\n    }\n\n    private void testWithStringArray(Function<String[], String[]> sortAlgorithm) {\n        String[] array = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        String[] sorted = sortAlgorithm.apply(array);\n        String[] expected = {\"a\", \"b\", \"c\", \"d\", \"e\"};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithRandomArrayPass() {\n        testWithRandomArray(insertionSort::sort);\n        testWithRandomArray(insertionSort::sentinelSort);\n    }\n\n    private void testWithRandomArray(Function<Double[], Double[]> sortAlgorithm) {\n        int randomSize = (int) (SortUtilsRandomGenerator.generateDouble() * 10_000);\n        Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);\n        Double[] sorted = sortAlgorithm.apply(array);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.function.Function;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass InsertionSortTest {\n    private InsertionSort insertionSort;\n\n    @BeforeEach\n    void setUp() {\n        insertionSort = new InsertionSort();\n    }\n\n    @Test\n    void insertionSortSortEmptyArrayShouldPass() {\n        testEmptyArray(insertionSort::sort);\n        testEmptyArray(insertionSort::sentinelSort);\n    }\n\n    private void testEmptyArray(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalSortSingleValueArrayShouldPass() {\n        testSingleValue(insertionSort::sort);\n        testSingleValue(insertionSort::sentinelSort);\n    }\n\n    private void testSingleValue(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {7};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {7};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithIntegerArrayShouldPass() {\n        testIntegerArray(insertionSort::sort);\n        testIntegerArray(insertionSort::sentinelSort);\n    }\n\n    private void testIntegerArray(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {49, 4, 36, 9, 144, 1};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {1, 4, 9, 36, 49, 144};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalForArrayWithNegativeValuesShouldPass() {\n        testWithNegativeValues(insertionSort::sort);\n        testWithNegativeValues(insertionSort::sentinelSort);\n    }\n\n    private void testWithNegativeValues(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {49, -36, -144, -49, 1, 9};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {-144, -49, -36, 1, 9, 49};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalForArrayWithDuplicateValuesShouldPass() {\n        testWithDuplicates(insertionSort::sort);\n        testWithDuplicates(insertionSort::sentinelSort);\n    }\n\n    private void testWithDuplicates(Function<Integer[], Integer[]> sortAlgorithm) {\n        Integer[] array = {36, 1, 49, 1, 4, 9};\n        Integer[] sorted = sortAlgorithm.apply(array);\n        Integer[] expected = {1, 1, 4, 9, 36, 49};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithStringArrayShouldPass() {\n        testWithStringArray(insertionSort::sort);\n        testWithStringArray(insertionSort::sentinelSort);\n    }\n\n    private void testWithStringArray(Function<String[], String[]> sortAlgorithm) {\n        String[] array = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        String[] sorted = sortAlgorithm.apply(array);\n        String[] expected = {\"a\", \"b\", \"c\", \"d\", \"e\"};\n        assertArrayEquals(expected, sorted);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n\n    @Test\n    void insertionSortClassicalWithRandomArrayPass() {\n        testWithRandomArray(insertionSort::sort);\n        testWithRandomArray(insertionSort::sentinelSort);\n    }\n\n    private void testWithRandomArray(Function<Double[], Double[]> sortAlgorithm) {\n        int randomSize = SortUtilsRandomGenerator.generateInt(10_000);\n        Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);\n        Double[] sorted = sortAlgorithm.apply(array);\n        assertTrue(SortUtils.isSorted(sorted));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "ea05286c862828287aaf96a9e931b7303ed6940e",
        "product_file_path": "src/main/java/com/thealgorithms/backtracking/PowerSum.java",
        "test_file_path": "src/test/java/com/thealgorithms/backtracking/PowerSumTest.java",
        "product_old_content": "package com.thealgorithms.backtracking;\n\nimport java.util.Scanner;\n\n/*\n * Problem Statement :\n * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers of unique, natural numbers.\n * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3.\n * Therefore output will be 1.\n */\npublic class PowerSum {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the number and the power\");\n        int N = sc.nextInt();\n        int X = sc.nextInt();\n        PowerSum ps = new PowerSum();\n        int count = ps.powSum(N, X);\n        //printing the answer.\n        System.out.println(\"Number of combinations of different natural number's raised to \" + X + \" having sum \" + N + \" are : \");\n        System.out.println(count);\n        sc.close();\n    }\n    private int count = 0, sum = 0;\n\n    public int powSum(int N, int X) {\n        Sum(N, X, 1);\n        return count;\n    }\n\n    //here i is the natural number which will be raised by X and added in sum.\n    public void Sum(int N, int X, int i) {\n        //if sum is equal to N that is one of our answer and count is increased.\n        if (sum == N) {\n            count++;\n            return;\n        } //we will be adding next natural number raised to X only if on adding it in sum the result is less than N.\n        else if (sum + power(i, X) <= N) {\n            sum += power(i, X);\n            Sum(N, X, i + 1);\n            //backtracking and removing the number added last since no possible combination is there with it.\n            sum -= power(i, X);\n        }\n        if (power(i, X) < N) {\n            //calling the sum function with next natural number after backtracking if when it is raised to X is still less than X.\n            Sum(N, X, i + 1);\n        }\n    }\n\n    //creating a separate power function so that it can be used again and again when required. \n    private int power(int a, int b) {\n        return (int) Math.pow(a, b);\n    }\n}",
        "product_new_content": "package com.thealgorithms.backtracking;\n\nimport java.util.Scanner;\n\n/*\n * Problem Statement :\n * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers of unique, natural numbers.\n * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3.\n * Therefore output will be 1.\n */\npublic class PowerSum {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the number and the power\");\n        int N = sc.nextInt();\n        int X = sc.nextInt();\n        PowerSum ps = new PowerSum();\n        int count = ps.powSum(N, X);\n        //printing the answer.\n        System.out.println(\n            \"Number of combinations of different natural number's raised to \" +\n            X +\n            \" having sum \" +\n            N +\n            \" are : \"\n        );\n        System.out.println(count);\n        sc.close();\n    }\n\n    private int count = 0, sum = 0;\n\n    public int powSum(int N, int X) {\n        Sum(N, X, 1);\n        return count;\n    }\n\n    //here i is the natural number which will be raised by X and added in sum.\n    public void Sum(int N, int X, int i) {\n        //if sum is equal to N that is one of our answer and count is increased.\n        if (sum == N) {\n            count++;\n            return;\n        } //we will be adding next natural number raised to X only if on adding it in sum the result is less than N.\n        else if (sum + power(i, X) <= N) {\n            sum += power(i, X);\n            Sum(N, X, i + 1);\n            //backtracking and removing the number added last since no possible combination is there with it.\n            sum -= power(i, X);\n        }\n        if (power(i, X) < N) {\n            //calling the sum function with next natural number after backtracking if when it is raised to X is still less than X.\n            Sum(N, X, i + 1);\n        }\n    }\n\n    //creating a separate power function so that it can be used again and again when required.\n    private int power(int a, int b) {\n        return (int) Math.pow(a, b);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.backtracking;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class PowerSumTest {\n\n    @Test\n    void testNumberZeroAndPowerZero() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(0, 0);\n        assertEquals(1, result);\n    }\n\n    @Test\n    void testNumberHundredAndPowerTwo() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 2);\n        assertEquals(3, result);\n    }\n  \n    @Test\n    void testNumberHundredAndPowerThree() {\n        PowerSum powerSum = new PowerSum();\n        int result = powerSum.powSum(100, 3);\n        assertEquals(1, result);\n    }\n    \n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "471d2c0b5d671d0caf98e84a88673de7b5778801",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/buffers/CircularBuffer.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/buffers/CircularBufferTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.buffers;\n\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CircularBuffer {\n\n    private char[] _buffer;\n    public final int _buffer_size;\n    private int _write_index = 0;\n    private int _read_index = 0;\n    private AtomicInteger _readable_data = new AtomicInteger(0);\n\n    public CircularBuffer(int buffer_size) {\n        if (!IsPowerOfTwo(buffer_size)) {\n            throw new IllegalArgumentException();\n        }\n        this._buffer_size = buffer_size;\n        _buffer = new char[buffer_size];\n    }\n\n    private boolean IsPowerOfTwo(int i) {\n        return (i & (i - 1)) == 0;\n    }\n\n    private int getTrueIndex(int i) {\n        return i % _buffer_size;\n    }\n\n    public Character readOutChar() {\n        Character result = null;\n\n        // if we have data to read\n        if (_readable_data.get() > 0) {\n\n            result = Character.valueOf(_buffer[getTrueIndex(_read_index)]);\n            _readable_data.decrementAndGet();\n            _read_index++;\n        }\n\n        return result;\n    }\n\n    public boolean writeToCharBuffer(char c) {\n        boolean result = false;\n\n        // if we can write to the buffer\n        if (_readable_data.get() < _buffer_size) {\n            // write to buffer\n            _buffer[getTrueIndex(_write_index)] = c;\n            _readable_data.incrementAndGet();\n            _write_index++;\n            result = true;\n        }\n\n        return result;\n    }\n\n    private static class TestWriteWorker implements Runnable {\n\n        String _alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n        Random _random = new Random();\n        CircularBuffer _buffer;\n\n        public TestWriteWorker(CircularBuffer cb) {\n            this._buffer = cb;\n        }\n\n        private char getRandomChar() {\n            return _alphabet.charAt(_random.nextInt(_alphabet.length()));\n        }\n\n        public void run() {\n            while (!Thread.interrupted()) {\n                if (!_buffer.writeToCharBuffer(getRandomChar())) {\n                    Thread.yield();\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    private static class TestReadWorker implements Runnable {\n\n        CircularBuffer _buffer;\n\n        public TestReadWorker(CircularBuffer cb) {\n            this._buffer = cb;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(\"Printing Buffer:\");\n            while (!Thread.interrupted()) {\n                Character c = _buffer.readOutChar();\n                if (c != null) {\n                    System.out.print(c.charValue());\n                } else {\n                    Thread.yield();\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        System.out.println();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        int buffer_size = 1024;\n        // create circular buffer\n        CircularBuffer cb = new CircularBuffer(buffer_size);\n\n        // create threads that read and write the buffer.\n        Thread write_thread = new Thread(new TestWriteWorker(cb));\n        Thread read_thread = new Thread(new TestReadWorker(cb));\n        read_thread.start();\n        write_thread.start();\n\n        // wait some amount of time\n        Thread.sleep(10000);\n\n        // interrupt threads and exit\n        write_thread.interrupt();\n        read_thread.interrupt();\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.buffers;\n\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CircularBuffer {\n\n    private char[] _buffer;\n    public final int _buffer_size;\n    private int _write_index = 0;\n    private int _read_index = 0;\n    private AtomicInteger _readable_data = new AtomicInteger(0);\n\n    public CircularBuffer(int buffer_size) {\n        if (!IsPowerOfTwo(buffer_size)) {\n            throw new IllegalArgumentException();\n        }\n        this._buffer_size = buffer_size;\n        _buffer = new char[buffer_size];\n    }\n\n    private boolean IsPowerOfTwo(int i) {\n        return (i & (i - 1)) == 0;\n    }\n\n    private int getTrueIndex(int i) {\n        return i % _buffer_size;\n    }\n\n    public Character readOutChar() {\n        Character result = null;\n\n        // if we have data to read\n        if (_readable_data.get() > 0) {\n            result = Character.valueOf(_buffer[getTrueIndex(_read_index)]);\n            _readable_data.decrementAndGet();\n            _read_index++;\n        }\n\n        return result;\n    }\n\n    public boolean writeToCharBuffer(char c) {\n        boolean result = false;\n\n        // if we can write to the buffer\n        if (_readable_data.get() < _buffer_size) {\n            // write to buffer\n            _buffer[getTrueIndex(_write_index)] = c;\n            _readable_data.incrementAndGet();\n            _write_index++;\n            result = true;\n        }\n\n        return result;\n    }\n\n    private static class TestWriteWorker implements Runnable {\n\n        String _alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n        Random _random = new Random();\n        CircularBuffer _buffer;\n\n        public TestWriteWorker(CircularBuffer cb) {\n            this._buffer = cb;\n        }\n\n        private char getRandomChar() {\n            return _alphabet.charAt(_random.nextInt(_alphabet.length()));\n        }\n\n        public void run() {\n            while (!Thread.interrupted()) {\n                if (!_buffer.writeToCharBuffer(getRandomChar())) {\n                    Thread.yield();\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    private static class TestReadWorker implements Runnable {\n\n        CircularBuffer _buffer;\n\n        public TestReadWorker(CircularBuffer cb) {\n            this._buffer = cb;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(\"Printing Buffer:\");\n            while (!Thread.interrupted()) {\n                Character c = _buffer.readOutChar();\n                if (c != null) {\n                    System.out.print(c.charValue());\n                } else {\n                    Thread.yield();\n                    try {\n                        Thread.sleep(10);\n                    } catch (InterruptedException e) {\n                        System.out.println();\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        int buffer_size = 1024;\n        // create circular buffer\n        CircularBuffer cb = new CircularBuffer(buffer_size);\n\n        // create threads that read and write the buffer.\n        Thread write_thread = new Thread(new TestWriteWorker(cb));\n        Thread read_thread = new Thread(new TestReadWorker(cb));\n        read_thread.start();\n        write_thread.start();\n\n        // wait some amount of time\n        Thread.sleep(10000);\n\n        // interrupt threads and exit\n        write_thread.interrupt();\n        read_thread.interrupt();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.buffers;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicIntegerArray;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CircularBufferTest {\n    private static final int BUFFER_SIZE = 10;\n    private CircularBuffer<Integer> buffer;\n\n    @BeforeEach\n    void setUp() {\n        buffer = new CircularBuffer<>(BUFFER_SIZE);\n    }\n\n    @Test\n    void isEmpty() {\n        assertTrue(buffer.isEmpty());\n        buffer.put(generateInt());\n        assertFalse(buffer.isEmpty());\n    }\n\n    @Test\n    void isFull() {\n        assertFalse(buffer.isFull());\n        buffer.put(generateInt());\n        assertFalse(buffer.isFull());\n\n        for (int i = 1; i < BUFFER_SIZE; i++)\n            buffer.put(generateInt());\n        assertTrue(buffer.isFull());\n    }\n\n    @Test\n    void get() {\n        assertNull(buffer.get());\n        for (int i = 0; i < 100; i++)\n            buffer.put(i);\n        for (int i = 0; i < BUFFER_SIZE; i++)\n            assertEquals(i, buffer.get());\n        assertNull(buffer.get());\n    }\n\n    @Test\n    void put() {\n        for (int i = 0; i < BUFFER_SIZE; i++)\n            assertTrue(buffer.put(generateInt()));\n        assertFalse(buffer.put(generateInt()));\n    }\n\n    @RepeatedTest(1000)\n    void concurrentTest() throws InterruptedException {\n        final int numberOfThreadsForProducers = 3;\n        final int numberOfThreadsForConsumers = 2;\n        final int numberOfItems = 300;\n        final CountDownLatch producerCountDownLatch = new CountDownLatch(numberOfItems);\n        final CountDownLatch consumerCountDownLatch = new CountDownLatch(numberOfItems);\n        final AtomicIntegerArray resultAtomicArray = new AtomicIntegerArray(numberOfItems);\n\n        // We are running 2 ExecutorService simultaneously 1 - producer, 2 - consumer\n        // Run producer threads to populate buffer.\n        ExecutorService putExecutors = Executors.newFixedThreadPool(numberOfThreadsForProducers);\n        putExecutors.execute(() -> {\n            while (producerCountDownLatch.getCount() > 0) {\n                int count = (int) producerCountDownLatch.getCount();\n                boolean put = buffer.put(count);\n                while (!put) put = buffer.put(count);\n                producerCountDownLatch.countDown();\n            }\n        });\n\n        // Run consumer threads to retrieve the data from buffer.\n        ExecutorService getExecutors = Executors.newFixedThreadPool(numberOfThreadsForConsumers);\n        getExecutors.execute(() -> {\n            while (consumerCountDownLatch.getCount() > 0) {\n                int count = (int) consumerCountDownLatch.getCount();\n                Integer item = buffer.get();\n                while (item == null) item = buffer.get();\n                resultAtomicArray.set(count - 1, item);\n                consumerCountDownLatch.countDown();\n            }\n        });\n\n        producerCountDownLatch.await();\n        consumerCountDownLatch.await();\n        putExecutors.shutdown();\n        getExecutors.shutdown();\n        shutDownExecutorSafely(putExecutors);\n        shutDownExecutorSafely(getExecutors);\n\n        List<Integer> resultArray = getSortedListFrom(resultAtomicArray);\n        for (int i = 0; i < numberOfItems; i++) {\n            int expectedItem = i + 1;\n            assertEquals(expectedItem, resultArray.get(i));\n        }\n    }\n\n    private int generateInt() {\n        return ThreadLocalRandom.current().nextInt(0, 100);\n    }\n\n    private void shutDownExecutorSafely(ExecutorService executorService) {\n        try {\n            if (!executorService.awaitTermination(1_000, TimeUnit.MILLISECONDS))\n                executorService.shutdownNow();\n        } catch (InterruptedException e) {\n            executorService.shutdownNow();\n        }\n    }\n\n    public List<Integer> getSortedListFrom(AtomicIntegerArray atomicArray) {\n        int length = atomicArray.length();\n        ArrayList<Integer> result = new ArrayList<>(length);\n        for (int i = 0; i < length; i++)\n            result.add(atomicArray.get(i));\n        result.sort(Comparator.comparingInt(o -> o));\n        return result;\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "8d4b048cb3a499cd57449d08730dd86952e7b175",
        "product_file_path": "src/main/java/com/thealgorithms/dynamicprogramming/LongestValidParentheses.java",
        "test_file_path": "src/test/java/com/thealgorithms/dynamicprogramming/LongestValidParenthesesTest",
        "product_old_content": "package com.thealgorithms.dynamicprogramming;\n\nimport java.util.Scanner;\n\n/**\n * Given a string containing just the characters '(' and ')', find the length of\n * the longest valid (well-formed) parentheses substring.\n *\n * @author Libin Yang (https://github.com/yanglbme)\n * @since 2018/10/5\n */\npublic class LongestValidParentheses {\n\n    public static int getLongestValidParentheses(String s) {\n        if (s == null || s.length() < 2) {\n            return 0;\n        }\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        int[] res = new int[n];\n        res[0] = 0;\n        res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;\n\n        int max = res[1];\n\n        for (int i = 2; i < n; ++i) {\n            if (chars[i] == ')') {\n                if (chars[i - 1] == '(') {\n                    res[i] = res[i - 2] + 2;\n                } else {\n                    int index = i - res[i - 1] - 1;\n                    if (index >= 0 && chars[index] == '(') {\n                        // ()(())\n                        res[i] = res[i - 1] + 2 + (index - 1 >= 0 ? res[index - 1] : 0);\n                    }\n                }\n            }\n            max = Math.max(max, res[i]);\n        }\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            String str = sc.nextLine();\n            if (\"quit\".equals(str)) {\n                break;\n            }\n\n            System.out.println(\"Len is: \" + getLongestValidParentheses(str));\n        }\n\n        sc.close();\n    }\n}",
        "product_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport java.util.Scanner;\n\n/**\n * Given a string containing just the characters '(' and ')', find the length of\n * the longest valid (well-formed) parentheses substring.\n *\n * @author Libin Yang (https://github.com/yanglbme)\n * @since 2018/10/5\n */\npublic class LongestValidParentheses {\n\n    public static int getLongestValidParentheses(String s) {\n        if (s == null || s.length() < 2) {\n            return 0;\n        }\n        char[] chars = s.toCharArray();\n        int n = chars.length;\n        int[] res = new int[n];\n        res[0] = 0;\n        res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;\n\n        int max = res[1];\n\n        for (int i = 2; i < n; ++i) {\n            if (chars[i] == ')') {\n                if (chars[i - 1] == '(') {\n                    res[i] = res[i - 2] + 2;\n                } else {\n                    int index = i - res[i - 1] - 1;\n                    if (index >= 0 && chars[index] == '(') {\n                        // ()(())\n                        res[i] =\n                            res[i - 1] +\n                            2 +\n                            (index - 1 >= 0 ? res[index - 1] : 0);\n                    }\n                }\n            }\n            max = Math.max(max, res[i]);\n        }\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            String str = sc.nextLine();\n            if (\"quit\".equals(str)) {\n                break;\n            }\n\n            System.out.println(\"Len is: \" + getLongestValidParentheses(str));\n        }\n\n        sc.close();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.dynamicprogramming;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass LongestValidParenthesesTest {\n\n    LongestValidParentheses longestValidParentheses = new LongestValidParentheses();\n\n    @Test\n    void shouldReturnZeroWhenSingleOpeningParenthesisIsGiven() {\n        String input = \"(\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(0, validLength);\n    }\n\n    @Test\n    void shouldReturnZeroWhenSingleClosingParenthesisIsGiven() {\n        String input = \")\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(0, validLength);\n    }\n\n    @Test\n    void shouldReturnZeroWhenNullStringIsGiven() {\n        String input = \"\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(0, validLength);\n    }\n\n    @Test\n    void shouldReturnTwoWhenTwoBalancedParenthesesAreGiven() {\n        String input = \"()\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(2, validLength);\n    }\n\n    @Test\n    void shouldReturnLengthWhenInputStringIsValid() {\n        String input = \"()((()))\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(8, validLength);\n    }\n\n    @Test\n    void shouldReturnValidLengthWhenInputStringIsGiven() {\n        String input = \"((()((())))\";\n        int validLength = longestValidParentheses.getLongestValidParentheses(input);\n        assertEquals(10, validLength);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "8803b7f5e7a05ba832aec0ed8ec2928a6d57fd55",
        "product_file_path": "src/main/java/com/thealgorithms/maths/Area.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/AreaTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    public static void main(String[] args) {\n\n        /* test cube */\n        assert Double.compare(surfaceAreaCube(1), 6.0) == 0;\n\n        /* test sphere */\n        assert Double.compare(surfaceAreaSphere(5), 314.1592653589793) == 0;\n        assert Double.compare(surfaceAreaSphere(1), 12.566370614359172) == 0;\n\n        /* test rectangle */\n        assert Double.compare(surfaceAreaRectangle(10, 20), 200.0) == 0;\n\n        /* test square */\n        assert Double.compare(surfaceAreaSquare(10), 100.0) == 0;\n\n        /* test triangle */\n        assert Double.compare(surfaceAreaTriangle(10, 10), 50.0) == 0;\n\n        /* test parallelogram */\n        assert Double.compare(surfaceAreaParallelogram(10, 20), 200.0) == 0;\n\n        /* test trapezium */\n        assert Double.compare(surfaceAreaTrapezium(10, 20, 30), 450.0) == 0;\n\n        /* test circle */\n        assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;\n\n        /* test cylinder */\n        assert Double.compare(surfaceAreaCylinder(1, 2), 18.84955592153876) == 0;\n\n        /* test hemisphere */\n        assert Double.compare(surfaceAreaHemisphere(5), 235.61944901923448) == 0;\n        assert Double.compare(surfaceAreaHemisphere(1), 9.42477796076938) == 0;\n\n        /* test cone */\n        assert Double.compare(surfaceAreaCone(6, 8), 301.59289474462014) == 0;\n        assert Double.compare(surfaceAreaCone(10, 24), 1130.9733552923256) == 0;\n\n    }\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    private static double surfaceAreaCube(double sideLength) {\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    private static double surfaceAreaSphere(double radius) {\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle\n     *\n     * @param length length of rectangle\n     * @param width width of rectangle\n     * @return area of given rectangle\n     */\n    private static double surfaceAreaRectangle(double length, double width) {\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    private static double surfaceAreaCylinder(double radius, double height) {\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    private static double surfaceAreaSquare(double sideLength) {\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle\n     *\n     * @param base base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    private static double surfaceAreaTriangle(double base, double height) {\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram\n     *\n     * @param base base of parallelogram\n     * @param height height of parallelogram\n     * @return area of given parallelogram\n     */\n    private static double surfaceAreaParallelogram(double base, double height) {\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium\n     *\n     * @param base1 upper base of trapezium\n     * @param base2 bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    private static double surfaceAreaTrapezium(double base1, double base2, double height) {\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    private static double surfaceAreaCircle(double radius) {\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    private static double surfaceAreaHemisphere(double radius) {\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    private static double surfaceAreaCone(double radius, double height) {\n        return Math.PI * radius * (radius + Math.pow((height * height + radius * radius), 0.5));\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/**\n * Find the area of various geometric shapes\n */\npublic class Area {\n\n    public static void main(String[] args) {\n        /* test cube */\n        assert Double.compare(surfaceAreaCube(1), 6.0) == 0;\n\n        /* test sphere */\n        assert Double.compare(surfaceAreaSphere(5), 314.1592653589793) == 0;\n        assert Double.compare(surfaceAreaSphere(1), 12.566370614359172) == 0;\n\n        /* test rectangle */\n        assert Double.compare(surfaceAreaRectangle(10, 20), 200.0) == 0;\n\n        /* test square */\n        assert Double.compare(surfaceAreaSquare(10), 100.0) == 0;\n\n        /* test triangle */\n        assert Double.compare(surfaceAreaTriangle(10, 10), 50.0) == 0;\n\n        /* test parallelogram */\n        assert Double.compare(surfaceAreaParallelogram(10, 20), 200.0) == 0;\n\n        /* test trapezium */\n        assert Double.compare(surfaceAreaTrapezium(10, 20, 30), 450.0) == 0;\n\n        /* test circle */\n        assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;\n\n        /* test cylinder */\n        assert Double.compare(surfaceAreaCylinder(1, 2), 18.84955592153876) ==\n        0;\n\n        /* test hemisphere */\n        assert Double.compare(surfaceAreaHemisphere(5), 235.61944901923448) ==\n        0;\n        assert Double.compare(surfaceAreaHemisphere(1), 9.42477796076938) == 0;\n\n        /* test cone */\n        assert Double.compare(surfaceAreaCone(6, 8), 301.59289474462014) == 0;\n        assert Double.compare(surfaceAreaCone(10, 24), 1130.9733552923256) == 0;\n    }\n\n    /**\n     * Calculate the surface area of a cube.\n     *\n     * @param sideLength side length of cube\n     * @return surface area of given cube\n     */\n    private static double surfaceAreaCube(double sideLength) {\n        return 6 * sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the surface area of a sphere.\n     *\n     * @param radius radius of sphere\n     * @return surface area of given sphere\n     */\n    private static double surfaceAreaSphere(double radius) {\n        return 4 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the area of a rectangle\n     *\n     * @param length length of rectangle\n     * @param width width of rectangle\n     * @return area of given rectangle\n     */\n    private static double surfaceAreaRectangle(double length, double width) {\n        return length * width;\n    }\n\n    /**\n     * Calculate surface area of a cylinder\n     *\n     * @param radius radius of the floor\n     * @param height height of the cylinder.\n     * @return volume of given cylinder\n     */\n    private static double surfaceAreaCylinder(double radius, double height) {\n        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);\n    }\n\n    /**\n     * Calculate the area of a square\n     *\n     * @param sideLength side length of square\n     * @return area of given square\n     */\n    private static double surfaceAreaSquare(double sideLength) {\n        return sideLength * sideLength;\n    }\n\n    /**\n     * Calculate the area of a triangle\n     *\n     * @param base base of triangle\n     * @param height height of triangle\n     * @return area of given triangle\n     */\n    private static double surfaceAreaTriangle(double base, double height) {\n        return base * height / 2;\n    }\n\n    /**\n     * Calculate the area of a parallelogram\n     *\n     * @param base base of parallelogram\n     * @param height height of parallelogram\n     * @return area of given parallelogram\n     */\n    private static double surfaceAreaParallelogram(double base, double height) {\n        return base * height;\n    }\n\n    /**\n     * Calculate the area of a trapezium\n     *\n     * @param base1 upper base of trapezium\n     * @param base2 bottom base of trapezium\n     * @param height height of trapezium\n     * @return area of given trapezium\n     */\n    private static double surfaceAreaTrapezium(\n        double base1,\n        double base2,\n        double height\n    ) {\n        return (base1 + base2) * height / 2;\n    }\n\n    /**\n     * Calculate the area of a circle\n     *\n     * @param radius radius of circle\n     * @return area of given circle\n     */\n    private static double surfaceAreaCircle(double radius) {\n        return Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a hemisphere.\n     *\n     * @param radius radius of hemisphere\n     * @return surface area of given hemisphere\n     */\n    private static double surfaceAreaHemisphere(double radius) {\n        return 3 * Math.PI * radius * radius;\n    }\n\n    /**\n     * Calculate the surface area of a cone.\n     *\n     * @param radius radius of cone.\n     * @param height of cone.\n     * @return surface area of given cone.\n     */\n    private static double surfaceAreaCone(double radius, double height) {\n        return (\n            Math.PI *\n            radius *\n            (radius + Math.pow((height * height + radius * radius), 0.5))\n        );\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n * @author Amarildo Aliaj\n */\nclass AreaTest {\n\n    @Test\n    void testSurfaceAreaCube() {\n        assertEquals(6.0, Area.surfaceAreaCube(1));\n    }\n\n    @Test\n    void testSurfaceAreaSphere() {\n        assertEquals(12.566370614359172, Area.surfaceAreaSphere(1));\n    }\n\n    @Test\n    void testSurfaceAreaRectangle() {\n        assertEquals(200.0, Area.surfaceAreaRectangle(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaCylinder() {\n        assertEquals(18.84955592153876, Area.surfaceAreaCylinder(1, 2));\n    }\n\n    @Test\n    void testSurfaceAreaSquare() {\n        assertEquals(100.0, Area.surfaceAreaSquare(10));\n    }\n\n    @Test\n    void testSurfaceAreaTriangleRectangle() {\n        assertEquals(50.0, Area.surfaceAreaTriangleRectangle(10, 10));\n    }\n\n    @Test\n    void testSurfaceAreaParallelogram() {\n        assertEquals(200.0, Area.surfaceAreaParallelogram(10, 20));\n    }\n\n    @Test\n    void testSurfaceAreaTrapezium() {\n        assertEquals(450.0, Area.surfaceAreaTrapezium(10, 20, 30));\n    }\n\n    @Test\n    void testSurfaceAreaCircle() {\n        assertEquals(1256.6370614359173, Area.surfaceAreaCircle(20));\n    }\n\n    @Test\n    void surfaceAreaHemisphere() {\n        assertEquals(235.61944901923448, Area.surfaceAreaHemisphere(5));\n    }\n\n    @Test\n    void surfaceAreaCone() {\n        assertEquals(301.59289474462014, Area.surfaceAreaCone(6, 8));\n    }\n\n    @Test\n    void testAllIllegalInput() {\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCube(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSphere(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(0, 10)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaRectangle(10, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCylinder(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaSquare(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTriangleRectangle(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaParallelogram(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(0, 1, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 0, 1)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaTrapezium(1, 1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCircle(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaHemisphere(0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(1, 0)),\n                () -> assertThrows(IllegalArgumentException.class, () -> Area.surfaceAreaCone(0, 1))\n        );\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "911b98472c59275da3c96a92d85b19120e14bf74",
        "product_file_path": "src/main/java/com/thealgorithms/maths/DudeneyNumber.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/DudeneyNumberTest.java",
        "product_old_content": "/**\n * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.\n * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.\n *          Since, the sum of the digits is equal to the cube root of the entered number;\n *          it is a Dudeney Number.\n */\npackage com.thealgorithms.maths;\n\nimport java.io.*;\n\npublic class DudeneyNumber {\n\n    //returns True if the number is a Dudeney number and False if it is not a Dudeney number.\n    public static boolean isDudeney(int n) {\n        // Calculating Cube Root\n        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));\n        // If the number is not a perfect cube the method returns false.\n        if (cube_root * cube_root * cube_root != n) {\n            return false;\n        }\n        int sum_of_digits = 0;// Stores the sums of the digit of the entered number\n        int temp = n;//A temporary variable to store the entered number\n        // Loop to calculate sum of the digits.\n        while (temp > 0) {\n\n            // Extracting Last digit of the number\n            int rem = temp % 10;\n\n            // Calculating sum of digits.\n            sum_of_digits += rem;\n\n            // Removing the last digit\n            temp /= 10;\n        }\n\n        //If the cube root of the number is not equal to the sum of its digits we return false.  \n        if (cube_root != sum_of_digits) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Method to check if number is Dudeney Number or Not 1) Input - Enter a\n     * Number: 512 Output - It is a Dudeney Number. 2) Input - Enter a Number:\n     * 125 Output - It is not a Dudeney Number.\n     */\n    public static void main(String args[]) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter a Number: \");\n        int n = Integer.parseInt(br.readLine());\n        if (isDudeney(n)) {\n            System.out.println(\"It is a Dudeney Number.\");\n        } else {\n            System.out.println(\"It is not a Dudeney Number.\");\n        }\n    }\n}",
        "product_new_content": "/**\n * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.\n * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.\n *          Since, the sum of the digits is equal to the cube root of the entered number;\n *          it is a Dudeney Number.\n */\npackage com.thealgorithms.maths;\n\nimport java.io.*;\n\npublic class DudeneyNumber {\n\n    //returns True if the number is a Dudeney number and False if it is not a Dudeney number.\n    public static boolean isDudeney(int n) {\n        // Calculating Cube Root\n        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));\n        // If the number is not a perfect cube the method returns false.\n        if (cube_root * cube_root * cube_root != n) {\n            return false;\n        }\n        int sum_of_digits = 0; // Stores the sums of the digit of the entered number\n        int temp = n; //A temporary variable to store the entered number\n        // Loop to calculate sum of the digits.\n        while (temp > 0) {\n            // Extracting Last digit of the number\n            int rem = temp % 10;\n\n            // Calculating sum of digits.\n            sum_of_digits += rem;\n\n            // Removing the last digit\n            temp /= 10;\n        }\n\n        //If the cube root of the number is not equal to the sum of its digits we return false.\n        if (cube_root != sum_of_digits) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Method to check if number is Dudeney Number or Not 1) Input - Enter a\n     * Number: 512 Output - It is a Dudeney Number. 2) Input - Enter a Number:\n     * 125 Output - It is not a Dudeney Number.\n     */\n    public static void main(String args[]) throws IOException {\n        BufferedReader br = new BufferedReader(\n            new InputStreamReader(System.in)\n        );\n        System.out.println(\"Enter a Number: \");\n        int n = Integer.parseInt(br.readLine());\n        if (isDudeney(n)) {\n            System.out.println(\"It is a Dudeney Number.\");\n        } else {\n            System.out.println(\"It is not a Dudeney Number.\");\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass DudeneyNumberTest {\n\n    @Test\n    void isDudeney() {\n        final int validDudeneyNumber = 512;\n        final int invalidDudeneyNumber = 125;\n\n        assertTrue(() -> DudeneyNumber.isDudeney(validDudeneyNumber));\n        assertFalse(() -> DudeneyNumber.isDudeney(invalidDudeneyNumber));\n\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "c805437c0c5e057f3ad60c397fe6550eec7be453",
        "product_file_path": "src/main/java/com/thealgorithms/others/CountChar.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/CountCharTest.java",
        "product_old_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\n\npublic class CountChar {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.print(\"Enter your text: \");\n        String str = input.nextLine();\n        input.close();\n        System.out.println(\"There are \" + CountCharacters(str) + \" characters.\");\n    }\n\n    /**\n     * Count non space character in string\n     *\n     * @param str String to count the characters\n     * @return number of character in the specified string\n     */\n    private static int CountCharacters(String str) {\n        return str.replaceAll(\"\\\\s\", \"\").length();\n    }\n}",
        "product_new_content": "package com.thealgorithms.others;\n\nimport java.util.Scanner;\n\npublic class CountChar {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.print(\"Enter your text: \");\n        String str = input.nextLine();\n        input.close();\n        System.out.println(\n            \"There are \" + CountCharacters(str) + \" characters.\"\n        );\n    }\n\n    /**\n     * Count non space character in string\n     *\n     * @param str String to count the characters\n     * @return number of character in the specified string\n     */\n    private static int CountCharacters(String str) {\n        return str.replaceAll(\"\\\\s\", \"\").length();\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CountCharTest {\n\n    @Test\n    void testCountCharacters(){\n        String input = \"12345\";\n        int expectedValue = 5;\n\n        assertEquals(expectedValue, CountChar.CountCharacters(input));\n    }\n\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "cce1dbd124de7197de383deb11c936a39a3e5463",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(T array[], T key, int left, int right) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers\n                = IntStream.generate(() -> r.nextInt(maxElement))\n                        .limit(size)\n                        .sorted()\n                        .boxed()\n                        .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.println(\n                format(\n                        \"Should be found: %d. Found %d at index %d. An array length %d\",\n                        shouldBeFound, integers[atIndex], atIndex, size));\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.println(\n                format(\n                        \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport static java.lang.String.format;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n        T array[],\n        T key,\n        int left,\n        int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.println(\n            format(\n                \"Should be found: %d. Found %d at index %d. An array length %d\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n            )\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.println(\n            format(\n                \"Found by system method at an index: %d. Is equal: %b\",\n                toCheck,\n                toCheck == atIndex\n            )\n        );\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\npublic class RowColumnWiseSorted2dArrayBinarySearchTest {\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestMiddle() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 35;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {1,2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 48;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {2,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpper() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 20;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpperSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 40;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLower() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 31;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLowerSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 51;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestNotFound() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 101;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {-1,-1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "03a4832a7da6c98b2083e8dda90f0a5d8c8a9a47",
        "product_file_path": "src/main/java/com/thealgorithms/searches/BinarySearch.java",
        "test_file_path": "src/test/java/com/thealgorithms/searches/RowColumnWiseSorted2dArrayBinarySearchTest.java",
        "product_old_content": "package com.thealgorithms.searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(T array[], T key, int left, int right) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers\n                = IntStream.generate(() -> r.nextInt(maxElement))\n                        .limit(size)\n                        .sorted()\n                        .boxed()\n                        .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.println(\n                format(\n                        \"Should be found: %d. Found %d at index %d. An array length %d\",\n                        shouldBeFound, integers[atIndex], atIndex, size));\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.println(\n                format(\n                        \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n    }\n}",
        "product_new_content": "package com.thealgorithms.searches;\n\nimport static java.lang.String.format;\n\nimport com.thealgorithms.devutils.searches.SearchAlgorithm;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the\n * position of a target value within a sorted array\n *\n * <p>\n * Worst-case performance O(log n) Best-case performance O(1) Average\n * performance O(log n) Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n    /**\n     * @param array is an array where the element should be found\n     * @param key is an element which should be found\n     * @param <T> is any comparable type\n     * @return index of the element\n     */\n    @Override\n    public <T extends Comparable<T>> int find(T[] array, T key) {\n        return search(array, key, 0, array.length - 1);\n    }\n\n    /**\n     * This method implements the Generic Binary Search\n     *\n     * @param array The array to make the binary search\n     * @param key The number you are looking for\n     * @param left The lower bound\n     * @param right The upper bound\n     * @return the location of the key\n     */\n    private <T extends Comparable<T>> int search(\n        T array[],\n        T key,\n        int left,\n        int right\n    ) {\n        if (right < left) {\n            return -1; // this means that the key not found\n        }\n        // find median\n        int median = (left + right) >>> 1;\n        int comp = key.compareTo(array[median]);\n\n        if (comp == 0) {\n            return median;\n        } else if (comp < 0) {\n            return search(array, key, left, median - 1);\n        } else {\n            return search(array, key, median + 1, right);\n        }\n    }\n\n    // Driver Program\n    public static void main(String[] args) {\n        // Just generate data\n        Random r = ThreadLocalRandom.current();\n\n        int size = 100;\n        int maxElement = 100000;\n\n        Integer[] integers = IntStream\n            .generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n        // The element that should be found\n        int shouldBeFound = integers[r.nextInt(size - 1)];\n\n        BinarySearch search = new BinarySearch();\n        int atIndex = search.find(integers, shouldBeFound);\n\n        System.out.println(\n            format(\n                \"Should be found: %d. Found %d at index %d. An array length %d\",\n                shouldBeFound,\n                integers[atIndex],\n                atIndex,\n                size\n            )\n        );\n\n        int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n        System.out.println(\n            format(\n                \"Found by system method at an index: %d. Is equal: %b\",\n                toCheck,\n                toCheck == atIndex\n            )\n        );\n    }\n}",
        "test_old_content": "package com.thealgorithms.searches;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\npublic class RowColumnWiseSorted2dArrayBinarySearchTest {\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestMiddle() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 35;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {1,2};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(1, ans[0]);\n        assertEquals(2, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArrayBinarySearchTestSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 48;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {2,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(2, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpper() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 20;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestUpperSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 40;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {0,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(0, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLower() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 31;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(1, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestLowerSide() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 51;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {3,3};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(3, ans[0]);\n        assertEquals(3, ans[1]);\n    }\n\n    @Test\n    // valid test case\n    public void rowColumnSorted2dArray_BinarySearchTestNotFound() {\n        int[][] arr = { {10, 20, 30, 40},\n                        {15, 25, 35, 45},\n                        {18, 28, 38, 48},\n                        {21, 31, 41, 51}\n                      };\n        int target = 101;\n        int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n        int[] expected = {-1,-1};\n        System.out.println(Arrays.toString(ans));\n        assertEquals(-1, ans[0]);\n        assertEquals(-1, ans[1]);\n    }\n\n}",
        "test_new_content": "package com.thealgorithms.searches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RowColumnWiseSorted2dArrayBinarySearchTest {\n\n  @Test\n  public void rowColumnSorted2dArrayBinarySearchTestMiddle() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 35;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 1, 2 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArrayBinarySearchTestSide() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 48;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 2, 3 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestUpper() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 20;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 0, 1 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestUpperSide() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 40;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 0, 3 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestLower() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 31;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 3, 1 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestLowerSide() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 51;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { 3, 3 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n\n  @Test\n  public void rowColumnSorted2dArray_BinarySearchTestNotFound() {\n    Integer[][] arr = {\n      { 10, 20, 30, 40 },\n      { 15, 25, 35, 45 },\n      { 18, 28, 38, 48 },\n      { 21, 31, 41, 51 },\n    };\n    Integer target = 101;\n    int[] ans = RowColumnWiseSorted2dArrayBinarySearch.search(arr, target);\n    int[] expected = { -1, -1 };\n    assertEquals(expected[0], ans[0]);\n    assertEquals(expected[1], ans[1]);\n  }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "cdd12a128d061bd6a5cfae4e0d8d2478d24d1c47",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/QuickSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/DualPivotQuickSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Ramdomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(\n        T[] array,\n        int left,\n        int right\n    ) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Ramdomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(\n        T[] array,\n        int left,\n        int right\n    ) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Debasish Biswas (https://github.com/debasishbsws)\n * @see DualPivotQuickSort\n */\nclass DualPivotQuickSortTest {\n\n    private DualPivotQuickSort dualPivotquickSort = new DualPivotQuickSort();\n\n    @Test\n    void quickSortEmptyArrayShouldPass() {\n        Integer[] array = {};\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = {};\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortSingleValueArrayShouldPass() {\n        Integer[] array = { 7 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 7 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithIntegerArrayShouldPass() {\n        Integer[] array = { 49, 4, 36, 9, 144, 1 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 4, 9, 36, 49, 144 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithNegativeValuesShouldPass() {\n        Integer[] array = { 49, -36, -124, -49, 12, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { -124, -49, -36, 9, 12, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortForArrayWithDuplicateValuesShouldPass() {\n        Integer[] array = { 36, 1, 49, 1, 4, 9 };\n        Integer[] sorted = dualPivotquickSort.sort(array);\n        Integer[] expected = { 1, 1, 4, 9, 36, 49 };\n        assertArrayEquals(expected, sorted);\n    }\n\n    @Test\n    void quickSortWithStringArrayShouldPass() {\n        String[] array = { \"cat\", \"ant\", \"eat\", \"boss\", \"dog\", \"apple\" };\n        String[] sorted = dualPivotquickSort.sort(array);\n        String[] expected = { \"ant\", \"apple\", \"boss\", \"cat\", \"dog\", \"eat\" };\n        assertArrayEquals(expected, sorted);\n    }\n\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "ddcb5cfead1b834f39eb6d5f5ace3764e44ff151",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/SlowSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/SlowSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\n/**\n * @author Amir Hassan (https://github.com/ahsNT)\n * @see SortAlgorithm\n */\npublic class SlowSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        sort(unsortedArray, 0, unsortedArray.length - 1);\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> void sort(T[] array, int i, int j) {\n        if (SortUtils.greaterOrEqual(i, j)) {\n            return;\n        }\n        int m = (i + j) / 2;\n        sort(array, i, m);\n        sort(array, m + 1, j);\n        if (SortUtils.less(array[j], array[m])) {\n            T temp = array[j];\n            array[j] = array[m];\n            array[m] = temp;\n        }\n        sort(array, i, j - 1);\n    }\n\n    public static void main(String[] args) {\n        SlowSort slowSort = new SlowSort();\n\n        Integer[] integerArray = {8, 84, 53, 953, 64, 2, 202, 98};\n        // Print integerArray unsorted\n        SortUtils.print(integerArray);\n\n        slowSort.sort(integerArray);\n        // Print integerArray sorted\n        SortUtils.print(integerArray);\n\n        String[] stringArray = {\"g\", \"d\", \"a\", \"b\", \"f\", \"c\", \"e\"};\n        // Print stringArray unsorted\n        SortUtils.print(stringArray);\n\n        slowSort.sort(stringArray);\n        // Print stringArray sorted\n        SortUtils.print(stringArray);\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\n/**\n * @author Amir Hassan (https://github.com/ahsNT)\n * @see SortAlgorithm\n */\npublic class SlowSort implements SortAlgorithm {\n\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {\n        sort(unsortedArray, 0, unsortedArray.length - 1);\n        return unsortedArray;\n    }\n\n    private <T extends Comparable<T>> void sort(T[] array, int i, int j) {\n        if (SortUtils.greaterOrEqual(i, j)) {\n            return;\n        }\n        int m = (i + j) / 2;\n        sort(array, i, m);\n        sort(array, m + 1, j);\n        if (SortUtils.less(array[j], array[m])) {\n            T temp = array[j];\n            array[j] = array[m];\n            array[m] = temp;\n        }\n        sort(array, i, j - 1);\n    }\n\n    public static void main(String[] args) {\n        SlowSort slowSort = new SlowSort();\n\n        Integer[] integerArray = { 8, 84, 53, 953, 64, 2, 202, 98 };\n        // Print integerArray unsorted\n        SortUtils.print(integerArray);\n\n        slowSort.sort(integerArray);\n        // Print integerArray sorted\n        SortUtils.print(integerArray);\n\n        String[] stringArray = { \"g\", \"d\", \"a\", \"b\", \"f\", \"c\", \"e\" };\n        // Print stringArray unsorted\n        SortUtils.print(stringArray);\n\n        slowSort.sort(stringArray);\n        // Print stringArray sorted\n        SortUtils.print(stringArray);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Rebecca Velez (https://github.com/rebeccavelez)\n * @see SlowSort\n */\n\npublic class SlowSortTest {\n\n    private SlowSort slowSort = new SlowSort();\n\n    @Test\n    public void slowSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortSingleIntegerElementArray() {\n        Integer[] inputArray = {5};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {5};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortSingleStringElementArray() {\n        String[] inputArray = {\"k\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"k\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortIntegerArray() {\n        Integer[] inputArray = {8, 84, 53, -683, 953, 64, 2, 202, 98, -10};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {-683, -10, 2, 8, 53, 64, 84, 98, 202, 953};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortDuplicateIntegerArray() {\n        Integer[] inputArray = {8, 84, 8, -2, 953, 64, 2, 953, 98};\n        Integer[] outputArray = slowSort.sort(inputArray);\n        Integer[] expectedOutput = {-2, 2, 8, 8, 64, 84, 98, 953, 953};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortStringArray() {\n        String[] inputArray = {\"g\", \"d\", \"a\", \"b\", \"f\", \"c\", \"e\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortDuplicateStringArray() {\n        String[] inputArray = {\"g\", \"d\", \"a\", \"g\", \"b\", \"f\", \"d\", \"c\", \"e\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"a\", \"b\", \"c\", \"d\", \"d\", \"e\", \"f\", \"g\", \"g\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void slowSortStringSymbolArray() {\n        String[] inputArray = {\"cbf\", \"auk\", \"\u00f3\", \"(b\", \"a\", \")\", \"au\", \"\u00e1\", \"cba\", \"auk\", \"(a\", \"bhy\", \"cba\"};\n        String[] outputArray = slowSort.sort(inputArray);\n        String[] expectedOutput = {\"(a\", \"(b\", \")\", \"a\", \"au\", \"auk\", \"auk\", \"bhy\", \"cba\", \"cba\", \"cbf\", \"\u00e1\", \"\u00f3\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "bf03d16303745e7c616c069db8db68b14be78484",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Lower.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/LowerTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\npublic class Lower {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"};\n        for (String s : strings) {\n            assert toLowerCase(s).equals(s.toLowerCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */\n    public static String toLowerCase(String s) {\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n                values[i] = Character.toLowerCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\npublic class Lower {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = { \"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\" };\n        for (String s : strings) {\n            assert toLowerCase(s).equals(s.toLowerCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */\n    public static String toLowerCase(String s) {\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (\n                Character.isLetter(values[i]) &&\n                Character.isUpperCase(values[i])\n            ) {\n                values[i] = Character.toLowerCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class LowerTest {\n    @Test\n    public void toLowerCase() {\n        String input1 = \"hello world\";\n        String input2 = \"HelLO WoRld\";\n        String input3 = \"HELLO WORLD\";\n        \n        assertEquals(\"hello world\", Lower.toLowerCase(input1));\n        assertEquals(\"hello world\", Lower.toLowerCase(input2));\n        assertEquals(\"hello world\", Lower.toLowerCase(input3));\n    }\n}"
    },
    {
        "product_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "test_commit": "f35aeb53116e4f99535e516bcb66d043036ace0f",
        "product_file_path": "src/main/java/com/thealgorithms/strings/ReverseString.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/ReverseStringTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Reverse String using different version\n */\npublic class ReverseString {\n\n    public static void main(String[] args) {\n        assert reverse(\"abc123\").equals(\"321cba\");\n        assert reverse2(\"abc123\").equals(\"321cba\");\n    }\n\n    /**\n     * easiest way to reverses the string str and returns it\n     *\n     * @param str string to be reversed\n     * @return reversed string\n     */\n    public static String reverse(String str) {\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    /**\n     * second way to reverses the string str and returns it\n     *\n     * @param str string to be reversed\n     * @return reversed string\n     */\n    public static String reverse2(String str) {\n\n        if (str == null || str.isEmpty()) {\n            return str;\n        }\n\n        char[] value = str.toCharArray();\n        for (int i = 0, j = str.length() - 1; i < j; i++, j--) {\n            char temp = value[i];\n            value[i] = value[j];\n            value[j] = temp;\n        }\n        return new String(value);\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Reverse String using different version\n */\npublic class ReverseString {\n\n    public static void main(String[] args) {\n        assert reverse(\"abc123\").equals(\"321cba\");\n        assert reverse2(\"abc123\").equals(\"321cba\");\n    }\n\n    /**\n     * easiest way to reverses the string str and returns it\n     *\n     * @param str string to be reversed\n     * @return reversed string\n     */\n    public static String reverse(String str) {\n        return new StringBuilder(str).reverse().toString();\n    }\n\n    /**\n     * second way to reverses the string str and returns it\n     *\n     * @param str string to be reversed\n     * @return reversed string\n     */\n    public static String reverse2(String str) {\n        if (str == null || str.isEmpty()) {\n            return str;\n        }\n\n        char[] value = str.toCharArray();\n        for (int i = 0, j = str.length() - 1; i < j; i++, j--) {\n            char temp = value[i];\n            value[i] = value[j];\n            value[j] = temp;\n        }\n        return new String(value);\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class ReverseStringTest {\n\n    @Test\n    public void ReverseStringTest() {\n        String input1 = \"Hello World\";\n        String input2 = \"helloworld\";\n        String input3 = \"123456789\";\n        String input4 = \"\";\n\n        String expectedOutput1 = \"dlroW olleH\";\n        String expectedOutput2 = \"dlrowolleh\";\n        String expectedOutput3 = \"987654321\";\n        String expectedOutput4 = \"\";\n\n        assertEquals(ReverseString.reverse(input1), expectedOutput1);\n        assertEquals(ReverseString.reverse(input2), expectedOutput2);\n        assertEquals(ReverseString.reverse(input3), expectedOutput3);\n        assertEquals(ReverseString.reverse(input4), expectedOutput4);\n\n        assertEquals(ReverseString.reverse2(input1), expectedOutput1);\n        assertEquals(ReverseString.reverse2(input2), expectedOutput2);\n        assertEquals(ReverseString.reverse2(input3), expectedOutput3);\n        assertEquals(ReverseString.reverse2(input4), expectedOutput4);\n    }\n}"
    },
    {
        "product_commit": "e4eb99ff189e6ec9db1640fbca1b875d36daa9b0",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/ciphers/a5/LFSR.java",
        "test_file_path": "src/test/java/com/thealgorithms/ciphers/a5/LFSRTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.ciphers.a5;\n\nimport java.util.BitSet;\n\npublic class LFSR implements BaseLFSR {\n    private final BitSet register;\n    private final int length;\n    private final int clockBitIndex;\n    private final int[] tappingBitsIndices;\n\n    public LFSR( int length, int clockBitIndex, int[] tappingBitsIndices ) {\n        this.length = length;\n        this.clockBitIndex = clockBitIndex;\n        this.tappingBitsIndices = tappingBitsIndices;\n        register = new BitSet( length );\n    }\n\n    @Override\n    public void initialize( BitSet sessionKey, BitSet frameCounter ) {\n        register.clear();\n        clock( sessionKey, SESSION_KEY_LENGTH );\n        clock( frameCounter, FRAME_COUNTER_LENGTH );\n    }\n\n    private void clock( BitSet key, int keyLength ) {\n        // We start from reverse because LFSR 0 index is the left most bit\n        // while key 0 index is right most bit, so we reverse it\n        for ( int i = keyLength - 1; i >= 0; --i ) {\n            var newBit = key.get( i ) ^ xorTappingBits();\n            pushBit( newBit );\n        }\n    }\n\n    @Override\n    public boolean clock() {\n        return pushBit( xorTappingBits() );\n    }\n\n    public boolean getClockBit() {\n        return register.get( clockBitIndex );\n    }\n\n    public boolean get( int bitIndex ) {\n        return register.get( bitIndex );\n    }\n\n    public boolean getLastBit() {\n        return register.get( length - 1 );\n    }\n\n    private boolean xorTappingBits() {\n        boolean result = false;\n        for ( int i : tappingBitsIndices ) {\n            result ^= register.get( i );\n        }\n        return result;\n    }\n\n    private boolean pushBit( boolean bit ) {\n        boolean discardedBit = rightShift();\n        register.set( 0, bit );\n        return discardedBit;\n    }\n\n    private boolean rightShift() {\n        boolean discardedBit = get( length - 1 );\n        for ( int i = length - 1; i > 0; --i ) {\n            register.set( i, get( i - 1 ) );\n        }\n        register.set( 0, false );\n        return discardedBit;\n    }\n\n    @Override\n    public String toString() {\n        return register.toString();\n    }\n}",
        "test_old_content": "package com.thealgorithms.ciphers.a5;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.BitSet;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\n// Basic tests for sanity check\nclass LFSRTest {\n    // Represents 0100 1110 0010 1111 0100 1101 0111 1100 0001 1110 1011 1000 1000 1011 0011 1010\n    // But we start reverse way because bitset starts from most right (1010)\n    byte[] sessionKeyBytes = { 58, (byte) 139, (byte) 184, 30, 124, 77, 47, 78 };\n\n    // Represents 11 1010 1011 0011 1100 1011\n    byte[] frameCounterBytes = { (byte) 203, (byte) 179, 58 };\n\n    @Test\n    void initialize() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        BitSet expected = new BitSet( 19 );\n        expected.set( 0 );\n        expected.set( 1 );\n        expected.set( 3 );\n        expected.set( 4 );\n        expected.set( 5 );\n        expected.set( 7 );\n        expected.set( 9 );\n        expected.set( 10 );\n        expected.set( 11 );\n        expected.set( 12 );\n        expected.set( 13 );\n        expected.set( 15 );\n        expected.set( 16 );\n        expected.set( 17 );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n        lfsr0.initialize( sessionKey, frameCounter );\n        assertEquals( expected.toString(), lfsr0.toString() );\n    }\n\n    @Test\n    void clock() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n        lfsr0.initialize( sessionKey, frameCounter );\n\n        BitSet expected = new BitSet( 19 );\n        expected.set( 0 );\n        expected.set( 1 );\n        expected.set( 2 );\n        expected.set( 4 );\n        expected.set( 5 );\n        expected.set( 6 );\n        expected.set( 8 );\n        expected.set( 10 );\n        expected.set( 11 );\n        expected.set( 12 );\n        expected.set( 13 );\n        expected.set( 14 );\n        expected.set( 16 );\n        expected.set( 17 );\n        expected.set( 18 );\n\n        lfsr0.clock();\n        assertEquals( expected.toString(), lfsr0.toString() );\n    }\n\n    @Test\n    void getClockBit() {\n        BitSet sessionKey = BitSet.valueOf( sessionKeyBytes );\n        BitSet frameCounter = BitSet.valueOf( frameCounterBytes );\n\n        LFSR lfsr0 = new LFSR( 19, 8, new int[]{ 13, 16, 17, 18 } );\n\n        assertFalse( lfsr0.getClockBit() );\n\n        lfsr0.initialize( sessionKey, frameCounter );\n\n        assertFalse( lfsr0.getClockBit() );\n    }\n}",
        "test_new_content": "package com.thealgorithms.ciphers.a5;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.util.BitSet;\nimport org.junit.jupiter.api.Test;\n\n// Basic tests for sanity check\nclass LFSRTest {\n\n    // Represents 0100 1110 0010 1111 0100 1101 0111 1100 0001 1110 1011 1000 1000 1011 0011 1010\n    // But we start reverse way because bitset starts from most right (1010)\n    byte[] sessionKeyBytes = {\n        58,\n        (byte) 139,\n        (byte) 184,\n        30,\n        124,\n        77,\n        47,\n        78,\n    };\n\n    // Represents 11 1010 1011 0011 1100 1011\n    byte[] frameCounterBytes = { (byte) 203, (byte) 179, 58 };\n\n    @Test\n    void initialize() {\n        BitSet sessionKey = BitSet.valueOf(sessionKeyBytes);\n        BitSet frameCounter = BitSet.valueOf(frameCounterBytes);\n\n        BitSet expected = new BitSet(19);\n        expected.set(0);\n        expected.set(1);\n        expected.set(3);\n        expected.set(4);\n        expected.set(5);\n        expected.set(7);\n        expected.set(9);\n        expected.set(10);\n        expected.set(11);\n        expected.set(12);\n        expected.set(13);\n        expected.set(15);\n        expected.set(16);\n        expected.set(17);\n\n        LFSR lfsr0 = new LFSR(19, 8, new int[] { 13, 16, 17, 18 });\n        lfsr0.initialize(sessionKey, frameCounter);\n        assertEquals(expected.toString(), lfsr0.toString());\n    }\n\n    @Test\n    void clock() {\n        BitSet sessionKey = BitSet.valueOf(sessionKeyBytes);\n        BitSet frameCounter = BitSet.valueOf(frameCounterBytes);\n\n        LFSR lfsr0 = new LFSR(19, 8, new int[] { 13, 16, 17, 18 });\n        lfsr0.initialize(sessionKey, frameCounter);\n\n        BitSet expected = new BitSet(19);\n        expected.set(0);\n        expected.set(1);\n        expected.set(2);\n        expected.set(4);\n        expected.set(5);\n        expected.set(6);\n        expected.set(8);\n        expected.set(10);\n        expected.set(11);\n        expected.set(12);\n        expected.set(13);\n        expected.set(14);\n        expected.set(16);\n        expected.set(17);\n        expected.set(18);\n\n        lfsr0.clock();\n        assertEquals(expected.toString(), lfsr0.toString());\n    }\n\n    @Test\n    void getClockBit() {\n        BitSet sessionKey = BitSet.valueOf(sessionKeyBytes);\n        BitSet frameCounter = BitSet.valueOf(frameCounterBytes);\n\n        LFSR lfsr0 = new LFSR(19, 8, new int[] { 13, 16, 17, 18 });\n\n        assertFalse(lfsr0.getClockBit());\n\n        lfsr0.initialize(sessionKey, frameCounter);\n\n        assertFalse(lfsr0.getClockBit());\n    }\n}"
    },
    {
        "product_commit": "8ca571d8870b20f1a15ca355bf612385291b9c5c",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/CollatzConjecture.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/CollatzConjectureTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * <a href=\"https://en.wikipedia.org/wiki/Collatz_conjecture\">...</a>\n */\npublic class CollatzConjecture {\n\n    /**\n     * Calculate the next number of the sequence.\n     *\n     * @param n current number of the sequence\n     * @return next number of the sequence\n     */\n    public int nextNumber(final int n) {\n        if (n % 2 == 0) {\n            return n / 2;\n        }\n        return 3 * n + 1;\n    }\n\n    /**\n     * Calculate the Collatz sequence of any natural number.\n     *\n     * @param firstNumber starting number of the sequence\n     * @return sequence of the Collatz Conjecture\n     */\n    public List<Integer> collatzConjecture(int firstNumber) {\n        if (firstNumber < 1) {\n            throw new IllegalArgumentException(\"Must be a natural number\");\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        result.add(firstNumber);\n        while (firstNumber != 1) {\n            result.add(nextNumber(firstNumber));\n            firstNumber = nextNumber(firstNumber);\n        }\n        return result;\n    }\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CollatzConjectureTest {\n\n    static CollatzConjecture cConjecture;\n\n    @BeforeAll\n    static void setUp() {\n        cConjecture = new CollatzConjecture();\n    }\n\n    @Test\n    void nextNumberFromEvenNumber() {\n        assertEquals(25, cConjecture.nextNumber(50));\n    }\n\n    @Test\n    void nextNumberFromOddNumber() {\n        assertEquals(154, cConjecture.nextNumber(51));\n    }\n\n    @Test\n    void collatzConjecture() {\n        final List<Integer> expected = List.of(35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1);\n        assertIterableEquals(expected, cConjecture.collatzConjecture(35));\n    }\n\n    @Test\n    void sequenceOfNotNaturalFirstNumber() {\n        assertThrows(IllegalArgumentException.class, () -> cConjecture.collatzConjecture(0));\n        assertThrows(IllegalArgumentException.class, () -> cConjecture.collatzConjecture(-1));\n    }\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\n\nclass CollatzConjectureTest {\n\n    static CollatzConjecture cConjecture;\n\n    @BeforeAll\n    static void setUp() {\n        cConjecture = new CollatzConjecture();\n    }\n\n    @Test\n    void nextNumberFromEvenNumber() {\n        assertEquals(25, cConjecture.nextNumber(50));\n    }\n\n    @Test\n    void nextNumberFromOddNumber() {\n        assertEquals(154, cConjecture.nextNumber(51));\n    }\n\n    @Test\n    void collatzConjecture() {\n        final List<Integer> expected = List.of(\n            35,\n            106,\n            53,\n            160,\n            80,\n            40,\n            20,\n            10,\n            5,\n            16,\n            8,\n            4,\n            2,\n            1\n        );\n        assertIterableEquals(expected, cConjecture.collatzConjecture(35));\n    }\n\n    @Test\n    void sequenceOfNotNaturalFirstNumber() {\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> cConjecture.collatzConjecture(0)\n        );\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> cConjecture.collatzConjecture(-1)\n        );\n    }\n}"
    },
    {
        "product_commit": "ea8e0463ef83293b32a6820f64173073e557596e",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/LiouvilleLambdaFunction.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/LiouvilleLambdaFunctionTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for liouville lambda function\n * For any positive integer n, define \u03bb(n) as the sum of the primitive nth roots of unity. \n * It has values in {\u22121, 1} depending on the factorization of n into prime factors:\n *   \u03bb(n) = +1 if n is a positive integer with an even number of prime factors.\n *   \u03bb(n) = \u22121 if n is a positive integer with an odd number of prime factors.\n * Wikipedia: https://en.wikipedia.org/wiki/Liouville_function\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\n\npublic class LiouvilleLambdaFunction {\n\n\t/**\n\t * This method returns \u03bb(n) of given number n\n\t *\n\t * @param number Integer value which \u03bb(n) is to be calculated \n\t * @return  1 when number has even number of prime factors\n\t *         -1 when number has odd number of prime factors\n\t * @throws IllegalArgumentException when number is negative\n\t */\n\tstatic int liouvilleLambda(int number) {\n\t\tif(number <= 0) {\n\t\t\t//throw exception when number is less than or is zero\n\t\t\tthrow new IllegalArgumentException(\"Number must be greater than zero.\");\n\t\t}\n\n\t\t//return 1 if size of prime factor list is even, -1 otherwise\n\t\treturn PrimeFactorization.pfactors(number).size() % 2 == 0 ? 1 : -1;\n\t}\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass LiouvilleLambdaFunctionTest {\n\n\t@Test\n\tvoid testLiouvilleLambdaMustThrowExceptionIfNumberIsZero() {\n\t\t//given\n\t\tint number = 0;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tLiouvilleLambdaFunction.liouvilleLambda(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustThrowExceptionIfNumberIsNegative() {\n\t\t//given\n\t\tint number = -1;\n\t\tString expectedMessage = \"Number must be greater than zero.\";\n\n\t\t//when\n\t\tException exception = assertThrows(IllegalArgumentException.class, () -> {\n\t\t\tLiouvilleLambdaFunction.liouvilleLambda(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustReturnNegativeOne() {\n\t\t//given\n\t\tint number = 11;\n\t\tint expectedOutput = -1;\n\n\t\t//when\n\t\tint actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n\t\t//then\n\t\tassertEquals(expectedOutput, actualOutput);\n\t}\n\n\t@Test\n\tvoid testLiouvilleLambdaMustReturnPositiveOne() {\n\t\t//given\n\t\tint number = 10;\n\t\tint expectedOutput = 1;\n\n\t\t//when\n\t\tint actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n\t\t//then\n\t\tassertEquals(expectedOutput, actualOutput);\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass LiouvilleLambdaFunctionTest {\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsZero() {\n        //given\n        int number = 0;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                LiouvilleLambdaFunction.liouvilleLambda(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustThrowExceptionIfNumberIsNegative() {\n        //given\n        int number = -1;\n        String expectedMessage = \"Number must be greater than zero.\";\n\n        //when\n        Exception exception = assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                LiouvilleLambdaFunction.liouvilleLambda(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnNegativeOne() {\n        //given\n        int number = 11;\n        int expectedOutput = -1;\n\n        //when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        //then\n        assertEquals(expectedOutput, actualOutput);\n    }\n\n    @Test\n    void testLiouvilleLambdaMustReturnPositiveOne() {\n        //given\n        int number = 10;\n        int expectedOutput = 1;\n\n        //when\n        int actualOutput = LiouvilleLambdaFunction.liouvilleLambda(number);\n\n        //then\n        assertEquals(expectedOutput, actualOutput);\n    }\n}"
    },
    {
        "product_commit": "2fbb1d64029b6a842cc1d70cdfaed3800d69bf03",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/others/cn/HammingDistance.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/cn/HammingDistanceTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others.cn;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class HammingDistance {\n\n\n\n    public int getHammingDistanceBetweenBits(String senderBits, String receiverBits) {\n\n        if(senderBits.length() != receiverBits.length()) {\n            throw new IllegalArgumentException(\"Sender and Receiver bits should be same\");\n        }\n\n        List<byte[]> byteArray = new ArrayList<>();\n\n        byteArray.add(senderBits.getBytes());\n        byteArray.add(receiverBits.getBytes());\n\n\n        byte[] senderData = byteArray.get(0);\n        byte[] receiverData = byteArray.get(1);\n\n        int totalErrorBitCount = 0;\n\n        for(int i = 0; i < senderData.length; i++){\n           totalErrorBitCount += senderData[i] ^ receiverData[i];\n        }\n\n        if(totalErrorBitCount == 0){\n            System.out.println(\"No Error bit in data segments\");\n        } else{\n            System.out.println(\"Total Error bit count \"+totalErrorBitCount);\n        }\n        return totalErrorBitCount;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n     void initialize(){\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits(){\n         String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n/*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength(){\n       String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n\n    @Test\n    public void checkForSameBits(){\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits(){\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits(){\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, () ->{\n            int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        });\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n\n    }\n\n    @Test\n    public void checkForLongDataBitsSame(){\n        String senderBits = \"10010101101010000100110100\", receiverBits = \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n\n\n}",
        "test_new_content": "package com.thealgorithms.others.cn;\n\nimport org.assertj.core.api.Assertions;\nimport org.assertj.core.api.ThrowableTypeAssert;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\npublic class HammingDistanceTest {\n\n    HammingDistance hd;\n\n    @BeforeEach\n    void initialize() {\n        hd = new HammingDistance();\n    }\n\n    @Test\n    public void checkForDifferentBits() {\n        String senderBits = \"000\", receiverBits = \"011\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(2);\n    }\n\n    /*\n\n    1 0 1 0 1\n    1 1 1 1 0\n    ----------\n    0 1 0 1 1\n\n\n */\n    @Test\n    public void checkForDifferentBitsLength() {\n        String senderBits = \"10101\", receiverBits = \"11110\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(3);\n    }\n\n    @Test\n    public void checkForSameBits() {\n        String senderBits = \"111\", receiverBits = \"111\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n\n    @Test\n    public void checkForLongDataBits() {\n        String senderBits = \"10010101101010000100110100\", receiverBits =\n            \"00110100001011001100110101\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(7);\n    }\n\n    @Test\n    public void mismatchDataBits() {\n        String senderBits = \"100010\", receiverBits = \"00011\";\n\n        Exception ex = org.junit.jupiter.api.Assertions.assertThrows(\n            IllegalArgumentException.class,\n            () -> {\n                int answer = hd.getHammingDistanceBetweenBits(\n                    senderBits,\n                    receiverBits\n                );\n            }\n        );\n\n        Assertions.assertThat(ex.getMessage()).contains(\"bits should be same\");\n    }\n\n    @Test\n    public void checkForLongDataBitsSame() {\n        String senderBits = \"10010101101010000100110100\", receiverBits =\n            \"10010101101010000100110100\";\n        int answer = hd.getHammingDistanceBetweenBits(senderBits, receiverBits);\n        Assertions.assertThat(answer).isEqualTo(0);\n    }\n}"
    },
    {
        "product_commit": "07a5531f1a7b22782c2ca899550c7a6f52154343",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PrimeFactorization.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PrimeFactorizationTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.Scanner;\n\npublic class PrimeFactorization {\n\n    public static void main(String[] args) {\n        System.out.println(\"## all prime factors ##\");\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter a number: \");\n        int n = scanner.nextInt();\n        System.out.print((\"printing factors of \" + n + \" : \"));\n        pfactors(n);\n        scanner.close();\n    }\n\n    public static void pfactors(int n) {\n\n        while (n % 2 == 0) {\n            System.out.print(2 + \" \");\n            n /= 2;\n        }\n\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            while (n % i == 0) {\n                System.out.print(i + \" \");\n                n /= i;\n            }\n        }\n\n        if (n > 2) {\n            System.out.print(n);\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Authors: \n * (1) Aitor Fidalgo S\u00e1nchez (https://github.com/aitorfi) \n * (2) Akshay Dubey (https://github.com/itsAkshayDubey)\n*/\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PrimeFactorization {\n\n\tpublic static List<Integer> pfactors(int n) {\n\t\t\n\t\tList<Integer> primeFactors = new ArrayList<>();\n\n\t\tif (n == 0) {\n\t\t\treturn primeFactors;\n\t\t}\n\n\t\twhile (n % 2 == 0) {\n\t\t\tprimeFactors.add(2);\n\t\t\tn /= 2;\n\t\t}\n\n\t\tfor (int i = 3; i <= Math.sqrt(n); i += 2) {\n\t\t\twhile (n % i == 0) {\n\t\t\t\tprimeFactors.add(i);\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t}\n\n\t\tif (n > 2) {\n\t\t\tprimeFactors.add(n);\n\t\t}\n\t\treturn primeFactors;\n\t}\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nclass PrimeFactorizationTest {\n\n\t@Test\n\tvoid testpFactorsMustReturnEmptyList() {\n\t\t//given\n\t\tint n = 0; \n\t\t\n\t\t//then\n\t\tassertTrue(PrimeFactorization.pfactors(n).isEmpty());\n\t}\n\t\n\t@Test\n\tvoid testpFactorsMustReturnNonEmptyList() {\n\t\t//given\n\t\tint n = 198;\n\t\tint expectedListSize = 4;\n\t\t\n\t\t//when\n\t\tList<Integer> actualResultList = PrimeFactorization.pfactors(n);\n\t\t\n\t\t//then\n\t\tassertEquals(expectedListSize, actualResultList.size());\n\t\tassertEquals(2, actualResultList.get(0));\n\t\tassertEquals(3, actualResultList.get(1));\n\t\tassertEquals(3, actualResultList.get(2));\n\t\tassertEquals(11, actualResultList.get(3));\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\nclass PrimeFactorizationTest {\n\n    @Test\n    void testpFactorsMustReturnEmptyList() {\n        //given\n        int n = 0;\n\n        //then\n        assertTrue(PrimeFactorization.pfactors(n).isEmpty());\n    }\n\n    @Test\n    void testpFactorsMustReturnNonEmptyList() {\n        //given\n        int n = 198;\n        int expectedListSize = 4;\n\n        //when\n        List<Integer> actualResultList = PrimeFactorization.pfactors(n);\n\n        //then\n        assertEquals(expectedListSize, actualResultList.size());\n        assertEquals(2, actualResultList.get(0));\n        assertEquals(3, actualResultList.get(1));\n        assertEquals(3, actualResultList.get(2));\n        assertEquals(11, actualResultList.get(3));\n    }\n}"
    },
    {
        "product_commit": "d56eaa58af12ea54c4db7a974074c19f886bc332",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/LRUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/LRUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Least recently used (LRU)\n * <p>\n * Discards the least recently used items first. This algorithm requires keeping\n * track of what was used when, which is expensive if one wants to make sure the\n * algorithm always discards the least recently used item.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class LRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public LRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    public LRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        Entry<K, V> evicted = head;\n        head = evicted.getNextEntry();\n        head.setPreEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveNodeToLast(entry);\n        return entry.getValue();\n    }\n\n    private void moveNodeToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> existingEntry = data.get(key);\n            existingEntry.setValue(value);\n            moveNodeToLast(existingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        final LRUCache<String, Integer> cache = new LRUCache<>(2);\n        cache.put(\"Key1\", 1);\n        cache.put(\"Key2\", 2);\n        cache.put(\"Key3\", 3);\n        cache.put(\"Key4\", 4);\n        System.out.println(\"getValue(Key1): \" + cache.get(\"Key1\"));\n        System.out.println(\"getValue(Key2): \" + cache.get(\"Key2\"));\n        System.out.println(\"getValue(Key3): \" + cache.get(\"Key3\"));\n        System.out.println(\"getValue(Key4): \" + cache.get(\"Key4\"));\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Least recently used (LRU)\n * <p>\n * Discards the least recently used items first. This algorithm requires keeping\n * track of what was used when, which is expensive if one wants to make sure the\n * algorithm always discards the least recently used item.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class LRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public LRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    public LRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        Entry<K, V> evicted = head;\n        head = evicted.getNextEntry();\n        head.setPreEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveNodeToLast(entry);\n        return entry.getValue();\n    }\n\n    private void moveNodeToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> existingEntry = data.get(key);\n            existingEntry.setValue(value);\n            moveNodeToLast(existingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        LRUCache<Integer, Integer> lruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        LRUCache<String, String> lruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n\n        for(int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class LRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        LRUCache<Integer, Integer> lruCache = new LRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        LRUCache<String, String> lruCache = new LRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        LRUCache<Integer, Integer> mruCache = new LRUCache<>(SIZE);\n\n        for (int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}"
    },
    {
        "product_commit": "d56eaa58af12ea54c4db7a974074c19f886bc332",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/caches/MRUCache.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/caches/MRUCacheTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Most recently used (MRU)\n * <p>\n * In contrast to Least Recently Used (LRU), MRU discards the most recently used\n * items first.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Most_recently_used_(MRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class MRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public MRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        final Entry<K, V> evicted = this.tail;\n        tail = evicted.getPreEntry();\n        tail.setNextEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    public MRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveEntryToLast(entry);\n        return entry.getValue();\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> exitingEntry = data.get(key);\n            exitingEntry.setValue(value);\n            moveEntryToLast(exitingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    private void moveEntryToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        final MRUCache<String, Integer> cache = new MRUCache<>(2);\n        cache.put(\"Key1\", 1);\n        cache.put(\"Key2\", 2);\n        cache.put(\"Key3\", 3);\n        cache.put(\"Key4\", 4);\n        System.out.println(\"getValue(Key1): \" + cache.get(\"Key1\"));\n        System.out.println(\"getValue(Key2): \" + cache.get(\"Key2\"));\n        System.out.println(\"getValue(Key3): \" + cache.get(\"Key3\"));\n        System.out.println(\"getValue(Key4): \" + cache.get(\"Key4\"));\n    }\n}",
        "product_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Most recently used (MRU)\n * <p>\n * In contrast to Least Recently Used (LRU), MRU discards the most recently used\n * items first.\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#Most_recently_used_(MRU)\n *\n * @param <K> key type\n * @param <V> value type\n */\npublic class MRUCache<K, V> {\n\n    private final Map<K, Entry<K, V>> data = new HashMap<>();\n    private Entry<K, V> head;\n    private Entry<K, V> tail;\n    private int cap;\n    private static final int DEFAULT_CAP = 100;\n\n    public MRUCache() {\n        setCapacity(DEFAULT_CAP);\n    }\n\n    private void setCapacity(int newCapacity) {\n        checkCapacity(newCapacity);\n        for (int i = data.size(); i > newCapacity; i--) {\n            Entry<K, V> evicted = evict();\n            data.remove(evicted.getKey());\n        }\n        this.cap = newCapacity;\n    }\n\n    private void checkCapacity(int capacity) {\n        if (capacity <= 0) {\n            throw new RuntimeException(\"capacity must greater than 0!\");\n        }\n    }\n\n    private Entry<K, V> evict() {\n        if (head == null) {\n            throw new RuntimeException(\"cache cannot be empty!\");\n        }\n        final Entry<K, V> evicted = this.tail;\n        tail = evicted.getPreEntry();\n        tail.setNextEntry(null);\n        evicted.setNextEntry(null);\n        return evicted;\n    }\n\n    public MRUCache(int cap) {\n        setCapacity(cap);\n    }\n\n    public V get(K key) {\n        if (!data.containsKey(key)) {\n            return null;\n        }\n        final Entry<K, V> entry = data.get(key);\n        moveEntryToLast(entry);\n        return entry.getValue();\n    }\n\n    public void put(K key, V value) {\n        if (data.containsKey(key)) {\n            final Entry<K, V> exitingEntry = data.get(key);\n            exitingEntry.setValue(value);\n            moveEntryToLast(exitingEntry);\n            return;\n        }\n        Entry<K, V> newEntry;\n        if (data.size() == cap) {\n            newEntry = evict();\n            data.remove(newEntry.getKey());\n        } else {\n            newEntry = new Entry<>();\n        }\n        newEntry.setKey(key);\n        newEntry.setValue(value);\n        addNewEntry(newEntry);\n        data.put(key, newEntry);\n    }\n\n    private void addNewEntry(Entry<K, V> newEntry) {\n        if (data.isEmpty()) {\n            head = newEntry;\n            tail = newEntry;\n            return;\n        }\n        tail.setNextEntry(newEntry);\n        newEntry.setPreEntry(tail);\n        newEntry.setNextEntry(null);\n        tail = newEntry;\n    }\n\n    private void moveEntryToLast(Entry<K, V> entry) {\n        if (tail == entry) {\n            return;\n        }\n        final Entry<K, V> preEntry = entry.getPreEntry();\n        final Entry<K, V> nextEntry = entry.getNextEntry();\n        if (preEntry != null) {\n            preEntry.setNextEntry(nextEntry);\n        }\n        if (nextEntry != null) {\n            nextEntry.setPreEntry(preEntry);\n        }\n        if (head == entry) {\n            head = nextEntry;\n        }\n        tail.setNextEntry(entry);\n        entry.setPreEntry(tail);\n        entry.setNextEntry(null);\n        tail = entry;\n    }\n\n    static final class Entry<I, J> {\n\n        private Entry<I, J> preEntry;\n        private Entry<I, J> nextEntry;\n        private I key;\n        private J value;\n\n        public Entry() {\n        }\n\n        public Entry(Entry<I, J> preEntry, Entry<I, J> nextEntry, I key, J value) {\n            this.preEntry = preEntry;\n            this.nextEntry = nextEntry;\n            this.key = key;\n            this.value = value;\n        }\n\n        public Entry<I, J> getPreEntry() {\n            return preEntry;\n        }\n\n        public void setPreEntry(Entry<I, J> preEntry) {\n            this.preEntry = preEntry;\n        }\n\n        public Entry<I, J> getNextEntry() {\n            return nextEntry;\n        }\n\n        public void setNextEntry(Entry<I, J> nextEntry) {\n            this.nextEntry = nextEntry;\n        }\n\n        public I getKey() {\n            return key;\n        }\n\n        public void setKey(I key) {\n            this.key = key;\n        }\n\n        public J getValue() {\n            return value;\n        }\n\n        public void setValue(J value) {\n            this.value = value;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.caches;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class MRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        MRUCache<Integer, Integer> lruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        MRUCache<String, String> lruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for(int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n\n        for(int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.caches;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport org.junit.jupiter.api.Test;\n\npublic class MRUCacheTest {\n\n    private static final int SIZE = 5;\n\n    @Test\n    public void putAndGetIntegerValues() {\n        MRUCache<Integer, Integer> lruCache = new MRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(i, i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(i, lruCache.get(i));\n        }\n    }\n\n    @Test\n    public void putAndGetStringValues() {\n        MRUCache<String, String> lruCache = new MRUCache<>(SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            lruCache.put(\"key\" + i, \"value\" + i);\n        }\n\n        for (int i = 0; i < SIZE; i++) {\n            assertEquals(\"value\" + i, lruCache.get(\"key\" + i));\n        }\n    }\n\n    @Test\n    public void nullKeysAndValues() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n        mruCache.put(null, 2);\n        mruCache.put(6, null);\n\n        assertEquals(2, mruCache.get(null));\n        assertNull(mruCache.get(6));\n    }\n\n    @Test\n    public void overCapacity() {\n        MRUCache<Integer, Integer> mruCache = new MRUCache<>(SIZE);\n\n        for (int i = 0; i < 10; i++) {\n            mruCache.put(i, i);\n        }\n\n        assertEquals(9, mruCache.get(9));\n    }\n}"
    },
    {
        "product_commit": "a2dd154ad65fc1199d97d793afb4fe0082a8db67",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/sorts/BubbleSort.java",
        "test_file_path": "src/test/java/com/thealgorithms/sorts/BubbleSortTest.java",
        "product_old_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass BubbleSort implements SortAlgorithm {\n\n    /**\n     * Implements generic bubble sort algorithm.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the type of elements in the array.\n     * @return the sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1, size = array.length; i < size; ++i) {\n            boolean swapped = false;\n            for (int j = 0; j < size - i; ++j) {\n                if (greater(array[j], array[j + 1])) {\n                    swap(array, j, j + 1);\n                    swapped = true;\n                }\n            }\n            if (!swapped) {\n                break;\n            }\n        }\n        return array;\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n\n        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n        BubbleSort bubbleSort = new BubbleSort();\n        bubbleSort.sort(integers);\n\n        for (int i = 0; i < integers.length - 1; ++i) {\n            assert integers[i] <= integers[i + 1];\n        }\n        print(integers);\n        /* output: [1, 4, 6, 9, 12, 23, 54, 78, 231] */\n\n        String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n        bubbleSort.sort(strings);\n        for (int i = 0; i < strings.length - 1; i++) {\n            assert strings[i].compareTo(strings[i + 1]) <= 0;\n        }\n        print(bubbleSort.sort(strings));\n        /* output: [a, b, c, d, e] */\n    }\n}",
        "product_new_content": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass BubbleSort implements SortAlgorithm {\n\n    /**\n     * Implements generic bubble sort algorithm.\n     *\n     * @param array the array to be sorted.\n     * @param <T> the type of elements in the array.\n     * @return the sorted array.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        for (int i = 1, size = array.length; i < size; ++i) {\n            boolean swapped = false;\n            for (int j = 0; j < size - i; ++j) {\n                if (greater(array[j], array[j + 1])) {\n                    swap(array, j, j + 1);\n                    swapped = true;\n                }\n            }\n            if (!swapped) {\n                break;\n            }\n        }\n        return array;\n    }\n}",
        "test_old_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Aitor Fidalgo (https://github.com/aitorfi)\n * @see BubbleSort\n */\npublic class BubbleSortTest {\n    private BubbleSort bubbleSort = new BubbleSort();\n\n    @Test\n    public void bubbleSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortSingleIntegerElementArray() {\n        Integer[] inputArray = {4};\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {4};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortSingleStringElementArray() {\n        String[] inputArray = {\"s\"};\n        String[] outputArray = bubbleSort.sort(inputArray);\n        String[] expectedOutput = {\"s\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortIntegerArray() {\n        Integer[] inputArray = {4, 23, -6, 78, 1, 54, 23, -6, -231, 9, 12};\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {-231, -6, -6, 1, 4, 9, 12, 23, 23, 54, 78};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortStringArray() {\n        String[] inputArray = {\"cbf\", \"auk\", \"\u00f3\", \"(b\", \"a\", \")\", \"au\", \"\u00e1\", \"cba\", \"auk\", \"(a\", \"bhy\", \"cba\"};\n        String[] outputArray = bubbleSort.sort(inputArray);\n        String[] expectedOutput = {\"(a\", \"(b\", \")\", \"a\", \"au\", \"auk\", \"auk\", \"bhy\", \"cba\", \"cba\", \"cbf\", \"\u00e1\", \"\u00f3\"};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}",
        "test_new_content": "package com.thealgorithms.sorts;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * @author Aitor Fidalgo (https://github.com/aitorfi)\n * @see BubbleSort\n */\npublic class BubbleSortTest {\n\n    private BubbleSort bubbleSort = new BubbleSort();\n\n    @Test\n    public void bubbleSortEmptyArray() {\n        Integer[] inputArray = {};\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {};\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortSingleIntegerElementArray() {\n        Integer[] inputArray = { 4 };\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = { 4 };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortSingleStringElementArray() {\n        String[] inputArray = { \"s\" };\n        String[] outputArray = bubbleSort.sort(inputArray);\n        String[] expectedOutput = { \"s\" };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortIntegerArray() {\n        Integer[] inputArray = { 4, 23, -6, 78, 1, 54, 23, -6, -231, 9, 12 };\n        Integer[] outputArray = bubbleSort.sort(inputArray);\n        Integer[] expectedOutput = {\n            -231,\n            -6,\n            -6,\n            1,\n            4,\n            9,\n            12,\n            23,\n            23,\n            54,\n            78,\n        };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n\n    @Test\n    public void bubbleSortStringArray() {\n        String[] inputArray = {\n            \"cbf\",\n            \"auk\",\n            \"\u00f3\",\n            \"(b\",\n            \"a\",\n            \")\",\n            \"au\",\n            \"\u00e1\",\n            \"cba\",\n            \"auk\",\n            \"(a\",\n            \"bhy\",\n            \"cba\",\n        };\n        String[] outputArray = bubbleSort.sort(inputArray);\n        String[] expectedOutput = {\n            \"(a\",\n            \"(b\",\n            \")\",\n            \"a\",\n            \"au\",\n            \"auk\",\n            \"auk\",\n            \"bhy\",\n            \"cba\",\n            \"cba\",\n            \"cbf\",\n            \"\u00e1\",\n            \"\u00f3\",\n        };\n        assertArrayEquals(outputArray, expectedOutput);\n    }\n}"
    },
    {
        "product_commit": "a41656a31130f74634e88b9c2a9f747827d0dbb2",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/maths/PollardRho.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/PollardRhoTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.maths;\n\n/*\n * Java program for pollard rho algorithm\n * The algorithm is used to factorize a number n = pq,\n * where p is a non-trivial factor. \n * Pollard's rho algorithm is an algorithm for integer factorization\n * and it takes as its inputs n, the integer to be factored; \n * and g(x), a polynomial in x computed modulo n.\n * In the original algorithm, g(x) = ((x ^ 2) \u2212 1) mod n,\n * but nowadays it is more common to use g(x) = ((x ^ 2) + 1 ) mod n. \n * The output is either a non-trivial factor of n, or failure.\n * It performs the following steps:\n *     x \u2190 2\n *     y \u2190 2\n *     d \u2190 1\n\n *     while d = 1:\n *         x \u2190 g(x)\n *         y \u2190 g(g(y))\n *         d \u2190 gcd(|x - y|, n)\n\n *     if d = n: \n *         return failure\n *     else:\n *         return d\n\n * Here x and y corresponds to xi and xj in the previous section. \n * Note that this algorithm may fail to find a nontrivial factor even when n is composite.\n * In that case, the method can be tried again, using a starting value other than 2 or a different g(x)\n * \n * Wikipedia: https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n * \n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n * \n * */\npublic class PollardRho {\n\t\n\t/**\n\t * This method returns a polynomial in x computed modulo n\n\t *\n\t * @param base Integer base of the polynomial\n\t * @param modulus Integer is value which is to be used to perform modulo operation over the polynomial \n\t * @return Integer (((base * base) - 1) % modulus)\n\t */\n\tstatic int g(int base,int modulus) {\n\t\treturn ((base * base) - 1) % modulus;\n\t}\n\t\n\t/**\n\t * This method returns a non-trivial factor of given integer number  \n\t *\n\t * @param number Integer is a integer value whose non-trivial factor is to be found\n\t * @return Integer non-trivial factor of number\n\t * @throws RuntimeException object if GCD of given number cannot be found\n\t */\n\tstatic int pollardRho(int number) {\n\t\tint x = 2, y = 2, d = 1;\n\t\twhile(d == 1) {\n\t\t\t//tortoise move\n\t\t\tx = g(x, number);\n\t\t\t\n\t\t\t//hare move\n\t\t\ty = g(g(y, number), number);\n\t\t\t\n\t\t\t//check GCD of |x-y| and number\n\t\t\td = GCD.gcd(Math.abs(x - y), number);\n\t\t}\n\t\tif(d == number) {\n\t\t\tthrow new RuntimeException(\"GCD cannot be found.\");\n\t\t}\n\t\treturn d;\n\t}\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass PollardRhoTest {\n\n\t@Test\n\tvoid testPollardRhoForNumber315MustReturn5() {\n\t\t//given\n\t\tint number = 315;\n\t\tint expectedResult = 5;\n\n\t\t//when\n\t\tint actualResult = PollardRho.pollardRho(number);\n\n\t\t//then\n\t\tassertEquals(expectedResult, actualResult);\n\t}\n\n\t@Test\n\tvoid testPollardRhoForNumber187MustReturn11() {\n\t\t//given\n\t\tint number = 187;\n\t\tint expectedResult = 11;\n\n\t\t//when\n\t\tint actualResult = PollardRho.pollardRho(number);\n\n\t\t//then\n\t\tassertEquals(expectedResult, actualResult);\n\t}\n\n\t@Test\n\tvoid testPollardRhoForNumber239MustThrowException() {\n\t\t//given\n\t\tint number = 239;\n\t\tString expectedMessage = \"GCD cannot be found.\";\n\n\t\t//when\n\t\tException exception = assertThrows(RuntimeException.class, () -> {\n\t\t\tPollardRho.pollardRho(number);\n\t\t});\n\t\tString actualMessage = exception.getMessage();\n\n\t\t//then\n\t\tassertEquals(expectedMessage, actualMessage);\n\t}\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport org.junit.jupiter.api.Test;\n\nclass PollardRhoTest {\n\n    @Test\n    void testPollardRhoForNumber315MustReturn5() {\n        //given\n        int number = 315;\n        int expectedResult = 5;\n\n        //when\n        int actualResult = PollardRho.pollardRho(number);\n\n        //then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber187MustReturn11() {\n        //given\n        int number = 187;\n        int expectedResult = 11;\n\n        //when\n        int actualResult = PollardRho.pollardRho(number);\n\n        //then\n        assertEquals(expectedResult, actualResult);\n    }\n\n    @Test\n    void testPollardRhoForNumber239MustThrowException() {\n        //given\n        int number = 239;\n        String expectedMessage = \"GCD cannot be found.\";\n\n        //when\n        Exception exception = assertThrows(\n            RuntimeException.class,\n            () -> {\n                PollardRho.pollardRho(number);\n            }\n        );\n        String actualMessage = exception.getMessage();\n\n        //then\n        assertEquals(expectedMessage, actualMessage);\n    }\n}"
    },
    {
        "product_commit": "9c418ba827605589485be4ef28fed28f3f9e9c61",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/strings/Pangram.java",
        "test_file_path": "src/test/java/com/thealgorithms/strings/PangramTest.java",
        "product_old_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\");\n        /* not exists l character */\n    }\n\n    /**\n     * Check if a string is a pangram string or not\n     *\n     * @param s string to check\n     * @return {@code true} if given string is pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] marked = new boolean[26];\n        /* by default all letters don't exists */\n        char[] values = s.toCharArray();\n        for (char value : values) {\n            if (Character.isLetter(value)) {\n                int index = Character.isUpperCase(value) ? value - 'A' : value - 'a';\n                marked[index] = true;\n                /* mark current character exists */\n            }\n        }\n\n        for (boolean b : marked) {\n            if (!b) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "product_new_content": "package com.thealgorithms.strings;\n\n/**\n * Wikipedia: https://en.wikipedia.org/wiki/Pangram\n */\npublic class Pangram {\n\n    /**\n     * Test code\n     */\n    public static void main(String[] args) {\n        assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n        assert !isPangram(\"The quick brown fox jumps over the azy dog\"); // L is missing\n        assert !isPangram(\"+-1234 This string is not alphabetical\");\n        assert !isPangram(\"\\u0000/\\\\\");\n    }\n\n    /**\n     * Checks if a String is considered a Pangram\n     *\n     * @param s The String to check\n     * @return {@code true} if s is a Pangram, otherwise {@code false}\n     */\n    public static boolean isPangram(String s) {\n        boolean[] lettersExisting = new boolean[26];\n        for (char c : s.toCharArray()) {\n            int letterIndex = c - (Character.isUpperCase(c) ? 'A' : 'a');\n            if (letterIndex >= 0 && letterIndex < lettersExisting.length) {\n                lettersExisting[letterIndex] = true;\n            }\n        }\n        for (boolean letterFlag : lettersExisting) {\n            if (!letterFlag) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "test_old_content": "package com.thealgorithms.strings;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static com.thealgorithms.strings.Pangram.isPangram;\n\n\npublic class PangramTest {\n    @Test\n    public void testPangram() {\n        assertTrue(isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}",
        "test_new_content": "package com.thealgorithms.strings;\n\nimport static com.thealgorithms.strings.Pangram.isPangram;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class PangramTest {\n\n    @Test\n    public void testPangram() {\n        assertTrue(isPangram(\"The quick brown fox jumps over the lazy dog\"));\n        assertFalse(isPangram(\"The quick brown fox jumps over the azy dog\")); // L is missing\n        assertFalse(isPangram(\"+-1234 This string is not alphabetical\"));\n        assertFalse(isPangram(\"\\u0000/\\\\ Invalid characters are alright too\"));\n    }\n}"
    },
    {
        "product_commit": "8f18b92f6e19fe44595fb5c167a1b83d6ca4a16f",
        "test_commit": "e96f567bfc6e980dc5c4c48ccf185d7f7c7108ab",
        "product_file_path": "src/main/java/com/thealgorithms/others/countSetBits.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/countSetBitsTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\n\npublic class countSetBits {\n    /** \n     * The below algorithm is called as Brian Kernighan's algorithm \n     * We can use Brian Kernighan\u2019s algorithm to improve the above naive algorithm\u2019s performance. The idea is to only consider the set bits of an integer by turning off its rightmost set bit (after counting it), so the next iteration of the loop considers the next rightmost bit.\n\n        The expression n & (n-1) can be used to turn off the rightmost set bit of a number n. This works as the expression n-1 flips all the bits after the rightmost set bit of n, including the rightmost set bit itself. Therefore, n & (n-1) results in the last bit flipped of n.\n\n        For example, consider number 52, which is 00110100 in binary, and has a total 3 bits set.\n\n        1st iteration of the loop: n = 52\n        \n        00110100    &               (n)\n        00110011                    (n-1)\n        ~~~~~~~~\n        00110000\n        \n        \n        2nd iteration of the loop: n = 48\n        \n        00110000    &               (n)\n        00101111                    (n-1)\n        ~~~~~~~~\n        00100000\n        \n        \n        3rd iteration of the loop: n = 32\n        \n        00100000    &               (n)\n        00011111                    (n-1)\n        ~~~~~~~~\n        00000000                    (n = 0)\n        \n     * @param num takes Long number whose number of set bit is to be found\n     * @return the count of set bits in the binary equivalent\n    */\n    public long countsetBits(long num){\n        long cnt=0;\n        while(num>0){\n            cnt++;\n            num&=(num-1);\n        }\n        return cnt;\n    }\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\npublic class countSetBitsTest {\n    @Test\n    void testSetBits(){\n        countSetBits csb= new countSetBits();\n        assertEquals(1L,csb.countsetBits(16));\n        assertEquals(4, csb.countsetBits(15));\n        assertEquals(5, csb.countsetBits(10000));\n        assertEquals(5, csb.countsetBits(31));\n    }\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class countSetBitsTest {\n\n    @Test\n    void testSetBits() {\n        countSetBits csb = new countSetBits();\n        assertEquals(1L, csb.countsetBits(16));\n        assertEquals(4, csb.countsetBits(15));\n        assertEquals(5, csb.countsetBits(10000));\n        assertEquals(5, csb.countsetBits(31));\n    }\n}"
    },
    {
        "product_commit": "e59568bc5e1b0aabc41bef8de0c0da918baa9bfd",
        "test_commit": "d14a5d1eed14ca9aee01e2f775c7a3128ef20659",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/lists/SkipList.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/lists/SkipListTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Skip list is a data structure that allows {@code O(log n)} search complexity\n * as well as {@code O(log n)} insertion complexity within an ordered sequence\n * of {@code n} elements. Thus it can get the best features of a sorted array\n * (for searching) while maintaining a linked list-like structure that allows\n * insertion, which is not possible with a static array.\n * <p>\n * A skip list is built in layers. The bottom layer is an ordinary ordered\n * linked list. Each higher layer acts as an \"express lane\" for the lists\n * below.\n * <pre>\n * [ ] ------> [ ] --> [ ]\n * [ ] --> [ ] [ ] --> [ ]\n * [ ] [ ] [ ] [ ] [ ] [ ]\n *  H   0   1   2   3   4\n * </pre>\n *\n * @param <E> type of elements\n * @see <a href=\"https://en.wikipedia.org/wiki/Skip_list\">Wiki. Skip list</a>\n */\npublic class SkipList<E extends Comparable<E>> {\n\n    /**\n     * Node before first node.\n     */\n    private final Node<E> head;\n\n    /**\n     * Maximum layers count.\n     * Calculated by {@link #heightStrategy}.\n     */\n    private final int height;\n\n    /**\n     * Function for determining height of new nodes.\n     * @see HeightStrategy\n     */\n    private final HeightStrategy heightStrategy;\n\n    /**\n     * Current count of elements in list.\n     */\n    private int size;\n\n    private static final int DEFAULT_CAPACITY = 100;\n\n    public SkipList() {\n        this(DEFAULT_CAPACITY, new BernoulliHeightStrategy());\n    }\n\n    public SkipList(int expectedCapacity, HeightStrategy heightStrategy) {\n        this.heightStrategy = heightStrategy;\n        this.height = heightStrategy.height(expectedCapacity);\n        this.head = new Node<>(null, this.height);\n        this.size = 0;\n    }\n\n    public void add(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n        Node<E>[] toFix = new Node[height + 1];\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (next == null || next.getValue().compareTo(e) > 0) {\n                toFix[layer] = current;\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        int nodeHeight = heightStrategy.nodeHeight(height);\n        Node<E> node = new Node<>(e, nodeHeight);\n        for (int i = 0; i <= nodeHeight; i++) {\n            if (toFix[i].next(i) != null) {\n                node.setNext(i, toFix[i].next(i));\n                toFix[i].next(i).setPrevious(i, node);\n            }\n\n            toFix[i].setNext(i, node);\n            node.setPrevious(i, toFix[i]);\n        }\n        size++;\n    }\n\n    public E get(int index) {\n        int counter = -1; // head index\n        Node<E> current = head;\n        while (counter != index) {\n            current = current.next(0);\n            counter++;\n        }\n        return current.value;\n    }\n\n    public void remove(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                break;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        for (int i = 0; i <= layer; i++) {\n            current.previous(i).setNext(i, current.next(i));\n            current.next(i).setPrevious(i, current.previous(i));\n        }\n        size--;\n    }\n\n    /**\n     * A search for a target element begins at the head element in the top\n     * list, and proceeds horizontally until the current element is greater\n     * than or equal to the target. If the current element is equal to the\n     * target, it has been found. If the current element is greater than the\n     * target, or the search reaches the end of the linked list, the procedure\n     * is repeated after returning to the previous element and dropping down\n     * vertically to the next lower list.\n     *\n     * @param e element whose presence in this list is to be tested\n     * @return true if this list contains the specified element\n     */\n    public boolean contains(E e) {\n        Objects.requireNonNull(e);\n        Node<E> current = head;\n        int layer = height;\n\n        while (layer >= 0) {\n            Node<E> next = current.next(layer);\n            if (e.equals(current.getValue())) {\n                return true;\n            } else if (next == null || next.getValue().compareTo(e) > 0) {\n                layer--;\n            } else {\n                current = next;\n            }\n        }\n        return false;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Print height distribution of the nodes in a manner:\n     * <pre>\n     * [ ] --- --- [ ] --- [ ]\n     * [ ] --- [ ] [ ] --- [ ]\n     * [ ] [ ] [ ] [ ] [ ] [ ]\n     *  H   0   1   2   3   4\n     * </pre>\n     * Values of nodes is not presented.\n     *\n     * @return string representation\n     */\n    @Override\n    public String toString() {\n        List<boolean[]> layers = new ArrayList<>();\n        int sizeWithHeader = size + 1;\n        for (int i = 0; i <= height; i++) {\n            layers.add(new boolean[sizeWithHeader]);\n        }\n\n        Node<E> current = head;\n        int position = 0;\n        while (current != null) {\n            for (int i = 0; i <= current.height; i++) {\n                layers.get(i)[position] = true;\n            }\n            current = current.next(0);\n            position++;\n        }\n\n        Collections.reverse(layers);\n        String result = layers.stream()\n                .map(layer -> {\n                    StringBuilder acc = new StringBuilder();\n                    for (boolean b : layer) {\n                        if (b) {\n                            acc.append(\"[ ]\");\n                        } else {\n                            acc.append(\"---\");\n                        }\n                        acc.append(\" \");\n                    }\n                    return acc.toString();\n                })\n                .collect(Collectors.joining(\"\\n\"));\n        String positions = IntStream.range(0, sizeWithHeader - 1)\n                .mapToObj(i -> String.format(\"%3d\", i))\n                .collect(Collectors.joining(\" \"));\n\n        return result + String.format(\"%n H %s%n\", positions);\n    }\n\n    /**\n     * Value container.\n     * Each node have pointers to the closest nodes left and right from current\n     * on each layer of nodes height.\n     * @param <E> type of elements\n     */\n    private static class Node<E> {\n\n        private final E value;\n        private final int height;\n        private final List<Node<E>> forward;\n        private final List<Node<E>> backward;\n\n        @SuppressWarnings(\"unchecked\")\n        public Node(E value, int height) {\n            this.value = value;\n            this.height = height;\n\n            // predefined size lists with null values in every cell\n            this.forward = Arrays.asList(new Node[height + 1]);\n            this.backward = Arrays.asList(new Node[height + 1]);\n        }\n\n        public Node<E> next(int layer) {\n            checkLayer(layer);\n            return forward.get(layer);\n        }\n\n        public void setNext(int layer, Node<E> node) {\n            forward.set(layer, node);\n        }\n\n        public void setPrevious(int layer, Node<E> node) {\n            backward.set(layer, node);\n        }\n\n        public Node<E> previous(int layer) {\n            checkLayer(layer);\n            return backward.get(layer);\n        }\n\n        public E getValue() {\n            return value;\n        }\n\n        private void checkLayer(int layer) {\n            if (layer < 0 || layer > height) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    /**\n     * Height strategy is a way of calculating maximum height for skip list\n     * and height for each node.\n     * @see BernoulliHeightStrategy\n     */\n    public interface HeightStrategy {\n        int height(int expectedSize);\n        int nodeHeight(int heightCap);\n    }\n\n    /**\n     * In most common skip list realisation element in layer {@code i} appears\n     * in layer {@code i+1} with some fixed probability {@code p}.\n     * Two commonly used values for {@code p} are 1/2 and 1/4.\n     * Probability of appearing element in layer {@code i} could be calculated\n     * with <code>P = p<sup>i</sup>(1 - p)</code>\n     * <p>\n     * Maximum height that would give the best search complexity\n     * calculated by <code>log<sub>1/p</sub>n</code>\n     * where {@code n} is an expected count of elements in list.\n     */\n    public static class BernoulliHeightStrategy implements HeightStrategy {\n\n        private final double probability;\n\n        private static final double DEFAULT_PROBABILITY = 0.5;\n        private static final Random RANDOM = new Random();\n\n        public BernoulliHeightStrategy() {\n            this.probability = DEFAULT_PROBABILITY;\n        }\n\n        public BernoulliHeightStrategy(double probability) {\n            if (probability <= 0 || probability >= 1) {\n                throw new IllegalArgumentException(\"Probability should be from 0 to 1. But was: \" + probability);\n            }\n            this.probability = probability;\n        }\n\n        @Override\n        public int height(int expectedSize) {\n            long height = Math.round(Math.log10(expectedSize) / Math.log10(1 / probability));\n            if (height > Integer.MAX_VALUE) {\n                throw new IllegalArgumentException();\n            }\n            return (int) height;\n        }\n\n        @Override\n        public int nodeHeight(int heightCap) {\n            int level = 0;\n            double border = 100 * (1 - probability);\n            while (((RANDOM.nextInt(Integer.MAX_VALUE) % 100) + 1) > border) {\n                if (level + 1 >= heightCap) {\n                    return level;\n                }\n                level++;\n            }\n            return level;\n        }\n    }\n}",
        "test_old_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void remove() {\n        SkipList<String> skipList = createSkipList();\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(\"a\");\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream.range(0, values.length)\n                .mapToObj(skipList::get)\n                .toArray(String[]::new);\n\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}",
        "test_new_content": "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SkipListTest {\n\n    @Test\n    void add() {\n        SkipList<String> skipList = new SkipList<>();\n        assertEquals(0, skipList.size());\n\n        skipList.add(\"value\");\n\n        print(skipList);\n        assertEquals(1, skipList.size());\n    }\n\n    @Test\n    void get() {\n        SkipList<String> skipList = new SkipList<>();\n        skipList.add(\"value\");\n\n        String actualValue = skipList.get(0);\n\n        print(skipList);\n        assertEquals(\"value\", actualValue);\n    }\n\n    @Test\n    void contains() {\n        SkipList<String> skipList = createSkipList();\n        print(skipList);\n\n        boolean contains = skipList.contains(\"b\");\n\n        assertTrue(contains);\n    }\n\n    @Test\n    void removeFromHead() {\n        SkipList<String> skipList = createSkipList();\n        String mostLeftElement = skipList.get(0);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostLeftElement);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void removeFromTail() {\n        SkipList<String> skipList = createSkipList();\n        String mostRightValue = skipList.get(skipList.size() - 1);\n        int initialSize = skipList.size();\n        print(skipList);\n\n        skipList.remove(mostRightValue);\n\n        print(skipList);\n        assertEquals(initialSize - 1, skipList.size());\n    }\n\n    @Test\n    void checkSortedOnLowestLayer() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"d\", \"b\", \"a\", \"c\"};\n        Arrays.stream(values).forEach(skipList::add);\n        print(skipList);\n\n        String[] actualOrder = IntStream.range(0, values.length)\n                .mapToObj(skipList::get)\n                .toArray(String[]::new);\n\n        assertArrayEquals(new String[]{\"a\", \"b\", \"c\", \"d\"}, actualOrder);\n    }\n\n    private SkipList<String> createSkipList() {\n        SkipList<String> skipList = new SkipList<>();\n        String[] values = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"};\n        Arrays.stream(values).forEach(skipList::add);\n        return skipList;\n    }\n\n    /**\n     * Print Skip List representation to console.\n     * Optional method not involved in testing process. Used only for visualisation purposes.\n     * @param skipList to print\n     */\n    private void print(SkipList<?> skipList) {\n        System.out.println(skipList);\n    }\n}"
    },
    {
        "product_commit": "ec1ab53eeacbd9913206bb5ab98c1dd7dfe2ebbe",
        "test_commit": "4ccb9f460fde1fc75dbce590f48cde9814eb22b3",
        "product_file_path": "src/main/java/com/thealgorithms/datastructures/bloomfilter/BloomFilter.java",
        "test_file_path": "src/test/java/com/thealgorithms/datastructures/bloomfilter/BloomFilterTest.java",
        "product_old_content": "package com.thealgorithms.datastructures.bloomfilter;\n\n\npublic class BloomFilter<T> {\n\n    private int numberOfHashFunctions;\n    private int [] bitArray;\n    private Hash<T>[] hashFunctions;\n\n    public BloomFilter(int numberOfHashFunctions, int n) {\n        this.numberOfHashFunctions = numberOfHashFunctions;\n        hashFunctions = new Hash[numberOfHashFunctions];\n        bitArray = new int[n];\n        insertHash();\n    }\n\n    private void insertHash() {\n        for (int i = 0; i < numberOfHashFunctions; i++) {\n            hashFunctions[i] = new Hash(i);\n        }\n    }\n\n    public void insert(T key) {\n        for (Hash<T> hash : hashFunctions){\n            bitArray[hash.compute(key) % bitArray.length] = 1;\n        }\n    }\n\n    public boolean contains(T key) {\n        for (Hash<T> hash : hashFunctions){\n            if (bitArray[hash.compute(key) % bitArray.length] == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private class Hash<T> {\n\n        int index;\n\n        public Hash(int index){\n            this.index = index;\n        }\n\n        public int compute(T key){\n            return index * asciiString(String.valueOf(key));\n        }\n\n        private int asciiString(String word){\n            int number = 0;\n            for (int i=0;i<word.length();i++){\n                number += word.charAt(i);\n            }\n            return number;\n        }\n    }\n\n}",
        "product_new_content": "package com.thealgorithms.datastructures.bloomfilter;\n\n\nimport java.util.BitSet;\n\npublic class BloomFilter<T> {\n\n    private int numberOfHashFunctions;\n    private BitSet bitArray;\n    private Hash<T>[] hashFunctions;\n\n    public BloomFilter(int numberOfHashFunctions, int n) {\n        this.numberOfHashFunctions = numberOfHashFunctions;\n        hashFunctions = new Hash[numberOfHashFunctions];\n        bitArray = new BitSet(n);\n        insertHash();\n    }\n\n    private void insertHash() {\n        for (int i = 0; i < numberOfHashFunctions; i++) {\n            hashFunctions[i] = new Hash(i);\n        }\n    }\n\n    public void insert(T key) {\n        for (Hash<T> hash : hashFunctions){\n            int position = hash.compute(key) % bitArray.size();\n            bitArray.set(position);\n        }\n    }\n\n    public boolean contains(T key) {\n        for (Hash<T> hash : hashFunctions){\n            int position = hash.compute(key) % bitArray.size();\n            if (!bitArray.get(position)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private class Hash<T> {\n\n        int index;\n\n        public Hash(int index){\n            this.index = index;\n        }\n\n        public int compute(T key){\n            return index * asciiString(String.valueOf(key));\n        }\n\n        private int asciiString(String word){\n            int number = 0;\n            for (int i=0;i<word.length();i++){\n                number += word.charAt(i);\n            }\n            return number;\n        }\n    }\n\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.datastructures.bloomfilter;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\n\npublic class BloomFilterTest {\n\n    @Test\n    public void test1(){\n        BloomFilter<Integer> bloomFilter = new BloomFilter<>(3,10);\n        bloomFilter.insert(3);\n        bloomFilter.insert(17);\n\n        Assertions.assertTrue(bloomFilter.contains(3));\n        Assertions.assertTrue(bloomFilter.contains(17));\n    }\n\n    @Test\n    public void test2(){\n        BloomFilter<String> bloomFilter = new BloomFilter<>(4,20);\n        bloomFilter.insert(\"omar\");\n        bloomFilter.insert(\"mahamid\");\n\n        Assertions.assertTrue(bloomFilter.contains(\"omar\"));\n        Assertions.assertTrue(bloomFilter.contains(\"mahamid\"));\n    }\n}"
    },
    {
        "product_commit": "fe61eb2bdf2b3834dd5f05ba7309e9a26f6165dd",
        "test_commit": "49a4a83adaa0dbe5bb6d594b51542aae4b0ba5b9",
        "product_file_path": "src/main/java/com/thealgorithms/maths/FFT.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/FFTTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            temp.real = (this.real * z.real + this.img * z.img) / (z.abs() * z.abs());\n            temp.img = (this.img * z.real - this.real * z.img) / (z.abs() * z.abs());\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *\n     * @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     */\n    public static void fft(ArrayList<Complex> x, boolean inverse) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n\n        /* Find the log2(N) */\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n\n        /* Swap the values of the signal with bit-reversal method */\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n\n        /* Divide by N if we want the inverse FFT */\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}",
        "product_new_content": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            double d = z.abs() * z.abs();\n            d = (double)Math.round(d * 1000000000d) / 1000000000d;\n            temp.real = (this.real * z.real + this.img * z.img) / (d);\n            temp.img = (this.img * z.real - this.real * z.img) / (d);\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *\n     * @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     */\n    public static void fft(ArrayList<Complex> x, boolean inverse) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n\n        /* Find the log2(N) */\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n\n        /* Swap the values of the signal with bit-reversal method */\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n\n        /* Divide by N if we want the inverse FFT */\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}",
        "test_old_content": null,
        "test_new_content": "package com.thealgorithms.maths;\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass FFTTest {\n\n    // Testing the simple function getReal\n    @Test\n    void getRealtest()\n    {\n        FFT.Complex complex = new FFT.Complex(1.0,1.0);\n        assertEquals(1.0,complex.getReal());\n    }\n\n    // Testing the simple function getImaginary\n    @Test\n    void getImaginaryTest()\n    {\n        FFT.Complex complex = new FFT.Complex();\n        assertEquals(0.0,complex.getImaginary());\n    }\n\n    // Testing the function add, assertEqual test\n    @Test\n    void addTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(1.0,1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0,2.0);\n        double add = complex1.add(complex2).getReal();\n        assertEquals(3.0,add);\n    }\n\n    // Testing the function add, assertNotEqual test\n    @Test\n    void addFalseTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(1.0,1.0);\n        FFT.Complex complex2 = new FFT.Complex(2.0,2.0);\n        double add = complex1.add(complex2).getReal();\n        assertNotEquals(2.0,add);\n    }\n\n    // Testing the function substract, assertEqual test\n    @Test\n    void subtractTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,1.0);\n        double sub = complex1.subtract(complex2).getReal();\n        assertEquals(1.0,sub);\n    }\n\n    // Testing the function multiply complex, assertEqual test\n    @Test\n    void multiplyWithComplexTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,1.0);\n        double multiReal = complex1.multiply(complex2).getReal();\n        double multiImg = complex1.multiply(complex2).getImaginary();\n        assertEquals(0.0,multiReal);\n        assertEquals(4.0,multiImg);\n    }\n\n    // Testing the function multiply scalar, assertEqual test\n    @Test\n    void multiplyWithScalarTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n\n        double multiReal = complex1.multiply(2).getReal();\n        double multiImg = complex1.multiply(3).getImaginary();\n        assertEquals(4.0,multiReal);\n        assertEquals(6.0,multiImg);\n    }\n\n    // Testing the function conjugate, assertEqual test\n    @Test\n    void conjugateTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        double conReal = complex1.conjugate().getReal();\n        double conImg = complex1.conjugate().getImaginary();\n        assertEquals(2.0,conReal);\n        assertEquals(-2.0,conImg);\n    }\n\n    // Testing the function abs, assertEqual test\n    @Test\n    void abs()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,3.0);\n        double abs = complex1.abs();\n        assertEquals(Math.sqrt(13),abs);\n    }\n\n    // Testing the function divide complex, assertEqual test.\n    @Test\n    void divideWithComplexTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,2.0);\n        double divReal = complex1.divide(complex2).getReal();\n        double divImg = complex1.divide(complex2).getImaginary();\n        assertEquals(1.2,divReal);\n        assertEquals(-0.4,divImg);\n    }\n\n    // Testing the function divide scalar, assertEqual test.\n    @Test\n    void divideWithScalarTest()\n    {\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        double divReal = complex1.divide(2).getReal();\n        double divImg = complex1.divide(2).getImaginary();\n        assertEquals(1,divReal);\n        assertEquals(1,divImg);\n    }\n\n    // Testing the function fft, assertEqual test.\n    // https://scistatcalc.blogspot.com/2013/12/fft-calculator.html used this link to\n    // ensure the result\n    @Test\n    void fft()\n    {\n        ArrayList<FFT.Complex> arr = new ArrayList<FFT.Complex>();\n        FFT.Complex complex1 = new FFT.Complex(2.0,2.0);\n        FFT.Complex complex2 = new FFT.Complex(1.0,3.0);\n        FFT.Complex complex3 = new FFT.Complex(3.0,1.0);\n        FFT.Complex complex4 = new FFT.Complex(2.0,2.0);\n\n        arr.add(complex1);\n        arr.add(complex2);\n        arr.add(complex3);\n        arr.add(complex4);\n        arr = FFT.fft(arr,false);\n        double realV1= arr.get(0).getReal();\n        double realV2= arr.get(2).getReal();\n        double imgV1 = arr.get(0).getImaginary();\n        double imgV2 = arr.get(2).getImaginary();\n        assertEquals(8.0,realV1);\n        assertEquals(2.0,realV2);\n        assertEquals(8.0, imgV1);\n        assertEquals(-2.0,imgV2);\n    }\n}"
    },
    {
        "product_commit": "a0a392297e94a86c03873f82d745cceba250c656",
        "test_commit": "ab9f74c2ee0dee9174616f2154f1161d600f68cd",
        "product_file_path": "src/main/java/com/thealgorithms/maths/KaprekarNumbers.java",
        "test_file_path": "src/test/java/com/thealgorithms/maths/KaprekarNumbersTest.java",
        "product_old_content": "package com.thealgorithms.maths;\n\npublic class KaprekarNumbers {\n\n\t/* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n\t// Checks whether a given number is Kaprekar Number or not\n\n\tpublic static boolean isKaprekarNumber(long number) {\t\t\t\n\t\tlong numberSquared = number * number;\n\t\tif(Long.toString(number).length() == Long.toString(numberSquared).length()){\n\t\t\treturn (number == numberSquared);\n\t\t}\n\t\telse{\n\t\t\tlong leftDigits1 = 0, leftDigits2 = 0;\n\t\t\tif(Long.toString(numberSquared).contains(\"0\")){\n\t\t\t\tleftDigits1 = Long.parseLong(Long.toString(numberSquared).substring(0, Long.toString(numberSquared).indexOf(\"0\")));\n\t\t\t}\n\t\t\tleftDigits2 = Long.parseLong(Long.toString(numberSquared).substring(0, (Long.toString(numberSquared).length() - Long.toString(number).length())));\n\t\t\tlong rightDigits = Long.parseLong(Long.toString(numberSquared).substring(Long.toString(numberSquared).length() - Long.toString(number).length()));\n\t\t\treturn (number == (leftDigits1 + rightDigits)) || (number == (leftDigits2 + rightDigits));\n\t\t}\t\t\n\t}\n\n}",
        "product_new_content": "package com.thealgorithms.maths;\nimport java.util.*;\n\npublic class KaprekarNumbers {\n\n\t/* This program demonstrates if a given number is Kaprekar Number or not.\n\tKaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n\n\tdigits and sum of these parts is equal to the original number. */\n\n\t// Provides a list of kaprekarNumber in a range\n\tpublic static ArrayList<Long> kaprekarNumberInRange(long start, long end) throws Exception {\n\t\tlong n = end-start;\n\t\tif (n <0) throw new Exception(\"Invalid range\");\n\t\tArrayList<Long> list = new ArrayList<>();\n\n\t\tfor (long i = start; i <= end; i++) {\n\t\t\tif (isKaprekarNumber(i)) list.add(i);\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t// Checks whether a given number is Kaprekar Number or not\n\tpublic static boolean isKaprekarNumber(long number) {\n\t\tlong numberSquared = number * number;\n\t\tif(Long.toString(number).length() == Long.toString(numberSquared).length()){\n\t\t\treturn (number == numberSquared);\n\t\t}\n\t\telse{\n\t\t\tlong leftDigits1 = 0, leftDigits2;\n\t\t\tif(Long.toString(numberSquared).contains(\"0\")){\n\t\t\t\tleftDigits1 = Long.parseLong(Long.toString(numberSquared).substring(0, Long.toString(numberSquared).indexOf(\"0\")));\n\t\t\t}\n\t\t\tleftDigits2 = Long.parseLong(Long.toString(numberSquared).substring(0, (Long.toString(numberSquared).length() - Long.toString(number).length())));\n\t\t\tlong rightDigits = Long.parseLong(Long.toString(numberSquared).substring(Long.toString(numberSquared).length() - Long.toString(number).length()));\n\t\t\treturn (number == (leftDigits1 + rightDigits)) || (number == (leftDigits2 + rightDigits));\n\t\t}\t\t\n\t}\n\n}",
        "test_old_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KaprekarNumbersTest {\n\n\t@Test\n\tvoid testFor1() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(1));\n\t}\n\n\t@Test\n\tvoid testFor45() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(45));\n\t}\n\n\t@Test\n\tvoid testFor297() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(297));\n\t}\n\n\t@Test\n\tvoid testFor2223() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n\t}\n\n\t@Test\n\tvoid testFor857143() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n\t}\n\n\n\t@Test\n\tvoid testFor3() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(3));\n\t}\n\n\t@Test\n\tvoid testFor26() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(26));\n\t}\n\n\t@Test\n\tvoid testFor98() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(98));\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KaprekarNumbersTest {\n\n\t@Test\n\tvoid testFor1() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(1));\n\t}\n\n\t@Test\n\tvoid testFor45() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(45));\n\t}\n\n\t@Test\n\tvoid testFor297() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(297));\n\t}\n\n\t@Test\n\tvoid testFor2223() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(2223));\n\t}\n\n\t@Test\n\tvoid testFor857143() \n\t{\n\t\tassertTrue(KaprekarNumbers.isKaprekarNumber(857143));\n\t}\n\n\n\t@Test\n\tvoid testFor3() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(3));\n\t}\n\n\t@Test\n\tvoid testFor26() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(26));\n\t}\n\n\t@Test\n\tvoid testFor98() \n\t{\n\t\tassertFalse(KaprekarNumbers.isKaprekarNumber(98));\n\t}\n\n\t@Test\n\tvoid testForRangeOfNumber() { try {\n\t\tArrayList<Long> rangedNumbers = KaprekarNumbers.kaprekarNumberInRange(1,100000);\n\t\tlong[] allTheNumbers = {1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4950, 5050, 7272, 7777, 9999, 17344, 22222, 77778, 82656, 95121, 99999};\n\t\tfor (long i:allTheNumbers) {\n\t\t\tassert rangedNumbers.contains(i);\n\t\t}\n\t} catch (Exception e) {\n\t\tassert false;\n\t}\n\t}\n\n}"
    },
    {
        "product_commit": "734f7a4a042f68d4bc4fd8dd83ae6227f432a297",
        "test_commit": "b1242e045b1d1cffbe71f05b8aeb97469f154f13",
        "product_file_path": "src/main/java/com/thealgorithms/others/ArrayLeftRotation.java",
        "test_file_path": "src/test/java/com/thealgorithms/others/ArrayLeftRotationTest.java",
        "product_old_content": null,
        "product_new_content": "package com.thealgorithms.others;\n\n/*\n * A left rotation operation on an array\n * shifts each of the array's elements\n * given integer n unit to the left.\n * \n * @author sangin-lee \n */\n\npublic class ArrayLeftRotation {\n\n\t/*\n\t * Returns the result of left rotation of given array arr and integer n\n\t * \n\t * @param arr : int[] given array\n\t * \n\t * @param n : int given integer\n\t * \n\t * @return : int[] result of left rotation\n\t */\n\tpublic static int[] rotateLeft(int[] arr, int n) {\n\t\tint size = arr.length;\n\t\tint[] dst = new int[size];\n\t\tn = n % size;\n\t\tfor(int i = 0; i < size; i++) {\n\t\t\tdst[i] = arr[n];\n\t\t\tn = (n + 1) % size;\n\t\t}\n\t\treturn dst;\n\t}\n\n}",
        "test_old_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ArrayLeftRotationTest {\n\n\t@Test\n\tvoid testForOneElement() {\n\t\tint[] arr = {3};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 3);\n\t\tassertArrayEquals(arr, result);\n\t}\n\t\n\t@Test\n\tvoid testForZeroStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 0);\n\t\tassertArrayEquals(arr, result);\n\t}\n\t\n\t@Test\n\tvoid testForEqualSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 5);\n\t\tassertArrayEquals(arr, result);\n\t}\n\t\n\t@Test\n\tvoid testForLowerSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 2;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\t\n\t@Test\n\tvoid testForHigherSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 7;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\n}",
        "test_new_content": "package com.thealgorithms.others;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ArrayLeftRotationTest {\n\n\t@Test\n\tvoid testForOneElement() {\n\t\tint[] arr = {3};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 3);\n\t\tassertArrayEquals(arr, result);\n\t}\n\n\t@Test\n\tvoid testForZeroStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 0);\n\t\tassertArrayEquals(arr, result);\n\t}\n\n\t@Test\n\tvoid testForEqualSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, 5);\n\t\tassertArrayEquals(arr, result);\n\t}\n\n\t@Test\n\tvoid testForLowerSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 2;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\n\t@Test\n\tvoid testForHigherSizeStep() {\n\t\tint[] arr = {3, 1, 5, 8, 6};\n\t\tint n = 7;\n\t\tint[] expected = {5, 8, 6, 3, 1};\n\t\tint[] result = ArrayLeftRotation.rotateLeft(arr, n);\n\t\tassertArrayEquals(expected, result);\n\t}\n\n}"
    }
]