--- 
+++ 
@@ -19,8 +19,8 @@
 
 import java.io.Serializable;
 
-import org.apache.commons.math4.legacy.Field;
-import org.apache.commons.math4.legacy.FieldElement;
+import org.apache.commons.math4.legacy.core.Field;
+import org.apache.commons.math4.legacy.core.FieldElement;
 import org.apache.commons.math4.legacy.exception.DimensionMismatchException;
 import org.apache.commons.math4.legacy.exception.NoDataException;
 import org.apache.commons.math4.legacy.exception.NotStrictlyPositiveException;
@@ -28,8 +28,8 @@
 import org.apache.commons.math4.legacy.exception.NumberIsTooSmallException;
 import org.apache.commons.math4.legacy.exception.OutOfRangeException;
 import org.apache.commons.math4.legacy.exception.util.LocalizedFormats;
-import org.apache.commons.math4.legacy.util.FastMath;
-import org.apache.commons.math4.legacy.util.MathArrays;
+import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
+import org.apache.commons.math4.legacy.core.MathArrays;
 
 /**
  * Cache-friendly implementation of FieldMatrix using a flat arrays to store
@@ -224,11 +224,11 @@
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart  = iBlock * BLOCK_SIZE;
-            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd    = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             final int iHeight = pEnd - pStart;
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                 final int jWidth = qEnd - qStart;
 
                 // allocate new block
@@ -273,11 +273,11 @@
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart  = iBlock * BLOCK_SIZE;
-            final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd    = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             final int iHeight = pEnd - pStart;
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                 final int jWidth = qEnd - qStart;
                 blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth);
                 ++blockIndex;
@@ -333,9 +333,9 @@
                 final T[] outBlock = out.blocks[blockIndex];
                 final T[] tBlock   = blocks[blockIndex];
                 final int      pStart   = iBlock * BLOCK_SIZE;
-                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);
+                final int      pEnd     = AccurateMath.min(pStart + BLOCK_SIZE, rows);
                 final int      qStart   = jBlock * BLOCK_SIZE;
-                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int      qEnd     = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
                     for (int q = qStart; q < qEnd; ++q) {
@@ -404,9 +404,9 @@
                 final T[] outBlock = out.blocks[blockIndex];
                 final T[] tBlock   = blocks[blockIndex];
                 final int      pStart   = iBlock * BLOCK_SIZE;
-                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, rows);
+                final int      pEnd     = AccurateMath.min(pStart + BLOCK_SIZE, rows);
                 final int      qStart   = jBlock * BLOCK_SIZE;
-                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int      qEnd     = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
                     for (int q = qStart; q < qEnd; ++q) {
@@ -505,12 +505,12 @@
         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {
 
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
 
             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {
 
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());
+                final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());
 
                 // select current block
                 final T[] outBlock = out.blocks[blockIndex];
@@ -567,7 +567,7 @@
         for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {
 
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
 
             for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {
                 final int jWidth = out.blockWidth(jBlock);
@@ -627,7 +627,7 @@
 
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             int regularPos   = 0;
             int lastPos      = 0;
             for (int p = pStart; p < pEnd; ++p) {
@@ -804,14 +804,14 @@
         for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
             final int iHeight  = blockHeight(iBlock);
             final int firstRow = iBlock * BLOCK_SIZE;
-            final int iStart   = FastMath.max(row,    firstRow);
-            final int iEnd     = FastMath.min(endRow + 1, firstRow + iHeight);
+            final int iStart   = AccurateMath.max(row,    firstRow);
+            final int iEnd     = AccurateMath.min(endRow + 1, firstRow + iHeight);
 
             for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
                 final int jWidth      = blockWidth(jBlock);
                 final int firstColumn = jBlock * BLOCK_SIZE;
-                final int jStart      = FastMath.max(column,    firstColumn);
-                final int jEnd        = FastMath.min(endColumn + 1, firstColumn + jWidth);
+                final int jStart      = AccurateMath.max(column,    firstColumn);
+                final int jEnd        = AccurateMath.min(endColumn + 1, firstColumn + jWidth);
                 final int jLength     = jEnd - jStart;
 
                 // handle one block, row by row
@@ -1226,9 +1226,9 @@
                 final T[] outBlock = out.blocks[blockIndex];
                 final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];
                 final int      pStart   = iBlock * BLOCK_SIZE;
-                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);
+                final int      pEnd     = AccurateMath.min(pStart + BLOCK_SIZE, columns);
                 final int      qStart   = jBlock * BLOCK_SIZE;
-                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);
+                final int      qEnd     = AccurateMath.min(qStart + BLOCK_SIZE, rows);
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
                     final int lInc = pEnd - pStart;
@@ -1273,11 +1273,11 @@
         // perform multiplication block-wise, to ensure good cache behavior
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final T[] block  = blocks[iBlock * blockColumns + jBlock];
                 final int      qStart = jBlock * BLOCK_SIZE;
-                final int      qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int      qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
                     T sum = zero;
@@ -1319,11 +1319,11 @@
             final int jWidth3 = jWidth2 + jWidth;
             final int jWidth4 = jWidth3 + jWidth;
             final int qStart = jBlock * BLOCK_SIZE;
-            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+            final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
             for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
                 final T[] block  = blocks[iBlock * blockColumns + jBlock];
                 final int      pStart = iBlock * BLOCK_SIZE;
-                final int      pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+                final int      pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
                 for (int q = qStart; q < qEnd; ++q) {
                     int k = q - qStart;
                     T sum = zero;
@@ -1355,12 +1355,12 @@
         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
                     final int qStart = jBlock * BLOCK_SIZE;
-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                    final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                     final T[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - pStart) * jWidth;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1379,12 +1379,12 @@
         visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
                     final int qStart = jBlock * BLOCK_SIZE;
-                    final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                    final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                     final T[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - pStart) * jWidth;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1407,14 +1407,14 @@
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
             final int p0     = iBlock * BLOCK_SIZE;
-            final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pStart = AccurateMath.max(startRow, p0);
+            final int pEnd   = AccurateMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
                     final int q0     = jBlock * BLOCK_SIZE;
-                    final int qStart = FastMath.max(startColumn, q0);
-                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                    final int qStart = AccurateMath.max(startColumn, q0);
+                    final int qEnd   = AccurateMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                     final T[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - p0) * jWidth + qStart - q0;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1437,14 +1437,14 @@
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
             final int p0     = iBlock * BLOCK_SIZE;
-            final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pStart = AccurateMath.max(startRow, p0);
+            final int pEnd   = AccurateMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int p = pStart; p < pEnd; ++p) {
                 for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                     final int jWidth = blockWidth(jBlock);
                     final int q0     = jBlock * BLOCK_SIZE;
-                    final int qStart = FastMath.max(startColumn, q0);
-                    final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                    final int qStart = AccurateMath.max(startColumn, q0);
+                    final int qEnd   = AccurateMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                     final T[] block = blocks[iBlock * blockColumns + jBlock];
                     int k = (p - p0) * jWidth + qStart - q0;
                     for (int q = qStart; q < qEnd; ++q) {
@@ -1464,10 +1464,10 @@
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                 final T[] block = blocks[blockIndex];
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
@@ -1489,10 +1489,10 @@
         int blockIndex = 0;
         for (int iBlock = 0; iBlock < blockRows; ++iBlock) {
             final int pStart = iBlock * BLOCK_SIZE;
-            final int pEnd   = FastMath.min(pStart + BLOCK_SIZE, rows);
+            final int pEnd   = AccurateMath.min(pStart + BLOCK_SIZE, rows);
             for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {
                 final int qStart = jBlock * BLOCK_SIZE;
-                final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);
+                final int qEnd   = AccurateMath.min(qStart + BLOCK_SIZE, columns);
                 final T[] block = blocks[blockIndex];
                 int k = 0;
                 for (int p = pStart; p < pEnd; ++p) {
@@ -1517,13 +1517,13 @@
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
             final int p0     = iBlock * BLOCK_SIZE;
-            final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pStart = AccurateMath.max(startRow, p0);
+            final int pEnd   = AccurateMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                 final int jWidth = blockWidth(jBlock);
                 final int q0     = jBlock * BLOCK_SIZE;
-                final int qStart = FastMath.max(startColumn, q0);
-                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                final int qStart = AccurateMath.max(startColumn, q0);
+                final int qEnd   = AccurateMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                 final T[] block = blocks[iBlock * blockColumns + jBlock];
                 for (int p = pStart; p < pEnd; ++p) {
                     int k = (p - p0) * jWidth + qStart - q0;
@@ -1547,13 +1547,13 @@
         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {
             final int p0     = iBlock * BLOCK_SIZE;
-            final int pStart = FastMath.max(startRow, p0);
-            final int pEnd   = FastMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
+            final int pStart = AccurateMath.max(startRow, p0);
+            final int pEnd   = AccurateMath.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);
             for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {
                 final int jWidth = blockWidth(jBlock);
                 final int q0     = jBlock * BLOCK_SIZE;
-                final int qStart = FastMath.max(startColumn, q0);
-                final int qEnd   = FastMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
+                final int qStart = AccurateMath.max(startColumn, q0);
+                final int qEnd   = AccurateMath.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);
                 final T[] block = blocks[iBlock * blockColumns + jBlock];
                 for (int p = pStart; p < pEnd; ++p) {
                     int k = (p - p0) * jWidth + qStart - q0;