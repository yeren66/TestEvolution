--- 
+++ 
@@ -97,89 +97,5 @@
                 return lower + rng.nextLong(max);
             }
         }
-
-        /**
-         * Generates a uniformly distributed random value from the open interval
-         * {@code (lower, upper)} (i.e., endpoints excluded).
-         * <p>
-         * <strong>Definition</strong>:
-         * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm">
-         * Uniform Distribution</a> {@code lower} and {@code upper - lower} are the
-         * <a href = "http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm">
-         * location and scale parameters</a>, respectively.</p>
-         * <p>
-         * <strong>Algorithm Description</strong>: scales the output of
-         * Random.nextDouble(), but rejects 0 values (i.e., will generate another
-         * random double if Random.nextDouble() returns 0). This is necessary to
-         * provide a symmetric output interval (both endpoints excluded).
-         * </p>
-         *
-         * @param lower Lower bound of the support (excluded).
-         * @param upper Upper bound of the support (excluded).
-         * @return a uniformly distributed random value between lower and upper
-         * (both excluded).
-         * @throws NumberIsTooLargeException if {@code lower >= upper}.
-         * @throws NotFiniteNumberException if one of the bounds is infinite.
-         * @throws NotANumberException if one of the bounds is NaN.
-         */
-        public double nextUniform(double lower, double upper) {
-            return nextUniform(lower, upper, false);
-        }
-
-        /**
-         * Generates a uniformly distributed random value from the interval
-         * {@code (lower, upper)} or the interval {@code [lower, upper)}. The lower
-         * bound is thus optionally included, while the upper bound is always
-         * excluded.
-         * <p>
-         * <strong>Definition</strong>:
-         * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm">
-         * Uniform Distribution</a> {@code lower} and {@code upper - lower} are the
-         * <a href = "http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm">
-         * location and scale parameters</a>, respectively.</p>
-         * <p>
-         * <strong>Algorithm Description</strong>: if the lower bound is excluded,
-         * scales the output of "nextDouble()", but rejects 0 values (i.e. it
-         * will generate another random double if "nextDouble()" returns 0).
-         * This is necessary to provide a symmetric output interval (both
-         * endpoints excluded).
-         * </p>
-         *
-         * @param lower Lower bound of the support.
-         * @param upper Exclusive upper bound of the support.
-         * @param lowerInclusive {@code true} if the lower bound is inclusive.
-         * @return a uniformly distributed random value in the {@code (lower, upper)}
-         * interval, if {@code lowerInclusive} is {@code false}, or in the
-         * {@code [lower, upper)} interval, if {@code lowerInclusive} is
-         * {@code true}.
-         * @throws NumberIsTooLargeException if {@code lower >= upper}.
-         * @throws NotFiniteNumberException if one of the bounds is infinite.
-         * @throws NotANumberException if one of the bounds is NaN.
-         */
-        public double nextUniform(double lower,
-                                  double upper,
-                                  boolean lowerInclusive) {
-            if (lower >= upper) {
-                throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,
-                                                    lower, upper, false);
-            }
-            if (Double.isInfinite(lower)) {
-                throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, lower);
-            }
-            if (Double.isInfinite(upper)) {
-                throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, upper);
-            }
-            if (Double.isNaN(lower) || Double.isNaN(upper)) {
-                throw new NotANumberException();
-            }
-
-            // Ensure nextDouble() isn't 0.0
-            double u = rng.nextDouble();
-            while (!lowerInclusive && u <= 0.0) {
-                u = rng.nextDouble();
-            }
-
-            return u * upper + (1.0 - u) * lower;
-        }
     }
 }