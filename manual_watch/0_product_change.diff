--- 
+++ 
@@ -17,10 +17,19 @@
 package org.apache.commons.math4.legacy.optim.nonlinear.scalar;
 
 import org.apache.commons.math4.legacy.analysis.MultivariateFunction;
+import org.apache.commons.math4.legacy.analysis.UnivariateFunction;
 import org.apache.commons.math4.legacy.optim.BaseMultivariateOptimizer;
 import org.apache.commons.math4.legacy.optim.ConvergenceChecker;
 import org.apache.commons.math4.legacy.optim.OptimizationData;
 import org.apache.commons.math4.legacy.optim.PointValuePair;
+import org.apache.commons.math4.legacy.optim.MaxEval;
+import org.apache.commons.math4.legacy.optim.univariate.BracketFinder;
+import org.apache.commons.math4.legacy.optim.univariate.BrentOptimizer;
+import org.apache.commons.math4.legacy.optim.univariate.SearchInterval;
+import org.apache.commons.math4.legacy.optim.univariate.SimpleUnivariateValueChecker;
+import org.apache.commons.math4.legacy.optim.univariate.UnivariateObjectiveFunction;
+import org.apache.commons.math4.legacy.optim.univariate.UnivariateOptimizer;
+import org.apache.commons.math4.legacy.optim.univariate.UnivariatePointValuePair;
 
 /**
  * Base class for a multivariate scalar function optimizer.
@@ -33,6 +42,14 @@
     private MultivariateFunction function;
     /** Type of optimization. */
     private GoalType goal;
+    /** Line search relative tolerance. */
+    private double lineSearchRelativeTolerance = 1e-8;
+    /** Line search absolute tolerance. */
+    private double lineSearchAbsoluteTolerance = 1e-8;
+    /** Line serach initial bracketing range. */
+    private double lineSearchInitialBracketingRange = 1d;
+    /** Line search. */
+    private LineSearch lineSearch;
 
     /**
      * @param checker Convergence checker.
@@ -50,6 +67,7 @@
      * <ul>
      *  <li>{@link ObjectiveFunction}</li>
      *  <li>{@link GoalType}</li>
+     *  <li>{@link LineSearchTolerance}</li>
      * </ul>
      * @return {@inheritDoc}
      * @throws org.apache.commons.math4.legacy.exception.TooManyEvaluationsException
@@ -70,6 +88,7 @@
      * <ul>
      *  <li>{@link ObjectiveFunction}</li>
      *  <li>{@link GoalType}</li>
+     *  <li>{@link LineSearchTolerance}</li>
      * </ul>
      */
     @Override
@@ -95,13 +114,45 @@
                     };
                 continue;
             }
+            if (data instanceof LineSearchTolerance) {
+                final LineSearchTolerance tol = (LineSearchTolerance) data;
+                lineSearchRelativeTolerance = tol.getRelativeTolerance();
+                lineSearchAbsoluteTolerance = tol.getAbsoluteTolerance();
+                lineSearchInitialBracketingRange = tol.getInitialBracketingRange();
+                continue;
+            }
         }
     }
 
     /**
+     * Intantiate the line search implementation.
+     */
+    protected void createLineSearch() {
+        lineSearch = new LineSearch(this,
+                                    lineSearchRelativeTolerance,
+                                    lineSearchAbsoluteTolerance,
+                                    lineSearchInitialBracketingRange);
+    }
+
+    /**
+     * Finds the number {@code alpha} that optimizes
+     * {@code f(startPoint + alpha * direction)}.
+     *
+     * @param startPoint Starting point.
+     * @param direction Search direction.
+     * @return the optimum.
+     * @throws org.apache.commons.math4.legacy.exception.TooManyEvaluationsException
+     * if the number of evaluations is exceeded.
+     */
+    protected UnivariatePointValuePair lineSearch(final double[] startPoint,
+                                                  final double[] direction) {
+        return lineSearch.search(startPoint, direction);
+    }
+
+    /**
      * @return the optimization type.
      */
-    public GoalType getGoalType() {
+    protected GoalType getGoalType() {
         return goal;
     }
 
@@ -129,4 +180,115 @@
     public double computeObjectiveValue(double[] params) {
         return function.value(params);
     }
+
+    /**
+     * Find the minimum of the objective function along a given direction.
+     *
+     * @since 4.0
+     */
+    private static class LineSearch {
+        /**
+         * Value that will pass the precondition check for {@link BrentOptimizer}
+         * but will not pass the convergence check, so that the custom checker
+         * will always decide when to stop the line search.
+         */
+        private static final double REL_TOL_UNUSED = 1e-15;
+        /**
+         * Value that will pass the precondition check for {@link BrentOptimizer}
+         * but will not pass the convergence check, so that the custom checker
+         * will always decide when to stop the line search.
+         */
+        private static final double ABS_TOL_UNUSED = Double.MIN_VALUE;
+        /**
+         * Optimizer used for line search.
+         */
+        private final UnivariateOptimizer lineOptimizer;
+        /**
+         * Automatic bracketing.
+         */
+        private final BracketFinder bracket = new BracketFinder();
+        /**
+         * Extent of the initial interval used to find an interval that
+         * brackets the optimum.
+         */
+        private final double initialBracketingRange;
+        /**
+         * Optimizer on behalf of which the line search must be performed.
+         */
+        private final MultivariateOptimizer mainOptimizer;
+
+        /**
+         * The {@code BrentOptimizer} default stopping criterion uses the
+         * tolerances to check the domain (point) values, not the function
+         * values.
+         * The {@code relativeTolerance} and {@code absoluteTolerance}
+         * arguments are thus passed to a {@link SimpleUnivariateValueChecker
+         * custom checker} that will use the function values.
+         *
+         * @param optimizer Optimizer on behalf of which the line search
+         * be performed.
+         * Its {@link MultivariateOptimizer#getObjectiveFunction() objective
+         * function} will be called by the {@link #search(double[],double[])
+         * search} method.
+         * @param relativeTolerance Search will stop when the function relative
+         * difference between successive iterations is below this value.
+         * @param absoluteTolerance Search will stop when the function absolute
+         * difference between successive iterations is below this value.
+         * @param initialBracketingRange Extent of the initial interval used to
+         * find an interval that brackets the optimum.
+         * If the optimized function varies a lot in the vicinity of the optimum,
+         * it may be necessary to provide a value lower than the distance between
+         * successive local minima.
+         */
+        /* package-private */ LineSearch(MultivariateOptimizer optimizer,
+                                         double relativeTolerance,
+                                         double absoluteTolerance,
+                                         double initialBracketingRange) {
+            mainOptimizer = optimizer;
+            lineOptimizer = new BrentOptimizer(REL_TOL_UNUSED,
+                                               ABS_TOL_UNUSED,
+                                               new SimpleUnivariateValueChecker(relativeTolerance,
+                                                                                absoluteTolerance));
+            this.initialBracketingRange = initialBracketingRange;
+        }
+
+        /**
+         * Finds the number {@code alpha} that optimizes
+         * {@code f(startPoint + alpha * direction)}.
+         *
+         * @param startPoint Starting point.
+         * @param direction Search direction.
+         * @return the optimum.
+         * @throws org.apache.commons.math4.legacy.exception.TooManyEvaluationsException
+         * if the number of evaluations is exceeded.
+         */
+        /* package-private */ UnivariatePointValuePair search(final double[] startPoint,
+                                                              final double[] direction) {
+            final int n = startPoint.length;
+            final MultivariateFunction func = mainOptimizer.getObjectiveFunction();
+            final UnivariateFunction f = new UnivariateFunction() {
+                    /** {@inheritDoc} */
+                    @Override
+                    public double value(double alpha) {
+                        final double[] x = new double[n];
+                        for (int i = 0; i < n; i++) {
+                            x[i] = startPoint[i] + alpha * direction[i];
+                        }
+                        return func.value(x);
+                    }
+                };
+
+            final GoalType goal = mainOptimizer.getGoalType();
+            bracket.search(f, goal, 0, initialBracketingRange);
+            // Passing "MAX_VALUE" as a dummy value because it is the enclosing
+            // class that counts the number of evaluations (and will eventually
+            // generate the exception).
+            return lineOptimizer.optimize(new MaxEval(Integer.MAX_VALUE),
+                                          new UnivariateObjectiveFunction(f),
+                                          goal,
+                                          new SearchInterval(bracket.getLo(),
+                                                             bracket.getHi(),
+                                                             bracket.getMid()));
+        }
+    }
 }