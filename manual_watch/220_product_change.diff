--- 
+++ 
@@ -24,7 +24,7 @@
 import org.apache.commons.math4.legacy.linear.ArrayRealVector;
 import org.apache.commons.math4.legacy.linear.RealMatrix;
 import org.apache.commons.math4.legacy.optim.ConvergenceChecker;
-import org.apache.commons.math4.legacy.util.FastMath;
+import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
 import org.apache.commons.math4.legacy.util.IntegerSequence;
 import org.apache.commons.numbers.core.Precision;
 
@@ -305,7 +305,7 @@
         final ConvergenceChecker<Evaluation> checker = problem.getConvergenceChecker();
 
         // arrays shared with the other private methods
-        final int solvedCols  = FastMath.min(nR, nC);
+        final int solvedCols  = AccurateMath.min(nR, nC);
         /* Parameters evolution direction associated with lmPar. */
         double[] lmDir = new double[nC];
         /* Levenberg-Marquardt parameter. */
@@ -375,7 +375,7 @@
                     xNorm  += xk * xk;
                     diag[k] = dk;
                 }
-                xNorm = FastMath.sqrt(xNorm);
+                xNorm = AccurateMath.sqrt(xNorm);
 
                 // initialize the step bound delta
                 delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
@@ -392,7 +392,7 @@
                         for (int i = 0; i <= j; ++i) {
                             sum += weightedJacobian[i][pj] * qtf[i];
                         }
-                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
+                        maxCosine = AccurateMath.max(maxCosine, AccurateMath.abs(sum) / (s * currentCost));
                     }
                 }
             }
@@ -406,7 +406,7 @@
 
             // rescale if necessary
             for (int j = 0; j < nC; ++j) {
-                diag[j] = FastMath.max(diag[j], jacNorm[j]);
+                diag[j] = AccurateMath.max(diag[j], jacNorm[j]);
             }
 
             // Inner loop.
@@ -436,10 +436,10 @@
                     double s = diag[pj] * lmDir[pj];
                     lmNorm  += s * s;
                 }
-                lmNorm = FastMath.sqrt(lmNorm);
+                lmNorm = AccurateMath.sqrt(lmNorm);
                 // on the first iteration, adjust the initial step bound.
                 if (firstIteration) {
-                    delta = FastMath.min(delta, lmNorm);
+                    delta = AccurateMath.min(delta, lmNorm);
                 }
 
                 // Evaluate the function at x + p and calculate its norm.
@@ -486,7 +486,7 @@
                         if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                             tmp = 0.1;
                         }
-                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
+                        delta = tmp * AccurateMath.min(delta, 10.0 * lmNorm);
                         lmPar /= tmp;
                 } else if ((lmPar == 0) || (ratio >= 0.75)) {
                     delta = 2 * lmNorm;
@@ -502,7 +502,7 @@
                         double xK = diag[k] * currentPoint[k];
                         xNorm += xK * xK;
                     }
-                    xNorm = FastMath.sqrt(xNorm);
+                    xNorm = AccurateMath.sqrt(xNorm);
 
                     // tests for convergence.
                     if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {
@@ -523,7 +523,7 @@
                 }
 
                 // Default convergence criteria.
-                if ((FastMath.abs(actRed) <= costRelativeTolerance &&
+                if ((AccurateMath.abs(actRed) <= costRelativeTolerance &&
                      preRed <= costRelativeTolerance &&
                      ratio <= 2.0) ||
                     delta <= parRelativeTolerance * xNorm) {
@@ -531,7 +531,7 @@
                 }
 
                 // tests for termination and stringent tolerances
-                if (FastMath.abs(actRed) <= TWO_EPS &&
+                if (AccurateMath.abs(actRed) <= TWO_EPS &&
                     preRed <= TWO_EPS &&
                     ratio <= 2.0) {
                     throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
@@ -655,7 +655,7 @@
             work1[pj] = s;
             dxNorm += s * s;
         }
-        dxNorm = FastMath.sqrt(dxNorm);
+        dxNorm = AccurateMath.sqrt(dxNorm);
         double fp = dxNorm - delta;
         if (fp <= 0.1 * delta) {
             lmPar = 0;
@@ -697,15 +697,15 @@
             sum /= diag[pj];
             sum2 += sum * sum;
         }
-        double gNorm = FastMath.sqrt(sum2);
+        double gNorm = AccurateMath.sqrt(sum2);
         double paru = gNorm / delta;
         if (paru == 0) {
-            paru = Precision.SAFE_MIN / FastMath.min(delta, 0.1);
+            paru = Precision.SAFE_MIN / AccurateMath.min(delta, 0.1);
         }
 
         // if the input par lies outside of the interval (parl,paru),
         // set par to the closer endpoint
-        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));
+        lmPar = AccurateMath.min(paru, AccurateMath.max(lmPar, parl));
         if (lmPar == 0) {
             lmPar = gNorm / dxNorm;
         }
@@ -714,9 +714,9 @@
 
             // evaluate the function at the current value of lmPar
             if (lmPar == 0) {
-                lmPar = FastMath.max(Precision.SAFE_MIN, 0.001 * paru);
-            }
-            double sPar = FastMath.sqrt(lmPar);
+                lmPar = AccurateMath.max(Precision.SAFE_MIN, 0.001 * paru);
+            }
+            double sPar = AccurateMath.sqrt(lmPar);
             for (int j = 0; j < solvedCols; ++j) {
                 int pj = permutation[j];
                 work1[pj] = sPar * diag[pj];
@@ -730,13 +730,13 @@
                 work3[pj] = s;
                 dxNorm += s * s;
             }
-            dxNorm = FastMath.sqrt(dxNorm);
+            dxNorm = AccurateMath.sqrt(dxNorm);
             double previousFP = fp;
             fp = dxNorm - delta;
 
             // if the function is small enough, accept the current value
             // of lmPar, also test for the exceptional cases where parl is zero
-            if (FastMath.abs(fp) <= 0.1 * delta ||
+            if (AccurateMath.abs(fp) <= 0.1 * delta ||
                 (parl == 0 &&
                  fp <= previousFP &&
                  previousFP < 0)) {
@@ -765,13 +765,13 @@
 
             // depending on the sign of the function, update parl or paru.
             if (fp > 0) {
-                parl = FastMath.max(parl, lmPar);
+                parl = AccurateMath.max(parl, lmPar);
             } else if (fp < 0) {
-                paru = FastMath.min(paru, lmPar);
+                paru = AccurateMath.min(paru, lmPar);
             }
 
             // compute an improved estimate for lmPar
-            lmPar = FastMath.max(parl, lmPar + correction);
+            lmPar = AccurateMath.max(parl, lmPar + correction);
         }
 
         return lmPar;
@@ -847,13 +847,13 @@
                     final double sin;
                     final double cos;
                     double rkk = weightedJacobian[k][pk];
-                    if (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {
+                    if (AccurateMath.abs(rkk) < AccurateMath.abs(lmDiag[k])) {
                         final double cotan = rkk / lmDiag[k];
-                        sin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);
+                        sin   = 1.0 / AccurateMath.sqrt(1.0 + cotan * cotan);
                         cos   = sin * cotan;
                     } else {
                         final double tan = lmDiag[k] / rkk;
-                        cos = 1.0 / FastMath.sqrt(1.0 + tan * tan);
+                        cos = 1.0 / AccurateMath.sqrt(1.0 + tan * tan);
                         sin = cos * tan;
                     }
 
@@ -956,7 +956,7 @@
                 double akk = weightedJacobian[i][k];
                 norm2 += akk * akk;
             }
-            jacNorm[k] = FastMath.sqrt(norm2);
+            jacNorm[k] = AccurateMath.sqrt(norm2);
         }
 
         // transform the matrix column after column
@@ -989,7 +989,7 @@
 
             // choose alpha such that Hk.u = alpha ek
             double akk = weightedJacobian[k][pk];
-            double alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);
+            double alpha = (akk > 0) ? -AccurateMath.sqrt(ak2) : AccurateMath.sqrt(ak2);
             double betak = 1.0 / (ak2 - akk * alpha);
             beta[pk] = betak;
 