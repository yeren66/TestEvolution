--- 
+++ 
@@ -24,7 +24,7 @@
 import org.apache.commons.math4.legacy.exception.NumberIsTooLargeException;
 import org.apache.commons.math4.legacy.exception.TooManyEvaluationsException;
 import org.apache.commons.math4.legacy.exception.util.LocalizedFormats;
-import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
+import org.apache.commons.math4.core.jdkmath.JdkMath;
 
 /**
  * Implements the <a href="http://mathworld.wolfram.com/LaguerresMethod.html">
@@ -100,13 +100,13 @@
 
         // Return the initial guess if it is good enough.
         final double yInitial = computeObjectiveValue(initial);
-        if (AccurateMath.abs(yInitial) <= functionValueAccuracy) {
+        if (JdkMath.abs(yInitial) <= functionValueAccuracy) {
             return initial;
         }
 
         // Return the first endpoint if it is good enough.
         final double yMin = computeObjectiveValue(min);
-        if (AccurateMath.abs(yMin) <= functionValueAccuracy) {
+        if (JdkMath.abs(yMin) <= functionValueAccuracy) {
             return min;
         }
 
@@ -117,7 +117,7 @@
 
         // Return the second endpoint if it is good enough.
         final double yMax = computeObjectiveValue(max);
-        if (AccurateMath.abs(yMax) <= functionValueAccuracy) {
+        if (JdkMath.abs(yMax) <= functionValueAccuracy) {
             return max;
         }
 
@@ -241,8 +241,8 @@
          */
         public boolean isRoot(double min, double max, Complex z) {
             if (isSequence(min, z.getReal(), max)) {
-                double tolerance = AccurateMath.max(getRelativeAccuracy() * z.abs(), getAbsoluteAccuracy());
-                return (AccurateMath.abs(z.getImaginary()) <= tolerance) ||
+                double tolerance = JdkMath.max(getRelativeAccuracy() * z.abs(), getAbsoluteAccuracy());
+                return (JdkMath.abs(z.getImaginary()) <= tolerance) ||
                      (z.abs() <= getFunctionValueAccuracy());
             }
             return false;
@@ -347,7 +347,7 @@
                 d2v = d2v.multiply(Complex.ofCartesian(2.0, 0.0));
 
                 // Check for convergence.
-                final double tolerance = AccurateMath.max(relativeAccuracy * z.abs(),
+                final double tolerance = JdkMath.max(relativeAccuracy * z.abs(),
                                                       absoluteAccuracy);
                 if ((z.subtract(oldz)).abs() <= tolerance) {
                     return z;