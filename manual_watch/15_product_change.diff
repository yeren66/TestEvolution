--- 
+++ 
@@ -17,6 +17,8 @@
 package org.apache.commons.math4.legacy.analysis.interpolation;
 
 import java.util.Arrays;
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.Function;
 
 import org.apache.commons.numbers.core.Sum;
 import org.apache.commons.math4.legacy.analysis.BivariateFunction;
@@ -92,6 +94,38 @@
         throws DimensionMismatchException,
                NoDataException,
                NonMonotonicSequenceException {
+        this(x, y, f, dFdX, dFdY, d2FdXdY, false);
+    }
+
+    /**
+     * @param x Sample values of the x-coordinate, in increasing order.
+     * @param y Sample values of the y-coordinate, in increasing order.
+     * @param f Values of the function on every grid point.
+     * @param dFdX Values of the partial derivative of function with respect
+     * to x on every grid point.
+     * @param dFdY Values of the partial derivative of function with respect
+     * to y on every grid point.
+     * @param d2FdXdY Values of the cross partial derivative of function on
+     * every grid point.
+     * @param initializeDerivatives Whether to initialize the internal data
+     * needed for calling any of the methods that compute the partial derivatives
+     * this function.
+     * @throws DimensionMismatchException if the various arrays do not contain
+     * the expected number of elements.
+     * @throws NonMonotonicSequenceException if {@code x} or {@code y} are
+     * not strictly increasing.
+     * @throws NoDataException if any of the arrays has zero length.
+     */
+    public BicubicInterpolatingFunction(double[] x,
+                                        double[] y,
+                                        double[][] f,
+                                        double[][] dFdX,
+                                        double[][] dFdY,
+                                        double[][] d2FdXdY,
+                                        boolean initializeDerivatives)
+        throws DimensionMismatchException,
+               NoDataException,
+               NonMonotonicSequenceException {
         final int xLen = x.length;
         final int yLen = y.length;
 
@@ -147,7 +181,10 @@
                     d2FdXdY[i][j] * xRyR, d2FdXdY[ip1][j] * xRyR, d2FdXdY[i][jp1] * xRyR, d2FdXdY[ip1][jp1] * xRyR
                 };
 
-                splines[i][j] = new BicubicFunction(computeSplineCoefficients(beta));
+                splines[i][j] = new BicubicFunction(computeSplineCoefficients(beta),
+                                                    xR,
+                                                    yR,
+                                                    initializeDerivatives);
             }
         }
     }
@@ -179,6 +216,75 @@
             x > xval[xval.length - 1] ||
             y < yval[0] ||
             y > yval[yval.length - 1]);
+    }
+
+    /**
+     * @return the first partial derivative respect to x.
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
+     */
+    public DoubleBinaryOperator partialDerivativeX() {
+        return partialDerivative(BicubicFunction::partialDerivativeX);
+    }
+
+    /**
+     * @return the first partial derivative respect to y.
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
+     */
+    public DoubleBinaryOperator partialDerivativeY() {
+        return partialDerivative(BicubicFunction::partialDerivativeY);
+    }
+
+    /**
+     * @return the second partial derivative respect to x.
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
+     */
+    public DoubleBinaryOperator partialDerivativeXX() {
+        return partialDerivative(BicubicFunction::partialDerivativeXX);
+    }
+
+    /**
+     * @return the second partial derivative respect to y.
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
+     */
+    public DoubleBinaryOperator partialDerivativeYY() {
+        return partialDerivative(BicubicFunction::partialDerivativeYY);
+    }
+
+    /**
+     * @return the second partial cross derivative.
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
+     */
+    public DoubleBinaryOperator partialDerivativeXY() {
+        return partialDerivative(BicubicFunction::partialDerivativeXY);
+    }
+
+    /**
+     * @param which derivative function to apply.
+     * @return the selected partial derivative.
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
+     */
+    private DoubleBinaryOperator partialDerivative(Function<BicubicFunction, BivariateFunction> which) {
+        return (x, y) -> {
+            final int i = searchIndex(x, xval);
+            final int j = searchIndex(y, yval);
+
+            final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);
+            final double yN = (y - yval[j]) / (yval[j + 1] - yval[j]);
+
+            return which.apply(splines[i][j]).value(xN, yN);
+        };
     }
 
     /**
@@ -256,6 +362,7 @@
 
         return a;
     }
+
 }
 
 /**
@@ -266,19 +373,111 @@
     private static final short N = 4;
     /** Coefficients. */
     private final double[][] a;
+    /** First partial derivative along x. */
+    private final BivariateFunction partialDerivativeX;
+    /** First partial derivative along y. */
+    private final BivariateFunction partialDerivativeY;
+    /** Second partial derivative along x. */
+    private final BivariateFunction partialDerivativeXX;
+    /** Second partial derivative along y. */
+    private final BivariateFunction partialDerivativeYY;
+    /** Second crossed partial derivative. */
+    private final BivariateFunction partialDerivativeXY;
 
     /**
      * Simple constructor.
      *
      * @param coeff Spline coefficients.
-     */
-    BicubicFunction(double[] coeff) {
+     * @param xR x spacing.
+     * @param yR y spacing.
+     * @param initializeDerivatives Whether to initialize the internal data
+     * needed for calling any of the methods that compute the partial derivatives
+     * this function.
+     */
+    BicubicFunction(double[] coeff,
+                    double xR,
+                    double yR,
+                    boolean initializeDerivatives) {
         a = new double[N][N];
         for (int j = 0; j < N; j++) {
             final double[] aJ = a[j];
             for (int i = 0; i < N; i++) {
                 aJ[i] = coeff[i * N + j];
             }
+        }
+
+        if (initializeDerivatives) {
+            // Compute all partial derivatives functions.
+            final double[][] aX = new double[N][N];
+            final double[][] aY = new double[N][N];
+            final double[][] aXX = new double[N][N];
+            final double[][] aYY = new double[N][N];
+            final double[][] aXY = new double[N][N];
+
+            for (int i = 0; i < N; i++) {
+                for (int j = 0; j < N; j++) {
+                    final double c = a[i][j];
+                    aX[i][j] = i * c;
+                    aY[i][j] = j * c;
+                    aXX[i][j] = (i - 1) * aX[i][j];
+                    aYY[i][j] = (j - 1) * aY[i][j];
+                    aXY[i][j] = j * aX[i][j];
+                }
+            }
+
+            partialDerivativeX = (double x, double y) -> {
+                final double x2 = x * x;
+                final double[] pX = {0, 1, x, x2};
+
+                final double y2 = y * y;
+                final double y3 = y2 * y;
+                final double[] pY = {1, y, y2, y3};
+
+                return apply(pX, pY, aX) / xR;
+            };
+            partialDerivativeY = (double x, double y) -> {
+                final double x2 = x * x;
+                final double x3 = x2 * x;
+                final double[] pX = {1, x, x2, x3};
+
+                final double y2 = y * y;
+                final double[] pY = {0, 1, y, y2};
+
+                return apply(pX, pY, aY) / yR;
+            };
+            partialDerivativeXX = (double x, double y) -> {
+                final double[] pX = {0, 0, 1, x};
+
+                final double y2 = y * y;
+                final double y3 = y2 * y;
+                final double[] pY = {1, y, y2, y3};
+
+                return apply(pX, pY, aXX) / (xR * xR);
+            };
+            partialDerivativeYY = (double x, double y) -> {
+                final double x2 = x * x;
+                final double x3 = x2 * x;
+                final double[] pX = {1, x, x2, x3};
+
+                final double[] pY = {0, 0, 1, y};
+
+                return apply(pX, pY, aYY) / (yR * yR);
+            };
+            partialDerivativeXY = (double x, double y) -> {
+                final double x2 = x * x;
+                final double[] pX = {0, 1, x, x2};
+
+                final double y2 = y * y;
+                final double[] pY = {0, 1, y, y2};
+
+                return apply(pX, pY, aXY) / (xR * yR);
+            };
+        } else {
+            partialDerivativeX = null;
+            partialDerivativeY = null;
+            partialDerivativeXX = null;
+            partialDerivativeYY = null;
+            partialDerivativeXY = null;
         }
     }
 
@@ -322,4 +521,40 @@
 
         return result;
     }
+
+    /**
+     * @return the partial derivative wrt {@code x}.
+     */
+    BivariateFunction partialDerivativeX() {
+        return partialDerivativeX;
+    }
+
+    /**
+     * @return the partial derivative wrt {@code y}.
+     */
+    BivariateFunction partialDerivativeY() {
+        return partialDerivativeY;
+    }
+
+    /**
+     * @return the second partial derivative wrt {@code x}.
+     */
+    BivariateFunction partialDerivativeXX() {
+        return partialDerivativeXX;
+    }
+
+    /**
+     * @return the second partial derivative wrt {@code y}.
+     */
+    BivariateFunction partialDerivativeYY() {
+        return partialDerivativeYY;
+    }
+
+    /**
+     * @return the second partial cross-derivative.
+     */
+    BivariateFunction partialDerivativeXY() {
+        return partialDerivativeXY;
+    }
+
 }