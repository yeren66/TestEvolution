--- 
+++ 
@@ -23,7 +23,7 @@
 import org.apache.commons.statistics.distribution.ContinuousDistribution;
 import org.apache.commons.statistics.distribution.NormalDistribution;
 import org.apache.commons.math4.legacy.exception.MathUnsupportedOperationException;
-import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
+import org.apache.commons.math4.core.jdkmath.JdkMath;
 import org.apache.commons.math4.legacy.core.MathArrays;
 import org.apache.commons.numbers.core.Precision;
 import org.apache.commons.rng.simple.RandomSource;
@@ -513,7 +513,7 @@
 
             double diffNorm = x.subtract(y).getNorm();
             Assert.assertTrue("The norm of (X-Y) is too large: " + diffNorm + ", matrix=" + m.toString(),
-                    x.subtract(y).getNorm() < 1000 * Precision.EPSILON * AccurateMath.max(x.getNorm(), y.getNorm()));
+                    x.subtract(y).getNorm() < 1000 * Precision.EPSILON * JdkMath.max(x.getNorm(), y.getNorm()));
 
             RealMatrix invV = new LUDecomposition(v).getSolver().getInverse();
             double norm = v.multiply(d).multiply(invV).subtract(m).getNorm();
@@ -617,11 +617,11 @@
         EigenDecomposition ed;
         ed = new EigenDecomposition(indefinite);
         checkEigenValues(new double[] {2, 1, -1}, ed, 1E-12);
-        double isqrt3 = 1/AccurateMath.sqrt(3.0);
+        double isqrt3 = 1/JdkMath.sqrt(3.0);
         checkEigenVector(new double[] {isqrt3,isqrt3,-isqrt3}, ed, 1E-12);
-        double isqrt2 = 1/AccurateMath.sqrt(2.0);
+        double isqrt2 = 1/JdkMath.sqrt(2.0);
         checkEigenVector(new double[] {0.0,-isqrt2,-isqrt2}, ed, 1E-12);
-        double isqrt6 = 1/AccurateMath.sqrt(6.0);
+        double isqrt6 = 1/JdkMath.sqrt(6.0);
         checkEigenVector(new double[] {2*isqrt6,-isqrt6,isqrt6}, ed, 1E-12);
     }
 
@@ -670,7 +670,7 @@
        boolean found = false;
        int i = 0;
        while (!found && i < searchArray.length) {
-           if (AccurateMath.abs(value - searchArray[i]) < tolerance) {
+           if (JdkMath.abs(value - searchArray[i]) < tolerance) {
                found = true;
            }
            i++;
@@ -703,11 +703,11 @@
             while (matching && j < searchMatrix.getRowDimension()) {
                 double colEntry = searchMatrix.getEntry(j, i);
                 // Use the first entry where both are non-zero as scalar
-                if (AccurateMath.abs(multiplier - 1.0) <= AccurateMath.ulp(1.0) && AccurateMath.abs(colEntry) > 1E-14
-                        && AccurateMath.abs(column[j]) > 1e-14) {
+                if (JdkMath.abs(multiplier - 1.0) <= JdkMath.ulp(1.0) && JdkMath.abs(colEntry) > 1E-14
+                        && JdkMath.abs(column[j]) > 1e-14) {
                     multiplier = colEntry / column[j];
                 }
-                if (AccurateMath.abs(column[j] * multiplier - colEntry) > tolerance) {
+                if (JdkMath.abs(column[j] * multiplier - colEntry) > tolerance) {
                     matching = false;
                 }
                 j++;
@@ -770,7 +770,7 @@
                 for (final double dataIJ : dataI) {
                     norm2 += dataIJ * dataIJ;
                 }
-                final double inv = 1.0 / AccurateMath.sqrt(norm2);
+                final double inv = 1.0 / JdkMath.sqrt(norm2);
                 for (int j = 0; j < size; ++j) {
                     dataI[j] *= inv;
                 }