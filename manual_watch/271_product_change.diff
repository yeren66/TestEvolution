--- 
+++ 
@@ -38,7 +38,7 @@
 import org.apache.commons.rng.UniformRandomProvider;
 import org.apache.commons.statistics.distribution.ContinuousDistribution;
 import org.apache.commons.statistics.distribution.NormalDistribution;
-import org.apache.commons.math4.legacy.util.FastMath;
+import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
 
 /**
  * An implementation of the active Covariance Matrix Adaptation Evolution Strategy (CMA-ES)
@@ -443,7 +443,7 @@
                 updateCovarianceDiagonalOnly(hsig, bestArz);
             }
             // Adapt step size sigma - Eq. (5)
-            sigma *= FastMath.exp(FastMath.min(1, (normps/chiN - 1) * cs / damps));
+            sigma *= AccurateMath.exp(AccurateMath.min(1, (normps/chiN - 1) * cs / damps));
             final double bestFitness = fitness[arindex[0]];
             final double worstFitness = fitness[arindex[arindex.length - 1]];
             if (bestValue > bestFitness) {
@@ -464,7 +464,7 @@
             final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
             final double[] pcCol = pc.getColumn(0);
             for (int i = 0; i < dimension; i++) {
-                if (sigma * FastMath.max(FastMath.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
+                if (sigma * AccurateMath.max(AccurateMath.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                     break;
                 }
                 if (i >= dimension - 1) {
@@ -479,8 +479,8 @@
             final double historyBest = min(fitnessHistory);
             final double historyWorst = max(fitnessHistory);
             if (iterations > 2 &&
-                FastMath.max(historyWorst, worstFitness) -
-                FastMath.min(historyBest, bestFitness) < stopTolFun) {
+                AccurateMath.max(historyWorst, worstFitness) -
+                AccurateMath.min(historyBest, bestFitness) < stopTolFun) {
                 break generationLoop;
             }
             if (iterations > fitnessHistory.length &&
@@ -504,11 +504,11 @@
             }
             // Adjust step size in case of equal function values (flat fitness)
             if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
-                sigma *= FastMath.exp(0.2 + cs / damps);
-            }
-            if (iterations > 2 && FastMath.max(historyWorst, bestFitness) -
-                FastMath.min(historyBest, bestFitness) == 0) {
-                sigma *= FastMath.exp(0.2 + cs / damps);
+                sigma *= AccurateMath.exp(0.2 + cs / damps);
+            }
+            if (iterations > 2 && AccurateMath.max(historyWorst, bestFitness) -
+                AccurateMath.min(historyBest, bestFitness) == 0) {
+                sigma *= AccurateMath.exp(0.2 + cs / damps);
             }
             // store best in history
             push(fitnessHistory,bestFitness);
@@ -600,7 +600,7 @@
 
         // initialize selection strategy parameters
         mu = lambda / 2; // number of parents/points for recombination
-        logMu2 = FastMath.log(mu + 0.5);
+        logMu2 = AccurateMath.log(mu + 0.5);
         weights = log(sequence(1, mu, 1)).scalarMultiply(-1).scalarAdd(logMu2);
         double sumw = 0;
         double sumwq = 0;
@@ -616,16 +616,16 @@
         cc = (4 + mueff / dimension) /
                 (dimension + 4 + 2 * mueff / dimension);
         cs = (mueff + 2) / (dimension + mueff + 3.);
-        damps = (1 + 2 * FastMath.max(0, FastMath.sqrt((mueff - 1) /
+        damps = (1 + 2 * AccurateMath.max(0, AccurateMath.sqrt((mueff - 1) /
                                                        (dimension + 1)) - 1)) *
-            FastMath.max(0.3,
+            AccurateMath.max(0.3,
                          1 - dimension / (1e-6 + maxIterations)) + cs; // minor increment
         ccov1 = 2 / ((dimension + 1.3) * (dimension + 1.3) + mueff);
-        ccovmu = FastMath.min(1 - ccov1, 2 * (mueff - 2 + 1 / mueff) /
+        ccovmu = AccurateMath.min(1 - ccov1, 2 * (mueff - 2 + 1 / mueff) /
                               ((dimension + 2) * (dimension + 2) + mueff));
-        ccov1Sep = FastMath.min(1, ccov1 * (dimension + 1.5) / 3);
-        ccovmuSep = FastMath.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3);
-        chiN = FastMath.sqrt(dimension) *
+        ccov1Sep = AccurateMath.min(1, ccov1 * (dimension + 1.5) / 3);
+        ccovmuSep = AccurateMath.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3);
+        chiN = AccurateMath.sqrt(dimension) *
                 (1 - 1 / ((double) 4 * dimension) + 1 / ((double) 21 * dimension * dimension));
         // initialize CMA internal values - updated each generation
         xmean = MatrixUtils.createColumnRealMatrix(guess); // objective variables
@@ -657,14 +657,14 @@
     private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {
         ps = ps.scalarMultiply(1 - cs).add(
                 B.multiply(zmean).scalarMultiply(
-                        FastMath.sqrt(cs * (2 - cs) * mueff)));
+                        AccurateMath.sqrt(cs * (2 - cs) * mueff)));
         normps = ps.getFrobeniusNorm();
         final boolean hsig = normps /
-            FastMath.sqrt(1 - FastMath.pow(1 - cs, 2 * iterations)) /
+            AccurateMath.sqrt(1 - AccurateMath.pow(1 - cs, 2 * iterations)) /
             chiN < 1.4 + 2 / ((double) dimension + 1);
         pc = pc.scalarMultiply(1 - cc);
         if (hsig) {
-            pc = pc.add(xmean.subtract(xold).scalarMultiply(FastMath.sqrt(cc * (2 - cc) * mueff) / sigma));
+            pc = pc.add(xmean.subtract(xold).scalarMultiply(AccurateMath.sqrt(cc * (2 - cc) * mueff) / sigma));
         }
         return hsig;
     }
@@ -722,7 +722,7 @@
             if (isActiveCMA) {
                 // Adapt covariance matrix C active CMA
                 negccov = (1 - ccovmu) * 0.25 * mueff /
-                    (FastMath.pow(dimension + 2, 1.5) + 2 * mueff);
+                    (AccurateMath.pow(dimension + 2, 1.5) + 2 * mueff);
                 // keep at least 0.66 in all directions, small popsize are most
                 // critical
                 final double negminresidualvariance = 0.66;
@@ -1006,7 +1006,7 @@
         private double penalty(final double[] x, final double[] repaired) {
             double penalty = 0;
             for (int i = 0; i < x.length; i++) {
-                double diff = FastMath.abs(x[i] - repaired[i]);
+                double diff = AccurateMath.abs(x[i] - repaired[i]);
                 penalty += diff;
             }
             return isMinimize ? penalty : -penalty;
@@ -1023,7 +1023,7 @@
         final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
         for (int r = 0; r < m.getRowDimension(); r++) {
             for (int c = 0; c < m.getColumnDimension(); c++) {
-                d[r][c] = FastMath.log(m.getEntry(r, c));
+                d[r][c] = AccurateMath.log(m.getEntry(r, c));
             }
         }
         return new Array2DRowRealMatrix(d, false);
@@ -1037,7 +1037,7 @@
         final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
         for (int r = 0; r < m.getRowDimension(); r++) {
             for (int c = 0; c < m.getColumnDimension(); c++) {
-                d[r][c] = FastMath.sqrt(m.getEntry(r, c));
+                d[r][c] = AccurateMath.sqrt(m.getEntry(r, c));
             }
         }
         return new Array2DRowRealMatrix(d, false);