--- 
+++ 
@@ -26,7 +26,7 @@
 import org.apache.commons.math4.legacy.ode.events.EventHandler;
 import org.apache.commons.math4.legacy.ode.sampling.AbstractStepInterpolator;
 import org.apache.commons.math4.legacy.ode.sampling.StepHandler;
-import org.apache.commons.math4.legacy.util.FastMath;
+import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
 
 /**
  * This class implements a Gragg-Bulirsch-Stoer integrator for
@@ -425,12 +425,12 @@
   private void rescale(final double[] y1, final double[] y2, final double[] scale) {
     if (vecAbsoluteTolerance == null) {
       for (int i = 0; i < scale.length; ++i) {
-        final double yi = FastMath.max(FastMath.abs(y1[i]), FastMath.abs(y2[i]));
+        final double yi = AccurateMath.max(AccurateMath.abs(y1[i]), AccurateMath.abs(y2[i]));
         scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;
       }
     } else {
       for (int i = 0; i < scale.length; ++i) {
-        final double yi = FastMath.max(FastMath.abs(y1[i]), FastMath.abs(y2[i]));
+        final double yi = AccurateMath.max(AccurateMath.abs(y1[i]), AccurateMath.abs(y2[i]));
         scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;
       }
     }
@@ -500,7 +500,7 @@
           final double ratio = (f[j+1][l] - f[0][l]) / scale[l];
           deltaNorm += ratio * ratio;
         }
-        if (deltaNorm > 4 * FastMath.max(1.0e-15, initialNorm)) {
+        if (deltaNorm > 4 * AccurateMath.max(1.0e-15, initialNorm)) {
           return false;
         }
       }
@@ -595,10 +595,10 @@
     // initial order selection
     final double tol =
         (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
-    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));
-    int targetIter = FastMath.max(1,
-                              FastMath.min(sequence.length - 2,
-                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));
+    final double log10R = AccurateMath.log10(AccurateMath.max(1.0e-10, tol));
+    int targetIter = AccurateMath.max(1,
+                              AccurateMath.min(sequence.length - 2,
+                                       (int) AccurateMath.floor(0.5 - 0.6 * log10R)));
 
     // set up an interpolator sharing the integrator arrays
     final AbstractStepInterpolator interpolator =
@@ -665,7 +665,7 @@
                        yTmp)) {
 
           // the stability check failed, we reduce the global step
-          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
+          hNew   = AccurateMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
           reject = true;
           loop   = false;
 
@@ -682,26 +682,26 @@
             // estimate the error at the end of the step.
             error = 0;
             for (int j = 0; j < mainSetDimension; ++j) {
-              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];
+              final double e = AccurateMath.abs(y1[j] - y1Diag[0][j]) / scale[j];
               error += e * e;
             }
-            error = FastMath.sqrt(error / mainSetDimension);
+            error = AccurateMath.sqrt(error / mainSetDimension);
 
             if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
               // error is too big, we reduce the global step
-              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
+              hNew   = AccurateMath.abs(filterStep(stepSize * stabilityReduction, forward, false));
               reject = true;
               loop   = false;
             } else {
 
-              maxError = FastMath.max(4 * error, 1.0);
+              maxError = AccurateMath.max(4 * error, 1.0);
 
               // compute optimal stepsize for this order
               final double exp = 1.0 / (2 * k + 1);
-              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);
-              final double pow = FastMath.pow(stepControl3, exp);
-              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));
-              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));
+              double fac = stepControl2 / AccurateMath.pow(error / stepControl1, exp);
+              final double pow = AccurateMath.pow(stepControl3, exp);
+              fac = AccurateMath.max(pow / stepControl4, AccurateMath.min(1 / pow, fac));
+              optimalStep[k]     = AccurateMath.abs(filterStep(stepSize * fac, forward, true));
               costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];
 
               // check convergence
@@ -807,13 +807,13 @@
 
           // derivative at middle point of the step
           final int l2 = l / 2;
-          double factor = FastMath.pow(0.5 * sequence[l2], l);
+          double factor = AccurateMath.pow(0.5 * sequence[l2], l);
           int middleIndex = fk[l2].length / 2;
           for (int i = 0; i < y0.length; ++i) {
             yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];
           }
           for (int j = 1; j <= k - l2; ++j) {
-            factor = FastMath.pow(0.5 * sequence[j + l2], l);
+            factor = AccurateMath.pow(0.5 * sequence[j + l2], l);
             middleIndex = fk[l2+j].length / 2;
             for (int i = 0; i < y0.length; ++i) {
               diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];
@@ -845,7 +845,7 @@
           if (useInterpolationError) {
             // use the interpolation error to limit stepsize
             final double interpError = gbsInterpolator.estimateError(scale);
-            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),
+            hInt = AccurateMath.abs(stepSize / AccurateMath.max(AccurateMath.pow(interpError, 1.0 / (mu+4)),
                                                 0.01));
             if (interpError > 10.0) {
               hNew = hInt;
@@ -880,7 +880,7 @@
           if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {
             optimalIter = k-1;
           } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {
-            optimalIter = FastMath.min(k+1, sequence.length - 2);
+            optimalIter = AccurateMath.min(k+1, sequence.length - 2);
           }
         } else {
           optimalIter = k - 1;
@@ -889,15 +889,15 @@
             optimalIter = k - 2;
           }
           if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
-            optimalIter = FastMath.min(k, sequence.length - 2);
+            optimalIter = AccurateMath.min(k, sequence.length - 2);
           }
         }
 
         if (previousRejected) {
           // after a rejected step neither order nor stepsize
           // should increase
-          targetIter = FastMath.min(optimalIter, k);
-          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);
+          targetIter = AccurateMath.min(optimalIter, k);
+          hNew = AccurateMath.min(AccurateMath.abs(stepSize), optimalStep[targetIter]);
         } else {
           // stepsize control
           if (optimalIter <= k) {
@@ -921,7 +921,7 @@
 
       }
 
-      hNew = FastMath.min(hNew, hInt);
+      hNew = AccurateMath.min(hNew, hInt);
       if (! forward) {
         hNew = -hNew;
       }