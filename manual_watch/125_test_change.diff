--- 
+++ 
@@ -16,9 +16,6 @@
  */
 package org.apache.commons.math4.legacy.optim.nonlinear.scalar.noderiv;
 
-import java.util.Arrays;
-import java.util.Random;
-
 import org.apache.commons.math4.legacy.Retry;
 import org.apache.commons.math4.legacy.RetryRunner;
 import org.apache.commons.math4.legacy.analysis.MultivariateFunction;
@@ -33,6 +30,7 @@
 import org.apache.commons.math4.legacy.optim.SimpleBounds;
 import org.apache.commons.math4.legacy.optim.nonlinear.scalar.GoalType;
 import org.apache.commons.math4.legacy.optim.nonlinear.scalar.ObjectiveFunction;
+import org.apache.commons.math4.legacy.optim.nonlinear.scalar.TestFunction;
 import org.apache.commons.rng.simple.RandomSource;
 import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
 import org.junit.Assert;
@@ -50,71 +48,71 @@
 
     @Test(expected = NumberIsTooLargeException.class)
     public void testInitOutofbounds1() {
-        double[] startPoint = point(DIM,3);
-        double[] insigma = point(DIM, 0.3);
+        double[] startPoint = OptimTestUtils.point(DIM,3);
+        double[] insigma = OptimTestUtils.point(DIM, 0.3);
         double[][] boundaries = boundaries(DIM,-1,2);
         PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
     @Test(expected = NumberIsTooSmallException.class)
     public void testInitOutofbounds2() {
-        double[] startPoint = point(DIM, -2);
-        double[] insigma = point(DIM, 0.3);
+        double[] startPoint = OptimTestUtils.point(DIM, -2);
+        double[] insigma = OptimTestUtils.point(DIM, 0.3);
         double[][] boundaries = boundaries(DIM,-1,2);
         PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test(expected = DimensionMismatchException.class)
     public void testBoundariesDimensionMismatch() {
-        double[] startPoint = point(DIM,0.5);
-        double[] insigma = point(DIM, 0.3);
+        double[] startPoint = OptimTestUtils.point(DIM,0.5);
+        double[] insigma = OptimTestUtils.point(DIM, 0.3);
         double[][] boundaries = boundaries(DIM+1,-1,2);
         PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test(expected = NotPositiveException.class)
     public void testInputSigmaNegative() {
-        double[] startPoint = point(DIM,0.5);
-        double[] insigma = point(DIM,-0.5);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,0.5);
+        double[] insigma = OptimTestUtils.point(DIM,-0.5);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test(expected = OutOfRangeException.class)
     public void testInputSigmaOutOfRange() {
-        double[] startPoint = point(DIM,0.5);
-        double[] insigma = point(DIM, 1.1);
+        double[] startPoint = OptimTestUtils.point(DIM,0.5);
+        double[] insigma = OptimTestUtils.point(DIM, 1.1);
         double[][] boundaries = boundaries(DIM,-0.5,0.5);
         PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test(expected = DimensionMismatchException.class)
     public void testInputSigmaDimensionMismatch() {
-        double[] startPoint = point(DIM,0.5);
-        double[] insigma = point(DIM + 1, 0.5);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,0.5);
+        double[] insigma = OptimTestUtils.point(DIM + 1, 0.5);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
@@ -122,15 +120,15 @@
     @Test
     @Retry(3)
     public void testRosen() {
-        double[] startPoint = point(DIM,0.1);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
-                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
-                1e-13, 1e-6, 100000, expected);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,0.1);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
+                1e-13, 1e-6, 100000, expected);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
@@ -138,20 +136,20 @@
     @Test
     @Retry(3)
     public void testMaximize() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),1.0);
-        doTest(new MinusElli(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),1.0);
+        doTest(TestFunction.MINUS_ELLI.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,
                 2e-10, 5e-6, 100000, expected);
-        doTest(new MinusElli(), startPoint, insigma, boundaries,
+        doTest(TestFunction.MINUS_ELLI.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13,
                 2e-10, 5e-6, 100000, expected);
         boundaries = boundaries(DIM,-0.3,0.3);
-        startPoint = point(DIM,0.1);
-        doTest(new MinusElli(), startPoint, insigma, boundaries,
+        startPoint = OptimTestUtils.point(DIM,0.1);
+        doTest(TestFunction.MINUS_ELLI.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13,
                 2e-10, 5e-6, 100000, expected);
     }
@@ -182,207 +180,207 @@
 
     @Test
     public void testEllipse() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new Elli(), startPoint, insigma, boundaries,
-                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
-                1e-13, 1e-6, 100000, expected);
-        doTest(new Elli(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.ELLI.withDimension(DIM), startPoint, insigma, boundaries,
+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
+                1e-13, 1e-6, 100000, expected);
+        doTest(TestFunction.ELLI.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test
     public void testElliRotated() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new ElliRotated(), startPoint, insigma, boundaries,
-                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
-                1e-13, 1e-6, 100000, expected);
-        doTest(new ElliRotated(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(new OptimTestUtils.ElliRotated(), startPoint, insigma, boundaries,
+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
+                1e-13, 1e-6, 100000, expected);
+        doTest(new OptimTestUtils.ElliRotated(), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test
     public void testCigar() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new Cigar(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.CIGAR.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 200000, expected);
-        doTest(new Cigar(), startPoint, insigma, boundaries,
+        doTest(TestFunction.CIGAR.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test
     public void testCigarWithBoundaries() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
         double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY);
         PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new Cigar(), startPoint, insigma, boundaries,
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.CIGAR.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 200000, expected);
-        doTest(new Cigar(), startPoint, insigma, boundaries,
+        doTest(TestFunction.CIGAR.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test
     public void testTwoAxes() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new TwoAxes(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.TWO_AXES.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 200000, expected);
-        doTest(new TwoAxes(), startPoint, insigma, boundaries,
+        doTest(TestFunction.TWO_AXES.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,
                 1e-8, 1e-3, 200000, expected);
     }
 
     @Test
     public void testCigTab() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.3);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new CigTab(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.3);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.CIG_TAB.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
                 1e-13, 5e-5, 100000, expected);
-        doTest(new CigTab(), startPoint, insigma, boundaries,
+        doTest(TestFunction.CIG_TAB.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 5e-5, 100000, expected);
     }
 
     @Test
     public void testSphere() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new Sphere(), startPoint, insigma, boundaries,
-                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
-                1e-13, 1e-6, 100000, expected);
-        doTest(new Sphere(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.SPHERE.withDimension(DIM), startPoint, insigma, boundaries,
+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
+                1e-13, 1e-6, 100000, expected);
+        doTest(TestFunction.SPHERE.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test
     public void testTablet() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new Tablet(), startPoint, insigma, boundaries,
-                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
-                1e-13, 1e-6, 100000, expected);
-        doTest(new Tablet(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.TABLET.withDimension(DIM), startPoint, insigma, boundaries,
+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,
+                1e-13, 1e-6, 100000, expected);
+        doTest(TestFunction.TABLET.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test
     public void testDiffPow() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new DiffPow(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.DIFF_POW.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 10, true, 0, 1e-13,
                 1e-8, 1e-1, 100000, expected);
-        doTest(new DiffPow(), startPoint, insigma, boundaries,
+        doTest(TestFunction.DIFF_POW.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 10, false, 0, 1e-13,
                 1e-8, 2e-1, 100000, expected);
     }
 
     @Test
     public void testSsDiffPow() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new SsDiffPow(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.SS_DIFF_POW.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 10, true, 0, 1e-13,
                 1e-4, 1e-1, 200000, expected);
-        doTest(new SsDiffPow(), startPoint, insigma, boundaries,
+        doTest(TestFunction.SS_DIFF_POW.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 10, false, 0, 1e-13,
                 1e-4, 1e-1, 200000, expected);
     }
 
     @Test
     public void testAckley() {
-        double[] startPoint = point(DIM,1.0);
-        double[] insigma = point(DIM,1.0);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new Ackley(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,1.0);
+        double[] insigma = OptimTestUtils.point(DIM,1.0);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.ACKLEY.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,
                 1e-9, 1e-5, 100000, expected);
-        doTest(new Ackley(), startPoint, insigma, boundaries,
+        doTest(TestFunction.ACKLEY.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,
                 1e-9, 1e-5, 100000, expected);
     }
 
     @Test
     public void testRastrigin() {
-        double[] startPoint = point(DIM,0.1);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,0.0),0.0);
-        doTest(new Rastrigin(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,0.1);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,0.0),0.0);
+        doTest(TestFunction.RASTRIGIN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, (int)(200*AccurateMath.sqrt(DIM)), true, 0, 1e-13,
                 1e-13, 1e-6, 200000, expected);
-        doTest(new Rastrigin(), startPoint, insigma, boundaries,
+        doTest(TestFunction.RASTRIGIN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, (int)(200*AccurateMath.sqrt(DIM)), false, 0, 1e-13,
                 1e-13, 1e-6, 200000, expected);
     }
 
     @Test
     public void testConstrainedRosen() {
-        double[] startPoint = point(DIM, 0.1);
-        double[] insigma = point(DIM, 0.1);
+        double[] startPoint = OptimTestUtils.point(DIM, 0.1);
+        double[] insigma = OptimTestUtils.point(DIM, 0.1);
         double[][] boundaries = boundaries(DIM, -1, 2);
         PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13,
                 1e-13, 1e-6, 100000, expected);
     }
 
     @Test
     public void testDiagonalRosen() {
-        double[] startPoint = point(DIM,0.1);
-        double[] insigma = point(DIM,0.1);
-        double[][] boundaries = null;
-        PointValuePair expected =
-            new PointValuePair(point(DIM,1.0),0.0);
-        doTest(new Rosen(), startPoint, insigma, boundaries,
+        double[] startPoint = OptimTestUtils.point(DIM,0.1);
+        double[] insigma = OptimTestUtils.point(DIM,0.1);
+        double[][] boundaries = null;
+        PointValuePair expected =
+            new PointValuePair(OptimTestUtils.point(DIM,1.0),0.0);
+        doTest(TestFunction.ROSEN.withDimension(DIM), startPoint, insigma, boundaries,
                 GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13,
                 1e-10, 1e-4, 1000000, expected);
      }
@@ -529,19 +527,12 @@
                            new CMAESOptimizer.Sigma(inSigma),
                            new CMAESOptimizer.PopulationSize(lambda));
 
-        // System.out.println("sol=" + Arrays.toString(result.getPoint()));
         Assert.assertEquals(expected.getValue(), result.getValue(), fTol);
         for (int i = 0; i < dim; i++) {
             Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol);
         }
 
         Assert.assertTrue(optim.getIterations() > 0);
-    }
-
-    private static double[] point(int n, double value) {
-        double[] ds = new double[n];
-        Arrays.fill(ds, value);
-        return ds;
     }
 
     private static double[][] boundaries(int dim,
@@ -555,300 +546,4 @@
         }
         return boundaries;
     }
-
-    private static class Sphere implements MultivariateFunction {
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            for (int i = 0; i < x.length; ++i) {
-                f += x[i] * x[i];
-            }
-            return f;
-        }
-    }
-
-    private static class Cigar implements MultivariateFunction {
-        private double factor;
-
-        Cigar() {
-            this(1e3);
-        }
-
-        Cigar(double axisratio) {
-            factor = axisratio * axisratio;
-        }
-
-        @Override
-        public double value(double[] x) {
-            double f = x[0] * x[0];
-            for (int i = 1; i < x.length; ++i) {
-                f += factor * x[i] * x[i];
-            }
-            return f;
-        }
-    }
-
-    private static class Tablet implements MultivariateFunction {
-        private double factor;
-
-        Tablet() {
-            this(1e3);
-        }
-
-        Tablet(double axisratio) {
-            factor = axisratio * axisratio;
-        }
-
-        @Override
-        public double value(double[] x) {
-            double f = factor * x[0] * x[0];
-            for (int i = 1; i < x.length; ++i) {
-                f += x[i] * x[i];
-            }
-            return f;
-        }
-    }
-
-    private static class CigTab implements MultivariateFunction {
-        private double factor;
-
-        CigTab() {
-            this(1e4);
-        }
-
-        CigTab(double axisratio) {
-            factor = axisratio;
-        }
-
-        @Override
-        public double value(double[] x) {
-            int end = x.length - 1;
-            double f = x[0] * x[0] / factor + factor * x[end] * x[end];
-            for (int i = 1; i < end; ++i) {
-                f += x[i] * x[i];
-            }
-            return f;
-        }
-    }
-
-    private static class TwoAxes implements MultivariateFunction {
-
-        private double factor;
-
-        TwoAxes() {
-            this(1e6);
-        }
-
-        TwoAxes(double axisratio) {
-            factor = axisratio * axisratio;
-        }
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            for (int i = 0; i < x.length; ++i) {
-                f += (i < x.length / 2 ? factor : 1) * x[i] * x[i];
-            }
-            return f;
-        }
-    }
-
-    private static class ElliRotated implements MultivariateFunction {
-        private Basis B = new Basis();
-        private double factor;
-
-        ElliRotated() {
-            this(1e3);
-        }
-
-        ElliRotated(double axisratio) {
-            factor = axisratio * axisratio;
-        }
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            x = B.Rotate(x);
-            for (int i = 0; i < x.length; ++i) {
-                f += AccurateMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];
-            }
-            return f;
-        }
-    }
-
-    private static class Elli implements MultivariateFunction {
-
-        private double factor;
-
-        Elli() {
-            this(1e3);
-        }
-
-        Elli(double axisratio) {
-            factor = axisratio * axisratio;
-        }
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            for (int i = 0; i < x.length; ++i) {
-                f += AccurateMath.pow(factor, i / (x.length - 1.)) * x[i] * x[i];
-            }
-            return f;
-        }
-    }
-
-    private static class MinusElli implements MultivariateFunction {
-
-        @Override
-        public double value(double[] x) {
-            return 1.0-(new Elli().value(x));
-        }
-    }
-
-    private static class DiffPow implements MultivariateFunction {
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            for (int i = 0; i < x.length; ++i) {
-                f += AccurateMath.pow(AccurateMath.abs(x[i]), 2. + 10 * (double) i
-                        / (x.length - 1.));
-            }
-            return f;
-        }
-    }
-
-    private static class SsDiffPow implements MultivariateFunction {
-
-        @Override
-        public double value(double[] x) {
-            double f = AccurateMath.pow(new DiffPow().value(x), 0.25);
-            return f;
-        }
-    }
-
-    private static class Rosen implements MultivariateFunction {
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            for (int i = 0; i < x.length - 1; ++i) {
-                f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1])
-                + (x[i] - 1.) * (x[i] - 1.);
-            }
-            return f;
-        }
-    }
-
-    private static class Ackley implements MultivariateFunction {
-        private double axisratio;
-
-        Ackley(double axra) {
-            axisratio = axra;
-        }
-
-        Ackley() {
-            this(1);
-        }
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            double res2 = 0;
-            double fac = 0;
-            for (int i = 0; i < x.length; ++i) {
-                fac = AccurateMath.pow(axisratio, (i - 1.) / (x.length - 1.));
-                f += fac * fac * x[i] * x[i];
-                res2 += AccurateMath.cos(2. * AccurateMath.PI * fac * x[i]);
-            }
-            f = 20. - 20. * AccurateMath.exp(-0.2 * AccurateMath.sqrt(f / x.length))
-                    + AccurateMath.exp(1.) - AccurateMath.exp(res2 / x.length);
-            return f;
-        }
-    }
-
-    private static class Rastrigin implements MultivariateFunction {
-
-        private double axisratio;
-        private double amplitude;
-
-        Rastrigin() {
-            this(1, 10);
-        }
-
-        Rastrigin(double axisratio, double amplitude) {
-            this.axisratio = axisratio;
-            this.amplitude = amplitude;
-        }
-
-        @Override
-        public double value(double[] x) {
-            double f = 0;
-            double fac;
-            for (int i = 0; i < x.length; ++i) {
-                fac = AccurateMath.pow(axisratio, (i - 1.) / (x.length - 1.));
-                if (i == 0 && x[i] < 0) {
-                    fac *= 1.;
-                }
-                f += fac * fac * x[i] * x[i] + amplitude
-                * (1. - AccurateMath.cos(2. * AccurateMath.PI * fac * x[i]));
-            }
-            return f;
-        }
-    }
-
-    private static class Basis {
-        private double[][] basis;
-        private Random rand = new Random(2); // use not always the same basis
-
-        double[] Rotate(double[] x) {
-            GenBasis(x.length);
-            double[] y = new double[x.length];
-            for (int i = 0; i < x.length; ++i) {
-                y[i] = 0;
-                for (int j = 0; j < x.length; ++j) {
-                    y[i] += basis[i][j] * x[j];
-                }
-            }
-            return y;
-        }
-
-        void GenBasis(int dim) {
-            if (basis != null ? basis.length == dim : false) {
-                return;
-            }
-
-            double sp;
-            int i;
-            int j;
-            int k;
-
-            /* generate orthogonal basis */
-            basis = new double[dim][dim];
-            for (i = 0; i < dim; ++i) {
-                /* sample components gaussian */
-                for (j = 0; j < dim; ++j) {
-                    basis[i][j] = rand.nextGaussian();
-                }
-                /* substract projection of previous vectors */
-                for (j = i - 1; j >= 0; --j) {
-                    for (sp = 0., k = 0; k < dim; ++k) {
-                        sp += basis[i][k] * basis[j][k]; /* scalar product */
-                    }
-                    for (k = 0; k < dim; ++k) {
-                        basis[i][k] -= sp * basis[j][k]; /* substract */
-                    }
-                }
-                /* normalize */
-                for (sp = 0., k = 0; k < dim; ++k) {
-                    sp += basis[i][k] * basis[i][k]; /* squared norm */
-                }
-                for (k = 0; k < dim; ++k) {
-                    basis[i][k] /= AccurateMath.sqrt(sp);
-                }
-            }
-        }
-    }
 }