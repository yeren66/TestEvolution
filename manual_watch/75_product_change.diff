--- 
+++ 
@@ -20,7 +20,7 @@
 import org.apache.commons.math4.legacy.exception.MaxCountExceededException;
 import org.apache.commons.math4.legacy.exception.NullArgumentException;
 import org.apache.commons.math4.legacy.exception.util.ExceptionContext;
-import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
+import org.apache.commons.math4.core.jdkmath.JdkMath;
 
 /**
  * <p>
@@ -360,8 +360,8 @@
         private boolean bIsNull;
 
         static {
-            MACH_PREC = AccurateMath.ulp(1.);
-            CBRT_MACH_PREC = AccurateMath.cbrt(MACH_PREC);
+            MACH_PREC = JdkMath.ulp(1.);
+            CBRT_MACH_PREC = JdkMath.cbrt(MACH_PREC);
         }
 
         /**
@@ -416,7 +416,7 @@
             final double s = y.dotProduct(y);
             final double t = x.dotProduct(z);
             final double epsa = (s + MACH_PREC) * CBRT_MACH_PREC;
-            if (AccurateMath.abs(s - t) > epsa) {
+            if (JdkMath.abs(s - t) > epsa) {
                 final NonSelfAdjointOperatorException e;
                 e = new NonSelfAdjointOperatorException();
                 final ExceptionContext context = e.getContext();
@@ -511,11 +511,11 @@
                     }
                 }
             } else {
-                final double anorm = AccurateMath.sqrt(tnorm);
+                final double anorm = JdkMath.sqrt(tnorm);
                 final double diag = gbar == 0. ? anorm * MACH_PREC : gbar;
                 final double zbar = gammaZeta / diag;
                 final double step = (bstep + snprod * zbar) / beta1;
-                // ynorm = AccurateMath.sqrt(ynorm2 + zbar * zbar);
+                // ynorm = JdkMath.sqrt(ynorm2 + zbar * zbar);
                 if (!goodb) {
                     for (int i = 0; i < n; i++) {
                         final double xi = this.xL.getEntry(i);
@@ -560,7 +560,7 @@
                 return;
             }
             this.bIsNull = false;
-            this.beta1 = AccurateMath.sqrt(this.beta1);
+            this.beta1 = JdkMath.sqrt(this.beta1);
             /* At this point
              *   r1 = b,
              *   y = M * b,
@@ -596,7 +596,7 @@
             if (this.beta < 0.) {
                 throwNPDLOException(this.m, this.y);
             }
-            this.beta = AccurateMath.sqrt(this.beta);
+            this.beta = JdkMath.sqrt(this.beta);
             /*
              * At this point
              *   oldb = beta[1]
@@ -613,7 +613,7 @@
             this.snprod = 1.;
             this.tnorm = alpha * alpha + this.beta * this.beta;
             this.ynorm2 = 0.;
-            this.gmax = AccurateMath.abs(alpha) + MACH_PREC;
+            this.gmax = JdkMath.abs(alpha) + MACH_PREC;
             this.gmin = this.gmax;
 
             if (this.goodb) {
@@ -670,7 +670,7 @@
             if (beta < 0.) {
                 throwNPDLOException(m, y);
             }
-            beta = AccurateMath.sqrt(beta);
+            beta = JdkMath.sqrt(beta);
             /*
              * At this point
              *   r1 = beta[k] * M^(-1) * P' * v[k],
@@ -687,7 +687,7 @@
              *   c     = c[k-1],
              *   s     = s[k-1].
              */
-            final double gamma = AccurateMath.sqrt(gbar * gbar + oldb * oldb);
+            final double gamma = JdkMath.sqrt(gbar * gbar + oldb * oldb);
             final double c = gbar / gamma;
             final double s = oldb / gamma;
             /*
@@ -730,8 +730,8 @@
              */
             bstep += snprod * c * zeta;
             snprod *= s;
-            gmax = AccurateMath.max(gmax, gamma);
-            gmin = AccurateMath.min(gmin, gamma);
+            gmax = JdkMath.max(gmax, gamma);
+            gmin = JdkMath.min(gmin, gamma);
             ynorm2 += zeta * zeta;
             gammaZeta = minusEpsZeta - deltak * zeta;
             minusEpsZeta = -eps * zeta;
@@ -755,16 +755,16 @@
          * Updates {@link #lqnorm} and {@link #cgnorm}.
          */
         private void updateNorms() {
-            final double anorm = AccurateMath.sqrt(tnorm);
-            final double ynorm = AccurateMath.sqrt(ynorm2);
+            final double anorm = JdkMath.sqrt(tnorm);
+            final double ynorm = JdkMath.sqrt(ynorm2);
             final double epsa = anorm * MACH_PREC;
             final double epsx = anorm * ynorm * MACH_PREC;
             final double epsr = anorm * ynorm * delta;
             final double diag = gbar == 0. ? epsa : gbar;
-            lqnorm = AccurateMath.sqrt(gammaZeta * gammaZeta +
+            lqnorm = JdkMath.sqrt(gammaZeta * gammaZeta +
                                    minusEpsZeta * minusEpsZeta);
             final double qrnorm = snprod * beta1;
-            cgnorm = qrnorm * beta / AccurateMath.abs(diag);
+            cgnorm = qrnorm * beta / JdkMath.abs(diag);
 
             /*
              * Estimate cond(A). In this version we look at the diagonals of L
@@ -776,7 +776,7 @@
             if (lqnorm <= cgnorm) {
                 acond = gmax / gmin;
             } else {
-                acond = gmax / AccurateMath.min(gmin, AccurateMath.abs(diag));
+                acond = gmax / JdkMath.min(gmin, JdkMath.abs(diag));
             }
             if (acond * MACH_PREC >= 0.1) {
                 throw new IllConditionedOperatorException(acond);
@@ -788,7 +788,7 @@
                  */
                 throw new SingularOperatorException();
             }
-            rnorm = AccurateMath.min(cgnorm, lqnorm);
+            rnorm = JdkMath.min(cgnorm, lqnorm);
             hasConverged = (cgnorm <= epsx) || (cgnorm <= epsr);
         }
 