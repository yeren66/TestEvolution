--- 
+++ 
@@ -16,18 +16,29 @@
  */
 package org.apache.commons.math4.legacy.optim.nonlinear.scalar.noderiv;
 
+import java.util.Arrays;
+import java.util.List;
+import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.Collections;
 import java.util.function.UnaryOperator;
 
+import org.apache.commons.math4.legacy.core.MathArrays;
 import org.apache.commons.math4.legacy.analysis.MultivariateFunction;
 import org.apache.commons.math4.legacy.exception.MathUnsupportedOperationException;
+import org.apache.commons.math4.legacy.exception.ConvergenceException;
 import org.apache.commons.math4.legacy.exception.util.LocalizedFormats;
 import org.apache.commons.math4.legacy.optim.ConvergenceChecker;
 import org.apache.commons.math4.legacy.optim.OptimizationData;
 import org.apache.commons.math4.legacy.optim.PointValuePair;
 import org.apache.commons.math4.legacy.optim.SimpleValueChecker;
+import org.apache.commons.math4.legacy.optim.InitialGuess;
+import org.apache.commons.math4.legacy.optim.MaxEval;
 import org.apache.commons.math4.legacy.optim.nonlinear.scalar.GoalType;
 import org.apache.commons.math4.legacy.optim.nonlinear.scalar.MultivariateOptimizer;
+import org.apache.commons.math4.legacy.optim.nonlinear.scalar.SimulatedAnnealing;
+import org.apache.commons.math4.legacy.optim.nonlinear.scalar.PopulationSize;
+import org.apache.commons.math4.legacy.optim.nonlinear.scalar.ObjectiveFunction;
 
 /**
  * This class implements simplex-based direct search optimization.
@@ -57,8 +68,9 @@
  * an instance of this class will register the following data:
  * <ul>
  *  <li>{@link Simplex}</li>
- *  <li>{@link Simplex.TransformFactory} (either {@link NelderMeadTransform}
- *   or {@link MultiDirectionalTransform})</li>
+ *  <li>{@link Simplex.TransformFactory}</li>
+ *  <li>{@link SimulatedAnnealing}</li>
+ *  <li>{@link PopulationSize}</li>
  * </ul>
  *
  * <p>
@@ -72,18 +84,36 @@
  * <p>
  * Convergence is considered achieved when <em>all</em> the simplex points
  * have converged.
+ * <p>
+ * Whenever {@link SimulatedAnnealing simulated annealing (SA)} is activated,
+ * the SA phase will terminate when the temperature reaches \( 10^{-2} \).
+ * Indeed the chance of accepting the alternative state is vanishingly small.
+ * It does not mean however that the optimization has converged.
+ * In such a case, the {@link PopulationSize} argument to method
+ * {@link #optimize(OptimizationData[]) optimize} will trigger an additional
+ * "best list" search.
  *
  * <p>
  * This implementation does not directly support constrained optimization
  * with simple bounds.
  * The call to {@link #optimize(OptimizationData[]) optimize} will throw
  * {@link MathUnsupportedOperationException} if bounds are passed to it.
+ *
+ * @see NelderMeadTransform
+ * @see MultiDirectionalTransform
+ * @see HedarFukushimaTransform
  */
 public class SimplexOptimizer extends MultivariateOptimizer {
+    /** Final temperature for simulated annealing. */
+    private static final double SA_FINAL_TEMPERATURE = 1e-2;
     /** Simplex update function factory. */
     private Simplex.TransformFactory updateRule;
-    /** Current simplex. */
-    private Simplex simplex;
+    /** Initial simplex. */
+    private Simplex initialSimplex;
+    /** Simulated annealing setup (optional). */
+    private SimulatedAnnealing simulatedAnnealing = null;
+    /** Number of additional optimizations (optional). */
+    private int bestListSize = 0;
 
     /**
      * @param checker Convergence checker.
@@ -117,35 +147,78 @@
             return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
         };
 
-        final UnaryOperator<Simplex> update = updateRule.apply(evalFunc, comparator);
-
-        // Initialize search.
-        simplex = simplex.translate(getStartPoint()).evaluate(evalFunc, comparator);
-
-        Simplex previous = null;
-        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
+        // Start points for additional search.
+        final List<PointValuePair> bestList = new ArrayList<>();
+
+        Simplex currentSimplex = initialSimplex.translate(getStartPoint()).evaluate(evalFunc, comparator);
+        double temperature = Double.NaN; // Only used with simulated annealing.
+        Simplex previousSimplex = null;
+
+        if (simulatedAnnealing != null) {
+            temperature =
+                temperature(currentSimplex.get(0),
+                            currentSimplex.get(currentSimplex.getDimension()),
+                            simulatedAnnealing.getStartProbability());
+        }
+
         while (true) {
-            if (previous != null) { // Skip check at first iteration.
-                boolean converged = true;
-                for (int i = 0; i < simplex.getSize(); i++) {
-                    if (!checker.converged(getIterations(),
-                                           previous.get(i),
-                                           simplex.get(i))) {
-                        converged = false;
-                        break;
-                    }
-                }
-                if (converged) {
-                    // We have found an optimum.
-                    return simplex.get(0);
+            if (previousSimplex != null) { // Skip check at first iteration.
+                if (hasConverged(previousSimplex, currentSimplex)) {
+                    return currentSimplex.get(0);
                 }
             }
 
             // We still need to search.
-            previous = simplex;
-            simplex = update.apply(simplex).evaluate(evalFunc, comparator);
+            previousSimplex = currentSimplex;
+
+            if (simulatedAnnealing != null) {
+                // Update current temperature.
+                temperature =
+                    simulatedAnnealing.getCoolingSchedule().apply(temperature,
+                                                                  currentSimplex);
+
+                final double endTemperature =
+                    temperature(currentSimplex.get(0),
+                                currentSimplex.get(currentSimplex.getDimension()),
+                                simulatedAnnealing.getEndProbability());
+
+                if (temperature < endTemperature) {
+                    break;
+                }
+
+                final UnaryOperator<Simplex> update =
+                    updateRule.create(evalFunc,
+                                      comparator,
+                                      simulatedAnnealing.metropolis(temperature));
+
+                for (int i = 0; i < simulatedAnnealing.getEpochDuration(); i++) {
+                    currentSimplex = update.apply(currentSimplex).evaluate(evalFunc, comparator);
+                }
+            } else {
+                // No simulated annealing.
+                final UnaryOperator<Simplex> update =
+                    updateRule.create(evalFunc, comparator, null);
+
+                currentSimplex = update.apply(currentSimplex).evaluate(evalFunc, comparator);
+            }
+
+            if (bestListSize != 0) {
+                // Store best points.
+                for (int i = 0; i < currentSimplex.getSize(); i++) {
+                    keepIfBetter(currentSimplex.get(i), comparator, bestList, bestListSize);
+                }
+            }
 
             incrementIterationCount();
+        }
+
+        // No convergence.
+        if (bestList.isEmpty()) {
+            // Bail out.
+            throw new ConvergenceException();
+        } else {
+            // Additional optimizations.
+            return bestListSearch(evalFunc, comparator, bestList);
         }
     }
 
@@ -158,6 +231,8 @@
      * <ul>
      *  <li>{@link Simplex}</li>
      *  <li>{@link Simplex.TransformFactory}</li>
+     *  <li>{@link SimulatedAnnealing}</li>
+     *  <li>{@link PopulationSize}</li>
      * </ul>
      */
     @Override
@@ -169,11 +244,39 @@
         // if not provided in the argument list.
         for (OptimizationData data : optData) {
             if (data instanceof Simplex) {
-                simplex = (Simplex) data;
+                initialSimplex = (Simplex) data;
             } else if (data instanceof Simplex.TransformFactory) {
                 updateRule = (Simplex.TransformFactory) data;
-            }
-        }
+            } else if (data instanceof SimulatedAnnealing) {
+                simulatedAnnealing = (SimulatedAnnealing) data;
+            } else if (data instanceof PopulationSize) {
+                bestListSize = ((PopulationSize) data).getPopulationSize();
+            }
+        }
+    }
+
+    /**
+     * Detects whether the simplex has shrunk below the user-defined
+     * tolerance.
+     *
+     * @param previous Simplex at previous iteration.
+     * @param current Simplex at current iteration.
+     * @return {@code true} if convergence is considered achieved.
+     */
+    private boolean hasConverged(Simplex previous,
+                                 Simplex current) {
+        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
+
+        for (int i = 0; i < current.getSize(); i++) {
+            final PointValuePair prev = previous.get(i);
+            final PointValuePair curr = current.get(i);
+
+            if (!checker.converged(getIterations(), prev, curr)) {
+                return false;
+            }
+        }
+
+        return true;
     }
 
     /**
@@ -186,7 +289,7 @@
         if (updateRule == null) {
             throw new NullPointerException("No update rule");
         }
-        if (simplex == null) {
+        if (initialSimplex == null) {
             throw new NullPointerException("No initial simplex");
         }
         if (getLowerBound() != null ||
@@ -194,4 +297,154 @@
             throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);
         }
     }
+
+    /**
+     * Computes the temperature as a function of the acceptance probability
+     * and the fitness difference between two of the simplex vertices (usually
+     * the best and worst points).
+     *
+     * @param p1 Simplex point.
+     * @param p2 Simplex point.
+     * @param prob Acceptance probability.
+     * @return the temperature.
+     */
+    private double temperature(PointValuePair p1,
+                               PointValuePair p2,
+                               double prob) {
+        return -Math.abs(p1.getValue() - p2.getValue()) / Math.log(prob);
+    }
+
+    /**
+     * Stores the given {@code candidate} if its fitness is better than
+     * that of the last (assumed to be the worst) point in {@code list}.
+     *
+     * @param candidate Point to be stored.
+     * @param comp Fitness comparator.
+     * @param list Starting points (modified in-place).
+     * @param max Maximum size of the {@code list}.
+     */
+    private static void keepIfBetter(PointValuePair candidate,
+                                     Comparator<PointValuePair> comp,
+                                     List<PointValuePair> list,
+                                     int max) {
+        final int listSize = list.size();
+        final double[] candidatePoint = candidate.getPoint();
+        if (listSize == 0) {
+            list.add(candidate);
+        } else if (listSize < max) {
+            // List is not fully populated yet.
+            for (PointValuePair p : list) {
+                final double[] pPoint = p.getPoint();
+                if (Arrays.equals(pPoint, candidatePoint)) {
+                    // Point was already stored.
+                    return;
+                } else {
+                    // Store candidate.
+                    list.add(candidate);
+                    return;
+                }
+            }
+        } else {
+            final int last = max - 1;
+            if (comp.compare(candidate, list.get(last)) < 0) {
+                for (PointValuePair p : list) {
+                    final double[] pPoint = p.getPoint();
+                    if (Arrays.equals(pPoint, candidatePoint)) {
+                        // Point was already stored.
+                        return;
+                    }
+                }
+
+                // Store better candidate and reorder the list.
+                list.set(last, candidate);
+                Collections.sort(list, comp);
+            }
+        }
+    }
+
+    /**
+     * Computes the smallest distance between the given {@code point}
+     * and any of the other points in the {@code list}.
+     *
+     * @param point Point.
+     * @param list List.
+     * @return the smallest distance.
+     */
+    private static double shortestDistance(PointValuePair point,
+                                           List<PointValuePair> list) {
+        double minDist = Double.POSITIVE_INFINITY;
+
+        final double[] p = point.getPoint();
+        for (PointValuePair other : list) {
+            final double[] pOther = other.getPoint();
+            if (!Arrays.equals(p, pOther)) {
+                final double dist = MathArrays.distance(p, pOther);
+                if (dist < minDist) {
+                    minDist = dist;
+                }
+            }
+        }
+
+        return minDist;
+    }
+
+    /**
+     * Perform additional optimizations.
+     *
+     * @param evalFunc Objective function.
+     * @param comp Fitness comparator.
+     * @param starts Starting points.
+     * @return the optimum.
+     */
+    private PointValuePair bestListSearch(MultivariateFunction evalFunc,
+                                          Comparator<PointValuePair> comp,
+                                          List<PointValuePair> starts) {
+        PointValuePair best = starts.get(0); // Overall best result.
+
+        // Additional local optimizations using each of the best
+        // points visited during the main search.
+        for (PointValuePair p : starts) {
+            // Find shortest distance to the other points.
+            final double dist = shortestDistance(p, starts);
+            final double[] init = p.getPoint();
+            // Create smaller initial simplex.
+            final Simplex simplex = Simplex.equalSidesAlongAxes(init.length,
+                                                                0.5 * dist);
+
+            final PointValuePair r = directSearch(init,
+                                                  simplex,
+                                                  evalFunc,
+                                                  getConvergenceChecker(),
+                                                  getGoalType());
+            if (comp.compare(r, best) < 0) {
+                best = r; // New overall best.
+            }
+        }
+
+        return best;
+    }
+
+    /**
+     * @param init Start point.
+     * @param simplex Initial simplex.
+     * @param eval Objective function.
+     * Note: It is assumed that evaluations of this function are
+     * incrementing the main counter.
+     * @param checker Convergence checker.
+     * @param goalType Whether to minimize or maximize the objective function.
+     * @return the optimum.
+     */
+    private static PointValuePair directSearch(double[] init,
+                                               Simplex simplex,
+                                               MultivariateFunction eval,
+                                               ConvergenceChecker<PointValuePair> checker,
+                                               GoalType goalType) {
+        final SimplexOptimizer optim = new SimplexOptimizer(checker);
+        return optim.optimize(MaxEval.unlimited(),
+                              new ObjectiveFunction(eval),
+                              goalType,
+                              new InitialGuess(init),
+                              simplex,
+                              new NelderMeadTransform());
+    }
 }