--- 
+++ 
@@ -23,7 +23,7 @@
 import org.apache.commons.math4.legacy.linear.RealMatrix;
 import org.apache.commons.math4.legacy.linear.RealVector;
 import org.apache.commons.rng.simple.RandomSource;
-import org.apache.commons.math4.legacy.util.FastMath;
+import org.apache.commons.math4.legacy.core.jdkmath.AccurateMath;
 import org.apache.commons.numbers.core.Precision;
 import org.junit.Assert;
 import org.junit.Test;
@@ -142,7 +142,7 @@
             filter.correct(z);
 
             // state estimate shouldn't be larger than measurement noise
-            double diff = FastMath.abs(constantValue - filter.getStateEstimation()[0]);
+            double diff = AccurateMath.abs(constantValue - filter.getStateEstimation()[0]);
             // System.out.println(diff);
             Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);
         }
@@ -170,7 +170,7 @@
         // B = [ dt^2/2 ]
         //     [ dt     ]
         RealMatrix B = new Array2DRowRealMatrix(
-                new double[][] { { FastMath.pow(dt, 2d) / 2d }, { dt } });
+                new double[][] { { AccurateMath.pow(dt, 2d) / 2d }, { dt } });
 
         // H = [ 1 0 ]
         RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } });
@@ -179,12 +179,12 @@
         RealVector x = new ArrayRealVector(new double[] { 0, 0 });
 
         RealMatrix tmp = new Array2DRowRealMatrix(
-                new double[][] { { FastMath.pow(dt, 4d) / 4d, FastMath.pow(dt, 3d) / 2d },
-                                 { FastMath.pow(dt, 3d) / 2d, FastMath.pow(dt, 2d) } });
+                new double[][] { { AccurateMath.pow(dt, 4d) / 4d, AccurateMath.pow(dt, 3d) / 2d },
+                                 { AccurateMath.pow(dt, 3d) / 2d, AccurateMath.pow(dt, 2d) } });
 
         // Q = [ dt^4/4 dt^3/2 ]
         //     [ dt^3/2 dt^2   ]
-        RealMatrix Q = tmp.scalarMultiply(FastMath.pow(accelNoise, 2));
+        RealMatrix Q = tmp.scalarMultiply(AccurateMath.pow(accelNoise, 2));
 
         // P0 = [ 1 1 ]
         //      [ 1 1 ]
@@ -192,7 +192,7 @@
 
         // R = [ measurementNoise^2 ]
         RealMatrix R = new Array2DRowRealMatrix(
-                new double[] { FastMath.pow(measurementNoise, 2) });
+                new double[] { AccurateMath.pow(measurementNoise, 2) });
 
         // constant control input, increase velocity by 0.1 m/s per cycle
         RealVector u = new ArrayRealVector(new double[] { 0.1d });
@@ -213,7 +213,7 @@
         final ContinuousDistribution.Sampler rand = new NormalDistribution(0, 1).createSampler(RandomSource.create(RandomSource.WELL_19937_C));
 
         RealVector tmpPNoise = new ArrayRealVector(
-                new double[] { FastMath.pow(dt, 2d) / 2d, dt });
+                new double[] { AccurateMath.pow(dt, 2d) / 2d, dt });
 
         // iterate 60 steps
         for (int i = 0; i < 60; i++) {
@@ -234,7 +234,7 @@
             filter.correct(z);
 
             // state estimate shouldn't be larger than the measurement noise
-            double diff = FastMath.abs(x.getEntry(0) - filter.getStateEstimation()[0]);
+            double diff = AccurateMath.abs(x.getEntry(0) - filter.getStateEstimation()[0]);
             Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);
         }
 
@@ -258,10 +258,10 @@
         public Cannonball(double timeslice, double angle, double initialVelocity) {
             this.timeslice = timeslice;
 
-            final double angleInRadians = FastMath.toRadians(angle);
+            final double angleInRadians = AccurateMath.toRadians(angle);
             this.velocity = new double[] {
-                    initialVelocity * FastMath.cos(angleInRadians),
-                    initialVelocity * FastMath.sin(angleInRadians)
+                    initialVelocity * AccurateMath.cos(angleInRadians),
+                    initialVelocity * AccurateMath.sin(angleInRadians)
             };
 
             this.location = new double[] { 0, 0 };
@@ -405,7 +405,7 @@
             filter.correct(new double[] { nx, 0, ny, 0 } );
 
             // state estimate shouldn't be larger than the measurement noise
-            double diff = FastMath.abs(cannonball.getY() - filter.getStateEstimation()[2]);
+            double diff = AccurateMath.abs(cannonball.getY() - filter.getStateEstimation()[2]);
             Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);
         }
 