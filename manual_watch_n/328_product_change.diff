--- 
+++ 
@@ -112,6 +112,8 @@
  * @since 3.3
  */
 public class KolmogorovSmirnovTest {
+    /** pi^2. */
+    private static final double PI_SQUARED = FastMath.PI * FastMath.PI;
     /**
      * Bound on the number of partial sums in {@link #ksSum(double, double, int)}
      */
@@ -556,7 +558,7 @@
         double sum = 0;
         double increment = 0;
         double kTerm = 0;
-        double z2Term = MathUtils.PI_SQUARED / (8 * z2);
+        double z2Term = PI_SQUARED / (8 * z2);
         int k = 1;
         for (; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
             kTerm = 2 * k - 1;
@@ -581,7 +583,7 @@
         for (k = 0; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
             kTerm = k + 0.5;
             kTerm2 = kTerm * kTerm;
-            increment = (MathUtils.PI_SQUARED * kTerm2 - z2) * FastMath.exp(-MathUtils.PI_SQUARED * kTerm2 / twoZ2);
+            increment = (PI_SQUARED * kTerm2 - z2) * FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
             sum += increment;
             if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum)) {
                 break;
@@ -599,15 +601,15 @@
         final double z4Term = 2 * z4;
         final double z6Term = 6 * z6;
         z2Term = 5 * z2;
-        final double pi4 = MathUtils.PI_SQUARED * MathUtils.PI_SQUARED;
+        final double pi4 = PI_SQUARED * PI_SQUARED;
         sum = 0;
         kTerm = 0;
         kTerm2 = 0;
         for (k = 0; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
             kTerm = k + 0.5;
             kTerm2 = kTerm * kTerm;
-            increment =  (z6Term + z4Term + MathUtils.PI_SQUARED * (z4Term - z2Term) * kTerm2 +
-                    pi4 * (1 - twoZ2) * kTerm2 * kTerm2) * FastMath.exp(-MathUtils.PI_SQUARED * kTerm2 / twoZ2);
+            increment =  (z6Term + z4Term + PI_SQUARED * (z4Term - z2Term) * kTerm2 +
+                    pi4 * (1 - twoZ2) * kTerm2 * kTerm2) * FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
             sum += increment;
             if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum)) {
                 break;
@@ -620,7 +622,7 @@
         kTerm2 = 0;
         for (k = 1; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
             kTerm2 = k * k;
-            increment = MathUtils.PI_SQUARED * kTerm2 * FastMath.exp(-MathUtils.PI_SQUARED * kTerm2 / twoZ2);
+            increment = PI_SQUARED * kTerm2 * FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
             sum2 += increment;
             if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum2)) {
                 break;
@@ -634,7 +636,7 @@
 
         // K_3(z) One more time with feeling - two doubly infinite sums, all k powers even.
         // Multiply coefficient denominators by 2, so omit doubling sums.
-        final double pi6 = pi4 * MathUtils.PI_SQUARED;
+        final double pi6 = pi4 * PI_SQUARED;
         sum = 0;
         double kTerm4 = 0;
         double kTerm6 = 0;
@@ -644,8 +646,8 @@
             kTerm4 = kTerm2 * kTerm2;
             kTerm6 = kTerm4 * kTerm2;
             increment = (pi6 * kTerm6 * (5 - 30 * z2) + pi4 * kTerm4 * (-60 * z2 + 212 * z4) +
-                            MathUtils.PI_SQUARED * kTerm2 * (135 * z4 - 96 * z6) - 30 * z6 - 90 * z8) *
-                    FastMath.exp(-MathUtils.PI_SQUARED * kTerm2 / twoZ2);
+                            PI_SQUARED * kTerm2 * (135 * z4 - 96 * z6) - 30 * z6 - 90 * z8) *
+                    FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
             sum += increment;
             if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum)) {
                 break;
@@ -658,8 +660,8 @@
         for (k = 1; k < MAXIMUM_PARTIAL_SUM_COUNT; k++) {
             kTerm2 = k * k;
             kTerm4 = kTerm2 * kTerm2;
-            increment = (-pi4 * kTerm4 + 3 * MathUtils.PI_SQUARED * kTerm2 * z2) *
-                    FastMath.exp(-MathUtils.PI_SQUARED * kTerm2 / twoZ2);
+            increment = (-pi4 * kTerm4 + 3 * PI_SQUARED * kTerm2 * z2) *
+                    FastMath.exp(-PI_SQUARED * kTerm2 / twoZ2);
             sum2 += increment;
             if (FastMath.abs(increment) < PG_SUM_RELATIVE_ERROR * FastMath.abs(sum2)) {
                 break;